{"ast":null,"code":"import { Scene, Camera, Mesh, PlaneGeometry, ShaderMaterial, WebGLRenderTarget, RGBAFormat, DataTexture, FloatType, NoToneMapping, NearestFilter, ClampToEdgeWrapping } from \"three\";\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const scene = new Scene();\n    const camera = new Camera();\n    camera.position.z = 1;\n    const passThruUniforms = {\n      passThruTexture: {\n        value: null\n      }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n    scene.add(mesh);\n    this.setDataType = function (type) {\n      dataType = type;\n      return this;\n    };\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture,\n        material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n    this.init = function () {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n        return \"No OES_texture_float support for float textures.\";\n      }\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return \"No support for vertex shader textures.\";\n      }\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n        variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n        const material = variable.material;\n        const uniforms = material.uniforms;\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n            if (depVar.name !== variable.name) {\n              let found = false;\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n              }\n            }\n            uniforms[depVar.name] = {\n              value: null\n            };\n            material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n          }\n        }\n      }\n      this.currentTextureIndex = 0;\n      return null;\n    };\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n      this.currentTextureIndex = nextTextureIndex;\n    };\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n    this.dispose = function () {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      const variables = this.variables;\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n    }\n    this.addResolutionDefine = addResolutionDefine;\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n    this.createShaderMaterial = createShaderMaterial;\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n    this.renderTexture = function (input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      mesh.material = material;\n      renderer.setRenderTarget(output);\n      renderer.render(scene, camera);\n      mesh.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n    function getPassThroughVertexShader() {\n      return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n    }\n    function getPassThroughFragmentShader() {\n      return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n    }\n  }\n}\nexport { GPUComputationRenderer };","map":{"version":3,"sources":["../../src/misc/GPUComputationRenderer.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Camera,\n  ClampToEdgeWrapping,\n  DataTexture,\n  FloatType,\n  Mesh,\n  NearestFilter,\n  NoToneMapping,\n  PlaneGeometry,\n  RGBAFormat,\n  Scene,\n  ShaderMaterial,\n  WebGLRenderTarget,\n} from 'three'\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\n\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = []\n\n    this.currentTextureIndex = 0\n\n    let dataType = FloatType\n\n    const scene = new Scene()\n\n    const camera = new Camera()\n    camera.position.z = 1\n\n    const passThruUniforms = {\n      passThruTexture: { value: null },\n    }\n\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms)\n\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader)\n    scene.add(mesh)\n\n    this.setDataType = function (type) {\n      dataType = type\n      return this\n    }\n\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader)\n\n      const variable = {\n        name: variableName,\n        initialValueTexture: initialValueTexture,\n        material: material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n      }\n\n      this.variables.push(variable)\n\n      return variable\n    }\n\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies\n    }\n\n    this.init = function () {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n        return 'No OES_texture_float support for float textures.'\n      }\n\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return 'No support for vertex shader textures.'\n      }\n\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i]\n\n        // Creates rendertargets and initialize them with input texture\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0])\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1])\n\n        // Adds dependencies uniforms to the ShaderMaterial\n        const material = variable.material\n        const uniforms = material.uniforms\n\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d]\n\n            if (depVar.name !== variable.name) {\n              // Checks if variable exists\n              let found = false\n\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true\n                  break\n                }\n              }\n\n              if (!found) {\n                return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name\n              }\n            }\n\n            uniforms[depVar.name] = { value: null }\n\n            material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader\n          }\n        }\n      }\n\n      this.currentTextureIndex = 0\n\n      return null\n    }\n\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0\n\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i]\n\n        // Sets texture dependencies uniforms\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms\n\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d]\n\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture\n          }\n        }\n\n        // Performs the computation for this variable\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex])\n      }\n\n      this.currentTextureIndex = nextTextureIndex\n    }\n\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex]\n    }\n\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0]\n    }\n\n    this.dispose = function () {\n      mesh.geometry.dispose()\n      mesh.material.dispose()\n\n      const variables = this.variables\n\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i]\n\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose()\n\n        const renderTargets = variable.renderTargets\n\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j]\n          renderTarget.dispose()\n        }\n      }\n    }\n\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )'\n    }\n\n    this.addResolutionDefine = addResolutionDefine\n\n    // The following functions can be used to compute things manually\n\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {}\n\n      const material = new ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader,\n      })\n\n      addResolutionDefine(material)\n\n      return material\n    }\n\n    this.createShaderMaterial = createShaderMaterial\n\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX\n      sizeYTexture = sizeYTexture || sizeY\n\n      wrapS = wrapS || ClampToEdgeWrapping\n      wrapT = wrapT || ClampToEdgeWrapping\n\n      minFilter = minFilter || NearestFilter\n      magFilter = magFilter || NearestFilter\n\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS: wrapS,\n        wrapT: wrapT,\n        minFilter: minFilter,\n        magFilter: magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false,\n      })\n\n      return renderTarget\n    }\n\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4)\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType)\n      texture.needsUpdate = true\n      return texture\n    }\n\n    this.renderTexture = function (input, output) {\n      // Takes a texture, and render out in rendertarget\n      // input = Texture\n      // output = RenderTarget\n\n      passThruUniforms.passThruTexture.value = input\n\n      this.doRenderTarget(passThruShader, output)\n\n      passThruUniforms.passThruTexture.value = null\n    }\n\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentOutputColorSpace = renderer.outputColorSpace\n      const currentToneMapping = renderer.toneMapping\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.encoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      mesh.material = material\n      renderer.setRenderTarget(output)\n      renderer.render(scene, camera)\n      mesh.material = passThruShader\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.outputColorSpace = currentOutputColorSpace\n      renderer.toneMapping = currentToneMapping\n\n      renderer.setRenderTarget(currentRenderTarget)\n    }\n\n    // Shaders\n\n    function getPassThroughVertexShader() {\n      return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n'\n    }\n\n    function getPassThroughFragmentShader() {\n      return (\n        'uniform sampler2D passThruTexture;\\n' +\n        '\\n' +\n        'void main() {\\n' +\n        '\\n' +\n        '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n        '\\n' +\n        '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n        '\\n' +\n        '}\\n'\n      )\n    }\n  }\n}\n\nexport { GPUComputationRenderer }\n"]},"metadata":{},"sourceType":"module"}