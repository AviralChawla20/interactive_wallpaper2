{"ast":null,"code":"import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        const range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active) continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport { MorphBlendMesh };","map":{"version":3,"sources":["../../src/misc/MorphBlendMesh.js"],"names":[],"mappings":"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","sourcesContent":["import { MathUtils, Mesh } from 'three'\n\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material)\n\n    this.animationsMap = {}\n    this.animationsList = []\n\n    // prepare default animation\n    // (all frames played together in 1 second)\n\n    const numFrames = Object.keys(this.morphTargetDictionary).length\n\n    const name = '__default'\n\n    const startFrame = 0\n    const endFrame = numFrames - 1\n\n    const fps = numFrames / 1\n\n    this.createAnimation(name, startFrame, endFrame, fps)\n    this.setAnimationWeight(name, 1)\n  }\n\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start: start,\n      end: end,\n\n      length: end - start + 1,\n\n      fps: fps,\n      duration: (end - start) / fps,\n\n      lastFrame: 0,\n      currentFrame: 0,\n\n      active: false,\n\n      time: 0,\n      direction: 1,\n      weight: 1,\n\n      directionBackwards: false,\n      mirroredLoop: false,\n    }\n\n    this.animationsMap[name] = animation\n    this.animationsList.push(animation)\n  }\n\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i\n\n    let firstAnimation\n\n    const frameRanges = {}\n\n    let i = 0\n\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern)\n\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1]\n\n        if (!frameRanges[name]) frameRanges[name] = { start: Infinity, end: -Infinity }\n\n        const range = frameRanges[name]\n\n        if (i < range.start) range.start = i\n        if (i > range.end) range.end = i\n\n        if (!firstAnimation) firstAnimation = name\n      }\n\n      i++\n    }\n\n    for (const name in frameRanges) {\n      const range = frameRanges[name]\n      this.createAnimation(name, range.start, range.end, fps)\n    }\n\n    this.firstAnimation = firstAnimation\n  }\n\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = 1\n      animation.directionBackwards = false\n    }\n  }\n\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = -1\n      animation.directionBackwards = true\n    }\n  }\n\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.fps = fps\n      animation.duration = (animation.end - animation.start) / animation.fps\n    }\n  }\n\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.duration = duration\n      animation.fps = (animation.end - animation.start) / animation.duration\n    }\n  }\n\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.weight = weight\n    }\n  }\n\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = time\n    }\n  }\n\n  getAnimationTime(name) {\n    let time = 0\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      time = animation.time\n    }\n\n    return time\n  }\n\n  getAnimationDuration(name) {\n    let duration = -1\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      duration = animation.duration\n    }\n\n    return duration\n  }\n\n  playAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = 0\n      animation.active = true\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()')\n    }\n  }\n\n  stopAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.active = false\n    }\n  }\n\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i]\n\n      if (!animation.active) continue\n\n      const frameTime = animation.duration / animation.length\n\n      animation.time += animation.direction * delta\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration\n            animation.directionBackwards = true\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0\n            animation.directionBackwards = false\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration\n\n        if (animation.time < 0) animation.time += animation.duration\n      }\n\n      const keyframe =\n        animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1)\n      const weight = animation.weight\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight\n\n        this.morphTargetInfluences[keyframe] = 0\n\n        animation.lastFrame = animation.currentFrame\n        animation.currentFrame = keyframe\n      }\n\n      let mix = (animation.time % frameTime) / frameTime\n\n      if (animation.directionBackwards) mix = 1 - mix\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight\n      }\n    }\n  }\n}\n\nexport { MorphBlendMesh }\n"]},"metadata":{},"sourceType":"module"}