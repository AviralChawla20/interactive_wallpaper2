{"ast":null,"code":"import { Vector3, BoxGeometry } from \"three\";\nconst tempNormal = new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4;\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4;\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize();\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n  const arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);\n  }\n}\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    segments = segments * 2 + 1;\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments);\n    if (segments === 1) return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv;\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 1:\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 2:\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 3:\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 4:\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n        case 5:\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n      }\n    }\n  }\n}\nexport { RoundedBoxGeometry };","map":{"version":3,"sources":["../../src/geometries/RoundedBoxGeometry.js"],"names":[],"mappings":"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","sourcesContent":["import { BoxGeometry, Vector3 } from 'three'\n\nconst tempNormal = new Vector3()\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = (2 * Math.PI * radius) / 4\n\n  // length of the planes between the arcs on each axis\n  const centerLength = Math.max(sideLength - 2 * radius, 0)\n  const halfArc = Math.PI / 4\n\n  // Get the vector projected onto the Y plane\n  tempNormal.copy(normal)\n  tempNormal[projectionAxis] = 0\n  tempNormal.normalize()\n\n  // total amount of UV space alloted to a single arc\n  const arcUvRatio = (0.5 * totArcLength) / (totArcLength + centerLength)\n\n  // the distance along one arc the point is at\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength)\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio)\n  }\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1\n\n    // ensure radius isn't bigger than shortest side\n    radius = Math.min(width / 2, height / 2, depth / 2, radius)\n\n    super(1, 1, 1, segments, segments, segments)\n\n    // if we just have one segment we're the same as a regular box\n    if (segments === 1) return\n\n    const geometry2 = this.toNonIndexed()\n\n    this.index = null\n    this.attributes.position = geometry2.attributes.position\n    this.attributes.normal = geometry2.attributes.normal\n    this.attributes.uv = geometry2.attributes.uv\n\n    //\n\n    const position = new Vector3()\n    const normal = new Vector3()\n\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius)\n\n    const positions = this.attributes.position.array\n    const normals = this.attributes.normal.array\n    const uvs = this.attributes.uv.array\n\n    const faceTris = positions.length / 6\n    const faceDirVector = new Vector3()\n    const halfSegmentSize = 0.5 / segments\n\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i)\n      normal.copy(position)\n      normal.x -= Math.sign(normal.x) * halfSegmentSize\n      normal.y -= Math.sign(normal.y) * halfSegmentSize\n      normal.z -= Math.sign(normal.z) * halfSegmentSize\n      normal.normalize()\n\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius\n\n      normals[i + 0] = normal.x\n      normals[i + 1] = normal.y\n      normals[i + 2] = normal.z\n\n      const side = Math.floor(i / faceTris)\n\n      switch (side) {\n        case 0: // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 1: // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 2: // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 3: // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 4: // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n\n        case 5: // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n      }\n    }\n  }\n}\n\nexport { RoundedBoxGeometry }\n"]},"metadata":{},"sourceType":"module"}