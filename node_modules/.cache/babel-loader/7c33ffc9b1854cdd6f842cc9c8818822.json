{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, UnsignedByteType, CompressedTexture, LinearFilter, LinearMipmapLinearFilter, FloatType, HalfFloatType, DataTexture, RGFormat, RedFormat, RGBA_ASTC_6x6_Format } from \"three\";\nimport { WorkerPool } from \"../utils/WorkerPool.js\";\nimport { KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_ZSTD, KHR_SUPERCOMPRESSION_NONE, KHR_DF_PRIMARIES_BT709, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_DISPLAYP3, KHR_DF_PRIMARIES_UNSPECIFIED, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK } from \"../libs/ktx-parse.js\";\nimport { ZSTDDecoder } from \"../libs/zstddec.js\";\nimport { CompressedCubeTexture } from \"../_polyfill/CompressedCubeTexture.js\";\nimport { CompressedArrayTexture } from \"../_polyfill/CompressedArrayTexture.js\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nconst LinearEncoding = 3e3;\nconst sRGBEncoding = 3001;\nconst NoColorSpace = \"\";\nconst DisplayP3ColorSpace = \"display-p3\";\nconst LinearDisplayP3ColorSpace = \"display-p3-linear\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst SRGBColorSpace = \"srgb\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nlet _activeLoaders = 0;\nlet _zstd;\nconst _KTX2Loader = class extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = \"\";\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerPool = new WorkerPool();\n    this.workerSourceURL = \"\";\n    this.workerConfig = null;\n    if (typeof MSC_TRANSCODER !== \"undefined\") {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\". \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num);\n    return this;\n  }\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n      etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n      etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n      dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n      bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n      pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n    };\n    if (renderer.capabilities.isWebGL2) {\n      this.workerConfig.etc1Supported = false;\n    }\n    return this;\n  }\n  init() {\n    if (!this.transcoderPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = jsLoader.loadAsync(\"basis_transcoder.js\");\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = binaryLoader.loadAsync(\"basis_transcoder.wasm\");\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n        const fn = _KTX2Loader.BasisWorker.toString();\n        const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_KTX2Loader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_KTX2Loader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_KTX2Loader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent2;\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL);\n          const transcoderBinary = this.transcoderBinary.slice(0);\n          worker.postMessage({\n            type: \"init\",\n            config: this.workerConfig,\n            transcoderBinary\n          }, [transcoderBinary]);\n          return worker;\n        });\n      });\n      if (_activeLoaders > 0) {\n        console.warn(\"THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.\");\n      }\n      _activeLoaders++;\n    }\n    return this.transcoderPending;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error(\"THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.\");\n    }\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\n    }, onProgress, onError);\n  }\n  _createTextureFrom(transcodeResult, container) {\n    const {\n      faces,\n      width,\n      height,\n      format,\n      type,\n      error,\n      dfdFlags\n    } = transcodeResult;\n    if (type === \"error\") return Promise.reject(error);\n    let texture;\n    if (container.faceCount === 6) {\n      texture = new CompressedCubeTexture(faces, format, UnsignedByteType);\n    } else {\n      const mipmaps = faces[0].mipmaps;\n      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n    }\n    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n    texture.magFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const colorSpace = parseColorSpace(container);\n    if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n    return texture;\n  }\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer));\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createRawTexture(container);\n    }\n    const taskConfig = config;\n    const texturePending = this.init().then(() => {\n      return this.workerPool.postMessage({\n        type: \"transcode\",\n        buffer,\n        taskConfig\n      }, [buffer]);\n    }).then(e => this._createTextureFrom(e.data, container));\n    _taskCache.set(buffer, {\n      promise: texturePending\n    });\n    return texturePending;\n  }\n  dispose() {\n    this.workerPool.dispose();\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n    _activeLoaders--;\n    return this;\n  }\n};\nlet KTX2Loader = _KTX2Loader;\n/* CONSTANTS */\n__publicField(KTX2Loader, \"BasisFormat\", {\n  ETC1S: 0,\n  UASTC_4x4: 1\n});\n__publicField(KTX2Loader, \"TranscoderFormat\", {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n});\n__publicField(KTX2Loader, \"EngineFormat\", {\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format\n});\n/* WEB WORKER */\n__publicField(KTX2Loader, \"BasisWorker\", function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat;\n  const TranscoderFormat = _TranscoderFormat;\n  const BasisFormat = _BasisFormat;\n  self.addEventListener(\"message\", function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n      case \"transcode\":\n        transcoderPending.then(() => {\n          try {\n            const {\n              faces,\n              buffers,\n              width,\n              height,\n              hasAlpha,\n              format,\n              dfdFlags\n            } = transcode(message.buffer);\n            self.postMessage({\n              type: \"transcode\",\n              id: message.id,\n              faces,\n              width,\n              height,\n              hasAlpha,\n              format,\n              dfdFlags\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  });\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule);\n    }).then(() => {\n      BasisModule.initializeBasis();\n      if (BasisModule.KTX2File === void 0) {\n        console.warn(\"THREE.KTX2Loader: Please update Basis Universal transcoder.\");\n      }\n    });\n  }\n  function transcode(buffer) {\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n    function cleanup() {\n      ktx2File.close();\n      ktx2File.delete();\n    }\n    if (!ktx2File.isValid()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file\");\n    }\n    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = ktx2File.getWidth();\n    const height = ktx2File.getHeight();\n    const layerCount = ktx2File.getLayers() || 1;\n    const levelCount = ktx2File.getLevels();\n    const faceCount = ktx2File.getFaces();\n    const hasAlpha = ktx2File.getHasAlpha();\n    const dfdFlags = ktx2File.getDFDFlags();\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    if (!width || !height || !levelCount) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid texture\");\n    }\n    if (!ktx2File.startTranscoding()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader: .startTranscoding failed\");\n    }\n    const faces = [];\n    const buffers = [];\n    for (let face = 0; face < faceCount; face++) {\n      const mipmaps = [];\n      for (let mip = 0; mip < levelCount; mip++) {\n        const layerMips = [];\n        let mipWidth, mipHeight;\n        for (let layer = 0; layer < layerCount; layer++) {\n          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);\n          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {\n            console.warn(\"THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.\");\n          }\n          if (levelCount > 1) {\n            mipWidth = levelInfo.origWidth;\n            mipHeight = levelInfo.origHeight;\n          } else {\n            mipWidth = levelInfo.width;\n            mipHeight = levelInfo.height;\n          }\n          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));\n          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);\n          if (!status) {\n            cleanup();\n            throw new Error(\"THREE.KTX2Loader: .transcodeImage failed.\");\n          }\n          layerMips.push(dst);\n        }\n        const mipData = concat(layerMips);\n        mipmaps.push({\n          data: mipData,\n          width: mipWidth,\n          height: mipHeight\n        });\n        buffers.push(mipData.buffer);\n      }\n      faces.push({\n        mipmaps,\n        width,\n        height,\n        format: engineFormat\n      });\n    }\n    cleanup();\n    return {\n      faces,\n      buffers,\n      width,\n      height,\n      hasAlpha,\n      format: engineFormat,\n      dfdFlags\n    };\n  }\n  const FORMAT_OPTIONS = [{\n    if: \"astcSupported\",\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: \"bptcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: \"dxtSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc2Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc1Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: \"pvrtcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (hasAlpha && opt.transcoderFormat.length < 2) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    console.warn(\"THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.\");\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n  function concat(arrays) {\n    if (arrays.length === 1) return arrays[0];\n    let totalByteLength = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      totalByteLength += array.byteLength;\n    }\n    const result = new Uint8Array(totalByteLength);\n    let byteOffset = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      result.set(array, byteOffset);\n      byteOffset += array.byteLength;\n    }\n    return result;\n  }\n});\nconst UNCOMPRESSED_FORMATS = /* @__PURE__ */new Set([RGBAFormat, RGFormat, RedFormat]);\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType\n};\nasync function createRawTexture(container) {\n  const {\n    vkFormat\n  } = container;\n  if (FORMAT_MAP[vkFormat] === void 0) {\n    throw new Error(\"THREE.KTX2Loader: Unsupported vkFormat.\");\n  }\n  let zstd;\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async resolve => {\n        const zstd2 = new ZSTDDecoder();\n        await zstd2.init();\n        resolve(zstd2);\n      });\n    }\n    zstd = await _zstd;\n  }\n  const mipmaps = [];\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;\n    const level = container.levels[levelIndex];\n    let levelData;\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData;\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);\n    } else {\n      throw new Error(\"THREE.KTX2Loader: Unsupported supercompressionScheme.\");\n    }\n    let data;\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n    } else {\n      data = levelData;\n    }\n    mipmaps.push({\n      data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth\n    });\n  }\n  let texture;\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);\n  } else {\n    if (container.pixelDepth > 0) throw new Error(\"THREE.KTX2Loader: Unsupported pixelDepth.\");\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);\n  }\n  texture.mipmaps = mipmaps;\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.needsUpdate = true;\n  const colorSpace = parseColorSpace(container);\n  if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  return Promise.resolve(texture);\n}\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0];\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace;\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`);\n    return NoColorSpace;\n  }\n}\nexport { KTX2Loader };","map":{"version":3,"sources":["../../src/loaders/KTX2Loader.js"],"names":["jsContent","binaryContent","zstd"],"mappings":"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","sourcesContent":["/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nimport {\n  CompressedTexture,\n  DataTexture,\n  FileLoader,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RedFormat,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  RGBA_ASTC_4x4_Format,\n  RGBA_ASTC_6x6_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGBAFormat,\n  RGFormat,\n  UnsignedByteType,\n} from 'three'\nimport { WorkerPool } from '../utils/WorkerPool'\nimport {\n  read,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n} from '../libs/ktx-parse'\nimport { ZSTDDecoder } from '../libs/zstddec'\nimport { CompressedCubeTexture } from '../_polyfill/CompressedCubeTexture'\nimport { CompressedArrayTexture } from '../_polyfill/CompressedArrayTexture'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nconst LinearEncoding = 3000\nconst sRGBEncoding = 3001\n\nconst NoColorSpace = ''\nconst DisplayP3ColorSpace = 'display-p3'\nconst LinearDisplayP3ColorSpace = 'display-p3-linear'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst SRGBColorSpace = 'srgb'\n\nconst _taskCache = new WeakMap()\n\nlet _activeLoaders = 0\n\nlet _zstd\n\nclass KTX2Loader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    /** @type KTX2Loader.EngineFormat */\n    const EngineFormat = _EngineFormat\n    /** @type KTX2Loader.TranscoderFormat */\n    const TranscoderFormat = _TranscoderFormat\n    /** @type KTX2Loader.BasisFormat */\n    const BasisFormat = _BasisFormat\n\n    self.addEventListener('message', function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer)\n\n              self.postMessage(\n                { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags },\n                buffers,\n              )\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    })\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n\n        if (BasisModule.KTX2File === undefined) {\n          console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.')\n        }\n      })\n    }\n\n    function transcode(buffer) {\n      const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer))\n\n      function cleanup() {\n        ktx2File.close()\n        ktx2File.delete()\n      }\n\n      if (!ktx2File.isValid()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file')\n      }\n\n      const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = ktx2File.getWidth()\n      const height = ktx2File.getHeight()\n      const layerCount = ktx2File.getLayers() || 1\n      const levelCount = ktx2File.getLevels()\n      const faceCount = ktx2File.getFaces()\n      const hasAlpha = ktx2File.getHasAlpha()\n      const dfdFlags = ktx2File.getDFDFlags()\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levelCount) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid texture')\n      }\n\n      if (!ktx2File.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader: .startTranscoding failed')\n      }\n\n      const faces = []\n      const buffers = []\n\n      for (let face = 0; face < faceCount; face++) {\n        const mipmaps = []\n\n        for (let mip = 0; mip < levelCount; mip++) {\n          const layerMips = []\n\n          let mipWidth, mipHeight\n\n          for (let layer = 0; layer < layerCount; layer++) {\n            const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face)\n\n            if (\n              face === 0 &&\n              mip === 0 &&\n              layer === 0 &&\n              (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)\n            ) {\n              console.warn('THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.')\n            }\n\n            if (levelCount > 1) {\n              mipWidth = levelInfo.origWidth\n              mipHeight = levelInfo.origHeight\n            } else {\n              // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with\n              // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.\n              // See mrdoob/three.js#25908.\n              mipWidth = levelInfo.width\n              mipHeight = levelInfo.height\n            }\n\n            const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat))\n            const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1)\n\n            if (!status) {\n              cleanup()\n              throw new Error('THREE.KTX2Loader: .transcodeImage failed.')\n            }\n\n            layerMips.push(dst)\n          }\n\n          const mipData = concat(layerMips)\n\n          mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight })\n          buffers.push(mipData.buffer)\n        }\n\n        faces.push({ mipmaps, width, height, format: engineFormat })\n      }\n\n      cleanup()\n\n      return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (hasAlpha && opt.transcoderFormat.length < 2) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n\n    /** Concatenates N byte arrays. */\n    function concat(arrays) {\n      if (arrays.length === 1) return arrays[0]\n\n      let totalByteLength = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        totalByteLength += array.byteLength\n      }\n\n      const result = new Uint8Array(totalByteLength)\n\n      let byteOffset = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        result.set(array, byteOffset)\n\n        byteOffset += array.byteLength\n      }\n\n      return result\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerPool = new WorkerPool()\n    this.workerSourceURL = ''\n    this.workerConfig = null\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn(\n        'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n          ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n      )\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num)\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    if (renderer.capabilities.isWebGL2) {\n      // https://github.com/mrdoob/three.js/pull/22928\n      this.workerConfig.etc1Supported = false\n    }\n\n    return this\n  }\n\n  init() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js')\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm')\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = KTX2Loader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL)\n          const transcoderBinary = this.transcoderBinary.slice(0)\n\n          worker.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary }, [transcoderBinary])\n\n          return worker\n        })\n      })\n\n      if (_activeLoaders > 0) {\n        // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n\n        console.warn(\n          'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' +\n            ' Use a single KTX2Loader instance, or call .dispose() on old instances.',\n        )\n      }\n\n      _activeLoaders++\n    }\n\n    return this.transcoderPending\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.')\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture(buffer)\n          .then((texture) => (onLoad ? onLoad(texture) : null))\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  _createTextureFrom(transcodeResult, container) {\n    const { faces, width, height, format, type, error, dfdFlags } = transcodeResult\n\n    if (type === 'error') return Promise.reject(error)\n\n    let texture\n\n    if (container.faceCount === 6) {\n      texture = new CompressedCubeTexture(faces, format, UnsignedByteType)\n    } else {\n      const mipmaps = faces[0].mipmaps\n\n      texture =\n        container.layerCount > 1\n          ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType)\n          : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n    }\n\n    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n    texture.magFilter = LinearFilter\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const colorSpace = parseColorSpace(container)\n    if ('colorSpace' in texture) texture.colorSpace = colorSpace\n    else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED)\n\n    return texture\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer))\n\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createRawTexture(container)\n    }\n\n    //\n\n    const taskConfig = config\n    const texturePending = this.init()\n      .then(() => {\n        return this.workerPool.postMessage({ type: 'transcode', buffer, taskConfig: taskConfig }, [buffer])\n      })\n      .then((e) => this._createTextureFrom(e.data, container))\n\n    // Cache the task result.\n    _taskCache.set(buffer, { promise: texturePending })\n\n    return texturePending\n  }\n\n  dispose() {\n    this.workerPool.dispose()\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL)\n\n    _activeLoaders--\n\n    return this\n  }\n}\n\n//\n// Parsing for non-Basis textures. These textures are may have supercompression\n// like Zstd, but they do not require transcoding.\n\nconst UNCOMPRESSED_FORMATS = new Set([RGBAFormat, RGFormat, RedFormat])\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format,\n}\n\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType,\n}\n\nasync function createRawTexture(container) {\n  const { vkFormat } = container\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.')\n  }\n\n  //\n\n  let zstd\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd = new ZSTDDecoder()\n        await zstd.init()\n        resolve(zstd)\n      })\n    }\n\n    zstd = await _zstd\n  }\n\n  //\n\n  const mipmaps = []\n\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex)\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex)\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0\n\n    const level = container.levels[levelIndex]\n\n    let levelData\n\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength)\n    } else {\n      throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.')\n    }\n\n    let data\n\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT,\n      )\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT,\n      )\n    } else {\n      data = levelData\n    }\n\n    mipmaps.push({\n      data: data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth,\n    })\n  }\n\n  let texture\n\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture =\n      container.pixelDepth === 0\n        ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight)\n        : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth)\n  } else {\n    if (container.pixelDepth > 0) throw new Error('THREE.KTX2Loader: Unsupported pixelDepth.')\n\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight)\n  }\n\n  texture.mipmaps = mipmaps\n\n  texture.type = TYPE_MAP[vkFormat]\n  texture.format = FORMAT_MAP[vkFormat]\n  texture.needsUpdate = true\n\n  const colorSpace = parseColorSpace(container)\n  if ('colorSpace' in texture) texture.colorSpace = colorSpace\n  else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n  //\n\n  return Promise.resolve(texture)\n}\n\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0]\n\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`)\n    return NoColorSpace\n  }\n}\n\nexport { KTX2Loader }\n"]},"metadata":{},"sourceType":"module"}