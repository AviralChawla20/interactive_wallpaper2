{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"decode\",\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]);\n      });\n    }).then(message => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\"/* draco decoder */\", jsContent, \"\", \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          decoderConfig: this.decoderConfig\n        });\n        worker2.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map(worker => worker._taskLoad));\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            resolve({\n              draco\n            });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: \"decode\",\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = {\n      index: null,\n      attributes: []\n    };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport { DRACOLoader };","map":{"version":3,"sources":["../../src/loaders/DRACOLoader.js"],"names":["worker"],"mappings":"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","sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n"]},"metadata":{},"sourceType":"module"}