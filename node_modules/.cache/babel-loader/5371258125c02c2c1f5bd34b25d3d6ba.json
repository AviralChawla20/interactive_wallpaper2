{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from \"three\";\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== \"string\" || url === \"\") return \"\";\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\") continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = new Color().fromArray(value);\n          break;\n        case \"ks\":\n          params.specular = new Color().fromArray(value);\n          break;\n        case \"ke\":\n          params.emissive = new Color().fromArray(value);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== void 0) texture.mapping = mapping;\n    return texture;\n  }\n}\nexport { MTLLoader };","map":{"version":3,"sources":["../../src/loaders/MTLLoader.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Color,\n  DefaultLoadingManager,\n  FileLoader,\n  FrontSide,\n  Loader,\n  LoaderUtils,\n  MeshPhongMaterial,\n  RepeatWrapping,\n  TextureLoader,\n  Vector2,\n} from 'three'\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterialOptions(value) {\n    this.materialOptions = value\n    return this\n  }\n\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split('\\n')\n    let info = {}\n    const delimiter_pattern = /\\s+/\n    const materialsInfo = {}\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i]\n      line = line.trim()\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue\n      }\n\n      const pos = line.indexOf(' ')\n\n      let key = pos >= 0 ? line.substring(0, pos) : line\n      key = key.toLowerCase()\n\n      let value = pos >= 0 ? line.substring(pos + 1) : ''\n      value = value.trim()\n\n      if (key === 'newmtl') {\n        // New material\n\n        info = { name: value }\n        materialsInfo[value] = info\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3)\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])]\n        } else {\n          info[key] = value\n        }\n      }\n    }\n\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions)\n    materialCreator.setCrossOrigin(this.crossOrigin)\n    materialCreator.setManager(this.manager)\n    materialCreator.setMaterials(materialsInfo)\n    return materialCreator\n  }\n}\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nclass MaterialCreator {\n  constructor(baseUrl = '', options = {}) {\n    this.baseUrl = baseUrl\n    this.options = options\n    this.materialsInfo = {}\n    this.materials = {}\n    this.materialsArray = []\n    this.nameLookup = {}\n\n    this.crossOrigin = 'anonymous'\n\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping\n  }\n\n  setCrossOrigin(value) {\n    this.crossOrigin = value\n    return this\n  }\n\n  setManager(value) {\n    this.manager = value\n  }\n\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo)\n    this.materials = {}\n    this.materialsArray = []\n    this.nameLookup = {}\n  }\n\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo\n\n    const converted = {}\n\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n\n      const mat = materialsInfo[mn]\n\n      const covmat = {}\n\n      converted[mn] = covmat\n\n      for (const prop in mat) {\n        let save = true\n        let value = mat[prop]\n        const lprop = prop.toLowerCase()\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255]\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n\n                save = false\n              }\n            }\n\n            break\n\n          default:\n            break\n        }\n\n        if (save) {\n          covmat[lprop] = value\n        }\n      }\n    }\n\n    return converted\n  }\n\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn)\n    }\n  }\n\n  getIndex(materialName) {\n    return this.nameLookup[materialName]\n  }\n\n  getAsArray() {\n    let index = 0\n\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn)\n      this.nameLookup[mn] = index\n      index++\n    }\n\n    return this.materialsArray\n  }\n\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName)\n    }\n\n    return this.materials[materialName]\n  }\n\n  createMaterial_(materialName) {\n    // Create material\n\n    const scope = this\n    const mat = this.materialsInfo[materialName]\n    const params = {\n      name: materialName,\n      side: this.side,\n    }\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''\n\n      // Absolute URL\n      if (/^https?:\\/\\//i.test(url)) return url\n\n      return baseUrl + url\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params)\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url))\n\n      map.repeat.copy(texParams.scale)\n      map.offset.copy(texParams.offset)\n\n      map.wrapS = scope.wrap\n      map.wrapT = scope.wrap\n\n      params[mapType] = map\n    }\n\n    for (const prop in mat) {\n      const value = mat[prop]\n      let n\n\n      if (value === '') continue\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n\n          params.color = new Color().fromArray(value)\n\n          break\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value)\n\n          break\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value)\n\n          break\n\n        case 'map_kd':\n          // Diffuse texture map\n\n          setMapForType('map', value)\n\n          break\n\n        case 'map_ks':\n          // Specular map\n\n          setMapForType('specularMap', value)\n\n          break\n\n        case 'map_ke':\n          // Emissive map\n\n          setMapForType('emissiveMap', value)\n\n          break\n\n        case 'norm':\n          setMapForType('normalMap', value)\n\n          break\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n\n          setMapForType('bumpMap', value)\n\n          break\n\n        case 'map_d':\n          // Alpha map\n\n          setMapForType('alphaMap', value)\n          params.transparent = true\n\n          break\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n          params.shininess = parseFloat(value)\n\n          break\n\n        case 'd':\n          n = parseFloat(value)\n\n          if (n < 1) {\n            params.opacity = n\n            params.transparent = true\n          }\n\n          break\n\n        case 'tr':\n          n = parseFloat(value)\n\n          if (this.options && this.options.invertTrProperty) n = 1 - n\n\n          if (n > 0) {\n            params.opacity = 1 - n\n            params.transparent = true\n          }\n\n          break\n\n        default:\n          break\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params)\n    return this.materials[materialName]\n  }\n\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0),\n    }\n\n    const items = value.split(/\\s+/)\n    let pos\n\n    pos = items.indexOf('-bm')\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1])\n      items.splice(pos, 2)\n    }\n\n    pos = items.indexOf('-s')\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))\n      items.splice(pos, 4) // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o')\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))\n      items.splice(pos, 4) // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim()\n    return texParams\n  }\n\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager\n    let loader = manager.getHandler(url)\n\n    if (loader === null) {\n      loader = new TextureLoader(manager)\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin)\n\n    const texture = loader.load(url, onLoad, onProgress, onError)\n\n    if (mapping !== undefined) texture.mapping = mapping\n\n    return texture\n  }\n}\n\nexport { MTLLoader }\n"]},"metadata":{},"sourceType":"module"}