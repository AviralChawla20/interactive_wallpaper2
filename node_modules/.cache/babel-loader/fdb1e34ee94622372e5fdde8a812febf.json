{"ast":null,"code":"import { Vector4, Vector3, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nconst _viewport = new Vector4();\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 16777215\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nexport { LineSegments2 };","map":{"version":3,"sources":["../../src/lines/LineSegments2.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3()\nconst _end = new Vector3()\n\nconst _start4 = new Vector4()\nconst _end4 = new Vector4()\n\nconst _ssOrigin = new Vector4()\nconst _ssOrigin3 = new Vector3()\nconst _mvMatrix = new Matrix4()\nconst _line = new Line3()\nconst _closestPoint = new Vector3()\n\nconst _box = new Box3()\nconst _sphere = new Sphere()\nconst _clipToWorldVector = new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld);\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { LineSegments2 }\n"]},"metadata":{},"sourceType":"module"}