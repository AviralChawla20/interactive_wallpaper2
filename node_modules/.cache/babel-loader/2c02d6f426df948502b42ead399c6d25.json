{"ast":null,"code":"async function AmmoPhysics() {\n  if (\"Ammo\" in window === false) {\n    console.error(\"AmmoPhysics: Couldn't find Ammo.js\");\n    return;\n  }\n  const AmmoLib = await Ammo();\n  const frameRate = 60;\n  const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();\n  const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);\n  const broadphase = new AmmoLib.btDbvtBroadphase();\n  const solver = new AmmoLib.btSequentialImpulseConstraintSolver();\n  const world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n  world.setGravity(new AmmoLib.btVector3(0, -9.8, 0));\n  const worldTransform = new AmmoLib.btTransform();\n  function getShape(geometry) {\n    const parameters = geometry.parameters;\n    if (geometry.type === \"BoxGeometry\") {\n      const sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;\n      const sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;\n      const sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;\n      const shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));\n      shape.setMargin(0.05);\n      return shape;\n    } else if (geometry.type === \"SphereGeometry\" || geometry.type === \"IcosahedronGeometry\") {\n      const radius = parameters.radius !== void 0 ? parameters.radius : 1;\n      const shape = new AmmoLib.btSphereShape(radius);\n      shape.setMargin(0.05);\n      return shape;\n    }\n    return null;\n  }\n  const meshes = [];\n  const meshMap = /* @__PURE__ */new WeakMap();\n  function addMesh(mesh, mass = 0) {\n    const shape = getShape(mesh.geometry);\n    if (shape !== null) {\n      if (mesh.isInstancedMesh) {\n        handleInstancedMesh(mesh, mass, shape);\n      } else if (mesh.isMesh) {\n        handleMesh(mesh, mass, shape);\n      }\n    }\n  }\n  function handleMesh(mesh, mass, shape) {\n    const position = mesh.position;\n    const quaternion = mesh.quaternion;\n    const transform = new AmmoLib.btTransform();\n    transform.setIdentity();\n    transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n    transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));\n    const motionState = new AmmoLib.btDefaultMotionState(transform);\n    const localInertia = new AmmoLib.btVector3(0, 0, 0);\n    shape.calculateLocalInertia(mass, localInertia);\n    const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n    const body = new AmmoLib.btRigidBody(rbInfo);\n    world.addRigidBody(body);\n    if (mass > 0) {\n      meshes.push(mesh);\n      meshMap.set(mesh, body);\n    }\n  }\n  function handleInstancedMesh(mesh, mass, shape) {\n    const array = mesh.instanceMatrix.array;\n    const bodies = [];\n    for (let i = 0; i < mesh.count; i++) {\n      const index = i * 16;\n      const transform = new AmmoLib.btTransform();\n      transform.setFromOpenGLMatrix(array.slice(index, index + 16));\n      const motionState = new AmmoLib.btDefaultMotionState(transform);\n      const localInertia = new AmmoLib.btVector3(0, 0, 0);\n      shape.calculateLocalInertia(mass, localInertia);\n      const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n      const body = new AmmoLib.btRigidBody(rbInfo);\n      world.addRigidBody(body);\n      bodies.push(body);\n    }\n    if (mass > 0) {\n      mesh.instanceMatrix.setUsage(35048);\n      meshes.push(mesh);\n      meshMap.set(mesh, bodies);\n    }\n  }\n  function setMeshPosition(mesh, position, index = 0) {\n    if (mesh.isInstancedMesh) {\n      const bodies = meshMap.get(mesh);\n      const body = bodies[index];\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n      worldTransform.setIdentity();\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n      body.setWorldTransform(worldTransform);\n    } else if (mesh.isMesh) {\n      const body = meshMap.get(mesh);\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n      worldTransform.setIdentity();\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n      body.setWorldTransform(worldTransform);\n    }\n  }\n  let lastTime = 0;\n  function step() {\n    const time = performance.now();\n    if (lastTime > 0) {\n      const delta = (time - lastTime) / 1e3;\n      world.stepSimulation(delta, 10);\n    }\n    lastTime = time;\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i];\n      if (mesh.isInstancedMesh) {\n        const array = mesh.instanceMatrix.array;\n        const bodies = meshMap.get(mesh);\n        for (let j = 0; j < bodies.length; j++) {\n          const body = bodies[j];\n          const motionState = body.getMotionState();\n          motionState.getWorldTransform(worldTransform);\n          const position = worldTransform.getOrigin();\n          const quaternion = worldTransform.getRotation();\n          compose(position, quaternion, array, j * 16);\n        }\n        mesh.instanceMatrix.needsUpdate = true;\n      } else if (mesh.isMesh) {\n        const body = meshMap.get(mesh);\n        const motionState = body.getMotionState();\n        motionState.getWorldTransform(worldTransform);\n        const position = worldTransform.getOrigin();\n        const quaternion = worldTransform.getRotation();\n        mesh.position.set(position.x(), position.y(), position.z());\n        mesh.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());\n      }\n    }\n  }\n  setInterval(step, 1e3 / frameRate);\n  return {\n    addMesh,\n    setMeshPosition\n    // addCompoundMesh\n  };\n}\nfunction compose(position, quaternion, array, index) {\n  const x = quaternion.x(),\n    y = quaternion.y(),\n    z = quaternion.z(),\n    w = quaternion.w();\n  const x2 = x + x,\n    y2 = y + y,\n    z2 = z + z;\n  const xx = x * x2,\n    xy = x * y2,\n    xz = x * z2;\n  const yy = y * y2,\n    yz = y * z2,\n    zz = z * z2;\n  const wx = w * x2,\n    wy = w * y2,\n    wz = w * z2;\n  array[index + 0] = 1 - (yy + zz);\n  array[index + 1] = xy + wz;\n  array[index + 2] = xz - wy;\n  array[index + 3] = 0;\n  array[index + 4] = xy - wz;\n  array[index + 5] = 1 - (xx + zz);\n  array[index + 6] = yz + wx;\n  array[index + 7] = 0;\n  array[index + 8] = xz + wy;\n  array[index + 9] = yz - wx;\n  array[index + 10] = 1 - (xx + yy);\n  array[index + 11] = 0;\n  array[index + 12] = position.x();\n  array[index + 13] = position.y();\n  array[index + 14] = position.z();\n  array[index + 15] = 1;\n}\nexport { AmmoPhysics };","map":{"version":3,"sources":["../../src/physics/AmmoPhysics.js"],"names":[],"mappings":"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","sourcesContent":["async function AmmoPhysics() {\n  if ('Ammo' in window === false) {\n    console.error(\"AmmoPhysics: Couldn't find Ammo.js\")\n    return\n  }\n\n  const AmmoLib = await Ammo()\n\n  const frameRate = 60\n\n  const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration()\n  const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration)\n  const broadphase = new AmmoLib.btDbvtBroadphase()\n  const solver = new AmmoLib.btSequentialImpulseConstraintSolver()\n  const world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration)\n  world.setGravity(new AmmoLib.btVector3(0, -9.8, 0))\n\n  const worldTransform = new AmmoLib.btTransform()\n\n  //\n\n  function getShape(geometry) {\n    const parameters = geometry.parameters\n\n    // TODO change type to is*\n\n    if (geometry.type === 'BoxGeometry') {\n      const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5\n      const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5\n      const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5\n\n      const shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz))\n      shape.setMargin(0.05)\n\n      return shape\n    } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {\n      const radius = parameters.radius !== undefined ? parameters.radius : 1\n\n      const shape = new AmmoLib.btSphereShape(radius)\n      shape.setMargin(0.05)\n\n      return shape\n    }\n\n    return null\n  }\n\n  const meshes = []\n  const meshMap = new WeakMap()\n\n  function addMesh(mesh, mass = 0) {\n    const shape = getShape(mesh.geometry)\n\n    if (shape !== null) {\n      if (mesh.isInstancedMesh) {\n        handleInstancedMesh(mesh, mass, shape)\n      } else if (mesh.isMesh) {\n        handleMesh(mesh, mass, shape)\n      }\n    }\n  }\n\n  function handleMesh(mesh, mass, shape) {\n    const position = mesh.position\n    const quaternion = mesh.quaternion\n\n    const transform = new AmmoLib.btTransform()\n    transform.setIdentity()\n    transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n    transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w))\n\n    const motionState = new AmmoLib.btDefaultMotionState(transform)\n\n    const localInertia = new AmmoLib.btVector3(0, 0, 0)\n    shape.calculateLocalInertia(mass, localInertia)\n\n    const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia)\n\n    const body = new AmmoLib.btRigidBody(rbInfo)\n    // body.setFriction( 4 );\n    world.addRigidBody(body)\n\n    if (mass > 0) {\n      meshes.push(mesh)\n      meshMap.set(mesh, body)\n    }\n  }\n\n  function handleInstancedMesh(mesh, mass, shape) {\n    const array = mesh.instanceMatrix.array\n\n    const bodies = []\n\n    for (let i = 0; i < mesh.count; i++) {\n      const index = i * 16\n\n      const transform = new AmmoLib.btTransform()\n      transform.setFromOpenGLMatrix(array.slice(index, index + 16))\n\n      const motionState = new AmmoLib.btDefaultMotionState(transform)\n\n      const localInertia = new AmmoLib.btVector3(0, 0, 0)\n      shape.calculateLocalInertia(mass, localInertia)\n\n      const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia)\n\n      const body = new AmmoLib.btRigidBody(rbInfo)\n      world.addRigidBody(body)\n\n      bodies.push(body)\n    }\n\n    if (mass > 0) {\n      mesh.instanceMatrix.setUsage(35048) // THREE.DynamicDrawUsage = 35048\n      meshes.push(mesh)\n\n      meshMap.set(mesh, bodies)\n    }\n  }\n\n  //\n\n  function setMeshPosition(mesh, position, index = 0) {\n    if (mesh.isInstancedMesh) {\n      const bodies = meshMap.get(mesh)\n      const body = bodies[index]\n\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0))\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0))\n\n      worldTransform.setIdentity()\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n      body.setWorldTransform(worldTransform)\n    } else if (mesh.isMesh) {\n      const body = meshMap.get(mesh)\n\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0))\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0))\n\n      worldTransform.setIdentity()\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n      body.setWorldTransform(worldTransform)\n    }\n  }\n\n  //\n\n  let lastTime = 0\n\n  function step() {\n    const time = performance.now()\n\n    if (lastTime > 0) {\n      const delta = (time - lastTime) / 1000\n\n      // console.time( 'world.step' );\n      world.stepSimulation(delta, 10)\n      // console.timeEnd( 'world.step' );\n    }\n\n    lastTime = time\n\n    //\n\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i]\n\n      if (mesh.isInstancedMesh) {\n        const array = mesh.instanceMatrix.array\n        const bodies = meshMap.get(mesh)\n\n        for (let j = 0; j < bodies.length; j++) {\n          const body = bodies[j]\n\n          const motionState = body.getMotionState()\n          motionState.getWorldTransform(worldTransform)\n\n          const position = worldTransform.getOrigin()\n          const quaternion = worldTransform.getRotation()\n\n          compose(position, quaternion, array, j * 16)\n        }\n\n        mesh.instanceMatrix.needsUpdate = true\n      } else if (mesh.isMesh) {\n        const body = meshMap.get(mesh)\n\n        const motionState = body.getMotionState()\n        motionState.getWorldTransform(worldTransform)\n\n        const position = worldTransform.getOrigin()\n        const quaternion = worldTransform.getRotation()\n        mesh.position.set(position.x(), position.y(), position.z())\n        mesh.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w())\n      }\n    }\n  }\n\n  // animate\n\n  setInterval(step, 1000 / frameRate)\n\n  return {\n    addMesh: addMesh,\n    setMeshPosition: setMeshPosition,\n    // addCompoundMesh\n  }\n}\n\nfunction compose(position, quaternion, array, index) {\n  const x = quaternion.x(),\n    y = quaternion.y(),\n    z = quaternion.z(),\n    w = quaternion.w()\n  const x2 = x + x,\n    y2 = y + y,\n    z2 = z + z\n  const xx = x * x2,\n    xy = x * y2,\n    xz = x * z2\n  const yy = y * y2,\n    yz = y * z2,\n    zz = z * z2\n  const wx = w * x2,\n    wy = w * y2,\n    wz = w * z2\n\n  array[index + 0] = 1 - (yy + zz)\n  array[index + 1] = xy + wz\n  array[index + 2] = xz - wy\n  array[index + 3] = 0\n\n  array[index + 4] = xy - wz\n  array[index + 5] = 1 - (xx + zz)\n  array[index + 6] = yz + wx\n  array[index + 7] = 0\n\n  array[index + 8] = xz + wy\n  array[index + 9] = yz - wx\n  array[index + 10] = 1 - (xx + yy)\n  array[index + 11] = 0\n\n  array[index + 12] = position.x()\n  array[index + 13] = position.y()\n  array[index + 14] = position.z()\n  array[index + 15] = 1\n}\n\nexport { AmmoPhysics }\n"]},"metadata":{},"sourceType":"module"}