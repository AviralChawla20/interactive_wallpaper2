{"ast":null,"code":"import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, HalfFloatType } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nclass SSAARenderPass extends Pass {\n  constructor(scene, camera, clearColor, clearAlpha) {\n    super();\n    this.scene = scene;\n    this.camera = camera;\n    this.sampleLevel = 4;\n    this.unbiased = true;\n    this.clearColor = clearColor !== void 0 ? clearColor : 0;\n    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;\n    this._oldClearColor = new Color();\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyMaterial = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      premultipliedAlpha: true,\n      blending: AdditiveBlending\n    });\n    this.fsQuad = new FullScreenQuad(this.copyMaterial);\n  }\n  dispose() {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n    this.copyMaterial.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        type: HalfFloatType\n      });\n      this.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\n    }\n    const jitterOffsets = _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    const oldClearAlpha = renderer.getClearAlpha();\n    const baseSampleWeight = 1 / jitterOffsets.length;\n    const roundingRange = 1 / 32;\n    this.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n    const viewOffset = {\n      fullWidth: readBuffer.width,\n      fullHeight: readBuffer.height,\n      offsetX: 0,\n      offsetY: 0,\n      width: readBuffer.width,\n      height: readBuffer.height\n    };\n    const originalViewOffset = Object.assign({}, this.camera.view);\n    if (originalViewOffset.enabled) Object.assign(viewOffset, originalViewOffset);\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      const jitterOffset = jitterOffsets[i];\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(viewOffset.fullWidth, viewOffset.fullHeight, viewOffset.offsetX + jitterOffset[0] * 0.0625, viewOffset.offsetY + jitterOffset[1] * 0.0625,\n        // 0.0625 = 1 / 16\n        viewOffset.width, viewOffset.height);\n      }\n      let sampleWeight = baseSampleWeight;\n      if (this.unbiased) {\n        const uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n      this.copyUniforms[\"opacity\"].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n      if (i === 0) {\n        renderer.setClearColor(0, 0);\n        renderer.clear();\n      }\n      this.fsQuad.render(renderer);\n    }\n    if (this.camera.setViewOffset && originalViewOffset.enabled) {\n      this.camera.setViewOffset(originalViewOffset.fullWidth, originalViewOffset.fullHeight, originalViewOffset.offsetX, originalViewOffset.offsetY, originalViewOffset.width, originalViewOffset.height);\n    } else if (this.camera.clearViewOffset) {\n      this.camera.clearViewOffset();\n    }\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}\nconst _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };","map":{"version":3,"sources":["../../src/postprocessing/SSAARenderPass.js"],"names":[],"mappings":"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","sourcesContent":["import { AdditiveBlending, Color, HalfFloatType, ShaderMaterial, UniformsUtils, WebGLRenderTarget } from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nclass SSAARenderPass extends Pass {\n  constructor(scene, camera, clearColor, clearAlpha) {\n    super()\n\n    this.scene = scene\n    this.camera = camera\n\n    this.sampleLevel = 4 // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n    this.unbiased = true\n\n    // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n    this.clearColor = clearColor !== undefined ? clearColor : 0x000000\n    this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0\n    this._oldClearColor = new Color()\n\n    const copyShader = CopyShader\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n\n    this.copyMaterial = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      premultipliedAlpha: true,\n      blending: AdditiveBlending,\n    })\n\n    this.fsQuad = new FullScreenQuad(this.copyMaterial)\n  }\n\n  dispose() {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose()\n      this.sampleRenderTarget = null\n    }\n\n    this.copyMaterial.dispose()\n\n    this.fsQuad.dispose()\n  }\n\n  setSize(width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height)\n  }\n\n  render(renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, { type: HalfFloatType })\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample'\n    }\n\n    const jitterOffsets = _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))]\n\n    const autoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.getClearColor(this._oldClearColor)\n    const oldClearAlpha = renderer.getClearAlpha()\n\n    const baseSampleWeight = 1.0 / jitterOffsets.length\n    const roundingRange = 1 / 32\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture\n\n    const viewOffset = {\n      fullWidth: readBuffer.width,\n      fullHeight: readBuffer.height,\n      offsetX: 0,\n      offsetY: 0,\n      width: readBuffer.width,\n      height: readBuffer.height,\n    }\n\n    const originalViewOffset = Object.assign({}, this.camera.view)\n\n    if (originalViewOffset.enabled) Object.assign(viewOffset, originalViewOffset)\n\n    // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      const jitterOffset = jitterOffsets[i]\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(\n          viewOffset.fullWidth,\n          viewOffset.fullHeight,\n\n          viewOffset.offsetX + jitterOffset[0] * 0.0625,\n          viewOffset.offsetY + jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n\n          viewOffset.width,\n          viewOffset.height,\n        )\n      }\n\n      let sampleWeight = baseSampleWeight\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n\n        const uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length\n        sampleWeight += roundingRange * uniformCenteredDistribution\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight\n      renderer.setClearColor(this.clearColor, this.clearAlpha)\n      renderer.setRenderTarget(this.sampleRenderTarget)\n      renderer.clear()\n      renderer.render(this.scene, this.camera)\n\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer)\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0)\n        renderer.clear()\n      }\n\n      this.fsQuad.render(renderer)\n    }\n\n    if (this.camera.setViewOffset && originalViewOffset.enabled) {\n      this.camera.setViewOffset(\n        originalViewOffset.fullWidth,\n        originalViewOffset.fullHeight,\n\n        originalViewOffset.offsetX,\n        originalViewOffset.offsetY,\n\n        originalViewOffset.width,\n        originalViewOffset.height,\n      )\n    } else if (this.camera.clearViewOffset) {\n      this.camera.clearViewOffset()\n    }\n\n    renderer.autoClear = autoClear\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha)\n  }\n}\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n// prettier-ignore\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { SSAARenderPass }\n"]},"metadata":{},"sourceType":"module"}