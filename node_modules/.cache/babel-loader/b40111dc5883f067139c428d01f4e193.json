{"ast":null,"code":"import { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from \"three\";\nclass RenderableObject {\n  constructor() {\n    this.id = 0;\n    this.object = null;\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableFace {\n  constructor() {\n    this.id = 0;\n    this.v1 = new RenderableVertex();\n    this.v2 = new RenderableVertex();\n    this.v3 = new RenderableVertex();\n    this.normalModel = new Vector3();\n    this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\n    this.vertexNormalsLength = 0;\n    this.color = new Color();\n    this.material = null;\n    this.uvs = [new Vector2(), new Vector2(), new Vector2()];\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableVertex {\n  constructor() {\n    this.position = new Vector3();\n    this.positionWorld = new Vector3();\n    this.positionScreen = new Vector4();\n    this.visible = true;\n  }\n  copy(vertex) {\n    this.positionWorld.copy(vertex.positionWorld);\n    this.positionScreen.copy(vertex.positionScreen);\n  }\n}\nclass RenderableLine {\n  constructor() {\n    this.id = 0;\n    this.v1 = new RenderableVertex();\n    this.v2 = new RenderableVertex();\n    this.vertexColors = [new Color(), new Color()];\n    this.material = null;\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableSprite {\n  constructor() {\n    this.id = 0;\n    this.object = null;\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.rotation = 0;\n    this.scale = new Vector2();\n    this.material = null;\n    this.renderOrder = 0;\n  }\n}\nclass Projector {\n  constructor() {\n    let _object,\n      _objectCount,\n      _objectPoolLength = 0,\n      _vertex,\n      _vertexCount,\n      _vertexPoolLength = 0,\n      _face,\n      _faceCount,\n      _facePoolLength = 0,\n      _line,\n      _lineCount,\n      _linePoolLength = 0,\n      _sprite,\n      _spriteCount,\n      _spritePoolLength = 0,\n      _modelMatrix;\n    const _renderData = {\n        objects: [],\n        lights: [],\n        elements: []\n      },\n      _vector3 = new Vector3(),\n      _vector4 = new Vector4(),\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n      _boundingBox = new Box3(),\n      _points3 = new Array(3),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _modelViewProjectionMatrix = new Matrix4(),\n      _frustum = new Frustum(),\n      _objectPool = [],\n      _vertexPool = [],\n      _facePool = [],\n      _linePool = [],\n      _spritePool = [];\n    function RenderList() {\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      let object = null;\n      const normalMatrix = new Matrix3();\n      function setObject(value) {\n        object = value;\n        normalMatrix.getNormalMatrix(object.matrixWorld);\n        normals.length = 0;\n        colors.length = 0;\n        uvs.length = 0;\n      }\n      function projectVertex(vertex) {\n        const position = vertex.position;\n        const positionWorld = vertex.positionWorld;\n        const positionScreen = vertex.positionScreen;\n        positionWorld.copy(position).applyMatrix4(_modelMatrix);\n        positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n        const invW = 1 / positionScreen.w;\n        positionScreen.x *= invW;\n        positionScreen.y *= invW;\n        positionScreen.z *= invW;\n        vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n      }\n      function pushVertex(x, y, z) {\n        _vertex = getNextVertexInPool();\n        _vertex.position.set(x, y, z);\n        projectVertex(_vertex);\n      }\n      function pushNormal(x, y, z) {\n        normals.push(x, y, z);\n      }\n      function pushColor(r, g, b) {\n        colors.push(r, g, b);\n      }\n      function pushUv(x, y) {\n        uvs.push(x, y);\n      }\n      function checkTriangleVisibility(v1, v2, v3) {\n        if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n        _points3[0] = v1.positionScreen;\n        _points3[1] = v2.positionScreen;\n        _points3[2] = v3.positionScreen;\n        return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\n      }\n      function checkBackfaceCulling(v1, v2, v3) {\n        return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n      }\n      function pushLine(a, b) {\n        const v1 = _vertexPool[a];\n        const v2 = _vertexPool[b];\n        v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\n        v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\n        if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n          v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\n          v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\n          _line = getNextLineInPool();\n          _line.id = object.id;\n          _line.v1.copy(v1);\n          _line.v2.copy(v2);\n          _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\n          _line.renderOrder = object.renderOrder;\n          _line.material = object.material;\n          if (object.material.vertexColors) {\n            _line.vertexColors[0].fromArray(colors, a * 3);\n            _line.vertexColors[1].fromArray(colors, b * 3);\n          }\n          _renderData.elements.push(_line);\n        }\n      }\n      function pushTriangle(a, b, c, material) {\n        const v1 = _vertexPool[a];\n        const v2 = _vertexPool[b];\n        const v3 = _vertexPool[c];\n        if (checkTriangleVisibility(v1, v2, v3) === false) return;\n        if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n          _face = getNextFaceInPool();\n          _face.id = object.id;\n          _face.v1.copy(v1);\n          _face.v2.copy(v2);\n          _face.v3.copy(v3);\n          _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n          _face.renderOrder = object.renderOrder;\n          _vector3.subVectors(v3.position, v2.position);\n          _vector4.subVectors(v1.position, v2.position);\n          _vector3.cross(_vector4);\n          _face.normalModel.copy(_vector3);\n          _face.normalModel.applyMatrix3(normalMatrix).normalize();\n          for (let i = 0; i < 3; i++) {\n            const normal = _face.vertexNormalsModel[i];\n            normal.fromArray(normals, arguments[i] * 3);\n            normal.applyMatrix3(normalMatrix).normalize();\n            const uv = _face.uvs[i];\n            uv.fromArray(uvs, arguments[i] * 2);\n          }\n          _face.vertexNormalsLength = 3;\n          _face.material = material;\n          if (material.vertexColors) {\n            _face.color.fromArray(colors, a * 3);\n          }\n          _renderData.elements.push(_face);\n        }\n      }\n      return {\n        setObject,\n        projectVertex,\n        checkTriangleVisibility,\n        checkBackfaceCulling,\n        pushVertex,\n        pushNormal,\n        pushColor,\n        pushUv,\n        pushLine,\n        pushTriangle\n      };\n    }\n    const renderList = new RenderList();\n    function projectObject(object) {\n      if (object.visible === false) return;\n      if (object.isLight) {\n        _renderData.lights.push(object);\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material.visible === false) return;\n        if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\n        addObject(object);\n      } else if (object.isSprite) {\n        if (object.material.visible === false) return;\n        if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\n        addObject(object);\n      }\n      const children = object.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        projectObject(children[i]);\n      }\n    }\n    function addObject(object) {\n      _object = getNextObjectInPool();\n      _object.id = object.id;\n      _object.object = object;\n      _vector3.setFromMatrixPosition(object.matrixWorld);\n      _vector3.applyMatrix4(_viewProjectionMatrix);\n      _object.z = _vector3.z;\n      _object.renderOrder = object.renderOrder;\n      _renderData.objects.push(_object);\n    }\n    this.projectScene = function (scene, camera, sortObjects, sortElements) {\n      _faceCount = 0;\n      _lineCount = 0;\n      _spriteCount = 0;\n      _renderData.elements.length = 0;\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n      _viewMatrix.copy(camera.matrixWorldInverse);\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n      _frustum.setFromProjectionMatrix(_viewProjectionMatrix);\n      _objectCount = 0;\n      _renderData.objects.length = 0;\n      _renderData.lights.length = 0;\n      projectObject(scene);\n      if (sortObjects === true) {\n        _renderData.objects.sort(painterSort);\n      }\n      const objects = _renderData.objects;\n      for (let o = 0, ol = objects.length; o < ol; o++) {\n        const object = objects[o].object;\n        const geometry = object.geometry;\n        renderList.setObject(object);\n        _modelMatrix = object.matrixWorld;\n        _vertexCount = 0;\n        if (object.isMesh) {\n          let material = object.material;\n          const isMultiMaterial = Array.isArray(material);\n          const attributes = geometry.attributes;\n          const groups = geometry.groups;\n          if (attributes.position === void 0) continue;\n          const positions = attributes.position.array;\n          for (let i = 0, l = positions.length; i < l; i += 3) {\n            let x = positions[i];\n            let y = positions[i + 1];\n            let z = positions[i + 2];\n            const morphTargets = geometry.morphAttributes.position;\n            if (morphTargets !== void 0) {\n              const morphTargetsRelative = geometry.morphTargetsRelative;\n              const morphInfluences = object.morphTargetInfluences;\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\n                const influence = morphInfluences[t];\n                if (influence === 0) continue;\n                const target = morphTargets[t];\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence;\n                  y += target.getY(i / 3) * influence;\n                  z += target.getZ(i / 3) * influence;\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence;\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence;\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence;\n                }\n              }\n            }\n            renderList.pushVertex(x, y, z);\n          }\n          if (attributes.normal !== void 0) {\n            const normals = attributes.normal.array;\n            for (let i = 0, l = normals.length; i < l; i += 3) {\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);\n            }\n          }\n          if (attributes.color !== void 0) {\n            const colors = attributes.color.array;\n            for (let i = 0, l = colors.length; i < l; i += 3) {\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n            }\n          }\n          if (attributes.uv !== void 0) {\n            const uvs = attributes.uv.array;\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\n              renderList.pushUv(uvs[i], uvs[i + 1]);\n            }\n          }\n          if (geometry.index !== null) {\n            const indices = geometry.index.array;\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === void 0) continue;\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n                }\n              }\n            } else {\n              for (let i = 0, l = indices.length; i < l; i += 3) {\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === void 0) continue;\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(i, i + 1, i + 2, material);\n                }\n              }\n            } else {\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\n                renderList.pushTriangle(i, i + 1, i + 2, material);\n              }\n            }\n          }\n        } else if (object.isLine) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n          const attributes = geometry.attributes;\n          if (attributes.position !== void 0) {\n            const positions = attributes.position.array;\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\n            }\n            if (attributes.color !== void 0) {\n              const colors = attributes.color.array;\n              for (let i = 0, l = colors.length; i < l; i += 3) {\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n              }\n            }\n            if (geometry.index !== null) {\n              const indices = geometry.index.array;\n              for (let i = 0, l = indices.length; i < l; i += 2) {\n                renderList.pushLine(indices[i], indices[i + 1]);\n              }\n            } else {\n              const step = object.isLineSegments ? 2 : 1;\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n                renderList.pushLine(i, i + 1);\n              }\n            }\n          }\n        } else if (object.isPoints) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n          const attributes = geometry.attributes;\n          if (attributes.position !== void 0) {\n            const positions = attributes.position.array;\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);\n              _vector4.applyMatrix4(_modelViewProjectionMatrix);\n              pushPoint(_vector4, object, camera);\n            }\n          }\n        } else if (object.isSprite) {\n          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n          _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n          _vector4.applyMatrix4(_viewProjectionMatrix);\n          pushPoint(_vector4, object, camera);\n        }\n      }\n      if (sortElements === true) {\n        _renderData.elements.sort(painterSort);\n      }\n      return _renderData;\n    };\n    function pushPoint(_vector42, object, camera) {\n      const invW = 1 / _vector42.w;\n      _vector42.z *= invW;\n      if (_vector42.z >= -1 && _vector42.z <= 1) {\n        _sprite = getNextSpriteInPool();\n        _sprite.id = object.id;\n        _sprite.x = _vector42.x * invW;\n        _sprite.y = _vector42.y * invW;\n        _sprite.z = _vector42.z;\n        _sprite.renderOrder = object.renderOrder;\n        _sprite.object = object;\n        _sprite.rotation = object.rotation;\n        _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector42.x + camera.projectionMatrix.elements[0]) / (_vector42.w + camera.projectionMatrix.elements[12]));\n        _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector42.y + camera.projectionMatrix.elements[5]) / (_vector42.w + camera.projectionMatrix.elements[13]));\n        _sprite.material = object.material;\n        _renderData.elements.push(_sprite);\n      }\n    }\n    function getNextObjectInPool() {\n      if (_objectCount === _objectPoolLength) {\n        const object = new RenderableObject();\n        _objectPool.push(object);\n        _objectPoolLength++;\n        _objectCount++;\n        return object;\n      }\n      return _objectPool[_objectCount++];\n    }\n    function getNextVertexInPool() {\n      if (_vertexCount === _vertexPoolLength) {\n        const vertex = new RenderableVertex();\n        _vertexPool.push(vertex);\n        _vertexPoolLength++;\n        _vertexCount++;\n        return vertex;\n      }\n      return _vertexPool[_vertexCount++];\n    }\n    function getNextFaceInPool() {\n      if (_faceCount === _facePoolLength) {\n        const face = new RenderableFace();\n        _facePool.push(face);\n        _facePoolLength++;\n        _faceCount++;\n        return face;\n      }\n      return _facePool[_faceCount++];\n    }\n    function getNextLineInPool() {\n      if (_lineCount === _linePoolLength) {\n        const line = new RenderableLine();\n        _linePool.push(line);\n        _linePoolLength++;\n        _lineCount++;\n        return line;\n      }\n      return _linePool[_lineCount++];\n    }\n    function getNextSpriteInPool() {\n      if (_spriteCount === _spritePoolLength) {\n        const sprite = new RenderableSprite();\n        _spritePool.push(sprite);\n        _spritePoolLength++;\n        _spriteCount++;\n        return sprite;\n      }\n      return _spritePool[_spriteCount++];\n    }\n    function painterSort(a, b) {\n      if (a.renderOrder !== b.renderOrder) {\n        return a.renderOrder - b.renderOrder;\n      } else if (a.z !== b.z) {\n        return b.z - a.z;\n      } else if (a.id !== b.id) {\n        return a.id - b.id;\n      } else {\n        return 0;\n      }\n    }\n    function clipLine(s1, s2) {\n      let alpha1 = 0,\n        alpha2 = 1;\n      const bc1near = s1.z + s1.w,\n        bc2near = s2.z + s2.w,\n        bc1far = -s1.z + s1.w,\n        bc2far = -s2.z + s2.w;\n      if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n        return true;\n      } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n        return false;\n      } else {\n        if (bc1near < 0) {\n          alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n        } else if (bc2near < 0) {\n          alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n        }\n        if (bc1far < 0) {\n          alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n        } else if (bc2far < 0) {\n          alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n        }\n        if (alpha2 < alpha1) {\n          return false;\n        } else {\n          s1.lerp(s2, alpha1);\n          s2.lerp(s1, 1 - alpha2);\n          return true;\n        }\n      }\n    }\n  }\n}\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };","map":{"version":3,"sources":["../../src/renderers/Projector.js"],"names":["_vector4"],"mappings":"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","sourcesContent":["import { Box3, Color, DoubleSide, Frustum, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three'\n\nclass RenderableObject {\n  constructor() {\n    this.id = 0\n\n    this.object = null\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableFace {\n  constructor() {\n    this.id = 0\n\n    this.v1 = new RenderableVertex()\n    this.v2 = new RenderableVertex()\n    this.v3 = new RenderableVertex()\n\n    this.normalModel = new Vector3()\n\n    this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()]\n    this.vertexNormalsLength = 0\n\n    this.color = new Color()\n    this.material = null\n    this.uvs = [new Vector2(), new Vector2(), new Vector2()]\n\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableVertex {\n  constructor() {\n    this.position = new Vector3()\n    this.positionWorld = new Vector3()\n    this.positionScreen = new Vector4()\n\n    this.visible = true\n  }\n\n  copy(vertex) {\n    this.positionWorld.copy(vertex.positionWorld)\n    this.positionScreen.copy(vertex.positionScreen)\n  }\n}\n\n//\n\nclass RenderableLine {\n  constructor() {\n    this.id = 0\n\n    this.v1 = new RenderableVertex()\n    this.v2 = new RenderableVertex()\n\n    this.vertexColors = [new Color(), new Color()]\n    this.material = null\n\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableSprite {\n  constructor() {\n    this.id = 0\n\n    this.object = null\n\n    this.x = 0\n    this.y = 0\n    this.z = 0\n\n    this.rotation = 0\n    this.scale = new Vector2()\n\n    this.material = null\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass Projector {\n  constructor() {\n    let _object,\n      _objectCount,\n      _objectPoolLength = 0,\n      _vertex,\n      _vertexCount,\n      _vertexPoolLength = 0,\n      _face,\n      _faceCount,\n      _facePoolLength = 0,\n      _line,\n      _lineCount,\n      _linePoolLength = 0,\n      _sprite,\n      _spriteCount,\n      _spritePoolLength = 0,\n      _modelMatrix\n\n    const _renderData = { objects: [], lights: [], elements: [] },\n      _vector3 = new Vector3(),\n      _vector4 = new Vector4(),\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n      _boundingBox = new Box3(),\n      _points3 = new Array(3),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _modelViewProjectionMatrix = new Matrix4(),\n      _frustum = new Frustum(),\n      _objectPool = [],\n      _vertexPool = [],\n      _facePool = [],\n      _linePool = [],\n      _spritePool = []\n\n    //\n\n    function RenderList() {\n      const normals = []\n      const colors = []\n      const uvs = []\n\n      let object = null\n\n      const normalMatrix = new Matrix3()\n\n      function setObject(value) {\n        object = value\n\n        normalMatrix.getNormalMatrix(object.matrixWorld)\n\n        normals.length = 0\n        colors.length = 0\n        uvs.length = 0\n      }\n\n      function projectVertex(vertex) {\n        const position = vertex.position\n        const positionWorld = vertex.positionWorld\n        const positionScreen = vertex.positionScreen\n\n        positionWorld.copy(position).applyMatrix4(_modelMatrix)\n        positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix)\n\n        const invW = 1 / positionScreen.w\n\n        positionScreen.x *= invW\n        positionScreen.y *= invW\n        positionScreen.z *= invW\n\n        vertex.visible =\n          positionScreen.x >= -1 &&\n          positionScreen.x <= 1 &&\n          positionScreen.y >= -1 &&\n          positionScreen.y <= 1 &&\n          positionScreen.z >= -1 &&\n          positionScreen.z <= 1\n      }\n\n      function pushVertex(x, y, z) {\n        _vertex = getNextVertexInPool()\n        _vertex.position.set(x, y, z)\n\n        projectVertex(_vertex)\n      }\n\n      function pushNormal(x, y, z) {\n        normals.push(x, y, z)\n      }\n\n      function pushColor(r, g, b) {\n        colors.push(r, g, b)\n      }\n\n      function pushUv(x, y) {\n        uvs.push(x, y)\n      }\n\n      function checkTriangleVisibility(v1, v2, v3) {\n        if (v1.visible === true || v2.visible === true || v3.visible === true) return true\n\n        _points3[0] = v1.positionScreen\n        _points3[1] = v2.positionScreen\n        _points3[2] = v3.positionScreen\n\n        return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3))\n      }\n\n      function checkBackfaceCulling(v1, v2, v3) {\n        return (\n          (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) -\n            (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) <\n          0\n        )\n      }\n\n      function pushLine(a, b) {\n        const v1 = _vertexPool[a]\n        const v2 = _vertexPool[b]\n\n        // Clip\n\n        v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix)\n        v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix)\n\n        if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n          // Perform the perspective divide\n          v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w)\n          v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w)\n\n          _line = getNextLineInPool()\n          _line.id = object.id\n          _line.v1.copy(v1)\n          _line.v2.copy(v2)\n          _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z)\n          _line.renderOrder = object.renderOrder\n\n          _line.material = object.material\n\n          if (object.material.vertexColors) {\n            _line.vertexColors[0].fromArray(colors, a * 3)\n            _line.vertexColors[1].fromArray(colors, b * 3)\n          }\n\n          _renderData.elements.push(_line)\n        }\n      }\n\n      function pushTriangle(a, b, c, material) {\n        const v1 = _vertexPool[a]\n        const v2 = _vertexPool[b]\n        const v3 = _vertexPool[c]\n\n        if (checkTriangleVisibility(v1, v2, v3) === false) return\n\n        if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n          _face = getNextFaceInPool()\n\n          _face.id = object.id\n          _face.v1.copy(v1)\n          _face.v2.copy(v2)\n          _face.v3.copy(v3)\n          _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3\n          _face.renderOrder = object.renderOrder\n\n          // face normal\n          _vector3.subVectors(v3.position, v2.position)\n          _vector4.subVectors(v1.position, v2.position)\n          _vector3.cross(_vector4)\n          _face.normalModel.copy(_vector3)\n          _face.normalModel.applyMatrix3(normalMatrix).normalize()\n\n          for (let i = 0; i < 3; i++) {\n            const normal = _face.vertexNormalsModel[i]\n            normal.fromArray(normals, arguments[i] * 3)\n            normal.applyMatrix3(normalMatrix).normalize()\n\n            const uv = _face.uvs[i]\n            uv.fromArray(uvs, arguments[i] * 2)\n          }\n\n          _face.vertexNormalsLength = 3\n\n          _face.material = material\n\n          if (material.vertexColors) {\n            _face.color.fromArray(colors, a * 3)\n          }\n\n          _renderData.elements.push(_face)\n        }\n      }\n\n      return {\n        setObject: setObject,\n        projectVertex: projectVertex,\n        checkTriangleVisibility: checkTriangleVisibility,\n        checkBackfaceCulling: checkBackfaceCulling,\n        pushVertex: pushVertex,\n        pushNormal: pushNormal,\n        pushColor: pushColor,\n        pushUv: pushUv,\n        pushLine: pushLine,\n        pushTriangle: pushTriangle,\n      }\n    }\n\n    const renderList = new RenderList()\n\n    function projectObject(object) {\n      if (object.visible === false) return\n\n      if (object.isLight) {\n        _renderData.lights.push(object)\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material.visible === false) return\n        if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return\n\n        addObject(object)\n      } else if (object.isSprite) {\n        if (object.material.visible === false) return\n        if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return\n\n        addObject(object)\n      }\n\n      const children = object.children\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        projectObject(children[i])\n      }\n    }\n\n    function addObject(object) {\n      _object = getNextObjectInPool()\n      _object.id = object.id\n      _object.object = object\n\n      _vector3.setFromMatrixPosition(object.matrixWorld)\n      _vector3.applyMatrix4(_viewProjectionMatrix)\n      _object.z = _vector3.z\n      _object.renderOrder = object.renderOrder\n\n      _renderData.objects.push(_object)\n    }\n\n    this.projectScene = function (scene, camera, sortObjects, sortElements) {\n      _faceCount = 0\n      _lineCount = 0\n      _spriteCount = 0\n\n      _renderData.elements.length = 0\n\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      _viewMatrix.copy(camera.matrixWorldInverse)\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix)\n\n      _frustum.setFromProjectionMatrix(_viewProjectionMatrix)\n\n      //\n\n      _objectCount = 0\n\n      _renderData.objects.length = 0\n      _renderData.lights.length = 0\n\n      projectObject(scene)\n\n      if (sortObjects === true) {\n        _renderData.objects.sort(painterSort)\n      }\n\n      //\n\n      const objects = _renderData.objects\n\n      for (let o = 0, ol = objects.length; o < ol; o++) {\n        const object = objects[o].object\n        const geometry = object.geometry\n\n        renderList.setObject(object)\n\n        _modelMatrix = object.matrixWorld\n\n        _vertexCount = 0\n\n        if (object.isMesh) {\n          let material = object.material\n\n          const isMultiMaterial = Array.isArray(material)\n\n          const attributes = geometry.attributes\n          const groups = geometry.groups\n\n          if (attributes.position === undefined) continue\n\n          const positions = attributes.position.array\n\n          for (let i = 0, l = positions.length; i < l; i += 3) {\n            let x = positions[i]\n            let y = positions[i + 1]\n            let z = positions[i + 2]\n\n            const morphTargets = geometry.morphAttributes.position\n\n            if (morphTargets !== undefined) {\n              const morphTargetsRelative = geometry.morphTargetsRelative\n              const morphInfluences = object.morphTargetInfluences\n\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\n                const influence = morphInfluences[t]\n\n                if (influence === 0) continue\n\n                const target = morphTargets[t]\n\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence\n                  y += target.getY(i / 3) * influence\n                  z += target.getZ(i / 3) * influence\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence\n                }\n              }\n            }\n\n            renderList.pushVertex(x, y, z)\n          }\n\n          if (attributes.normal !== undefined) {\n            const normals = attributes.normal.array\n\n            for (let i = 0, l = normals.length; i < l; i += 3) {\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2])\n            }\n          }\n\n          if (attributes.color !== undefined) {\n            const colors = attributes.color.array\n\n            for (let i = 0, l = colors.length; i < l; i += 3) {\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2])\n            }\n          }\n\n          if (attributes.uv !== undefined) {\n            const uvs = attributes.uv.array\n\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\n              renderList.pushUv(uvs[i], uvs[i + 1])\n            }\n          }\n\n          if (geometry.index !== null) {\n            const indices = geometry.index.array\n\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g]\n\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material\n\n                if (material === undefined) continue\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material)\n                }\n              }\n            } else {\n              for (let i = 0, l = indices.length; i < l; i += 3) {\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material)\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g]\n\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material\n\n                if (material === undefined) continue\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(i, i + 1, i + 2, material)\n                }\n              }\n            } else {\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\n                renderList.pushTriangle(i, i + 1, i + 2, material)\n              }\n            }\n          }\n        } else if (object.isLine) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix)\n\n          const attributes = geometry.attributes\n\n          if (attributes.position !== undefined) {\n            const positions = attributes.position.array\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2])\n            }\n\n            if (attributes.color !== undefined) {\n              const colors = attributes.color.array\n\n              for (let i = 0, l = colors.length; i < l; i += 3) {\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2])\n              }\n            }\n\n            if (geometry.index !== null) {\n              const indices = geometry.index.array\n\n              for (let i = 0, l = indices.length; i < l; i += 2) {\n                renderList.pushLine(indices[i], indices[i + 1])\n              }\n            } else {\n              const step = object.isLineSegments ? 2 : 1\n\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n                renderList.pushLine(i, i + 1)\n              }\n            }\n          }\n        } else if (object.isPoints) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix)\n\n          const attributes = geometry.attributes\n\n          if (attributes.position !== undefined) {\n            const positions = attributes.position.array\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1)\n              _vector4.applyMatrix4(_modelViewProjectionMatrix)\n\n              pushPoint(_vector4, object, camera)\n            }\n          }\n        } else if (object.isSprite) {\n          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld)\n          _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1)\n          _vector4.applyMatrix4(_viewProjectionMatrix)\n\n          pushPoint(_vector4, object, camera)\n        }\n      }\n\n      if (sortElements === true) {\n        _renderData.elements.sort(painterSort)\n      }\n\n      return _renderData\n    }\n\n    function pushPoint(_vector4, object, camera) {\n      const invW = 1 / _vector4.w\n\n      _vector4.z *= invW\n\n      if (_vector4.z >= -1 && _vector4.z <= 1) {\n        _sprite = getNextSpriteInPool()\n        _sprite.id = object.id\n        _sprite.x = _vector4.x * invW\n        _sprite.y = _vector4.y * invW\n        _sprite.z = _vector4.z\n        _sprite.renderOrder = object.renderOrder\n        _sprite.object = object\n\n        _sprite.rotation = object.rotation\n\n        _sprite.scale.x =\n          object.scale.x *\n          Math.abs(\n            _sprite.x -\n              (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]),\n          )\n        _sprite.scale.y =\n          object.scale.y *\n          Math.abs(\n            _sprite.y -\n              (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]),\n          )\n\n        _sprite.material = object.material\n\n        _renderData.elements.push(_sprite)\n      }\n    }\n\n    // Pools\n\n    function getNextObjectInPool() {\n      if (_objectCount === _objectPoolLength) {\n        const object = new RenderableObject()\n        _objectPool.push(object)\n        _objectPoolLength++\n        _objectCount++\n        return object\n      }\n\n      return _objectPool[_objectCount++]\n    }\n\n    function getNextVertexInPool() {\n      if (_vertexCount === _vertexPoolLength) {\n        const vertex = new RenderableVertex()\n        _vertexPool.push(vertex)\n        _vertexPoolLength++\n        _vertexCount++\n        return vertex\n      }\n\n      return _vertexPool[_vertexCount++]\n    }\n\n    function getNextFaceInPool() {\n      if (_faceCount === _facePoolLength) {\n        const face = new RenderableFace()\n        _facePool.push(face)\n        _facePoolLength++\n        _faceCount++\n        return face\n      }\n\n      return _facePool[_faceCount++]\n    }\n\n    function getNextLineInPool() {\n      if (_lineCount === _linePoolLength) {\n        const line = new RenderableLine()\n        _linePool.push(line)\n        _linePoolLength++\n        _lineCount++\n        return line\n      }\n\n      return _linePool[_lineCount++]\n    }\n\n    function getNextSpriteInPool() {\n      if (_spriteCount === _spritePoolLength) {\n        const sprite = new RenderableSprite()\n        _spritePool.push(sprite)\n        _spritePoolLength++\n        _spriteCount++\n        return sprite\n      }\n\n      return _spritePool[_spriteCount++]\n    }\n\n    //\n\n    function painterSort(a, b) {\n      if (a.renderOrder !== b.renderOrder) {\n        return a.renderOrder - b.renderOrder\n      } else if (a.z !== b.z) {\n        return b.z - a.z\n      } else if (a.id !== b.id) {\n        return a.id - b.id\n      } else {\n        return 0\n      }\n    }\n\n    function clipLine(s1, s2) {\n      let alpha1 = 0,\n        alpha2 = 1\n\n      // Calculate the boundary coordinate of each vertex for the near and far clip planes,\n      // Z = -1 and Z = +1, respectively.\n\n      const bc1near = s1.z + s1.w,\n        bc2near = s2.z + s2.w,\n        bc1far = -s1.z + s1.w,\n        bc2far = -s2.z + s2.w\n\n      if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n        // Both vertices lie entirely within all clip planes.\n        return true\n      } else if ((bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0)) {\n        // Both vertices lie entirely outside one of the clip planes.\n        return false\n      } else {\n        // The line segment spans at least one clip plane.\n\n        if (bc1near < 0) {\n          // v1 lies outside the near plane, v2 inside\n          alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near))\n        } else if (bc2near < 0) {\n          // v2 lies outside the near plane, v1 inside\n          alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near))\n        }\n\n        if (bc1far < 0) {\n          // v1 lies outside the far plane, v2 inside\n          alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far))\n        } else if (bc2far < 0) {\n          // v2 lies outside the far plane, v2 inside\n          alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far))\n        }\n\n        if (alpha2 < alpha1) {\n          // The line segment spans two boundaries, but is outside both of them.\n          // (This can't happen when we're only clipping against just near/far but good\n          //  to leave the check here for future usage if other clip planes are added.)\n          return false\n        } else {\n          // Update the s1 and s2 vertices to match the clipped line segment.\n          s1.lerp(s2, alpha1)\n          s2.lerp(s1, 1 - alpha2)\n\n          return true\n        }\n      }\n    }\n  }\n}\n\nexport { RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite, Projector }\n"]},"metadata":{},"sourceType":"module"}