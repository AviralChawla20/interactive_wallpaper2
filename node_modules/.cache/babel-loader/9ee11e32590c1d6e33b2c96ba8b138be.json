{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"../libs/mmdparser.js\";\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null;\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  }\n  // Load MMD assets as Three.js Object\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    const modelExtension = this._extractExtension(url).toLowerCase();\n    if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n      if (onError) onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n      return;\n    }\n    this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](url, function (data) {\n      onLoad(builder.build(data, resourcePath, onProgress, onError));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(url, function (vmd) {\n      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(modelUrl, function (mesh) {\n      scope.loadAnimation(vmdUrl, mesh, function (animation) {\n        onLoad({\n          mesh,\n          animation\n        });\n      }, onProgress, onError);\n    }, onProgress, onError);\n  }\n  // Load MMD assets as Object data parsed by MMDParser\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmd(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmx(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(urls[i], function (buffer) {\n        vmds.push(parser.parseVmd(buffer, true));\n        if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n      }, onProgress, onError);\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n      onLoad(parser.parseVpd(text, true));\n    }, onProgress, onError);\n  }\n  // private methods\n  _extractExtension(url) {\n    const index = url.lastIndexOf(\".\");\n    return index < 0 ? \"\" : url.slice(index + 1);\n  }\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser();\n    }\n    return this.parser;\n  }\n}\nconst DEFAULT_TOON_TEXTURES = [\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"];\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton);\n    return mesh;\n  }\n}\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n  if (geometry && geometry.bones !== void 0) {\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      const bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0) bone.scale.fromArray(gbone.scl);\n    }\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        mesh.add(bones[i]);\n      }\n    }\n  }\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = [];\n    let offset = 0;\n    const boneTypeTable = {};\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0);\n      }\n    }\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    }\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex];\n      value = value === void 0 ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== void 0 ? boneTypeTable[i] : -1\n      };\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n      bones.push(bone);\n    }\n    if (data.metadata.format === \"pmd\") {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n            link.limitation = new Vector3(1, 0, 0);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === void 0) continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (ik.links[j].angleLimitation === 1) {\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle;\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n        bones[i].ik = param;\n      }\n    }\n    if (data.metadata.format === \"pmx\") {\n      let traverse = function (entry) {\n        if (entry.param) {\n          grants.push(entry.param);\n          bones[entry.param.index].grant = entry.param;\n        }\n        entry.visited = true;\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i];\n          if (!child.visited) traverse(child);\n        }\n      };\n      const grantEntryMap = {};\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === void 0) continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = {\n          parent: null,\n          children: [],\n          param,\n          visited: false\n        };\n      }\n      const rootEntry = {\n        parent: null,\n        children: [],\n        param: null,\n        visited: false\n      };\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      }\n      traverse(rootEntry);\n    }\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n        if (data.metadata.format === \"pmd\") {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = {\n        name: morph.name\n      };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1);\n        }\n      } else {\n        if (morph.type === 0) {\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            }\n          }\n        } else if (morph.type === 1) {\n          updateAttributes(attribute, morph, 1);\n        } else if (morph.type === 2) ;else if (morph.type === 3) ;else if (morph.type === 4) ;else if (morph.type === 5) ;else if (morph.type === 6) ;else if (morph.type === 7) ;else if (morph.type === 8) ;\n      }\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      if (data.metadata.format === \"pmx\") {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n      rigidBodies.push(params);\n    }\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2];\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n      constraints.push(params);\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones,\n      iks,\n      grants,\n      rigidBodies,\n      constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n}\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin);\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = {\n        userData: {}\n      };\n      if (material.name !== void 0) params.name = material.name;\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1;\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true;\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor;\n      if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split(\"*\");\n          params.map = this._loadTexture(fileNames[0], textures);\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n          }\n        }\n        const toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n          color: [0, 0, 0],\n          alpha: 1,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        }\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        }\n        let toonFileName, isDefaultToon;\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n        };\n      }\n      if (params.map !== void 0) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n        params.emissive.multiplyScalar(0.2);\n      }\n      materials.push(new MeshToonMaterial(params));\n    }\n    if (data.metadata.format === \"pmx\") {\n      let checkAlphaMorph = function (elements, materials2) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1) continue;\n          const material = materials2[element.index];\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      };\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8) continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n    return materials;\n  }\n  // private methods\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === void 0) {\n        throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n      }\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n    return this.tgaLoader;\n  }\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n    if (params.isDefaultToonTexture === true) {\n      let index;\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn(\"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\");\n        index = 0;\n      }\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n    if (textures[fullPath] !== void 0) return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n    }\n    const texture = loader.load(fullPath, function (t) {\n      if (params.isToonTexture === true) {\n        t.image = scope._getRotatedImage(t.image);\n        t.magFilter = NearestFilter;\n        t.minFilter = NearestFilter;\n      }\n      t.flipY = false;\n      t.wrapS = RepeatWrapping;\n      t.wrapT = RepeatWrapping;\n      for (let i = 0; i < texture.readyCallbacks.length; i++) {\n        texture.readyCallbacks[i](texture);\n      }\n      delete texture.readyCallbacks;\n    }, onProgress, onError);\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n  _getRotatedImage(image) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2, height / 2);\n    context.rotate(0.5 * Math.PI);\n    context.translate(-width / 2, -height / 2);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  }\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      function createImageData(image) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4) return false;\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = {\n            x: 0,\n            y: 0\n          };\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = {\n              x: uvs[index * 2 + 0],\n              y: uvs[index * 2 + 1]\n            };\n            if (getAlphaByUv(image, uv) < threshold) return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold) return true;\n        }\n        return false;\n      }\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0) x += width;\n        if (y < 0) y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n      const imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n        map.transparent = true;\n      }\n    });\n  }\n}\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127);\n      array.push(interpolation[index + 8] / 127);\n      array.push(interpolation[index + 4] / 127);\n      array.push(interpolation[index + 12] / 127);\n    }\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === void 0) continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n      const targetName = \".bones[\" + key + \"]\";\n      tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === void 0) continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n      tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127);\n      array.push(interpolation[index * 4 + 1] / 127);\n      array.push(interpolation[index * 4 + 2] / 127);\n      array.push(interpolation[index * 4 + 3] / 127);\n    }\n    const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n      pushInterpolation(qInterpolations, interpolation, 3);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n    const tracks = [];\n    tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  // private method\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n    const track = new typedKeyframeTrack(node, times, values);\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n    };\n    return track;\n  }\n}\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride;\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n    if (stride === 4) {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n    return result;\n  }\n  _calculate(x1, x2, y1, y2, x) {\n    let c = 0.5;\n    let t = c;\n    let s = 1 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3 * s * s * t;\n      stt3 = 3 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps) break;\n      c /= 2;\n      t += ft < 0 ? c : -c;\n      s = 1 - t;\n    }\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n}\nexport { MMDLoader };","map":{"version":3,"sources":["../../src/loaders/MMDLoader.js"],"names":["materials"],"mappings":";;;AAmEA,MAAM,SAAA,SAAkB,MAAA,CAAO;EAC7B,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;IAEb,IAAA,CAAK,MAAA,GAAS,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;IAEzC,IAAA,CAAK,MAAA,GAAS,IAAA;IACd,IAAA,CAAK,WAAA,GAAc,IAAI,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;IAC/C,IAAA,CAAK,gBAAA,GAAmB,IAAI,gBAAA,CAAkB,CAAA;EAC/C;EAAA;AAAA;AAAA;AAAA;EAMD,gBAAA,CAAiB,aAAA,EAAe;IAC9B,IAAA,CAAK,aAAA,GAAgB,aAAA;IACrB,OAAO,IAAA;EACR;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYD,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,OAAA,GAAU,IAAA,CAAK,WAAA,CAAY,cAAA,CAAe,IAAA,CAAK,WAAW,CAAA;IAIhE,IAAI,YAAA;IAEJ,IAAI,IAAA,CAAK,YAAA,KAAiB,EAAA,EAAI;MAC5B,YAAA,GAAe,IAAA,CAAK,YAAA;IAC1B,CAAA,MAAA,IAAe,IAAA,CAAK,IAAA,KAAS,EAAA,EAAI;MAC3B,YAAA,GAAe,IAAA,CAAK,IAAA;IAC1B,CAAA,MAAW;MACL,YAAA,GAAe,WAAA,CAAY,cAAA,CAAe,GAAG,CAAA;IAC9C;IAED,MAAM,cAAA,GAAiB,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAA,CAAE,WAAA,CAAa,CAAA;IAGhE,IAAI,cAAA,KAAmB,KAAA,IAAS,cAAA,KAAmB,KAAA,EAAO;MACxD,IAAI,OAAA,EAAS,OAAA,CAAQ,IAAI,KAAA,CAAM,iDAAA,GAAoD,cAAA,GAAiB,GAAG,CAAC,CAAA;MAExG;IACD;IAED,IAAA,CAAK,cAAA,KAAmB,KAAA,GAAQ,SAAA,GAAY,SAAS,CAAA,CACnD,GAAA,EACA,UAAU,IAAA,EAAM;MACd,MAAA,CAAO,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM,YAAA,EAAc,UAAA,EAAY,OAAO,CAAC,CAAA;IAC9D,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYD,aAAA,CAAc,GAAA,EAAK,MAAA,EAAQ,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACtD,MAAM,OAAA,GAAU,IAAA,CAAK,gBAAA;IAErB,IAAA,CAAK,OAAA,CACH,GAAA,EACA,UAAU,GAAA,EAAK;MACb,MAAA,CAAO,MAAA,CAAO,QAAA,GAAW,OAAA,CAAQ,oBAAA,CAAqB,GAAG,CAAA,GAAI,OAAA,CAAQ,KAAA,CAAM,GAAA,EAAK,MAAM,CAAC,CAAA;IACxF,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAaD,iBAAA,CAAkB,QAAA,EAAU,MAAA,EAAQ,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IAC/D,MAAM,KAAA,GAAQ,IAAA;IAEd,IAAA,CAAK,IAAA,CACH,QAAA,EACA,UAAU,IAAA,EAAM;MACd,KAAA,CAAM,aAAA,CACJ,MAAA,EACA,IAAA,EACA,UAAU,SAAA,EAAW;QACnB,MAAA,CAAO;UACL,IAAA;UACA;QACd,CAAa,CAAA;MACF,CAAA,EACD,UAAA,EACA,OACD,CAAA;IACF,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYD,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACxC,MAAM,MAAA,GAAS,IAAA,CAAK,UAAA,CAAY,CAAA;IAEhC,IAAA,CAAK,MAAA,CACF,WAAA,CAAY,KAAA,CAAS,CAAA,CACrB,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA,CACjB,eAAA,CAAgB,aAAa,CAAA,CAC7B,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA,CACnC,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA,CACvC,IAAA,CACC,GAAA,EACA,UAAU,MAAA,EAAQ;MAChB,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,MAAA,EAAQ,IAAI,CAAC,CAAA;IACrC,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACJ;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUD,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACxC,MAAM,MAAA,GAAS,IAAA,CAAK,UAAA,CAAY,CAAA;IAEhC,IAAA,CAAK,MAAA,CACF,WAAA,CAAY,KAAA,CAAS,CAAA,CACrB,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA,CACjB,eAAA,CAAgB,aAAa,CAAA,CAC7B,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA,CACnC,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA,CACvC,IAAA,CACC,GAAA,EACA,UAAU,MAAA,EAAQ;MAChB,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,MAAA,EAAQ,IAAI,CAAC,CAAA;IACrC,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACJ;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWD,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACxC,MAAM,IAAA,GAAO,KAAA,CAAM,OAAA,CAAQ,GAAG,CAAA,GAAI,GAAA,GAAM,CAAC,GAAG,CAAA;IAE5C,MAAM,IAAA,GAAO,EAAE;IACf,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;IAEpB,MAAM,MAAA,GAAS,IAAA,CAAK,UAAA,CAAY,CAAA;IAEhC,IAAA,CAAK,MAAA,CACF,WAAA,CAAY,KAAA,CAAS,CAAA,CACrB,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,CAC1B,eAAA,CAAgB,aAAa,CAAA,CAC7B,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA,CACnC,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA;IAE1C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC7C,IAAA,CAAK,MAAA,CAAO,IAAA,CACV,IAAA,CAAK,CAAC,CAAA,EACN,UAAU,MAAA,EAAQ;QAChB,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,MAAA,EAAQ,IAAI,CAAC,CAAA;QAEvC,IAAI,IAAA,CAAK,MAAA,KAAW,MAAA,EAAQ,MAAA,CAAO,MAAA,CAAO,SAAA,CAAU,IAAI,CAAC,CAAA;MAC1D,CAAA,EACD,UAAA,EACA,OACD,CAAA;IACF;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWD,OAAA,CAAQ,GAAA,EAAK,SAAA,EAAW,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACnD,MAAM,MAAA,GAAS,IAAA,CAAK,UAAA,CAAY,CAAA;IAEhC,IAAA,CAAK,MAAA,CACF,WAAA,CAAY,SAAA,GAAY,KAAA,CAAA,GAAY,+BAA+B,CAAA,CACnE,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,CAC1B,eAAA,CAAgB,MAAM,CAAA,CACtB,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA,CACnC,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA,CACvC,IAAA,CACC,GAAA,EACA,UAAU,IAAA,EAAM;MACd,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,IAAA,EAAM,IAAI,CAAC,CAAA;IACnC,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACJ;EAAA;EAID,iBAAA,CAAkB,GAAA,EAAK;IACrB,MAAM,KAAA,GAAQ,GAAA,CAAI,WAAA,CAAY,GAAG,CAAA;IACjC,OAAO,KAAA,GAAQ,CAAA,GAAI,EAAA,GAAK,GAAA,CAAI,KAAA,CAAM,KAAA,GAAQ,CAAC,CAAA;EAC5C;EAED,UAAA,CAAA,EAAa;IACX,IAAI,IAAA,CAAK,MAAA,KAAW,IAAA,EAAM;MACxB,IAAA,CAAK,MAAA,GAAS,IAAI,MAAA,CAAQ,CAAA;IAC3B;IAED,OAAO,IAAA,CAAK,MAAA;EACb;AACH;AASA,MAAM,qBAAA,GAAwB,CAC5B,oKAAA,EACA,gLAAA,EACA,gLAAA,EACA,gLAAA,EACA,oLAAA,EACA,4gBAAA,EACA,g1BAAA,EACA,oKAAA,EACA,oKAAA,EACA,oKAAA,EACA,oKAAA,CACF;AAOA,MAAM,WAAA,CAAY;EAChB,WAAA,CAAY,OAAA,EAAS;IACnB,IAAA,CAAK,WAAA,GAAc,WAAA;IACnB,IAAA,CAAK,eAAA,GAAkB,IAAI,eAAA,CAAiB,CAAA;IAC5C,IAAA,CAAK,eAAA,GAAkB,IAAI,eAAA,CAAgB,OAAO,CAAA;EACnD;EAAA;AAAA;AAAA;AAAA;EAMD,cAAA,CAAe,WAAA,EAAa;IAC1B,IAAA,CAAK,WAAA,GAAc,WAAA;IACnB,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASD,KAAA,CAAM,IAAA,EAAM,YAAA,EAAc,UAAA,EAAY,OAAA,EAAS;IAC7C,MAAM,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB,KAAA,CAAM,IAAI,CAAA;IAChD,MAAM,QAAA,GAAW,IAAA,CAAK,eAAA,CACnB,cAAA,CAAe,IAAA,CAAK,WAAW,CAAA,CAC/B,eAAA,CAAgB,YAAY,CAAA,CAC5B,KAAA,CAAM,IAAA,EAAM,QAAA,EAAU,UAAA,EAAY,OAAO,CAAA;IAE5C,MAAM,IAAA,GAAO,IAAI,WAAA,CAAY,QAAA,EAAU,QAAQ,CAAA;IAE/C,MAAM,QAAA,GAAW,IAAI,QAAA,CAAS,SAAA,CAAU,IAAI,CAAC,CAAA;IAC7C,IAAA,CAAK,IAAA,CAAK,QAAQ,CAAA;IAIlB,OAAO,IAAA;EACR;AACH;AAIA,SAAS,SAAA,CAAU,IAAA,EAAM;EACvB,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA;EAEtB,MAAM,KAAA,GAAQ,EAAE;EAEhB,IAAI,QAAA,IAAY,QAAA,CAAS,KAAA,KAAU,KAAA,CAAA,EAAW;IAG5C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACvD,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;MAI9B,MAAM,IAAA,GAAO,IAAI,IAAA,CAAM,CAAA;MACvB,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;MAIf,IAAA,CAAK,IAAA,GAAO,KAAA,CAAM,IAAA;MAClB,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,KAAA,CAAM,GAAG,CAAA;MACjC,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,KAAA,CAAM,IAAI,CAAA;MACpC,IAAI,KAAA,CAAM,GAAA,KAAQ,KAAA,CAAA,EAAW,IAAA,CAAK,KAAA,CAAM,SAAA,CAAU,KAAA,CAAM,GAAG,CAAA;IAC5D;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACvD,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;MAE9B,IAAI,KAAA,CAAM,MAAA,KAAW,CAAA,CAAA,IAAM,KAAA,CAAM,MAAA,KAAW,IAAA,IAAQ,KAAA,CAAM,KAAA,CAAM,MAAM,CAAA,KAAM,KAAA,CAAA,EAAW;QAGrF,KAAA,CAAM,KAAA,CAAM,MAAM,CAAA,CAAE,GAAA,CAAI,KAAA,CAAM,CAAC,CAAC,CAAA;MACxC,CAAA,MAAa;QAGL,IAAA,CAAK,GAAA,CAAI,KAAA,CAAM,CAAC,CAAC,CAAA;MAClB;IACF;EACF;EAKD,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;EAE3B,OAAO,KAAA;AACT;AAIA,MAAM,eAAA,CAAgB;EAAA;AAAA;AAAA;AAAA;EAKpB,KAAA,CAAM,IAAA,EAAM;IAEV,MAAM,SAAA,GAAY,EAAE;IACpB,MAAM,GAAA,GAAM,EAAE;IACd,MAAM,OAAA,GAAU,EAAE;IAElB,MAAM,OAAA,GAAU,EAAE;IAElB,MAAM,MAAA,GAAS,EAAE;IAEjB,MAAM,KAAA,GAAQ,EAAE;IAChB,MAAM,WAAA,GAAc,EAAE;IACtB,MAAM,WAAA,GAAc,EAAE;IAEtB,MAAM,YAAA,GAAe,EAAE;IACvB,MAAM,cAAA,GAAiB,EAAE;IAEzB,MAAM,GAAA,GAAM,EAAE;IACd,MAAM,MAAA,GAAS,EAAE;IAEjB,MAAM,WAAA,GAAc,EAAE;IACtB,MAAM,WAAA,GAAc,EAAE;IAGtB,IAAI,MAAA,GAAS,CAAA;IACb,MAAM,aAAA,GAAgB,CAAE,CAAA;IAIxB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,WAAA,EAAa,CAAA,EAAA,EAAK;MAClD,MAAM,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,CAAA,CAAE,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACnD,SAAA,CAAU,IAAA,CAAK,CAAA,CAAE,QAAA,CAAS,CAAC,CAAC,CAAA;MAC7B;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,CAAA,CAAE,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACjD,OAAA,CAAQ,IAAA,CAAK,CAAA,CAAE,MAAA,CAAO,CAAC,CAAC,CAAA;MACzB;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,CAAA,CAAE,EAAA,CAAG,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC7C,GAAA,CAAI,IAAA,CAAK,CAAA,CAAE,EAAA,CAAG,CAAC,CAAC,CAAA;MACjB;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QAC1B,WAAA,CAAY,IAAA,CAAK,CAAA,CAAE,WAAA,CAAY,MAAA,GAAS,CAAA,IAAK,CAAA,GAAI,CAAA,CAAE,WAAA,CAAY,CAAC,CAAA,GAAI,CAAG,CAAA;MACxE;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QAC1B,WAAA,CAAY,IAAA,CAAK,CAAA,CAAE,WAAA,CAAY,MAAA,GAAS,CAAA,IAAK,CAAA,GAAI,CAAA,CAAE,WAAA,CAAY,CAAC,CAAA,GAAI,CAAG,CAAA;MACxE;IACF;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,SAAA,EAAW,CAAA,EAAA,EAAK;MAChD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACrD,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAC,CAAA;MAC7B;IACF;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,aAAA,EAAe,CAAA,EAAA,EAAK;MACpD,MAAM,QAAA,GAAW,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;MAEjC,MAAA,CAAO,IAAA,CAAK;QACV,MAAA,EAAQ,MAAA,GAAS,CAAA;QACjB,KAAA,EAAO,QAAA,CAAS,SAAA,GAAY;MACpC,CAAO,CAAA;MAED,MAAA,IAAU,QAAA,CAAS,SAAA;IACpB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,cAAA,EAAgB,CAAA,EAAA,EAAK;MACrD,MAAM,IAAA,GAAO,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA;MAC/B,IAAI,KAAA,GAAQ,aAAA,CAAc,IAAA,CAAK,SAAS,CAAA;MAGxC,KAAA,GAAQ,KAAA,KAAU,KAAA,CAAA,GAAY,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM,KAAK,CAAA;MAEnE,aAAA,CAAc,IAAA,CAAK,SAAS,CAAA,GAAI,KAAA;IACjC;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,SAAA,EAAW,CAAA,EAAA,EAAK;MAChD,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAE7B,MAAM,IAAA,GAAO;QACX,KAAA,EAAO,CAAA;QACP,mBAAA,EAAqB,QAAA,CAAS,mBAAA;QAC9B,MAAA,EAAQ,QAAA,CAAS,WAAA;QACjB,IAAA,EAAM,QAAA,CAAS,IAAA;QACf,GAAA,EAAK,QAAA,CAAS,QAAA,CAAS,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA;QACjC,IAAA,EAAM,CAAC,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;QACjB,GAAA,EAAK,CAAC,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;QACb,aAAA,EAAe,aAAA,CAAc,CAAC,CAAA,KAAM,KAAA,CAAA,GAAY,aAAA,CAAc,CAAC,CAAA,GAAI,CAAA;MACpE,CAAA;MAED,IAAI,IAAA,CAAK,MAAA,KAAW,CAAA,CAAA,EAAI;QACtB,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAM,CAAA,CAAE,QAAA,CAAS,CAAC,CAAA;QACjD,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAM,CAAA,CAAE,QAAA,CAAS,CAAC,CAAA;QACjD,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAM,CAAA,CAAE,QAAA,CAAS,CAAC,CAAA;MAClD;MAED,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;IAChB;IAKD,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;MAClC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,OAAA,EAAS,CAAA,EAAA,EAAK;QAC9C,MAAM,EAAA,GAAK,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;QAErB,MAAM,KAAA,GAAQ;UACZ,MAAA,EAAQ,EAAA,CAAG,MAAA;UACX,QAAA,EAAU,EAAA,CAAG,QAAA;UACb,SAAA,EAAW,EAAA,CAAG,SAAA;UACd,QAAA,EAAU,EAAA,CAAG,QAAA,GAAW,CAAA;UACxB,KAAA,EAAO;QACR,CAAA;QAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,EAAA,CAAG,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACjD,MAAM,IAAA,GAAO,CAAE,CAAA;UACf,IAAA,CAAK,KAAA,GAAQ,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAE,KAAA;UACzB,IAAA,CAAK,OAAA,GAAU,IAAA;UAEf,IAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA,CAAE,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA,IAAK,CAAA,EAAG;YAClD,IAAA,CAAK,UAAA,GAAa,IAAI,OAAA,CAAQ,CAAA,EAAK,CAAA,EAAK,CAAG,CAAA;UAC5C;UAED,KAAA,CAAM,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;QACtB;QAED,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA;MACf;IACP,CAAA,MAAW;MACL,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,SAAA,EAAW,CAAA,EAAA,EAAK;QAChD,MAAM,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,EAAA;QAEzB,IAAI,EAAA,KAAO,KAAA,CAAA,EAAW;QAEtB,MAAM,KAAA,GAAQ;UACZ,MAAA,EAAQ,CAAA;UACR,QAAA,EAAU,EAAA,CAAG,QAAA;UACb,SAAA,EAAW,EAAA,CAAG,SAAA;UACd,QAAA,EAAU,EAAA,CAAG,QAAA;UACb,KAAA,EAAO;QACR,CAAA;QAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,EAAA,CAAG,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACjD,MAAM,IAAA,GAAO,CAAE,CAAA;UACf,IAAA,CAAK,KAAA,GAAQ,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAE,KAAA;UACzB,IAAA,CAAK,OAAA,GAAU,IAAA;UAEf,IAAI,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAE,eAAA,KAAoB,CAAA,EAAG;YAIrC,MAAM,WAAA,GAAc,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAE,oBAAA;YAChC,MAAM,WAAA,GAAc,EAAA,CAAG,KAAA,CAAM,CAAC,CAAA,CAAE,oBAAA;YAKhC,MAAM,IAAA,GAAO,CAAC,WAAA,CAAY,CAAC,CAAA;YAC3B,MAAM,IAAA,GAAO,CAAC,WAAA,CAAY,CAAC,CAAA;YAC3B,WAAA,CAAY,CAAC,CAAA,GAAI,CAAC,WAAA,CAAY,CAAC,CAAA;YAC/B,WAAA,CAAY,CAAC,CAAA,GAAI,CAAC,WAAA,CAAY,CAAC,CAAA;YAC/B,WAAA,CAAY,CAAC,CAAA,GAAI,IAAA;YACjB,WAAA,CAAY,CAAC,CAAA,GAAI,IAAA;YAEjB,IAAA,CAAK,WAAA,GAAc,IAAI,OAAA,CAAO,CAAA,CAAG,SAAA,CAAU,WAAW,CAAA;YACtD,IAAA,CAAK,WAAA,GAAc,IAAI,OAAA,CAAO,CAAA,CAAG,SAAA,CAAU,WAAW,CAAA;UACvD;UAED,KAAA,CAAM,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;QACtB;QAED,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA;QAId,KAAA,CAAM,CAAC,CAAA,CAAE,EAAA,GAAK,KAAA;MACf;IACF;IAID,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;MAuClC,IAAS,QAAA,GAAT,SAAA,CAAkB,KAAA,EAAO;QACvB,IAAI,KAAA,CAAM,KAAA,EAAO;UACf,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;UAIvB,KAAA,CAAM,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA,CAAE,KAAA,GAAQ,KAAA,CAAM,KAAA;QACxC;QAED,KAAA,CAAM,OAAA,GAAU,IAAA;QAEhB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACvD,MAAM,KAAA,GAAQ,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA;UAG9B,IAAI,CAAC,KAAA,CAAM,OAAA,EAAS,QAAA,CAAS,KAAK,CAAA;QACnC;MACF,CAAA;MAtDD,MAAM,aAAA,GAAgB,CAAE,CAAA;MAExB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,SAAA,EAAW,CAAA,EAAA,EAAK;QAChD,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;QAC7B,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA;QAEvB,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;QAEzB,MAAM,KAAA,GAAQ;UACZ,KAAA,EAAO,CAAA;UACP,WAAA,EAAa,KAAA,CAAM,WAAA;UACnB,KAAA,EAAO,KAAA,CAAM,KAAA;UACb,OAAA,EAAS,KAAA,CAAM,OAAA;UACf,cAAA,EAAgB,KAAA,CAAM,cAAA;UACtB,cAAA,EAAgB,KAAA,CAAM,cAAA;UACtB,mBAAA,EAAqB,QAAA,CAAS;QAC/B,CAAA;QAED,aAAA,CAAc,CAAC,CAAA,GAAI;UAAE,MAAA,EAAQ,IAAA;UAAM,QAAA,EAAU,EAAA;UAAI,KAAA;UAAc,OAAA,EAAS;QAAO,CAAA;MAChF;MAED,MAAM,SAAA,GAAY;QAAE,MAAA,EAAQ,IAAA;QAAM,QAAA,EAAU,EAAE;QAAE,KAAA,EAAO,IAAA;QAAM,OAAA,EAAS;MAAO,CAAA;MAI7E,KAAA,MAAW,SAAA,IAAa,aAAA,EAAe;QACrC,MAAM,UAAA,GAAa,aAAA,CAAc,SAAS,CAAA;QAC1C,MAAM,gBAAA,GAAmB,aAAA,CAAc,UAAA,CAAW,WAAW,CAAA,IAAK,SAAA;QAElE,UAAA,CAAW,MAAA,GAAS,gBAAA;QACpB,gBAAA,CAAiB,QAAA,CAAS,IAAA,CAAK,UAAU,CAAA;MAC1C;MAyBD,QAAA,CAAS,SAAS,CAAA;IACnB;IAID,SAAS,gBAAA,CAAiB,SAAA,EAAW,KAAA,EAAO,KAAA,EAAO;MACjD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,YAAA,EAAc,CAAA,EAAA,EAAK;QAC3C,MAAM,OAAA,GAAU,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA;QAEhC,IAAI,KAAA;QAEJ,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;UAClC,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,QAAA,CAAS,OAAA,CAAQ,KAAK,CAAA,CAAE,KAAA;QACzD,CAAA,MAAe;UACL,KAAA,GAAQ,OAAA,CAAQ,KAAA;QACjB;QAED,SAAA,CAAU,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,IAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA,GAAI,KAAA;QACxD,SAAA,CAAU,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,IAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA,GAAI,KAAA;QACxD,SAAA,CAAU,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,IAAK,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA,GAAI,KAAA;MACzD;IACF;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,UAAA,EAAY,CAAA,EAAA,EAAK;MACjD,MAAM,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA;MAC3B,MAAM,MAAA,GAAS;QAAE,IAAA,EAAM,KAAA,CAAM;MAAM,CAAA;MAEnC,MAAM,SAAA,GAAY,IAAI,sBAAA,CAAuB,IAAA,CAAK,QAAA,CAAS,WAAA,GAAc,CAAA,EAAG,CAAC,CAAA;MAC7E,SAAA,CAAU,IAAA,GAAO,KAAA,CAAM,IAAA;MAEvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,WAAA,GAAc,CAAA,EAAG,CAAA,EAAA,EAAK;QACtD,SAAA,CAAU,KAAA,CAAM,CAAC,CAAA,GAAI,SAAA,CAAU,CAAC,CAAA;MACjC;MAED,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;QAClC,IAAI,CAAA,KAAM,CAAA,EAAG;UACX,gBAAA,CAAiB,SAAA,EAAW,KAAA,EAAO,CAAG,CAAA;QACvC;MACT,CAAA,MAAa;QACL,IAAI,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;UAGpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,YAAA,EAAc,CAAA,EAAA,EAAK;YAC3C,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAK,CAAA;YAClD,MAAM,KAAA,GAAQ,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA;YAEhC,IAAI,MAAA,CAAO,IAAA,KAAS,CAAA,EAAG;cACrB,gBAAA,CAAiB,SAAA,EAAW,MAAA,EAAQ,KAAK,CAAA;YAG1C;UACF;QACX,CAAA,MAAA,IAAmB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;UAG3B,gBAAA,CAAiB,SAAA,EAAW,KAAA,EAAO,CAAG,CAAA;QAChD,CAAA,MAAA,IAAmB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG,CAAA,KAAA,IAGlB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;MAI9B;MAED,YAAA,CAAa,IAAA,CAAK,MAAM,CAAA;MACxB,cAAA,CAAe,IAAA,CAAK,SAAS,CAAA;IAC9B;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,cAAA,EAAgB,CAAA,EAAA,EAAK;MACrD,MAAM,SAAA,GAAY,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA;MACpC,MAAM,MAAA,GAAS,CAAE,CAAA;MAEjB,KAAA,MAAW,GAAA,IAAO,SAAA,EAAW;QAC3B,MAAA,CAAO,GAAG,CAAA,GAAI,SAAA,CAAU,GAAG,CAAA;MAC5B;MAOD,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;QAClC,IAAI,MAAA,CAAO,SAAA,KAAc,CAAA,CAAA,EAAI;UAC3B,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,SAAS,CAAA;UACxC,MAAA,CAAO,QAAA,CAAS,CAAC,CAAA,IAAK,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;UACrC,MAAA,CAAO,QAAA,CAAS,CAAC,CAAA,IAAK,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;UACrC,MAAA,CAAO,QAAA,CAAS,CAAC,CAAA,IAAK,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;QACtC;MACF;MAED,WAAA,CAAY,IAAA,CAAK,MAAM,CAAA;IACxB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,eAAA,EAAiB,CAAA,EAAA,EAAK;MACtD,MAAM,UAAA,GAAa,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA;MACrC,MAAM,MAAA,GAAS,CAAE,CAAA;MAEjB,KAAA,MAAW,GAAA,IAAO,UAAA,EAAY;QAC5B,MAAA,CAAO,GAAG,CAAA,GAAI,UAAA,CAAW,GAAG,CAAA;MAC7B;MAED,MAAM,KAAA,GAAQ,WAAA,CAAY,MAAA,CAAO,eAAe,CAAA;MAChD,MAAM,KAAA,GAAQ,WAAA,CAAY,MAAA,CAAO,eAAe,CAAA;MAGhD,IAAI,KAAA,CAAM,IAAA,KAAS,CAAA,IAAK,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;QACxC,IACE,KAAA,CAAM,SAAA,KAAc,CAAA,CAAA,IACpB,KAAA,CAAM,SAAA,KAAc,CAAA,CAAA,IACpB,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,SAAS,CAAA,CAAE,WAAA,KAAgB,KAAA,CAAM,SAAA,EAClD;UACA,KAAA,CAAM,IAAA,GAAO,CAAA;QACd;MACF;MAED,WAAA,CAAY,IAAA,CAAK,MAAM,CAAA;IACxB;IAID,MAAM,QAAA,GAAW,IAAI,cAAA,CAAgB,CAAA;IAErC,QAAA,CAAS,YAAA,CAAa,UAAA,EAAY,IAAI,sBAAA,CAAuB,SAAA,EAAW,CAAC,CAAC,CAAA;IAC1E,QAAA,CAAS,YAAA,CAAa,QAAA,EAAU,IAAI,sBAAA,CAAuB,OAAA,EAAS,CAAC,CAAC,CAAA;IACtE,QAAA,CAAS,YAAA,CAAa,IAAA,EAAM,IAAI,sBAAA,CAAuB,GAAA,EAAK,CAAC,CAAC,CAAA;IAC9D,QAAA,CAAS,YAAA,CAAa,WAAA,EAAa,IAAI,qBAAA,CAAsB,WAAA,EAAa,CAAC,CAAC,CAAA;IAC5E,QAAA,CAAS,YAAA,CAAa,YAAA,EAAc,IAAI,sBAAA,CAAuB,WAAA,EAAa,CAAC,CAAC,CAAA;IAC9E,QAAA,CAAS,QAAA,CAAS,OAAO,CAAA;IAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/C,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,CAAC,CAAA,CAAE,MAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EAAO,CAAC,CAAA;IACvD;IAED,QAAA,CAAS,KAAA,GAAQ,KAAA;IAEjB,QAAA,CAAS,YAAA,GAAe,YAAA;IACxB,QAAA,CAAS,eAAA,CAAgB,QAAA,GAAW,cAAA;IACpC,QAAA,CAAS,oBAAA,GAAuB,KAAA;IAEhC,QAAA,CAAS,QAAA,CAAS,GAAA,GAAM;MACtB,KAAA;MACA,GAAA;MACA,MAAA;MACA,WAAA;MACA,WAAA;MACA,MAAA,EAAQ,IAAA,CAAK,QAAA,CAAS;IACvB,CAAA;IAED,QAAA,CAAS,qBAAA,CAAuB,CAAA;IAEhC,OAAO,QAAA;EACR;AACH;AAOA,MAAM,eAAA,CAAgB;EACpB,WAAA,CAAY,OAAA,EAAS;IACnB,IAAA,CAAK,OAAA,GAAU,OAAA;IAEf,IAAA,CAAK,aAAA,GAAgB,IAAI,aAAA,CAAc,IAAA,CAAK,OAAO,CAAA;IACnD,IAAA,CAAK,SAAA,GAAY,IAAA;IAEjB,IAAA,CAAK,WAAA,GAAc,WAAA;IACnB,IAAA,CAAK,YAAA,GAAe,KAAA,CAAA;EACrB;EAAA;AAAA;AAAA;AAAA;EAMD,cAAA,CAAe,WAAA,EAAa;IAC1B,IAAA,CAAK,WAAA,GAAc,WAAA;IACnB,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;EAMD,eAAA,CAAgB,YAAA,EAAc;IAC5B,IAAA,CAAK,YAAA,GAAe,YAAA;IACpB,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASD,KAAA,CAAM,IAAA,EAAM,QAAA,EAAqC;IAC/C,MAAM,SAAA,GAAY,EAAE;IAEpB,MAAM,QAAA,GAAW,CAAE,CAAA;IAEnB,IAAA,CAAK,aAAA,CAAc,cAAA,CAAe,IAAA,CAAK,WAAW,CAAA;IAIlD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,aAAA,EAAe,CAAA,EAAA,EAAK;MACpD,MAAM,QAAA,GAAW,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;MAEjC,MAAM,MAAA,GAAS;QAAE,QAAA,EAAU,CAAA;MAAI,CAAA;MAE/B,IAAI,QAAA,CAAS,IAAA,KAAS,KAAA,CAAA,EAAW,MAAA,CAAO,IAAA,GAAO,QAAA,CAAS,IAAA;MAaxD,MAAA,CAAO,KAAA,GAAQ,IAAI,KAAA,CAAO,CAAA,CAAC,SAAA,CAAU,QAAA,CAAS,OAAO,CAAA;MACrD,MAAA,CAAO,OAAA,GAAU,QAAA,CAAS,OAAA,CAAQ,CAAC,CAAA;MACnC,MAAA,CAAO,QAAA,GAAW,IAAI,KAAA,CAAO,CAAA,CAAC,SAAA,CAAU,QAAA,CAAS,OAAO,CAAA;MACxD,MAAA,CAAO,WAAA,GAAc,MAAA,CAAO,OAAA,KAAY,CAAA;MAIxC,MAAA,CAAO,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,MAAA,GAAS,CAAA,GAAI,IAAA,GAAO,KAAA;MACrD,MAAA,CAAO,YAAA,GAAe,QAAA,CAAS,YAAA,CAAa,MAAA,GAAS,CAAA,GAAI,IAAA,GAAO,KAAA;MAChE,MAAA,CAAO,GAAA,GAAM,IAAA;MAIb,MAAA,CAAO,QAAA,GAAW,cAAA;MAClB,MAAA,CAAO,QAAA,GAAW,cAAA;MAClB,MAAA,CAAO,QAAA,GAAW,sBAAA;MAClB,MAAA,CAAO,aAAA,GAAgB,cAAA;MACvB,MAAA,CAAO,aAAA,GAAgB,cAAA;MAIvB,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,IAAA,CAAU,QAAA,CAAS,IAAA,GAAO,CAAA,MAAS,CAAA,EAAG;QACjE,MAAA,CAAO,IAAA,GAAO,UAAA;MACtB,CAAA,MAAa;QACL,MAAA,CAAO,IAAA,GAAO,MAAA,CAAO,OAAA,KAAY,CAAA,GAAM,SAAA,GAAY,UAAA;MACpD;MAED,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;QAGlC,IAAI,QAAA,CAAS,QAAA,EAAU;UACrB,MAAM,QAAA,GAAW,QAAA,CAAS,QAAA;UAC1B,MAAM,SAAA,GAAY,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA;UAKpC,MAAA,CAAO,GAAA,GAAM,IAAA,CAAK,YAAA,CAAa,SAAA,CAAU,CAAC,CAAA,EAAG,QAAQ,CAAA;UAErD,IAAI,SAAA,CAAU,MAAA,GAAS,CAAA,EAAG;YACxB,MAAM,SAAA,GAAY,SAAA,CAAU,CAAC,CAAA,CAAE,KAAA,CAAM,CAAA,CAAE,CAAA,CAAE,WAAA,CAAa,CAAA;YAEtD,MAAA,CAAO,MAAA,GAAS,IAAA,CAAK,YAAA,CAAa,SAAA,CAAU,CAAC,CAAA,EAAG,QAAQ,CAAA;YAExD,MAAA,CAAO,OAAA,GAAU,SAAA,KAAc,MAAA,GAAS,iBAAA,GAAoB,YAAA;UAC7D;QACF;QAID,MAAM,YAAA,GAAe,QAAA,CAAS,SAAA,KAAc,CAAA,CAAA,GAAK,YAAA,GAAe,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,SAAS,CAAA,CAAE,QAAA;QAEtG,MAAA,CAAO,WAAA,GAAc,IAAA,CAAK,YAAA,CAAa,YAAA,EAAc,QAAA,EAAU;UAC7D,aAAA,EAAe,IAAA;UACf,oBAAA,EAAsB,IAAA,CAAK,qBAAA,CAAsB,YAAY;QACvE,CAAS,CAAA;QAID,MAAA,CAAO,QAAA,CAAS,iBAAA,GAAoB;UAClC,SAAA,EAAW,QAAA,CAAS,QAAA,KAAa,CAAA,GAAI,IAAA,GAAQ,CAAA;UAC7C,KAAA,EAAO,CAAC,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;UACf,KAAA,EAAO,CAAA;UACP,OAAA,EAAS,QAAA,CAAS,QAAA,KAAa;QAChC,CAAA;MACT,CAAA,MAAa;QAGL,IAAI,QAAA,CAAS,YAAA,KAAiB,CAAA,CAAA,EAAI;UAChC,MAAA,CAAO,GAAA,GAAM,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,YAAY,CAAA,EAAG,QAAQ,CAAA;QAC9E;QAID,IAAI,QAAA,CAAS,eAAA,KAAoB,CAAA,CAAA,KAAO,QAAA,CAAS,OAAA,KAAY,CAAA,IAAK,QAAA,CAAS,OAAA,IAAW,CAAA,CAAA,EAAI;UACxF,MAAA,CAAO,MAAA,GAAS,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,eAAe,CAAA,EAAG,QAAQ,CAAA;UAEnF,MAAA,CAAO,OAAA,GAAU,QAAA,CAAS,OAAA,KAAY,CAAA,GAAI,iBAAA,GAAoB,YAAA;QAC/D;QAID,IAAI,YAAA,EAAc,aAAA;QAElB,IAAI,QAAA,CAAS,SAAA,KAAc,CAAA,CAAA,IAAM,QAAA,CAAS,QAAA,KAAa,CAAA,EAAG;UACxD,YAAA,GAAe,MAAA,GAAA,CAAU,GAAA,IAAO,QAAA,CAAS,SAAA,GAAY,CAAA,CAAA,EAAI,KAAA,CAAM,CAAA,CAAE,CAAA,GAAI,MAAA;UACrE,aAAA,GAAgB,IAAA;QAC1B,CAAA,MAAe;UACL,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,SAAS,CAAA;UAC/C,aAAA,GAAgB,KAAA;QACjB;QAED,MAAA,CAAO,WAAA,GAAc,IAAA,CAAK,YAAA,CAAa,YAAA,EAAc,QAAA,EAAU;UAC7D,aAAA,EAAe,IAAA;UACf,oBAAA,EAAsB;QAChC,CAAS,CAAA;QAGD,MAAA,CAAO,QAAA,CAAS,iBAAA,GAAoB;UAClC,SAAA,EAAW,QAAA,CAAS,QAAA,GAAW,GAAA;UAAA;UAC/B,KAAA,EAAO,QAAA,CAAS,SAAA,CAAU,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA;UACpC,KAAA,EAAO,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA;UAC3B,OAAA,EAAA,CAAU,QAAA,CAAS,IAAA,GAAO,EAAA,MAAU,CAAA,IAAK,QAAA,CAAS,QAAA,GAAW;QAC9D,CAAA;MACF;MAED,IAAI,MAAA,CAAO,GAAA,KAAQ,KAAA,CAAA,EAAW;QAC5B,IAAI,CAAC,MAAA,CAAO,WAAA,EAAa;UACvB,IAAA,CAAK,uBAAA,CAAwB,MAAA,CAAO,GAAA,EAAK,QAAA,EAAU,CAAC,CAAA;QACrD;QAED,MAAA,CAAO,QAAA,CAAS,cAAA,CAAe,GAAG,CAAA;MACnC;MAED,SAAA,CAAU,IAAA,CAAK,IAAI,gBAAA,CAAiB,MAAM,CAAC,CAAA;IAC5C;IAED,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,KAAA,EAAO;MAGlC,IAAS,eAAA,GAAT,SAAA,CAAyB,QAAA,EAAUA,UAAAA,EAAW;QAC5C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACjD,MAAM,OAAA,GAAU,QAAA,CAAS,CAAC,CAAA;UAE1B,IAAI,OAAA,CAAQ,KAAA,KAAU,CAAA,CAAA,EAAI;UAE1B,MAAM,QAAA,GAAWA,UAAAA,CAAU,OAAA,CAAQ,KAAK,CAAA;UAExC,IAAI,QAAA,CAAS,OAAA,KAAY,OAAA,CAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG;YAC3C,QAAA,CAAS,WAAA,GAAc,IAAA;UACxB;QACF;MACF,CAAA;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACpD,MAAM,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA;QAC3B,MAAM,QAAA,GAAW,KAAA,CAAM,QAAA;QAEvB,IAAI,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;UACpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;YACjD,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,CAAC,CAAA,CAAE,KAAK,CAAA;YAE5C,IAAI,MAAA,CAAO,IAAA,KAAS,CAAA,EAAG;YAEvB,eAAA,CAAgB,MAAA,CAAO,QAAA,EAAU,SAAS,CAAA;UAC3C;QACX,CAAA,MAAA,IAAmB,KAAA,CAAM,IAAA,KAAS,CAAA,EAAG;UAC3B,eAAA,CAAgB,QAAA,EAAU,SAAS,CAAA;QACpC;MACF;IACF;IAED,OAAO,SAAA;EACR;EAAA;EAID,aAAA,CAAA,EAAgB;IACd,IAAI,IAAA,CAAK,SAAA,KAAc,IAAA,EAAM;MAC3B,IAAI,SAAA,KAAc,KAAA,CAAA,EAAW;QAC3B,MAAM,IAAI,KAAA,CAAM,mCAAmC,CAAA;MACpD;MAED,IAAA,CAAK,SAAA,GAAY,IAAI,SAAA,CAAU,IAAA,CAAK,OAAO,CAAA;IAC5C;IAED,OAAO,IAAA,CAAK,SAAA;EACb;EAED,qBAAA,CAAsB,IAAA,EAAM;IAC1B,IAAI,IAAA,CAAK,MAAA,KAAW,EAAA,EAAI,OAAO,KAAA;IAE/B,OAAO,sBAAA,CAAuB,IAAA,CAAK,IAAI,CAAA;EACxC;EAED,YAAA,CAAa,QAAA,EAAU,QAAA,EAAU,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IAC5D,MAAA,GAAS,MAAA,IAAU,CAAE,CAAA;IAErB,MAAM,KAAA,GAAQ,IAAA;IAEd,IAAI,QAAA;IAEJ,IAAI,MAAA,CAAO,oBAAA,KAAyB,IAAA,EAAM;MACxC,IAAI,KAAA;MAEJ,IAAI;QACF,KAAA,GAAQ,QAAA,CAAS,QAAA,CAAS,KAAA,CAAM,sBAAsB,CAAA,CAAE,CAAC,CAAC,CAAA;MAC3D,CAAA,CAAA,OAAQ,CAAA,EAAP;QACA,OAAA,CAAQ,IAAA,CACN,mBAAA,GACE,QAAA,GACA,yEAEH,CAAA;QAED,KAAA,GAAQ,CAAA;MACT;MAED,QAAA,GAAW,qBAAA,CAAsB,KAAK,CAAA;IAC5C,CAAA,MAAW;MACL,QAAA,GAAW,IAAA,CAAK,YAAA,GAAe,QAAA;IAChC;IAED,IAAI,QAAA,CAAS,QAAQ,CAAA,KAAM,KAAA,CAAA,EAAW,OAAO,QAAA,CAAS,QAAQ,CAAA;IAE9D,IAAI,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,UAAA,CAAW,QAAQ,CAAA;IAE7C,IAAI,MAAA,KAAW,IAAA,EAAM;MACnB,MAAA,GAAS,QAAA,CAAS,KAAA,CAAM,CAAA,CAAE,CAAA,CAAE,WAAA,CAAA,CAAA,KAAkB,MAAA,GAAS,IAAA,CAAK,aAAA,CAAe,CAAA,GAAG,IAAA,CAAK,aAAA;IACpF;IAED,MAAM,OAAA,GAAU,MAAA,CAAO,IAAA,CACrB,QAAA,EACA,UAAU,CAAA,EAAG;MAIX,IAAI,MAAA,CAAO,aAAA,KAAkB,IAAA,EAAM;QACjC,CAAA,CAAE,KAAA,GAAQ,KAAA,CAAM,gBAAA,CAAiB,CAAA,CAAE,KAAK,CAAA;QAExC,CAAA,CAAE,SAAA,GAAY,aAAA;QACd,CAAA,CAAE,SAAA,GAAY,aAAA;MACf;MAED,CAAA,CAAE,KAAA,GAAQ,KAAA;MACV,CAAA,CAAE,KAAA,GAAQ,cAAA;MACV,CAAA,CAAE,KAAA,GAAQ,cAAA;MAEV,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,cAAA,CAAe,MAAA,EAAQ,CAAA,EAAA,EAAK;QACtD,OAAA,CAAQ,cAAA,CAAe,CAAC,CAAA,CAAE,OAAO,CAAA;MAClC;MAED,OAAO,OAAA,CAAQ,cAAA;IAChB,CAAA,EACD,UAAA,EACA,OACD,CAAA;IAED,OAAA,CAAQ,cAAA,GAAiB,EAAE;IAE3B,QAAA,CAAS,QAAQ,CAAA,GAAI,OAAA;IAErB,OAAO,OAAA;EACR;EAED,gBAAA,CAAiB,KAAA,EAAO;IACtB,MAAM,MAAA,GAAS,QAAA,CAAS,aAAA,CAAc,QAAQ,CAAA;IAC9C,MAAM,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,IAAI,CAAA;IAEtC,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA;IACpB,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA;IAErB,MAAA,CAAO,KAAA,GAAQ,KAAA;IACf,MAAA,CAAO,MAAA,GAAS,MAAA;IAEhB,OAAA,CAAQ,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;IACrC,OAAA,CAAQ,SAAA,CAAU,KAAA,GAAQ,CAAA,EAAK,MAAA,GAAS,CAAG,CAAA;IAC3C,OAAA,CAAQ,MAAA,CAAO,GAAA,GAAM,IAAA,CAAK,EAAE,CAAA;IAC5B,OAAA,CAAQ,SAAA,CAAU,CAAC,KAAA,GAAQ,CAAA,EAAK,CAAC,MAAA,GAAS,CAAG,CAAA;IAC7C,OAAA,CAAQ,SAAA,CAAU,KAAA,EAAO,CAAA,EAAG,CAAC,CAAA;IAE7B,OAAO,OAAA,CAAQ,YAAA,CAAa,CAAA,EAAG,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;EAChD;EAAA;EAGD,uBAAA,CAAwB,GAAA,EAAK,QAAA,EAAU,UAAA,EAAY;IACjD,GAAA,CAAI,cAAA,CAAe,IAAA,CAAK,UAAU,OAAA,EAAS;MAEzC,SAAS,eAAA,CAAgB,KAAA,EAAO;QAC9B,MAAM,MAAA,GAAS,QAAA,CAAS,aAAA,CAAc,QAAQ,CAAA;QAC9C,MAAA,CAAO,KAAA,GAAQ,KAAA,CAAM,KAAA;QACrB,MAAA,CAAO,MAAA,GAAS,KAAA,CAAM,MAAA;QAEtB,MAAM,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,IAAI,CAAA;QACtC,OAAA,CAAQ,SAAA,CAAU,KAAA,EAAO,CAAA,EAAG,CAAC,CAAA;QAE7B,OAAO,OAAA,CAAQ,YAAA,CAAa,CAAA,EAAG,CAAA,EAAG,MAAA,CAAO,KAAA,EAAO,MAAA,CAAO,MAAM,CAAA;MAC9D;MAED,SAAS,uBAAA,CAAwB,KAAA,EAAO,GAAA,EAAK,OAAA,EAAS;QACpD,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA;QACpB,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA;QACrB,MAAM,IAAA,GAAO,KAAA,CAAM,IAAA;QACnB,MAAM,SAAA,GAAY,GAAA;QAElB,IAAI,IAAA,CAAK,MAAA,IAAU,KAAA,GAAQ,MAAA,CAAA,KAAY,CAAA,EAAG,OAAO,KAAA;QAEjD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,IAAK,CAAA,EAAG;UAC1C,MAAM,QAAA,GAAW;YAAE,CAAA,EAAG,CAAA;YAAK,CAAA,EAAG;UAAK,CAAA;UAEnC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;YAC1B,MAAM,KAAA,GAAQ,OAAA,CAAQ,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;YAC/B,MAAM,EAAA,GAAK;cAAE,CAAA,EAAG,GAAA,CAAI,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA;cAAG,CAAA,EAAG,GAAA,CAAI,KAAA,GAAQ,CAAA,GAAI,CAAC;YAAG,CAAA;YAE3D,IAAI,YAAA,CAAa,KAAA,EAAO,EAAE,CAAA,GAAI,SAAA,EAAW,OAAO,IAAA;YAEhD,QAAA,CAAS,CAAA,IAAK,EAAA,CAAG,CAAA;YACjB,QAAA,CAAS,CAAA,IAAK,EAAA,CAAG,CAAA;UAClB;UAED,QAAA,CAAS,CAAA,IAAK,CAAA;UACd,QAAA,CAAS,CAAA,IAAK,CAAA;UAEd,IAAI,YAAA,CAAa,KAAA,EAAO,QAAQ,CAAA,GAAI,SAAA,EAAW,OAAO,IAAA;QACvD;QAED,OAAO,KAAA;MACR;MASD,SAAS,YAAA,CAAa,KAAA,EAAO,EAAA,EAAI;QAC/B,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA;QACpB,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA;QAErB,IAAI,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,EAAA,CAAG,CAAA,GAAI,KAAK,CAAA,GAAI,KAAA;QACnC,IAAI,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,EAAA,CAAG,CAAA,GAAI,MAAM,CAAA,GAAI,MAAA;QAEpC,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,KAAA;QAChB,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,MAAA;QAEhB,MAAM,KAAA,GAAQ,CAAA,GAAI,KAAA,GAAQ,CAAA;QAE1B,OAAO,KAAA,CAAM,IAAA,CAAK,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA;MAChC;MAED,MAAM,SAAA,GAAY,OAAA,CAAQ,KAAA,CAAM,IAAA,KAAS,KAAA,CAAA,GAAY,OAAA,CAAQ,KAAA,GAAQ,eAAA,CAAgB,OAAA,CAAQ,KAAK,CAAA;MAElG,MAAM,KAAA,GAAQ,QAAA,CAAS,MAAA,CAAO,UAAU,CAAA;MAExC,IACE,uBAAA,CACE,SAAA,EACA,QAAA,CAAS,UAAA,CAAW,EAAA,CAAG,KAAA,EACvB,QAAA,CAAS,KAAA,CAAM,KAAA,CAAM,KAAA,CAAM,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,KAAA,GAAQ,KAAA,CAAM,KAAK,CAClE,CAAA,EACD;QACA,GAAA,CAAI,WAAA,GAAc,IAAA;MACnB;IACP,CAAK,CAAA;EACF;AACH;AAIA,MAAM,gBAAA,CAAiB;EAAA;AAAA;AAAA;AAAA;AAAA;EAMrB,KAAA,CAAM,GAAA,EAAK,IAAA,EAAM;IAGf,MAAM,MAAA,GAAS,IAAA,CAAK,sBAAA,CAAuB,GAAA,EAAK,IAAI,CAAA,CAAE,MAAA;IACtD,MAAM,OAAA,GAAU,IAAA,CAAK,mBAAA,CAAoB,GAAA,EAAK,IAAI,CAAA,CAAE,MAAA;IAEpD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAChD,MAAA,CAAO,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAC,CAAA;IACvB;IAED,OAAO,IAAI,aAAA,CAAc,EAAA,EAAI,CAAA,CAAA,EAAI,MAAM,CAAA;EACxC;EAAA;AAAA;AAAA;AAAA;AAAA;EAOD,sBAAA,CAAuB,GAAA,EAAK,IAAA,EAAM;IAChC,SAAS,iBAAA,CAAkB,KAAA,EAAO,aAAA,EAAe,KAAA,EAAO;MACtD,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAG,CAAA;MACzC,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAG,CAAA;MACzC,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAG,CAAA;MACzC,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,EAAE,CAAA,GAAI,GAAG,CAAA;IAC3C;IAED,MAAM,MAAA,GAAS,EAAE;IAEjB,MAAM,OAAA,GAAU,CAAE,CAAA;IAClB,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;IAC5B,MAAM,kBAAA,GAAqB,CAAE,CAAA;IAE7B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,kBAAA,CAAmB,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,IAAA;IACrC;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,QAAA,CAAS,WAAA,EAAa,CAAA,EAAA,EAAK;MACjD,MAAM,MAAA,GAAS,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA;MAC5B,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA;MAExB,IAAI,kBAAA,CAAmB,QAAQ,CAAA,KAAM,KAAA,CAAA,EAAW;MAEhD,OAAA,CAAQ,QAAQ,CAAA,GAAI,OAAA,CAAQ,QAAQ,CAAA,IAAK,EAAE;MAC3C,OAAA,CAAQ,QAAQ,CAAA,CAAE,IAAA,CAAK,MAAM,CAAA;IAC9B;IAED,KAAA,MAAW,GAAA,IAAO,OAAA,EAAS;MACzB,MAAM,KAAA,GAAQ,OAAA,CAAQ,GAAG,CAAA;MAEzB,KAAA,CAAM,IAAA,CAAK,UAAU,CAAA,EAAG,CAAA,EAAG;QACzB,OAAO,CAAA,CAAE,QAAA,GAAW,CAAA,CAAE,QAAA;MAC9B,CAAO,CAAA;MAED,MAAM,KAAA,GAAQ,EAAE;MAChB,MAAM,SAAA,GAAY,EAAE;MACpB,MAAM,SAAA,GAAY,EAAE;MACpB,MAAM,eAAA,GAAkB,EAAE;MAC1B,MAAM,eAAA,GAAkB,EAAE;MAE1B,MAAM,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,aAAA,CAAc,GAAG,CAAA,CAAE,QAAA,CAAS,OAAA,CAAS,CAAA;MAExE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA,CAAE,QAAA,GAAW,EAAA;QACjC,MAAM,QAAA,GAAW,KAAA,CAAM,CAAC,CAAA,CAAE,QAAA;QAC1B,MAAM,QAAA,GAAW,KAAA,CAAM,CAAC,CAAA,CAAE,QAAA;QAC1B,MAAM,aAAA,GAAgB,KAAA,CAAM,CAAC,CAAA,CAAE,aAAA;QAE/B,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;QAEf,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,SAAA,CAAU,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,GAAI,QAAA,CAAS,CAAC,CAAC,CAAA;QACxE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,SAAA,CAAU,IAAA,CAAK,QAAA,CAAS,CAAC,CAAC,CAAA;QACtD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;QAE/E,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;MACpD;MAED,MAAM,UAAA,GAAa,SAAA,GAAY,GAAA,GAAM,GAAA;MAErC,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,UAAA,GAAa,WAAA,EAAa,mBAAA,EAAqB,KAAA,EAAO,SAAA,EAAW,eAAe,CAAC,CAAA;MAC/G,MAAA,CAAO,IAAA,CACL,IAAA,CAAK,YAAA,CAAa,UAAA,GAAa,aAAA,EAAe,uBAAA,EAAyB,KAAA,EAAO,SAAA,EAAW,eAAe,CACzG,CAAA;IACF;IAED,OAAO,IAAI,aAAA,CAAc,EAAA,EAAI,CAAA,CAAA,EAAI,MAAM,CAAA;EACxC;EAAA;AAAA;AAAA;AAAA;AAAA;EAOD,mBAAA,CAAoB,GAAA,EAAK,IAAA,EAAM;IAC7B,MAAM,MAAA,GAAS,EAAE;IAEjB,MAAM,MAAA,GAAS,CAAE,CAAA;IACjB,MAAM,qBAAA,GAAwB,IAAA,CAAK,qBAAA;IAEnC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,QAAA,CAAS,UAAA,EAAY,CAAA,EAAA,EAAK;MAChD,MAAM,KAAA,GAAQ,GAAA,CAAI,MAAA,CAAO,CAAC,CAAA;MAC1B,MAAM,SAAA,GAAY,KAAA,CAAM,SAAA;MAExB,IAAI,qBAAA,CAAsB,SAAS,CAAA,KAAM,KAAA,CAAA,EAAW;MAEpD,MAAA,CAAO,SAAS,CAAA,GAAI,MAAA,CAAO,SAAS,CAAA,IAAK,EAAE;MAC3C,MAAA,CAAO,SAAS,CAAA,CAAE,IAAA,CAAK,KAAK,CAAA;IAC7B;IAED,KAAA,MAAW,GAAA,IAAO,MAAA,EAAQ;MACxB,MAAM,KAAA,GAAQ,MAAA,CAAO,GAAG,CAAA;MAExB,KAAA,CAAM,IAAA,CAAK,UAAU,CAAA,EAAG,CAAA,EAAG;QACzB,OAAO,CAAA,CAAE,QAAA,GAAW,CAAA,CAAE,QAAA;MAC9B,CAAO,CAAA;MAED,MAAM,KAAA,GAAQ,EAAE;MAChB,MAAM,MAAA,GAAS,EAAE;MAEjB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC9C,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,QAAA,GAAW,EAAE,CAAA;QACjC,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,MAAM,CAAA;MAC5B;MAED,MAAA,CAAO,IAAA,CAAK,IAAI,mBAAA,CAAoB,yBAAA,GAA4B,qBAAA,CAAsB,GAAG,CAAA,GAAI,GAAA,EAAK,KAAA,EAAO,MAAM,CAAC,CAAA;IACjH;IAED,OAAO,IAAI,aAAA,CAAc,EAAA,EAAI,CAAA,CAAA,EAAI,MAAM,CAAA;EACxC;EAAA;AAAA;AAAA;AAAA;EAMD,oBAAA,CAAqB,GAAA,EAAK;IACxB,SAAS,WAAA,CAAY,KAAA,EAAO,GAAA,EAAK;MAC/B,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;MAChB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;MAChB,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;IACjB;IAED,SAAS,cAAA,CAAe,KAAA,EAAO,CAAA,EAAG;MAChC,KAAA,CAAM,IAAA,CAAK,CAAA,CAAE,CAAC,CAAA;MACd,KAAA,CAAM,IAAA,CAAK,CAAA,CAAE,CAAC,CAAA;MACd,KAAA,CAAM,IAAA,CAAK,CAAA,CAAE,CAAC,CAAA;MACd,KAAA,CAAM,IAAA,CAAK,CAAA,CAAE,CAAC,CAAA;IACf;IAED,SAAS,iBAAA,CAAkB,KAAA,EAAO,aAAA,EAAe,KAAA,EAAO;MACtD,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,GAAI,GAAG,CAAA;MAC7C,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,GAAI,GAAG,CAAA;MAC7C,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,GAAI,GAAG,CAAA;MAC7C,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA,GAAI,GAAG,CAAA;IAC9C;IAED,MAAM,OAAA,GAAU,GAAA,CAAI,OAAA,KAAY,KAAA,CAAA,GAAY,EAAA,GAAK,GAAA,CAAI,OAAA,CAAQ,KAAA,CAAO,CAAA;IAEpE,OAAA,CAAQ,IAAA,CAAK,UAAU,CAAA,EAAG,CAAA,EAAG;MAC3B,OAAO,CAAA,CAAE,QAAA,GAAW,CAAA,CAAE,QAAA;IAC5B,CAAK,CAAA;IAED,MAAM,KAAA,GAAQ,EAAE;IAChB,MAAM,OAAA,GAAU,EAAE;IAClB,MAAM,WAAA,GAAc,EAAE;IACtB,MAAM,SAAA,GAAY,EAAE;IACpB,MAAM,IAAA,GAAO,EAAE;IAEf,MAAM,eAAA,GAAkB,EAAE;IAC1B,MAAM,eAAA,GAAkB,EAAE;IAC1B,MAAM,eAAA,GAAkB,EAAE;IAC1B,MAAM,eAAA,GAAkB,EAAE;IAE1B,MAAM,UAAA,GAAa,IAAI,UAAA,CAAY,CAAA;IACnC,MAAM,KAAA,GAAQ,IAAI,KAAA,CAAO,CAAA;IACzB,MAAM,QAAA,GAAW,IAAI,OAAA,CAAS,CAAA;IAC9B,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAChD,MAAM,MAAA,GAAS,OAAA,CAAQ,CAAC,CAAA;MAExB,MAAM,IAAA,GAAO,MAAA,CAAO,QAAA,GAAW,EAAA;MAC/B,MAAM,GAAA,GAAM,MAAA,CAAO,QAAA;MACnB,MAAM,GAAA,GAAM,MAAA,CAAO,QAAA;MACnB,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA;MACxB,MAAM,GAAA,GAAM,MAAA,CAAO,GAAA;MACnB,MAAM,aAAA,GAAgB,MAAA,CAAO,aAAA;MAE7B,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;MAEf,QAAA,CAAS,GAAA,CAAI,CAAA,EAAG,CAAA,EAAG,CAAC,QAAQ,CAAA;MAC5B,MAAA,CAAO,GAAA,CAAI,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAC,CAAA;MAEjC,KAAA,CAAM,GAAA,CAAI,CAAC,GAAA,CAAI,CAAC,CAAA,EAAG,CAAC,GAAA,CAAI,CAAC,CAAA,EAAG,CAAC,GAAA,CAAI,CAAC,CAAC,CAAA;MACnC,UAAA,CAAW,YAAA,CAAa,KAAK,CAAA;MAE7B,QAAA,CAAS,GAAA,CAAI,MAAM,CAAA;MACnB,QAAA,CAAS,eAAA,CAAgB,UAAU,CAAA;MAEnC,WAAA,CAAY,OAAA,EAAS,MAAM,CAAA;MAC3B,cAAA,CAAe,WAAA,EAAa,UAAU,CAAA;MACtC,WAAA,CAAY,SAAA,EAAW,QAAQ,CAAA;MAE/B,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA;MAEb,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QAC1B,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;MACpD;MAED,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;MAGnD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QAC1B,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;MACpD;MAED,iBAAA,CAAkB,eAAA,EAAiB,aAAA,EAAe,CAAC,CAAA;IACpD;IAED,MAAM,MAAA,GAAS,EAAE;IAGjB,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,iBAAA,EAAmB,mBAAA,EAAqB,KAAA,EAAO,OAAA,EAAS,eAAe,CAAC,CAAA;IAEtG,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,aAAA,EAAe,uBAAA,EAAyB,KAAA,EAAO,WAAA,EAAa,eAAe,CAAC,CAAA;IAC1G,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,WAAA,EAAa,mBAAA,EAAqB,KAAA,EAAO,SAAA,EAAW,eAAe,CAAC,CAAA;IAClG,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,MAAA,EAAQ,mBAAA,EAAqB,KAAA,EAAO,IAAA,EAAM,eAAe,CAAC,CAAA;IAExF,OAAO,IAAI,aAAA,CAAc,EAAA,EAAI,CAAA,CAAA,EAAI,MAAM,CAAA;EACxC;EAAA;EAID,YAAA,CAAa,IAAA,EAAM,kBAAA,EAAoB,KAAA,EAAO,MAAA,EAAQ,cAAA,EAAgB;IAMpE,IAAI,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;MACpB,KAAA,GAAQ,KAAA,CAAM,KAAA,CAAO,CAAA;MACrB,MAAA,GAAS,MAAA,CAAO,KAAA,CAAO,CAAA;MACvB,cAAA,GAAiB,cAAA,CAAe,KAAA,CAAO,CAAA;MAEvC,MAAM,MAAA,GAAS,MAAA,CAAO,MAAA,GAAS,KAAA,CAAM,MAAA;MACrC,MAAM,iBAAA,GAAoB,cAAA,CAAe,MAAA,GAAS,KAAA,CAAM,MAAA;MAExD,IAAI,KAAA,GAAQ,CAAA;MAEZ,KAAA,IAAS,UAAA,GAAa,CAAA,EAAG,QAAA,GAAW,KAAA,CAAM,MAAA,EAAQ,UAAA,GAAa,QAAA,EAAU,UAAA,EAAA,EAAc;QACrF,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;UAC/B,IACE,MAAA,CAAO,KAAA,GAAQ,MAAA,GAAS,CAAC,CAAA,KAAM,MAAA,CAAA,CAAQ,KAAA,GAAQ,CAAA,IAAK,MAAA,GAAS,CAAC,CAAA,IAC9D,MAAA,CAAO,KAAA,GAAQ,MAAA,GAAS,CAAC,CAAA,KAAM,MAAA,CAAO,UAAA,GAAa,MAAA,GAAS,CAAC,CAAA,EAC7D;YACA,KAAA,EAAA;YACA;UACD;QACF;QAED,IAAI,UAAA,GAAa,KAAA,EAAO;UACtB,KAAA,CAAM,KAAK,CAAA,GAAI,KAAA,CAAM,UAAU,CAAA;UAE/B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;YAC/B,MAAA,CAAO,KAAA,GAAQ,MAAA,GAAS,CAAC,CAAA,GAAI,MAAA,CAAO,UAAA,GAAa,MAAA,GAAS,CAAC,CAAA;UAC5D;UAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,iBAAA,EAAmB,CAAA,EAAA,EAAK;YAC1C,cAAA,CAAe,KAAA,GAAQ,iBAAA,GAAoB,CAAC,CAAA,GAAI,cAAA,CAAe,UAAA,GAAa,iBAAA,GAAoB,CAAC,CAAA;UAClG;QACF;MACF;MAED,KAAA,CAAM,MAAA,GAAS,KAAA,GAAQ,CAAA;MACvB,MAAA,CAAO,MAAA,GAAA,CAAU,KAAA,GAAQ,CAAA,IAAK,MAAA;MAC9B,cAAA,CAAe,MAAA,GAAA,CAAU,KAAA,GAAQ,CAAA,IAAK,iBAAA;IACvC;IAED,MAAM,KAAA,GAAQ,IAAI,kBAAA,CAAmB,IAAA,EAAM,KAAA,EAAO,MAAM,CAAA;IAExD,KAAA,CAAM,iBAAA,GAAoB,SAAS,mCAAA,CAAoC,MAAA,EAAQ;MAC7E,OAAO,IAAI,wBAAA,CACT,IAAA,CAAK,KAAA,EACL,IAAA,CAAK,MAAA,EACL,IAAA,CAAK,YAAA,CAAc,CAAA,EACnB,MAAA,EACA,IAAI,YAAA,CAAa,cAAc,CAChC,CAAA;IACF,CAAA;IAED,OAAO,KAAA;EACR;AACH;AAIA,MAAM,wBAAA,SAAiC,WAAA,CAAY;EACjD,WAAA,CAAY,kBAAA,EAAoB,YAAA,EAAc,UAAA,EAAY,YAAA,EAAc,MAAA,EAAQ;IAC9E,KAAA,CAAM,kBAAA,EAAoB,YAAA,EAAc,UAAA,EAAY,YAAY,CAAA;IAEhE,IAAA,CAAK,mBAAA,GAAsB,MAAA;EAC5B;EAED,YAAA,CAAa,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI;IAC1B,MAAM,MAAA,GAAS,IAAA,CAAK,YAAA;IACpB,MAAM,MAAA,GAAS,IAAA,CAAK,YAAA;IACpB,MAAM,MAAA,GAAS,IAAA,CAAK,SAAA;IACpB,MAAM,MAAA,GAAS,IAAA,CAAK,mBAAA;IAEpB,MAAM,OAAA,GAAU,EAAA,GAAK,MAAA;IACrB,MAAM,OAAA,GAAU,OAAA,GAAU,MAAA;IAK1B,MAAM,OAAA,GAAU,EAAA,GAAK,EAAA,GAAM,CAAA,GAAI,EAAA,GAAM,GAAA,GAAM,CAAA,GAAA,CAAO,CAAA,GAAI,EAAA,KAAO,EAAA,GAAK,EAAA,CAAA;IAElE,IAAI,MAAA,KAAW,CAAA,EAAG;MAGhB,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAE5B,MAAM,KAAA,GAAQ,IAAA,CAAK,UAAA,CAAW,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,OAAO,CAAA;MAErD,UAAA,CAAW,SAAA,CAAU,MAAA,EAAQ,CAAA,EAAG,MAAA,EAAQ,OAAA,EAAS,MAAA,EAAQ,OAAA,EAAS,KAAK,CAAA;IAC7E,CAAA,MAAA,IAAe,MAAA,KAAW,CAAA,EAAG;MAGvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,KAAM,MAAA,EAAQ,EAAE,CAAA,EAAG;QACjC,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,EAAA,GAAK,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;QACrC,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,EAAA,GAAK,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;QACrC,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,EAAA,GAAK,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;QACrC,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,EAAA,GAAK,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;QAErC,MAAM,KAAA,GAAQ,IAAA,CAAK,UAAA,CAAW,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,OAAO,CAAA;QAErD,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,OAAA,GAAU,CAAC,CAAA,IAAK,CAAA,GAAI,KAAA,CAAA,GAAS,MAAA,CAAO,OAAA,GAAU,CAAC,CAAA,GAAI,KAAA;MACvE;IACP,CAAA,MAAW;MAGL,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAC5B,MAAM,EAAA,GAAK,MAAA,CAAO,EAAA,GAAK,CAAA,GAAI,CAAC,CAAA;MAE5B,MAAM,KAAA,GAAQ,IAAA,CAAK,UAAA,CAAW,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,OAAO,CAAA;MAErD,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,OAAO,CAAA,IAAK,CAAA,GAAI,KAAA,CAAA,GAAS,MAAA,CAAO,OAAO,CAAA,GAAI,KAAA;IAC/D;IAED,OAAO,MAAA;EACR;EAED,UAAA,CAAW,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG;IAsC5B,IAAI,CAAA,GAAI,GAAA;IACR,IAAI,CAAA,GAAI,CAAA;IACR,IAAI,CAAA,GAAI,CAAA,GAAM,CAAA;IACd,MAAM,IAAA,GAAO,EAAA;IACb,MAAM,GAAA,GAAM,IAAA;IACZ,MAAM,IAAA,GAAO,IAAA;IAEb,IAAI,IAAA,EAAM,IAAA,EAAM,GAAA;IAEhB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,EAAM,CAAA,EAAA,EAAK;MAC7B,IAAA,GAAO,CAAA,GAAM,CAAA,GAAI,CAAA,GAAI,CAAA;MACrB,IAAA,GAAO,CAAA,GAAM,CAAA,GAAI,CAAA,GAAI,CAAA;MACrB,GAAA,GAAM,CAAA,GAAI,CAAA,GAAI,CAAA;MAEd,MAAM,EAAA,GAAK,IAAA,GAAO,EAAA,GAAK,IAAA,GAAO,EAAA,GAAK,GAAA,GAAM,CAAA;MAEzC,IAAI,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA,GAAI,GAAA,EAAK;MAExB,CAAA,IAAK,CAAA;MAEL,CAAA,IAAK,EAAA,GAAK,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;MACnB,CAAA,GAAI,CAAA,GAAM,CAAA;IACX;IAED,OAAO,IAAA,GAAO,EAAA,GAAK,IAAA,GAAO,EAAA,GAAK,GAAA;EAChC;AACH","sourcesContent":["import {\n  AddOperation,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  Color,\n  CustomBlending,\n  DoubleSide,\n  DstAlphaFactor,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Interpolant,\n  Loader,\n  LoaderUtils,\n  MeshToonMaterial,\n  MultiplyOperation,\n  NearestFilter,\n  NumberKeyframeTrack,\n  OneMinusSrcAlphaFactor,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SrcAlphaFactor,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { Parser } from '../libs/mmdparser'\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.loader = new FileLoader(this.manager)\n\n    this.parser = null // lazy generation\n    this.meshBuilder = new MeshBuilder(this.manager)\n    this.animationBuilder = new AnimationBuilder()\n  }\n\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath\n    return this\n  }\n\n  // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin)\n\n    // resource path\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      resourcePath = this.path\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    const modelExtension = this._extractExtension(url).toLowerCase()\n\n    // Should I detect by seeing header?\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'))\n\n      return\n    }\n\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](\n      url,\n      function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder\n\n    this.loadVMD(\n      url,\n      function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this\n\n    this.load(\n      modelUrl,\n      function (mesh) {\n        scope.loadAnimation(\n          vmdUrl,\n          mesh,\n          function (animation) {\n            onLoad({\n              mesh: mesh,\n              animation: animation,\n            })\n          },\n          onProgress,\n          onError,\n        )\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmd(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmx(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url]\n\n    const vmds = []\n    const vmdNum = urls.length\n\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.animationPath)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(\n        urls[i],\n        function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true))\n\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds))\n        },\n        onProgress,\n        onError,\n      )\n    }\n  }\n\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis')\n      .setPath(this.animationPath)\n      .setResponseType('text')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (text) {\n          onLoad(parser.parseVpd(text, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  // private methods\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.')\n    return index < 0 ? '' : url.slice(index + 1)\n  }\n\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser()\n    }\n\n    return this.parser\n  }\n}\n\n// Utilities\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n * We don't need to request external toon image files.\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\nconst DEFAULT_TOON_TEXTURES = [\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n]\n\n// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous'\n    this.geometryBuilder = new GeometryBuilder()\n    this.materialBuilder = new MaterialBuilder(manager)\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data)\n    const material = this.materialBuilder\n      .setCrossOrigin(this.crossOrigin)\n      .setResourcePath(resourcePath)\n      .build(data, geometry, onProgress, onError)\n\n    const mesh = new SkinnedMesh(geometry, material)\n\n    const skeleton = new Skeleton(initBones(mesh))\n    mesh.bind(skeleton)\n\n    // console.log( mesh ); // for console debug\n\n    return mesh\n  }\n}\n\n// TODO: Try to remove this function\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry\n\n  const bones = []\n\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      // create new 'Bone' object\n\n      const bone = new Bone()\n      bones.push(bone)\n\n      // apply values\n\n      bone.name = gbone.name\n      bone.position.fromArray(gbone.pos)\n      bone.quaternion.fromArray(gbone.rotq)\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)\n    }\n\n    // second, create bone hierarchy\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n\n        bones[gbone.parent].add(bones[i])\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n\n        mesh.add(bones[i])\n      }\n    }\n  }\n\n  // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n  mesh.updateMatrixWorld(true)\n\n  return bones\n}\n\n//\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = []\n    const uvs = []\n    const normals = []\n\n    const indices = []\n\n    const groups = []\n\n    const bones = []\n    const skinIndices = []\n    const skinWeights = []\n\n    const morphTargets = []\n    const morphPositions = []\n\n    const iks = []\n    const grants = []\n\n    const rigidBodies = []\n    const constraints = []\n\n    // for work\n    let offset = 0\n    const boneTypeTable = {}\n\n    // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i]\n\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j])\n      }\n\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j])\n      }\n\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j])\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0)\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0)\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i]\n\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j])\n      }\n    }\n\n    // groups\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3,\n      })\n\n      offset += material.faceCount\n    }\n\n    // bones\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i]\n      let value = boneTypeTable[body.boneIndex]\n\n      // keeps greater number if already value is set without any special reasons\n      value = value === undefined ? body.type : Math.max(body.type, value)\n\n      boneTypeTable[body.boneIndex] = value\n    }\n\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i]\n\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1,\n      }\n\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0]\n        bone.pos[1] -= data.bones[bone.parent].position[1]\n        bone.pos[2] -= data.bones[bone.parent].position[2]\n      }\n\n      bones.push(bone)\n    }\n\n    // iks\n\n    // TODO: remove duplicated codes between PMD and PMX\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i]\n\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik\n\n        if (ik === undefined) continue\n\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n            const rotationMin = ik.links[j].lowerLimitationAngle\n            const rotationMax = ik.links[j].upperLimitationAngle\n\n            // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0]\n            const tmp2 = -rotationMax[1]\n            rotationMax[0] = -rotationMin[0]\n            rotationMax[1] = -rotationMin[1]\n            rotationMin[0] = tmp1\n            rotationMin[1] = tmp2\n\n            link.rotationMin = new Vector3().fromArray(rotationMin)\n            link.rotationMax = new Vector3().fromArray(rotationMax)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n\n        // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n        bones[i].ik = param\n      }\n    }\n\n    // grants\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {}\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i]\n        const grant = boneData.grant\n\n        if (grant === undefined) continue\n\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass,\n        }\n\n        grantEntryMap[i] = { parent: null, children: [], param: param, visited: false }\n      }\n\n      const rootEntry = { parent: null, children: [], param: null, visited: false }\n\n      // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex]\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry\n\n        grantEntry.parent = parentGrantEntry\n        parentGrantEntry.children.push(grantEntry)\n      }\n\n      // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param)\n\n          // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n          bones[entry.param.index].grant = entry.param\n        }\n\n        entry.visited = true\n\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i]\n\n          // Cut off a loop if exists. (Is a grant loop invalid?)\n          if (!child.visited) traverse(child)\n        }\n      }\n\n      traverse(rootEntry)\n    }\n\n    // morph\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i]\n\n        let index\n\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index\n        } else {\n          index = element.index\n        }\n\n        attribute.array[index * 3 + 0] += element.position[0] * ratio\n        attribute.array[index * 3 + 1] += element.position[1] * ratio\n        attribute.array[index * 3 + 2] += element.position[2] * ratio\n      }\n    }\n\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i]\n      const params = { name: morph.name }\n\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3)\n      attribute.name = morph.name\n\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j]\n      }\n\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0)\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index]\n            const ratio = morph.elements[j].ratio\n\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio)\n            } else {\n              // TODO: implement\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n\n          updateAttributes(attribute, morph, 1.0)\n        } else if (morph.type === 2) {\n          // bone\n          // TODO: implement\n        } else if (morph.type === 3) {\n          // uv\n          // TODO: implement\n        } else if (morph.type === 4) {\n          // additional uv1\n          // TODO: implement\n        } else if (morph.type === 5) {\n          // additional uv2\n          // TODO: implement\n        } else if (morph.type === 6) {\n          // additional uv3\n          // TODO: implement\n        } else if (morph.type === 7) {\n          // additional uv4\n          // TODO: implement\n        } else if (morph.type === 8) {\n          // material\n          // TODO: implement\n        }\n      }\n\n      morphTargets.push(params)\n      morphPositions.push(attribute)\n    }\n\n    // rigid bodies from rigidBodies field.\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i]\n      const params = {}\n\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key]\n      }\n\n      /*\n       * RigidBody position parameter in PMX seems global position\n       * while the one in PMD seems offset from corresponding bone.\n       * So unify being offset.\n       */\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex]\n          params.position[0] -= bone.position[0]\n          params.position[1] -= bone.position[1]\n          params.position[2] -= bone.position[2]\n        }\n      }\n\n      rigidBodies.push(params)\n    }\n\n    // constraints from constraints field.\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i]\n      const params = {}\n\n      for (const key in constraint) {\n        params[key] = constraint[key]\n      }\n\n      const bodyA = rigidBodies[params.rigidBodyIndex1]\n      const bodyB = rigidBodies[params.rigidBodyIndex2]\n\n      // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (\n          bodyA.boneIndex !== -1 &&\n          bodyB.boneIndex !== -1 &&\n          data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex\n        ) {\n          bodyB.type = 1\n        }\n      }\n\n      constraints.push(params)\n    }\n\n    // build BufferGeometry.\n\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4))\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4))\n    geometry.setIndex(indices)\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i)\n    }\n\n    geometry.bones = bones\n\n    geometry.morphTargets = morphTargets\n    geometry.morphAttributes.position = morphPositions\n    geometry.morphTargetsRelative = false\n\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format,\n    }\n\n    geometry.computeBoundingSphere()\n\n    return geometry\n  }\n}\n\n//\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager\n\n    this.textureLoader = new TextureLoader(this.manager)\n    this.tgaLoader = null // lazy generation\n\n    this.crossOrigin = 'anonymous'\n    this.resourcePath = undefined\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry /*, onProgress, onError */) {\n    const materials = []\n\n    const textures = {}\n\n    this.textureLoader.setCrossOrigin(this.crossOrigin)\n\n    // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      const params = { userData: {} }\n\n      if (material.name !== undefined) params.name = material.name\n\n      /*\n       * Color\n       *\n       * MMD         MeshToonMaterial\n       * diffuse  -  color\n       * ambient  -  emissive * a\n       *               (a = 1.0 without map texture or 0.2 with map texture)\n       *\n       * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n       * It'll be too bright if material has map texture so using coef 0.2.\n       */\n      params.color = new Color().fromArray(material.diffuse)\n      params.opacity = material.diffuse[3]\n      params.emissive = new Color().fromArray(material.ambient)\n      params.transparent = params.opacity !== 1.0\n\n      //\n\n      params.skinning = geometry.bones.length > 0 ? true : false\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false\n      params.fog = true\n\n      // blend\n\n      params.blending = CustomBlending\n      params.blendSrc = SrcAlphaFactor\n      params.blendDst = OneMinusSrcAlphaFactor\n      params.blendSrcAlpha = SrcAlphaFactor\n      params.blendDstAlpha = DstAlphaFactor\n\n      // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide\n      }\n\n      if (data.metadata.format === 'pmd') {\n        // map, envMap\n\n        if (material.fileName) {\n          const fileName = material.fileName\n          const fileNames = fileName.split('*')\n\n          // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: envMapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures)\n\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase()\n\n            params.envMap = this._loadTexture(fileNames[1], textures)\n\n            params.combine = extension === '.sph' ? MultiplyOperation : AddOperation\n          }\n        }\n\n        // gradientMap\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName),\n        })\n\n        // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1,\n        }\n      } else {\n        // map\n\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures)\n        }\n\n        // envMap TODO: support m.envFlag === 3\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures)\n\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation\n        }\n\n        // gradientMap\n\n        let toonFileName, isDefaultToon\n\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp'\n          isDefaultToon = true\n        } else {\n          toonFileName = data.textures[material.toonIndex]\n          isDefaultToon = false\n        }\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon,\n        })\n\n        // parameters for OutlineEffect\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300, // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0,\n        }\n      }\n\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i)\n        }\n\n        params.emissive.multiplyScalar(0.2)\n      }\n\n      materials.push(new MeshToonMaterial(params))\n    }\n\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i]\n\n          if (element.index === -1) continue\n\n          const material = materials[element.index]\n\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true\n          }\n        }\n      }\n\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i]\n        const elements = morph.elements\n\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index]\n\n            if (morph2.type !== 8) continue\n\n            checkAlphaMorph(morph2.elements, materials)\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials)\n        }\n      }\n    }\n\n    return materials\n  }\n\n  // private methods\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader')\n      }\n\n      this.tgaLoader = new TGALoader(this.manager)\n    }\n\n    return this.tgaLoader\n  }\n\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false\n\n    return /toon(10|0[0-9])\\.bmp/.test(name)\n  }\n\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {}\n\n    const scope = this\n\n    let fullPath\n\n    if (params.isDefaultToonTexture === true) {\n      let index\n\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1])\n      } catch (e) {\n        console.warn(\n          'THREE.MMDLoader: ' +\n            filePath +\n            ' seems like a ' +\n            'not right default texture path. Using toon00.bmp instead.',\n        )\n\n        index = 0\n      }\n\n      fullPath = DEFAULT_TOON_TEXTURES[index]\n    } else {\n      fullPath = this.resourcePath + filePath\n    }\n\n    if (textures[fullPath] !== undefined) return textures[fullPath]\n\n    let loader = this.manager.getHandler(fullPath)\n\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader\n    }\n\n    const texture = loader.load(\n      fullPath,\n      function (t) {\n        // MMD toon texture is Axis-Y oriented\n        // but Three.js gradient map is Axis-X oriented.\n        // So here replaces the toon texture image with the rotated one.\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image)\n\n          t.magFilter = NearestFilter\n          t.minFilter = NearestFilter\n        }\n\n        t.flipY = false\n        t.wrapS = RepeatWrapping\n        t.wrapT = RepeatWrapping\n\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture)\n        }\n\n        delete texture.readyCallbacks\n      },\n      onProgress,\n      onError,\n    )\n\n    texture.readyCallbacks = []\n\n    textures[fullPath] = texture\n\n    return texture\n  }\n\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')\n\n    const width = image.width\n    const height = image.height\n\n    canvas.width = width\n    canvas.height = height\n\n    context.clearRect(0, 0, width, height)\n    context.translate(width / 2.0, height / 2.0)\n    context.rotate(0.5 * Math.PI) // 90.0 * Math.PI / 180.0\n    context.translate(-width / 2.0, -height / 2.0)\n    context.drawImage(image, 0, 0)\n\n    return context.getImageData(0, 0, width, height)\n  }\n\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n\n        const context = canvas.getContext('2d')\n        context.drawImage(image, 0, 0)\n\n        return context.getImageData(0, 0, canvas.width, canvas.height)\n      }\n\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width\n        const height = image.height\n        const data = image.data\n        const threshold = 253\n\n        if (data.length / (width * height) !== 4) return false\n\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = { x: 0.0, y: 0.0 }\n\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j]\n            const uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] }\n\n            if (getAlphaByUv(image, uv) < threshold) return true\n\n            centerUV.x += uv.x\n            centerUV.y += uv.y\n          }\n\n          centerUV.x /= 3\n          centerUV.y /= 3\n\n          if (getAlphaByUv(image, centerUV) < threshold) return true\n        }\n\n        return false\n      }\n\n      /*\n       * This method expects\n       *   texture.flipY = false\n       *   texture.wrapS = RepeatWrapping\n       *   texture.wrapT = RepeatWrapping\n       * TODO: more precise\n       */\n      function getAlphaByUv(image, uv) {\n        const width = image.width\n        const height = image.height\n\n        let x = Math.round(uv.x * width) % width\n        let y = Math.round(uv.y * height) % height\n\n        if (x < 0) x += width\n        if (y < 0) y += height\n\n        const index = y * width + x\n\n        return image.data[index * 4 + 3]\n      }\n\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image)\n\n      const group = geometry.groups[groupIndex]\n\n      if (\n        detectImageTransparency(\n          imageData,\n          geometry.attributes.uv.array,\n          geometry.index.array.slice(group.start, group.start + group.count),\n        )\n      ) {\n        map.transparent = true\n      }\n    })\n  }\n}\n\n//\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks\n\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i])\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127) // x1\n      array.push(interpolation[index + 8] / 127) // x2\n      array.push(interpolation[index + 4] / 127) // y1\n      array.push(interpolation[index + 12] / 127) // y2\n    }\n\n    const tracks = []\n\n    const motions = {}\n    const bones = mesh.skeleton.bones\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true\n    }\n\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i]\n      const boneName = motion.boneName\n\n      if (boneNameDictionary[boneName] === undefined) continue\n\n      motions[boneName] = motions[boneName] || []\n      motions[boneName].push(motion)\n    }\n\n    for (const key in motions) {\n      const array = motions[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const positions = []\n      const rotations = []\n      const pInterpolations = []\n      const rInterpolations = []\n\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray()\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30\n        const position = array[i].position\n        const rotation = array[i].rotation\n        const interpolation = array[i].interpolation\n\n        times.push(time)\n\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j])\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j])\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j)\n\n        pushInterpolation(rInterpolations, interpolation, 3)\n      }\n\n      const targetName = '.bones[' + key + ']'\n\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations))\n      tracks.push(\n        this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations),\n      )\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = []\n\n    const morphs = {}\n    const morphTargetDictionary = mesh.morphTargetDictionary\n\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i]\n      const morphName = morph.morphName\n\n      if (morphTargetDictionary[morphName] === undefined) continue\n\n      morphs[morphName] = morphs[morphName] || []\n      morphs[morphName].push(morph)\n    }\n\n    for (const key in morphs) {\n      const array = morphs[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const values = []\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30)\n        values.push(array[i].weight)\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values))\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x)\n      array.push(vec.y)\n      array.push(vec.z)\n    }\n\n    function pushQuaternion(array, q) {\n      array.push(q.x)\n      array.push(q.y)\n      array.push(q.z)\n      array.push(q.w)\n    }\n\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127) // x1\n      array.push(interpolation[index * 4 + 1] / 127) // x2\n      array.push(interpolation[index * 4 + 2] / 127) // y1\n      array.push(interpolation[index * 4 + 3] / 127) // y2\n    }\n\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice()\n\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum\n    })\n\n    const times = []\n    const centers = []\n    const quaternions = []\n    const positions = []\n    const fovs = []\n\n    const cInterpolations = []\n    const qInterpolations = []\n    const pInterpolations = []\n    const fInterpolations = []\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n    const position = new Vector3()\n    const center = new Vector3()\n\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i]\n\n      const time = motion.frameNum / 30\n      const pos = motion.position\n      const rot = motion.rotation\n      const distance = motion.distance\n      const fov = motion.fov\n      const interpolation = motion.interpolation\n\n      times.push(time)\n\n      position.set(0, 0, -distance)\n      center.set(pos[0], pos[1], pos[2])\n\n      euler.set(-rot[0], -rot[1], -rot[2])\n      quaternion.setFromEuler(euler)\n\n      position.add(center)\n      position.applyQuaternion(quaternion)\n\n      pushVector3(centers, center)\n      pushQuaternion(quaternions, quaternion)\n      pushVector3(positions, position)\n\n      fovs.push(fov)\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j)\n      }\n\n      pushInterpolation(qInterpolations, interpolation, 3)\n\n      // use the same parameter for x, y, z axis.\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4)\n      }\n\n      pushInterpolation(fInterpolations, interpolation, 5)\n    }\n\n    const tracks = []\n\n    // I expect an object whose name 'target' exists under THREE.Camera\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations))\n\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations))\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations))\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations))\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  // private method\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n     * optimizes here not to let KeyframeTrackPrototype optimize\n     * because KeyframeTrackPrototype optimizes times and values but\n     * doesn't optimize interpolations.\n     */\n    if (times.length > 2) {\n      times = times.slice()\n      values = values.slice()\n      interpolations = interpolations.slice()\n\n      const stride = values.length / times.length\n      const interpolateStride = interpolations.length / times.length\n\n      let index = 1\n\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (\n            values[index * stride + i] !== values[(index - 1) * stride + i] ||\n            values[index * stride + i] !== values[aheadIndex * stride + i]\n          ) {\n            index++\n            break\n          }\n        }\n\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex]\n\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i]\n          }\n\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i]\n          }\n        }\n      }\n\n      times.length = index + 1\n      values.length = (index + 1) * stride\n      interpolations.length = (index + 1) * interpolateStride\n    }\n\n    const track = new typedKeyframeTrack(node, times, values)\n\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(\n        this.times,\n        this.values,\n        this.getValueSize(),\n        result,\n        new Float32Array(interpolations),\n      )\n    }\n\n    return track\n  }\n}\n\n// interpolation\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n\n    this.interpolationParams = params\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n    const params = this.interpolationParams\n\n    const offset1 = i1 * stride\n    const offset0 = offset1 - stride\n\n    // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n    const weight1 = t1 - t0 < (1 / 30) * 1.5 ? 0.0 : (t - t0) / (t1 - t0)\n\n    if (stride === 4) {\n      // Quaternion\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio)\n    } else if (stride === 3) {\n      // Vector3\n\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0]\n        const x2 = params[i1 * 12 + i * 4 + 1]\n        const y1 = params[i1 * 12 + i * 4 + 2]\n        const y2 = params[i1 * 12 + i * 4 + 3]\n\n        const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio\n      }\n    } else {\n      // Number\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio\n    }\n\n    return result\n  }\n\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n     * Cubic Bezier curves\n     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n     *\n     * B(t) = ( 1 - t ) ^ 3 * P0\n     *      + 3 * ( 1 - t ) ^ 2 * t * P1\n     *      + 3 * ( 1 - t ) * t^2 * P2\n     *      + t ^ 3 * P3\n     *      ( 0 <= t <= 1 )\n     *\n     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n     *\n     *    x = ( 1 - t ) ^ 3 * x0\n     *      + 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 * x3\n     *    y = ( 1 - t ) ^ 3 * y0\n     *      + 3 * ( 1 - t ) ^ 2 * t * y1\n     *      + 3 * ( 1 - t ) * t^2 * y2\n     *      + t ^ 3 * y3\n     *      ( x0 = 0, y0 = 0 )\n     *      ( x3 = 1, y3 = 1 )\n     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n     *\n     * Here solves this equation with Bisection method,\n     *   https://en.wikipedia.org/wiki/Bisection_method\n     * gets t, and then calculate y.\n     *\n     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 - x = 0\n     *\n     * (Another option: Newton's method\n     *    https://en.wikipedia.org/wiki/Newton%27s_method)\n     */\n\n    let c = 0.5\n    let t = c\n    let s = 1.0 - t\n    const loop = 15\n    const eps = 1e-5\n    const math = Math\n\n    let sst3, stt3, ttt\n\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t\n      stt3 = 3.0 * s * t * t\n      ttt = t * t * t\n\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x\n\n      if (math.abs(ft) < eps) break\n\n      c /= 2.0\n\n      t += ft < 0 ? c : -c\n      s = 1.0 - t\n    }\n\n    return sst3 * y1 + stt3 * y2 + ttt\n  }\n}\n\nexport { MMDLoader }\n"]},"metadata":{},"sourceType":"module"}