{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, EventDispatcher, Vector2, Vector3, Quaternion, Group, EllipseCurve, BufferGeometry, PerspectiveCamera, MathUtils, OrthographicCamera, Box3, Sphere, GridHelper, LineBasicMaterial, Line, Raycaster } from \"three\";\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n};\nconst _center = {\n  x: 0,\n  y: 0\n};\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n};\nconst _changeEvent = {\n  type: \"change\"\n};\nconst _startEvent = {\n  type: \"start\"\n};\nconst _endEvent = {\n  type: \"end\"\n};\nclass ArcballControls extends EventDispatcher {\n  constructor(camera, domElement = null, scene = null) {\n    super();\n    __publicField(this, \"camera\");\n    __publicField(this, \"domElement\");\n    __publicField(this, \"scene\");\n    __publicField(this, \"mouseActions\");\n    __publicField(this, \"_mouseOp\");\n    __publicField(this, \"_v2_1\");\n    __publicField(this, \"_v3_1\");\n    __publicField(this, \"_v3_2\");\n    __publicField(this, \"_m4_1\");\n    __publicField(this, \"_m4_2\");\n    __publicField(this, \"_quat\");\n    __publicField(this, \"_translationMatrix\");\n    __publicField(this, \"_rotationMatrix\");\n    __publicField(this, \"_scaleMatrix\");\n    __publicField(this, \"_rotationAxis\");\n    __publicField(this, \"_cameraMatrixState\");\n    __publicField(this, \"_cameraProjectionState\");\n    __publicField(this, \"_fovState\");\n    __publicField(this, \"_upState\");\n    __publicField(this, \"_zoomState\");\n    __publicField(this, \"_nearPos\");\n    __publicField(this, \"_farPos\");\n    __publicField(this, \"_gizmoMatrixState\");\n    __publicField(this, \"_up0\");\n    __publicField(this, \"_zoom0\");\n    __publicField(this, \"_fov0\");\n    __publicField(this, \"_initialNear\");\n    __publicField(this, \"_nearPos0\");\n    __publicField(this, \"_initialFar\");\n    __publicField(this, \"_farPos0\");\n    __publicField(this, \"_cameraMatrixState0\");\n    __publicField(this, \"_gizmoMatrixState0\");\n    __publicField(this, \"_button\");\n    __publicField(this, \"_touchStart\");\n    __publicField(this, \"_touchCurrent\");\n    __publicField(this, \"_input\");\n    __publicField(this, \"_switchSensibility\");\n    __publicField(this, \"_startFingerDistance\");\n    __publicField(this, \"_currentFingerDistance\");\n    __publicField(this, \"_startFingerRotation\");\n    __publicField(this, \"_currentFingerRotation\");\n    __publicField(this, \"_devPxRatio\");\n    __publicField(this, \"_downValid\");\n    __publicField(this, \"_nclicks\");\n    __publicField(this, \"_downEvents\");\n    __publicField(this, \"_clickStart\");\n    __publicField(this, \"_maxDownTime\");\n    __publicField(this, \"_maxInterval\");\n    __publicField(this, \"_posThreshold\");\n    __publicField(this, \"_movementThreshold\");\n    __publicField(this, \"_currentCursorPosition\");\n    __publicField(this, \"_startCursorPosition\");\n    __publicField(this, \"_grid\");\n    __publicField(this, \"_gridPosition\");\n    __publicField(this, \"_gizmos\");\n    __publicField(this, \"_curvePts\");\n    __publicField(this, \"_timeStart\");\n    __publicField(this, \"_animationId\");\n    __publicField(this, \"focusAnimationTime\");\n    __publicField(this, \"_timePrev\");\n    __publicField(this, \"_timeCurrent\");\n    __publicField(this, \"_anglePrev\");\n    __publicField(this, \"_angleCurrent\");\n    __publicField(this, \"_cursorPosPrev\");\n    __publicField(this, \"_cursorPosCurr\");\n    __publicField(this, \"_wPrev\");\n    __publicField(this, \"_wCurr\");\n    __publicField(this, \"adjustNearFar\");\n    __publicField(this, \"scaleFactor\");\n    __publicField(this, \"dampingFactor\");\n    __publicField(this, \"wMax\");\n    __publicField(this, \"enableAnimations\");\n    __publicField(this, \"enableGrid\");\n    __publicField(this, \"cursorZoom\");\n    __publicField(this, \"minFov\");\n    __publicField(this, \"maxFov\");\n    __publicField(this, \"enabled\");\n    __publicField(this, \"enablePan\");\n    __publicField(this, \"enableRotate\");\n    __publicField(this, \"enableZoom\");\n    __publicField(this, \"minDistance\");\n    __publicField(this, \"maxDistance\");\n    __publicField(this, \"minZoom\");\n    __publicField(this, \"maxZoom\");\n    __publicField(this, \"target\");\n    __publicField(this, \"_currentTarget\");\n    __publicField(this, \"_tbRadius\");\n    __publicField(this, \"_state\");\n    //listeners\n    __publicField(this, \"onWindowResize\", () => {\n      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n      if (this.camera) {\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n      }\n      const newRadius = this._tbRadius / scale;\n      const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      const points = curve.getPoints(this._curvePts);\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\n      for (const gizmo in this._gizmos.children) {\n        const child = this._gizmos.children[gizmo];\n        child.geometry = curveGeometry;\n      }\n      this.dispatchEvent(_changeEvent);\n    });\n    __publicField(this, \"onContextMenu\", event => {\n      if (!this.enabled) {\n        return;\n      }\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == 2) {\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n    __publicField(this, \"onPointerCancel\", () => {\n      this._touchStart.splice(0, this._touchStart.length);\n      this._touchCurrent.splice(0, this._touchCurrent.length);\n      this._input = INPUT.NONE;\n    });\n    __publicField(this, \"onPointerDown\", event => {\n      if (event.button == 0 && event.isPrimary) {\n        this._downValid = true;\n        this._downEvents.push(event);\n      } else {\n        this._downValid = false;\n      }\n      if (event.pointerType == \"touch\" && this._input != INPUT.CURSOR) {\n        this._touchStart.push(event);\n        this._touchCurrent.push(event);\n        switch (this._input) {\n          case INPUT.NONE:\n            this._input = INPUT.ONE_FINGER;\n            this.onSinglePanStart(event, \"ROTATE\");\n            window.addEventListener(\"pointermove\", this.onPointerMove);\n            window.addEventListener(\"pointerup\", this.onPointerUp);\n            break;\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            this._input = INPUT.TWO_FINGER;\n            this.onRotateStart();\n            this.onPinchStart();\n            this.onDoublePanStart();\n            break;\n          case INPUT.TWO_FINGER:\n            this._input = INPUT.MULT_FINGER;\n            this.onTriplePanStart();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && this._input == INPUT.NONE) {\n        let modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        this._mouseOp = this.getOpFromAction(event.button, modifier);\n        if (this._mouseOp) {\n          window.addEventListener(\"pointermove\", this.onPointerMove);\n          window.addEventListener(\"pointerup\", this.onPointerUp);\n          this._input = INPUT.CURSOR;\n          this._button = event.button;\n          this.onSinglePanStart(event, this._mouseOp);\n        }\n      }\n    });\n    __publicField(this, \"onPointerMove\", event => {\n      if (event.pointerType == \"touch\" && this._input != INPUT.CURSOR) {\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n            this.updateTouchEvent(event);\n            this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n          case INPUT.ONE_FINGER_SWITCHED:\n            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n            if (movement >= this._switchSensibility) {\n              this._input = INPUT.ONE_FINGER;\n              this.updateTouchEvent(event);\n              this.onSinglePanStart(event, \"ROTATE\");\n              break;\n            }\n            break;\n          case INPUT.TWO_FINGER:\n            this.updateTouchEvent(event);\n            this.onRotateMove();\n            this.onPinchMove();\n            this.onDoublePanMove();\n            break;\n          case INPUT.MULT_FINGER:\n            this.updateTouchEvent(event);\n            this.onTriplePanMove();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && this._input == INPUT.CURSOR) {\n        let modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n        if (mouseOpState) {\n          this.onSinglePanMove(event, mouseOpState);\n        }\n      }\n      if (this._downValid) {\n        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n        if (movement > this._movementThreshold) {\n          this._downValid = false;\n        }\n      }\n    });\n    __publicField(this, \"onPointerUp\", event => {\n      if (event.pointerType == \"touch\" && this._input != INPUT.CURSOR) {\n        const nTouch = this._touchCurrent.length;\n        for (let i = 0; i < nTouch; i++) {\n          if (this._touchCurrent[i].pointerId == event.pointerId) {\n            this._touchCurrent.splice(i, 1);\n            this._touchStart.splice(i, 1);\n            break;\n          }\n        }\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            window.removeEventListener(\"pointermove\", this.onPointerMove);\n            window.removeEventListener(\"pointerup\", this.onPointerUp);\n            this._input = INPUT.NONE;\n            this.onSinglePanEnd();\n            break;\n          case INPUT.TWO_FINGER:\n            this.onDoublePanEnd();\n            this.onPinchEnd();\n            this.onRotateEnd();\n            this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n          case INPUT.MULT_FINGER:\n            if (this._touchCurrent.length == 0) {\n              window.removeEventListener(\"pointermove\", this.onPointerMove);\n              window.removeEventListener(\"pointerup\", this.onPointerUp);\n              this._input = INPUT.NONE;\n              this.onTriplePanEnd();\n            }\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && this._input == INPUT.CURSOR) {\n        window.removeEventListener(\"pointermove\", this.onPointerMove);\n        window.removeEventListener(\"pointerup\", this.onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        this._button = -1;\n      }\n      if (event.isPrimary) {\n        if (this._downValid) {\n          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n          if (downTime <= this._maxDownTime) {\n            if (this._nclicks == 0) {\n              this._nclicks = 1;\n              this._clickStart = performance.now();\n            } else {\n              const clickInterval = event.timeStamp - this._clickStart;\n              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n                this._nclicks = 0;\n                this._downEvents.splice(0, this._downEvents.length);\n                this.onDoubleTap(event);\n              } else {\n                this._nclicks = 1;\n                this._downEvents.shift();\n                this._clickStart = performance.now();\n              }\n            }\n          } else {\n            this._downValid = false;\n            this._nclicks = 0;\n            this._downEvents.splice(0, this._downEvents.length);\n          }\n        } else {\n          this._nclicks = 0;\n          this._downEvents.splice(0, this._downEvents.length);\n        }\n      }\n    });\n    __publicField(this, \"onWheel\", event => {\n      var _a, _b;\n      if (this.enabled && this.enableZoom && this.domElement) {\n        let modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        const mouseOp = this.getOpFromAction(\"WHEEL\", modifier);\n        if (mouseOp) {\n          event.preventDefault();\n          this.dispatchEvent(_startEvent);\n          const notchDeltaY = 125;\n          let sgn = event.deltaY / notchDeltaY;\n          let size = 1;\n          if (sgn > 0) {\n            size = 1 / this.scaleFactor;\n          } else if (sgn < 0) {\n            size = this.scaleFactor;\n          }\n          switch (mouseOp) {\n            case \"ZOOM\":\n              this.updateTbState(STATE.SCALE, true);\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n              if (this.cursorZoom && this.enablePan) {\n                let scalePoint;\n                if (this.camera instanceof OrthographicCamera) {\n                  scalePoint = (_a = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) == null ? void 0 : _a.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n                }\n                if (this.camera instanceof PerspectiveCamera) {\n                  scalePoint = (_b = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) == null ? void 0 : _b.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n                }\n                if (scalePoint !== void 0) this.applyTransformMatrix(this.applyScale(size, scalePoint));\n              } else {\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n              if (this._grid) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n            case \"FOV\":\n              if (this.camera instanceof PerspectiveCamera) {\n                this.updateTbState(STATE.FOV, true);\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(this.scaleFactor, -sgn);\n                  }\n                }\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n                let xNew = x / size;\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5);\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                if (newFov > this.maxFov) {\n                  newFov = this.maxFov;\n                } else if (newFov < this.minFov) {\n                  newFov = this.minFov;\n                }\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false));\n              }\n              if (this._grid) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n    __publicField(this, \"onSinglePanStart\", (event, operation) => {\n      if (this.enabled && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n        switch (operation) {\n          case \"PAN\":\n            if (!this.enablePan) return;\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n            if (this.camera) {\n              this.updateTbState(STATE.PAN, true);\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n              if (rayDir !== void 0) {\n                this._startCursorPosition.copy(rayDir);\n              }\n              if (this.enableGrid) {\n                this.drawGrid();\n                this.dispatchEvent(_changeEvent);\n              }\n            }\n            break;\n          case \"ROTATE\":\n            if (!this.enableRotate) return;\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n            }\n            if (this.camera) {\n              this.updateTbState(STATE.ROTATE, true);\n              const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n              if (rayDir !== void 0) {\n                this._startCursorPosition.copy(rayDir);\n              }\n              this.activateGizmos(true);\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent = performance.now();\n                this._angleCurrent = this._anglePrev = 0;\n                this._cursorPosPrev.copy(this._startCursorPosition);\n                this._cursorPosCurr.copy(this._cursorPosPrev);\n                this._wCurr = 0;\n                this._wPrev = this._wCurr;\n              }\n            }\n            this.dispatchEvent(_changeEvent);\n            break;\n          case \"FOV\":\n            if (!this.enableZoom) return;\n            if (this.camera instanceof PerspectiveCamera) {\n              if (this._animationId != -1) {\n                cancelAnimationFrame(this._animationId);\n                this._animationId = -1;\n                this._timeStart = -1;\n                this.activateGizmos(false);\n                this.dispatchEvent(_changeEvent);\n              }\n              this.updateTbState(STATE.FOV, true);\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              this._currentCursorPosition.copy(this._startCursorPosition);\n            }\n            break;\n          case \"ZOOM\":\n            if (!this.enableZoom) return;\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n            this.updateTbState(STATE.SCALE, true);\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n            this._currentCursorPosition.copy(this._startCursorPosition);\n            break;\n        }\n      }\n    });\n    __publicField(this, \"onSinglePanMove\", (event, opState) => {\n      if (this.enabled && this.domElement) {\n        const restart = opState != this._state;\n        this.setCenter(event.clientX, event.clientY);\n        switch (opState) {\n          case STATE.PAN:\n            if (this.enablePan && this.camera) {\n              if (restart) {\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n                if (rayDir !== void 0) {\n                  this._startCursorPosition.copy(rayDir);\n                }\n                if (this.enableGrid) {\n                  this.drawGrid();\n                }\n                this.activateGizmos(false);\n              } else {\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n                if (rayDir !== void 0) {\n                  this._currentCursorPosition.copy(rayDir);\n                }\n                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n              }\n            }\n            break;\n          case STATE.ROTATE:\n            if (this.enableRotate && this.camera) {\n              if (restart) {\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n                if (rayDir !== void 0) {\n                  this._startCursorPosition.copy(rayDir);\n                }\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n                this.activateGizmos(true);\n              } else {\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n                if (rayDir !== void 0) {\n                  this._currentCursorPosition.copy(rayDir);\n                }\n                const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n                const amount = Math.max(distance / this._tbRadius, angle);\n                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n                if (this.enableAnimations) {\n                  this._timePrev = this._timeCurrent;\n                  this._timeCurrent = performance.now();\n                  this._anglePrev = this._angleCurrent;\n                  this._angleCurrent = amount;\n                  this._cursorPosPrev.copy(this._cursorPosCurr);\n                  this._cursorPosCurr.copy(this._currentCursorPosition);\n                  this._wPrev = this._wCurr;\n                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n                }\n              }\n            }\n            break;\n          case STATE.SCALE:\n            if (this.enableZoom) {\n              if (restart) {\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n                this._currentCursorPosition.copy(this._startCursorPosition);\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n                this.activateGizmos(false);\n              } else {\n                const screenNotches = 8;\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n            }\n            break;\n          case STATE.FOV:\n            if (this.enableZoom && this.camera instanceof PerspectiveCamera) {\n              if (restart) {\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n                this._currentCursorPosition.copy(this._startCursorPosition);\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n                this.activateGizmos(false);\n              } else {\n                const screenNotches = 8;\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n                let xNew = x / size;\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._v3_2, false));\n                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n            break;\n        }\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(this, \"onSinglePanEnd\", () => {\n      if (this._state == STATE.ROTATE) {\n        if (!this.enableRotate) {\n          return;\n        }\n        if (this.enableAnimations) {\n          const deltaTime = performance.now() - this._timeCurrent;\n          if (deltaTime < 120) {\n            const w = Math.abs((this._wPrev + this._wCurr) / 2);\n            const self = this;\n            this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            this.updateTbState(STATE.IDLE, false);\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n        this.updateTbState(STATE.IDLE, false);\n        if (this.enableGrid) {\n          this.disposeGrid();\n        }\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n      this.dispatchEvent(_endEvent);\n    });\n    __publicField(this, \"onDoubleTap\", event => {\n      if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n        if (hitP && this.enableAnimations) {\n          const self = this;\n          if (this._animationId != -1) {\n            window.cancelAnimationFrame(this._animationId);\n          }\n          this._timeStart = -1;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP && !this.enableAnimations) {\n          this.updateTbState(STATE.FOCUS, true);\n          this.focus(hitP, this.scaleFactor);\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n      this.dispatchEvent(_endEvent);\n    });\n    __publicField(this, \"onDoublePanStart\", () => {\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.PAN, true);\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\n        if (rayDir !== void 0) {\n          this._startCursorPosition.copy(rayDir);\n        }\n        this._currentCursorPosition.copy(this._startCursorPosition);\n        this.activateGizmos(false);\n      }\n    });\n    __publicField(this, \"onDoublePanMove\", () => {\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        if (this._state != STATE.PAN) {\n          this.updateTbState(STATE.PAN, true);\n          this._startCursorPosition.copy(this._currentCursorPosition);\n        }\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\n        if (rayDir !== void 0) this._currentCursorPosition.copy(rayDir);\n        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(this, \"onDoublePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n    __publicField(this, \"onRotateStart\", () => {\n      var _a;\n      if (this.enabled && this.enableRotate) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.ZROTATE, true);\n        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n        this._currentFingerRotation = this._startFingerRotation;\n        (_a = this.camera) == null ? void 0 : _a.getWorldDirection(this._rotationAxis);\n        if (!this.enablePan && !this.enableZoom) {\n          this.activateGizmos(true);\n        }\n      }\n    });\n    __publicField(this, \"onRotateMove\", () => {\n      var _a;\n      if (this.enabled && this.enableRotate && this.camera && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        let rotationPoint;\n        if (this._state != STATE.ZROTATE) {\n          this.updateTbState(STATE.ZROTATE, true);\n          this._startFingerRotation = this._currentFingerRotation;\n        }\n        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n        if (!this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n        } else if (this.camera) {\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n          rotationPoint = (_a = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) == null ? void 0 : _a.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n        }\n        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n        if (rotationPoint !== void 0) {\n          this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n        }\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(this, \"onRotateEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.activateGizmos(false);\n      this.dispatchEvent(_endEvent);\n    });\n    __publicField(this, \"onPinchStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true);\n        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n        this._currentFingerDistance = this._startFingerDistance;\n        this.activateGizmos(false);\n      }\n    });\n    __publicField(this, \"onPinchMove\", () => {\n      var _a, _b;\n      if (this.enabled && this.enableZoom && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const minDistance = 12;\n        if (this._state != STATE.SCALE) {\n          this._startFingerDistance = this._currentFingerDistance;\n          this.updateTbState(STATE.SCALE, true);\n        }\n        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n        const amount = this._currentFingerDistance / this._startFingerDistance;\n        let scalePoint;\n        if (!this.enablePan) {\n          scalePoint = this._gizmos.position;\n        } else {\n          if (this.camera instanceof OrthographicCamera) {\n            scalePoint = (_a = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) == null ? void 0 : _a.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n          } else if (this.camera instanceof PerspectiveCamera) {\n            scalePoint = (_b = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) == null ? void 0 : _b.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n          }\n        }\n        if (scalePoint !== void 0) {\n          this.applyTransformMatrix(this.applyScale(amount, scalePoint));\n        }\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(this, \"onPinchEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n    __publicField(this, \"onTriplePanStart\", () => {\n      if (this.enabled && this.enableZoom && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true);\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n        this._currentCursorPosition.copy(this._startCursorPosition);\n      }\n    });\n    __publicField(this, \"onTriplePanMove\", () => {\n      if (this.enabled && this.enableZoom && this.camera && this.domElement) {\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n        const screenNotches = 8;\n        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n        let size = 1;\n        if (movement < 0) {\n          size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(this.scaleFactor, movement * screenNotches);\n        }\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n        const x = this._v3_1.distanceTo(this._gizmos.position);\n        let xNew = x / size;\n        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n        this.setFov(newFov);\n        this.applyTransformMatrix(this.applyScale(size, this._v3_2, false));\n        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(this, \"onTriplePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n    /**\n     * Set _center's x/y coordinates\n     * @param {Number} clientX\n     * @param {Number} clientY\n     */\n    __publicField(this, \"setCenter\", (clientX, clientY) => {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n    /**\n     * Set default mouse actions\n     */\n    __publicField(this, \"initializeMouseActions\", () => {\n      this.setMouseAction(\"PAN\", 0, \"CTRL\");\n      this.setMouseAction(\"PAN\", 2);\n      this.setMouseAction(\"ROTATE\", 0);\n      this.setMouseAction(\"ZOOM\", \"WHEEL\");\n      this.setMouseAction(\"ZOOM\", 1);\n      this.setMouseAction(\"FOV\", \"WHEEL\", \"SHIFT\");\n      this.setMouseAction(\"FOV\", 1, \"SHIFT\");\n    });\n    /**\n     * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n     * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n     */\n    __publicField(this, \"setMouseAction\", (operation, mouse, key = null) => {\n      const operationInput = [\"PAN\", \"ROTATE\", \"ZOOM\", \"FOV\"];\n      const mouseInput = [0, 1, 2, \"WHEEL\"];\n      const keyInput = [\"CTRL\", \"SHIFT\", null];\n      let state;\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        return false;\n      }\n      if (mouse == \"WHEEL\") {\n        if (operation != \"ZOOM\" && operation != \"FOV\") {\n          return false;\n        }\n      }\n      switch (operation) {\n        case \"PAN\":\n          state = STATE.PAN;\n          break;\n        case \"ROTATE\":\n          state = STATE.ROTATE;\n          break;\n        case \"ZOOM\":\n          state = STATE.SCALE;\n          break;\n        case \"FOV\":\n          state = STATE.FOV;\n          break;\n      }\n      const action = {\n        operation,\n        mouse,\n        key,\n        state\n      };\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n          this.mouseActions.splice(i, 1, action);\n          return true;\n        }\n      }\n      this.mouseActions.push(action);\n      return true;\n    });\n    /**\n     * Return the operation associated to a mouse/keyboard combination\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns The operation if it has been found, null otherwise\n     */\n    __publicField(this, \"getOpFromAction\", (mouse, key) => {\n      let action;\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n      if (key) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n     * @param {Number} mouse Mouse button\n     * @param {String} key Keyboard modifier\n     * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n     */\n    __publicField(this, \"getOpStateFromAction\", (mouse, key) => {\n      let action;\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n      if (key) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Calculate the angle between two pointers\n     * @param {PointerEvent} p1\n     * @param {PointerEvent} p2\n     * @returns {Number} The angle between two pointers in degrees\n     */\n    __publicField(this, \"getAngle\", (p1, p2) => {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n    /**\n     * Update a PointerEvent inside current pointerevents array\n     * @param {PointerEvent} event\n     */\n    __publicField(this, \"updateTouchEvent\", event => {\n      for (let i = 0; i < this._touchCurrent.length; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1, event);\n          break;\n        }\n      }\n    });\n    /**\n     * Calculate the angular speed\n     * @param {Number} p0 Position at t0\n     * @param {Number} p1 Position at t1\n     * @param {Number} t0 Initial time in milliseconds\n     * @param {Number} t1 Ending time in milliseconds\n     */\n    __publicField(this, \"calculateAngularSpeed\", (p0, p1, t0, t1) => {\n      const s = p1 - p0;\n      const t = (t1 - t0) / 1e3;\n      if (t == 0) {\n        return 0;\n      }\n      return s / t;\n    });\n    /**\n     * Calculate the distance between two pointers\n     * @param {PointerEvent} p0 The first pointer\n     * @param {PointerEvent} p1 The second pointer\n     * @returns {number} The distance between the two pointers\n     */\n    __publicField(this, \"calculatePointersDistance\", (p0, p1) => {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n    /**\n     * Calculate the rotation axis as the vector perpendicular between two vectors\n     * @param {Vector3} vec1 The first vector\n     * @param {Vector3} vec2 The second vector\n     * @returns {Vector3} The normalized rotation axis\n     */\n    __publicField(this, \"calculateRotationAxis\", (vec1, vec2) => {\n      this._rotationMatrix.extractRotation(this._cameraMatrixState);\n      this._quat.setFromRotationMatrix(this._rotationMatrix);\n      this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n      return this._rotationAxis.normalize().clone();\n    });\n    /**\n     * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n     * @param {Camera} camera\n     * @returns {Number} The trackball radius\n     */\n    __publicField(this, \"calculateTbRadius\", camera => {\n      const factor = 0.67;\n      const distance = camera.position.distanceTo(this._gizmos.position);\n      if (camera instanceof PerspectiveCamera) {\n        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5;\n        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV));\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera instanceof OrthographicCamera) {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n    /**\n     * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n     * @param {Vector3} point The point of interest\n     * @param {Number} size Scale factor\n     * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n     */\n    __publicField(this, \"focus\", (point, size, amount = 1) => {\n      if (this.camera) {\n        const focusPoint = point.clone();\n        focusPoint.sub(this._gizmos.position).multiplyScalar(amount);\n        this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n        const gizmoStateTemp = this._gizmoMatrixState.clone();\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        const cameraStateTemp = this._cameraMatrixState.clone();\n        this._cameraMatrixState.premultiply(this._translationMatrix);\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n        if (this.enableZoom) {\n          this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n        }\n        this._gizmoMatrixState.copy(gizmoStateTemp);\n        this._cameraMatrixState.copy(cameraStateTemp);\n      }\n    });\n    /**\n     * Draw a grid and add it to the scene\n     */\n    __publicField(this, \"drawGrid\", () => {\n      if (this.scene) {\n        const color = 8947848;\n        const multiplier = 3;\n        let size, divisions, maxLength, tick;\n        if (this.camera instanceof OrthographicCamera) {\n          const width = this.camera.right - this.camera.left;\n          const height = this.camera.bottom - this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / this.camera.zoom * multiplier;\n          divisions = size / tick * this.camera.zoom;\n        } else if (this.camera instanceof PerspectiveCamera) {\n          const distance = this.camera.position.distanceTo(this._gizmos.position);\n          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n        if (this._grid == null && this.camera) {\n          this._grid = new GridHelper(size, divisions, color, color);\n          this._grid.position.copy(this._gizmos.position);\n          this._gridPosition.copy(this._grid.position);\n          this._grid.quaternion.copy(this.camera.quaternion);\n          this._grid.rotateX(Math.PI * 0.5);\n          this.scene.add(this._grid);\n        }\n      }\n    });\n    __publicField(this, \"connect\", domElement => {\n      if (domElement === document) {\n        console.error('THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n      }\n      this.domElement = domElement;\n      this.domElement.style.touchAction = \"none\";\n      this.domElement.addEventListener(\"contextmenu\", this.onContextMenu);\n      this.domElement.addEventListener(\"pointerdown\", this.onPointerDown);\n      this.domElement.addEventListener(\"pointercancel\", this.onPointerCancel);\n      this.domElement.addEventListener(\"wheel\", this.onWheel);\n    });\n    /**\n     * Remove all listeners, stop animations and clean scene\n     */\n    __publicField(this, \"dispose\", () => {\n      var _a, _b, _c, _d, _e;\n      if (this._animationId != -1) {\n        window.cancelAnimationFrame(this._animationId);\n      }\n      (_a = this.domElement) == null ? void 0 : _a.removeEventListener(\"pointerdown\", this.onPointerDown);\n      (_b = this.domElement) == null ? void 0 : _b.removeEventListener(\"pointercancel\", this.onPointerCancel);\n      (_c = this.domElement) == null ? void 0 : _c.removeEventListener(\"wheel\", this.onWheel);\n      (_d = this.domElement) == null ? void 0 : _d.removeEventListener(\"contextmenu\", this.onContextMenu);\n      window.removeEventListener(\"pointermove\", this.onPointerMove);\n      window.removeEventListener(\"pointerup\", this.onPointerUp);\n      window.removeEventListener(\"resize\", this.onWindowResize);\n      (_e = this.scene) == null ? void 0 : _e.remove(this._gizmos);\n      this.disposeGrid();\n    });\n    /**\n     * remove the grid from the scene\n     */\n    __publicField(this, \"disposeGrid\", () => {\n      if (this._grid && this.scene) {\n        this.scene.remove(this._grid);\n        this._grid = null;\n      }\n    });\n    /**\n     * Compute the easing out cubic function for ease out effect in animation\n     * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n     * @returns {Number} Result of easing out cubic at time t\n     */\n    __publicField(this, \"easeOutCubic\", t => {\n      return 1 - Math.pow(1 - t, 3);\n    });\n    /**\n     * Make rotation gizmos more or less visible\n     * @param {Boolean} isActive If true, make gizmos more visible\n     */\n    __publicField(this, \"activateGizmos\", isActive => {\n      for (const gizmo of this._gizmos.children) {\n        gizmo.material.setValues({\n          opacity: isActive ? 1 : 0.6\n        });\n      }\n    });\n    /**\n     * Calculate the cursor position in NDC\n     * @param {number} x Cursor horizontal coordinate within the canvas\n     * @param {number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor normalized position inside the canvas\n     */\n    __publicField(this, \"getCursorNDC\", (cursorX, cursorY, canvas) => {\n      const canvasRect = canvas.getBoundingClientRect();\n      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n      return this._v2_1.clone();\n    });\n    /**\n     * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n     * @param {Number} x Cursor horizontal coordinate within the canvas\n     * @param {Number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor position inside the canvas\n     */\n    __publicField(this, \"getCursorPosition\", (cursorX, cursorY, canvas) => {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n      if (this.camera instanceof OrthographicCamera) {\n        this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n        this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n      }\n      return this._v2_1.clone();\n    });\n    /**\n     * Set the camera to be controlled\n     * @param {Camera} camera The virtual camera to be controlled\n     */\n    __publicField(this, \"setCamera\", camera => {\n      if (camera) {\n        camera.lookAt(this.target);\n        camera.updateMatrix();\n        if (camera instanceof PerspectiveCamera) {\n          this._fov0 = camera.fov;\n          this._fovState = camera.fov;\n        }\n        this._cameraMatrixState0.copy(camera.matrix);\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\n        this._cameraProjectionState.copy(camera.projectionMatrix);\n        this._zoom0 = camera.zoom;\n        this._zoomState = this._zoom0;\n        this._initialNear = camera.near;\n        this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n        this._nearPos = this._initialNear;\n        this._initialFar = camera.far;\n        this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n        this._farPos = this._initialFar;\n        this._up0.copy(camera.up);\n        this._upState.copy(camera.up);\n        this.camera = camera;\n        this.camera.updateProjectionMatrix();\n        const tbRadius = this.calculateTbRadius(camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        this.makeGizmos(this.target, this._tbRadius);\n      }\n    });\n    /**\n     * Creates the rotation gizmos matching trackball center and radius\n     * @param {Vector3} tbCenter The trackball center\n     * @param {number} tbRadius The trackball radius\n     */\n    __publicField(this, \"makeGizmos\", (tbCenter, tbRadius) => {\n      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      const points = curve.getPoints(this._curvePts);\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\n      const curveMaterialX = new LineBasicMaterial({\n        color: 16744576,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialY = new LineBasicMaterial({\n        color: 8454016,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialZ = new LineBasicMaterial({\n        color: 8421631,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const gizmoX = new Line(curveGeometry, curveMaterialX);\n      const gizmoY = new Line(curveGeometry, curveMaterialY);\n      const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      const rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation;\n      this._gizmoMatrixState0.identity().setPosition(tbCenter);\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n      if (this.camera && this.camera.zoom != 1) {\n        const size = 1 / this.camera.zoom;\n        this._scaleMatrix.makeScale(size, size, size);\n        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n      }\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this._gizmos.clear();\n      this._gizmos.add(gizmoX);\n      this._gizmos.add(gizmoY);\n      this._gizmos.add(gizmoZ);\n    });\n    /**\n     * Perform animation for focus operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} point Point of interest for focus operation\n     * @param {Matrix4} cameraMatrix Camera matrix\n     * @param {Matrix4} gizmoMatrix Gizmos matrix\n     */\n    __publicField(this, \"onFocusAnim\", (time, point, cameraMatrix, gizmoMatrix) => {\n      if (this._timeStart == -1) {\n        this._timeStart = time;\n      }\n      if (this._state == STATE.ANIMATION_FOCUS) {\n        const deltaTime = time - this._timeStart;\n        const animTime = deltaTime / this.focusAnimationTime;\n        this._gizmoMatrixState.copy(gizmoMatrix);\n        if (animTime >= 1) {\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n          this.focus(point, this.scaleFactor);\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        } else {\n          const amount = this.easeOutCubic(animTime);\n          const size = 1 - amount + this.scaleFactor * amount;\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n          this.focus(point, size, amount);\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        this._animationId = -1;\n        this._timeStart = -1;\n      }\n    });\n    /**\n     * Perform animation for rotation operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} rotationAxis Rotation axis\n     * @param {number} w0 Initial angular velocity\n     */\n    __publicField(this, \"onRotationAnim\", (time, rotationAxis, w0) => {\n      if (this._timeStart == -1) {\n        this._anglePrev = 0;\n        this._angleCurrent = 0;\n        this._timeStart = time;\n      }\n      if (this._state == STATE.ANIMATION_ROTATE) {\n        const deltaTime = (time - this._timeStart) / 1e3;\n        const w = w0 + -this.dampingFactor * deltaTime;\n        if (w > 0) {\n          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          this._animationId = -1;\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        this._animationId = -1;\n        this._timeStart = -1;\n        if (this._state != STATE.ROTATE) {\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n    /**\n     * Perform pan operation moving camera between two points\n     * @param {Vector3} p0 Initial point\n     * @param {Vector3} p1 Ending point\n     * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n     */\n    __publicField(this, \"pan\", (p0, p1, adjust = false) => {\n      if (this.camera) {\n        const movement = p0.clone().sub(p1);\n        if (this.camera instanceof OrthographicCamera) {\n          movement.multiplyScalar(1 / this.camera.zoom);\n        }\n        if (this.camera instanceof PerspectiveCamera && adjust) {\n          this._v3_1.setFromMatrixPosition(this._cameraMatrixState0);\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0);\n          const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);\n          movement.multiplyScalar(1 / distanceFactor);\n        }\n        this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);\n        this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\n        this.setTransformationMatrices(this._m4_1, this._m4_1);\n      }\n      return _transformation;\n    });\n    /**\n     * Reset trackball\n     */\n    __publicField(this, \"reset\", () => {\n      if (this.camera) {\n        this.camera.zoom = this._zoom0;\n        if (this.camera instanceof PerspectiveCamera) {\n          this.camera.fov = this._fov0;\n        }\n        this.camera.near = this._nearPos;\n        this.camera.far = this._farPos;\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n        this.camera.up.copy(this._up0);\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n        this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n        this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this._gizmos.updateMatrix();\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    /**\n     * Rotate the camera around an axis passing by trackball's center\n     * @param {Vector3} axis Rotation axis\n     * @param {number} angle Angle in radians\n     * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n     */\n    __publicField(this, \"rotate\", (axis, angle) => {\n      const point = this._gizmos.position;\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      this._rotationMatrix.makeRotationAxis(axis, -angle);\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n      this._m4_1.multiply(this._rotationMatrix);\n      this._m4_1.multiply(this._translationMatrix);\n      this.setTransformationMatrices(this._m4_1);\n      return _transformation;\n    });\n    __publicField(this, \"copyState\", () => {\n      if (this.camera) {\n        const state = JSON.stringify(this.camera instanceof OrthographicCamera ? {\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        } : {\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraFov: this.camera.fov,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n        navigator.clipboard.writeText(state);\n      }\n    });\n    __publicField(this, \"pasteState\", () => {\n      const self = this;\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n    /**\n     * Save the current state of the control. This can later be recovered with .reset\n     */\n    __publicField(this, \"saveState\", () => {\n      if (!this.camera) return;\n      this._cameraMatrixState0.copy(this.camera.matrix);\n      this._gizmoMatrixState0.copy(this._gizmos.matrix);\n      this._nearPos = this.camera.near;\n      this._farPos = this.camera.far;\n      this._zoom0 = this.camera.zoom;\n      this._up0.copy(this.camera.up);\n      if (this.camera instanceof PerspectiveCamera) {\n        this._fov0 = this.camera.fov;\n      }\n    });\n    /**\n     * Perform uniform scale operation around a given point\n     * @param {Number} size Scale factor\n     * @param {Vector3} point Point around which scale\n     * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n     * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n     */\n    __publicField(this, \"applyScale\", (size, point, scaleGizmos = true) => {\n      if (!this.camera) return;\n      const scalePoint = point.clone();\n      let sizeInverse = 1 / size;\n      if (this.camera instanceof OrthographicCamera) {\n        this.camera.zoom = this._zoomState;\n        this.camera.zoom *= size;\n        if (this.camera.zoom > this.maxZoom) {\n          this.camera.zoom = this.maxZoom;\n          sizeInverse = this._zoomState / this.maxZoom;\n        } else if (this.camera.zoom < this.minZoom) {\n          this.camera.zoom = this.minZoom;\n          sizeInverse = this._zoomState / this.minZoom;\n        }\n        this.camera.updateProjectionMatrix();\n        this._v3_1.setFromMatrixPosition(this._gizmoMatrixState);\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n        this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\n        this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\n        this._m4_2.multiply(this._translationMatrix);\n        scalePoint.sub(this._v3_1);\n        const amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n        this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n        this._m4_2.premultiply(this._m4_1);\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\n        return _transformation;\n      }\n      if (this.camera instanceof PerspectiveCamera) {\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n        let distance = this._v3_1.distanceTo(scalePoint);\n        let amount = distance - distance * sizeInverse;\n        const newDistance = distance - amount;\n        if (newDistance < this.minDistance) {\n          sizeInverse = this.minDistance / distance;\n          amount = distance - distance * sizeInverse;\n        } else if (newDistance > this.maxDistance) {\n          sizeInverse = this.maxDistance / distance;\n          amount = distance - distance * sizeInverse;\n        }\n        let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount);\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        if (scaleGizmos) {\n          const pos = this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount);\n          this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n          this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n          this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix);\n          this._m4_2.multiply(this._scaleMatrix);\n          this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n          this._m4_2.multiply(this._translationMatrix);\n          this.setTransformationMatrices(this._m4_1, this._m4_2);\n        } else {\n          this.setTransformationMatrices(this._m4_1);\n        }\n        return _transformation;\n      }\n    });\n    /**\n     * Set camera fov\n     * @param {Number} value fov to be setted\n     */\n    __publicField(this, \"setFov\", value => {\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n    });\n    /**\n     * Set the trackball's center point\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Number} z Z coordinate\n     */\n    __publicField(this, \"setTarget\", (x, y, z) => {\n      if (this.camera) {\n        this.target.set(x, y, z);\n        this._gizmos.position.set(x, y, z);\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        this.makeGizmos(this.target, this._tbRadius);\n        this.camera.lookAt(this.target);\n      }\n    });\n    /**\n     * Rotate camera around its direction axis passing by a given point by a given angle\n     * @param {Vector3} point The point where the rotation axis is passing trough\n     * @param {Number} angle Angle in radians\n     * @returns The computed transormation matix\n     */\n    __publicField(this, \"zRotate\", (point, angle) => {\n      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n      this._m4_1.multiply(this._rotationMatrix);\n      this._m4_1.multiply(this._translationMatrix);\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point);\n      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle);\n      this._v3_2.sub(this._v3_1);\n      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    });\n    /**\n     * Unproject the cursor on the 3D object surface\n     * @param {Vector2} cursor Cursor coordinates in NDC\n     * @param {Camera} camera Virtual camera\n     * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n     */\n    __publicField(this, \"unprojectOnObj\", (cursor, camera) => {\n      if (!this.scene) return null;\n      const raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      const intersect = raycaster.intersectObjects(this.scene.children, true);\n      for (let i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\n          return intersect[i].point.clone();\n        }\n      }\n      return null;\n    });\n    /**\n     * Unproject the cursor on the trackball surface\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {number} tbRadius The trackball radius\n     * @returns {Vector3} The unprojected point on the trackball surface\n     */\n    __publicField(this, \"unprojectOnTbSurface\", (camera, cursorX, cursorY, canvas, tbRadius) => {\n      if (camera instanceof OrthographicCamera) {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n        const x2 = Math.pow(this._v2_1.x, 2);\n        const y2 = Math.pow(this._v2_1.y, 2);\n        const r2 = Math.pow(this._tbRadius, 2);\n        if (x2 + y2 <= r2 * 0.5) {\n          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n        return this._v3_1;\n      }\n      if (camera instanceof PerspectiveCamera) {\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        const rayDir = this._v3_1.clone().normalize();\n        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        const radius2 = Math.pow(tbRadius, 2);\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n        if (l == 0) {\n          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        let a = Math.pow(m, 2) + 1;\n        let b = 2 * m * q;\n        let c = Math.pow(q, 2) - radius2;\n        let delta = Math.pow(b, 2) - 4 * a * c;\n        if (delta >= 0) {\n          this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n          this._v2_1.setY(m * this._v2_1.x + q);\n          const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n          if (angle >= 45) {\n            const rayLength2 = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength2);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        }\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n        this._v2_1.setY(m * this._v2_1.x + q);\n        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n    /**\n     * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n     * @returns {Vector3} The unprojected point on the trackball plane\n     */\n    __publicField(this, \"unprojectOnTbPlane\", (camera, cursorX, cursorY, canvas, initialDistance = false) => {\n      if (camera instanceof OrthographicCamera) {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n        return this._v3_1.clone();\n      }\n      if (camera instanceof PerspectiveCamera) {\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        const rayDir = this._v3_1.clone().normalize();\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n        let cameraGizmoDistance;\n        if (initialDistance) {\n          cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        }\n        if (l == 0) {\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        const x = -q / m;\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n    /**\n     * Update camera and gizmos state\n     */\n    __publicField(this, \"updateMatrixState\", () => {\n      if (!this.camera) return;\n      this._cameraMatrixState.copy(this.camera.matrix);\n      this._gizmoMatrixState.copy(this._gizmos.matrix);\n      if (this.camera instanceof OrthographicCamera) {\n        this._cameraProjectionState.copy(this.camera.projectionMatrix);\n        this.camera.updateProjectionMatrix();\n        this._zoomState = this.camera.zoom;\n      }\n      if (this.camera instanceof PerspectiveCamera) {\n        this._fovState = this.camera.fov;\n      }\n    });\n    /**\n     * Update the trackball FSA\n     * @param {STATE} newState New state of the FSA\n     * @param {Boolean} updateMatrices If matriices state should be updated\n     */\n    __publicField(this, \"updateTbState\", (newState, updateMatrices) => {\n      this._state = newState;\n      if (updateMatrices) {\n        this.updateMatrixState();\n      }\n    });\n    __publicField(this, \"update\", () => {\n      const EPS = 1e-6;\n      if (!this.target.equals(this._currentTarget) && this.camera) {\n        this._gizmos.position.set(this.target.x, this.target.y, this.target.z);\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        this.makeGizmos(this.target, this._tbRadius);\n        this._currentTarget.copy(this.target);\n      }\n      if (!this.camera) return;\n      if (this.camera instanceof OrthographicCamera) {\n        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));\n        }\n      }\n      if (this.camera instanceof PerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n        if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n          const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n          this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position));\n          this.updateMatrixState();\n        }\n        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n          this.camera.updateProjectionMatrix();\n        }\n        const oldRadius = this._tbRadius;\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n          const newRadius = this._tbRadius / scale;\n          const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          const points = curve.getPoints(this._curvePts);\n          const curveGeometry = new BufferGeometry().setFromPoints(points);\n          for (const gizmo in this._gizmos.children) {\n            const child = this._gizmos.children[gizmo];\n            child.geometry = curveGeometry;\n          }\n        }\n      }\n      this.camera.lookAt(this._gizmos.position);\n    });\n    __publicField(this, \"setStateFromJSON\", json => {\n      const state = JSON.parse(json);\n      if (state.arcballState && this.camera) {\n        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n        this.camera.up.copy(state.arcballState.cameraUp);\n        this.camera.near = state.arcballState.cameraNear;\n        this.camera.far = state.arcballState.cameraFar;\n        this.camera.zoom = state.arcballState.cameraZoom;\n        if (this.camera instanceof PerspectiveCamera) {\n          this.camera.fov = state.arcballState.cameraFov;\n        }\n        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n        this._gizmos.updateMatrix();\n        const tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n        this._gizmoMatrixState0.copy(gizmoTmp);\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n    this.camera = null;\n    this.domElement = domElement;\n    this.scene = scene;\n    this.mouseActions = [];\n    this._mouseOp = null;\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion();\n    this._translationMatrix = new Matrix4();\n    this._rotationMatrix = new Matrix4();\n    this._scaleMatrix = new Matrix4();\n    this._rotationAxis = new Vector3();\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4();\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4();\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE;\n    this._switchSensibility = 32;\n    this._startFingerDistance = 0;\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0;\n    this._currentFingerRotation = 0;\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._clickStart = 0;\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24;\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3();\n    this._grid = null;\n    this._gridPosition = new Vector3();\n    this._gizmos = new Group();\n    this._curvePts = 128;\n    this._timeStart = -1;\n    this._animationId = -1;\n    this.focusAnimationTime = 500;\n    this._timePrev = 0;\n    this._timeCurrent = 0;\n    this._anglePrev = 0;\n    this._angleCurrent = 0;\n    this._cursorPosPrev = new Vector3();\n    this._cursorPosCurr = new Vector3();\n    this._wPrev = 0;\n    this._wCurr = 0;\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1;\n    this.dampingFactor = 25;\n    this.wMax = 20;\n    this.enableAnimations = true;\n    this.enableGrid = false;\n    this.cursorZoom = false;\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n    this.target = new Vector3(0, 0, 0);\n    this._currentTarget = new Vector3(0, 0, 0);\n    this._tbRadius = 1;\n    this._state = STATE.IDLE;\n    this.setCamera(camera);\n    if (this.scene) {\n      this.scene.add(this._gizmos);\n    }\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n    if (this.domElement) this.connect(this.domElement);\n    window.addEventListener(\"resize\", this.onWindowResize);\n  }\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  applyTransformMatrix(transformation) {\n    if ((transformation == null ? void 0 : transformation.camera) && this.camera) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n      this.camera.updateMatrix();\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n    if (transformation == null ? void 0 : transformation.gizmos) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this._gizmos.updateMatrix();\n    }\n    if ((this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) && this.camera) {\n      const tbRadius = this.calculateTbRadius(this.camera);\n      if (tbRadius !== void 0) {\n        this._tbRadius = tbRadius;\n      }\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  setTransformationMatrices(camera = null, gizmos = null) {\n    if (camera) {\n      if (_transformation.camera) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n    if (gizmos) {\n      if (_transformation.gizmos) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n}\nexport { ArcballControls };","map":{"version":3,"sources":["../../src/controls/ArcballControls.ts"],"names":["rayLength"],"mappings":"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","sourcesContent":["import {\n  GridHelper,\n  EllipseCurve,\n  BufferGeometry,\n  Line,\n  LineBasicMaterial,\n  Raycaster,\n  Group,\n  Box3,\n  Sphere,\n  Quaternion,\n  Vector2,\n  Vector3,\n  Matrix4,\n  MathUtils,\n  Scene,\n  PerspectiveCamera,\n  OrthographicCamera,\n  Mesh,\n  Material,\n  EventDispatcher,\n} from 'three'\n\ntype Camera = OrthographicCamera | PerspectiveCamera\ntype Operation = 'PAN' | 'ROTATE' | 'ZOOM' | 'FOV'\ntype MouseButtonType = number | 'WHEEL'\ntype ModifierKey = 'CTRL' | 'SHIFT'\ntype MouseAction = {\n  operation: Operation\n  mouse: MouseButtonType\n  key: ModifierKey | null\n}\n\ntype Transformation = {\n  camera: Matrix4 | null\n  gizmos: Matrix4 | null\n}\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol(),\n}\n\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol(),\n}\n\n//cursor center coordinates\nconst _center = {\n  x: 0,\n  y: 0,\n}\n\n//transformation matrices for gizmos and camera\nconst _transformation: Transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4(),\n}\n\n//events\nconst _changeEvent = { type: 'change' }\nconst _startEvent = { type: 'start' }\nconst _endEvent = { type: 'end' }\n\n/**\n *\n * @param {CamOrthographicCamera | PerspectiveCameraera} camera Virtual camera used in the scene\n * @param {HTMLElement=null} domElement Renderer's dom element\n * @param {Scene=null} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher {\n  private camera: OrthographicCamera | PerspectiveCamera | null\n  private domElement: HTMLElement | null | undefined\n  private scene: Scene | null | undefined\n\n  private mouseActions: (MouseAction & { state: Symbol })[]\n  private _mouseOp: Operation | null\n\n  private _v2_1: Vector2\n  private _v3_1: Vector3\n  private _v3_2: Vector3\n\n  private _m4_1: Matrix4\n  private _m4_2: Matrix4\n\n  private _quat: Quaternion\n\n  private _translationMatrix: Matrix4\n  private _rotationMatrix: Matrix4\n  private _scaleMatrix: Matrix4\n\n  private _rotationAxis: Vector3\n\n  private _cameraMatrixState: Matrix4\n  private _cameraProjectionState: Matrix4\n\n  private _fovState: number\n  private _upState: Vector3\n  private _zoomState: number\n  private _nearPos: number\n  private _farPos: number\n\n  private _gizmoMatrixState: Matrix4\n\n  private _up0: Vector3\n  private _zoom0: number\n  private _fov0: number\n  private _initialNear: number\n  private _nearPos0: number\n  private _initialFar: number\n  private _farPos0: number\n  private _cameraMatrixState0: Matrix4\n  private _gizmoMatrixState0: Matrix4\n\n  private _button: MouseButtonType\n  private _touchStart: PointerEvent[]\n  private _touchCurrent: PointerEvent[]\n  private _input: Symbol\n\n  private _switchSensibility: number\n  private _startFingerDistance: number\n  private _currentFingerDistance: number\n  private _startFingerRotation: number\n  private _currentFingerRotation: number\n\n  private _devPxRatio: number\n  private _downValid: boolean\n  private _nclicks: number\n  private _downEvents: PointerEvent[]\n  private _clickStart: number\n  private _maxDownTime: number\n  private _maxInterval: number\n  private _posThreshold: number\n  private _movementThreshold: number\n\n  private _currentCursorPosition: Vector3\n  private _startCursorPosition: Vector3\n\n  private _grid: GridHelper | null\n  private _gridPosition: Vector3\n\n  private _gizmos: Group\n  private _curvePts: number\n\n  private _timeStart: number\n  private _animationId: number\n\n  public focusAnimationTime: number\n\n  private _timePrev: number\n  private _timeCurrent: number\n  private _anglePrev: number\n  private _angleCurrent: number\n  private _cursorPosPrev: Vector3\n  private _cursorPosCurr: Vector3\n  private _wPrev: number\n  private _wCurr: number\n\n  public adjustNearFar: boolean\n  public scaleFactor: number\n  public dampingFactor: number\n  public wMax: number\n  public enableAnimations: boolean\n  public enableGrid: boolean\n  public cursorZoom: boolean\n  public minFov: number\n  public maxFov: number\n\n  public enabled: boolean\n  public enablePan: boolean\n  public enableRotate: boolean\n  public enableZoom: boolean\n\n  public minDistance: number\n  public maxDistance: number\n  public minZoom: number\n  public maxZoom: number\n\n  readonly target: Vector3\n  private _currentTarget: Vector3\n\n  private _tbRadius: number\n\n  private _state: Symbol\n\n  constructor(\n    camera: Camera | null,\n    domElement: HTMLElement | null | undefined = null,\n    scene: Scene | null | undefined = null,\n  ) {\n    super()\n    this.camera = null\n    this.domElement = domElement\n    this.scene = scene\n\n    this.mouseActions = []\n    this._mouseOp = null\n\n    //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n    this._v2_1 = new Vector2()\n    this._v3_1 = new Vector3()\n    this._v3_2 = new Vector3()\n\n    this._m4_1 = new Matrix4()\n    this._m4_2 = new Matrix4()\n\n    this._quat = new Quaternion()\n\n    //transformation matrices\n    this._translationMatrix = new Matrix4() //matrix for translation operation\n    this._rotationMatrix = new Matrix4() //matrix for rotation operation\n    this._scaleMatrix = new Matrix4() //matrix for scaling operation\n\n    this._rotationAxis = new Vector3() //axis for rotate operation\n\n    //camera state\n    this._cameraMatrixState = new Matrix4()\n    this._cameraProjectionState = new Matrix4()\n\n    this._fovState = 1\n    this._upState = new Vector3()\n    this._zoomState = 1\n    this._nearPos = 0\n    this._farPos = 0\n\n    this._gizmoMatrixState = new Matrix4()\n\n    //initial values\n    this._up0 = new Vector3()\n    this._zoom0 = 1\n    this._fov0 = 0\n    this._initialNear = 0\n    this._nearPos0 = 0\n    this._initialFar = 0\n    this._farPos0 = 0\n    this._cameraMatrixState0 = new Matrix4()\n    this._gizmoMatrixState0 = new Matrix4()\n\n    //pointers array\n    this._button = -1\n    this._touchStart = []\n    this._touchCurrent = []\n    this._input = INPUT.NONE\n\n    //two fingers touch interaction\n    this._switchSensibility = 32 //minimum movement to be performed to fire single pan start after the second finger has been released\n    this._startFingerDistance = 0 //distance between two fingers\n    this._currentFingerDistance = 0\n    this._startFingerRotation = 0 //amount of rotation performed with two fingers\n    this._currentFingerRotation = 0\n\n    //double tap\n    this._devPxRatio = 0\n    this._downValid = true\n    this._nclicks = 0\n    this._downEvents = []\n    this._clickStart = 0 //first click time\n    this._maxDownTime = 250\n    this._maxInterval = 300\n    this._posThreshold = 24\n    this._movementThreshold = 24\n\n    //cursor positions\n    this._currentCursorPosition = new Vector3()\n    this._startCursorPosition = new Vector3()\n\n    //grid\n    this._grid = null //grid to be visualized during pan operation\n    this._gridPosition = new Vector3()\n\n    //gizmos\n    this._gizmos = new Group()\n    this._curvePts = 128\n\n    //animations\n    this._timeStart = -1 //initial time\n    this._animationId = -1\n\n    //focus animation\n    this.focusAnimationTime = 500 //duration of focus animation in ms\n\n    //rotate animation\n    this._timePrev = 0 //time at which previous rotate operation has been detected\n    this._timeCurrent = 0 //time at which current rotate operation has been detected\n    this._anglePrev = 0 //angle of previous rotation\n    this._angleCurrent = 0 //angle of current rotation\n    this._cursorPosPrev = new Vector3() //cursor position when previous rotate operation has been detected\n    this._cursorPosCurr = new Vector3() //cursor position when current rotate operation has been detected\n    this._wPrev = 0 //angular velocity of the previous rotate operation\n    this._wCurr = 0 //angular velocity of the current rotate operation\n\n    //parameters\n    this.adjustNearFar = false\n    this.scaleFactor = 1.1 //zoom/distance multiplier\n    this.dampingFactor = 25\n    this.wMax = 20 //maximum angular velocity allowed\n    this.enableAnimations = true //if animations should be performed\n    this.enableGrid = false //if grid should be showed during pan operation\n    this.cursorZoom = false //if wheel zoom should be cursor centered\n    this.minFov = 5\n    this.maxFov = 90\n\n    this.enabled = true\n    this.enablePan = true\n    this.enableRotate = true\n    this.enableZoom = true\n\n    this.minDistance = 0\n    this.maxDistance = Infinity\n    this.minZoom = 0\n    this.maxZoom = Infinity\n\n    //trackball parameters\n    this.target = new Vector3(0, 0, 0)\n    this._currentTarget = new Vector3(0, 0, 0)\n\n    this._tbRadius = 1\n\n    //FSA\n    this._state = STATE.IDLE\n\n    this.setCamera(camera)\n\n    if (this.scene) {\n      this.scene.add(this._gizmos)\n    }\n\n    this._devPxRatio = window.devicePixelRatio\n\n    this.initializeMouseActions()\n\n    if (this.domElement) this.connect(this.domElement)\n\n    window.addEventListener('resize', this.onWindowResize)\n  }\n\n  //listeners\n\n  private onWindowResize = (): void => {\n    const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n    if (this.camera) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n    }\n\n    const newRadius = this._tbRadius / scale\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n    const points = curve.getPoints(this._curvePts)\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    for (const gizmo in this._gizmos.children) {\n      const child = this._gizmos.children[gizmo] as Mesh\n      child.geometry = curveGeometry\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  private onContextMenu = (event: MouseEvent): void => {\n    if (!this.enabled) {\n      return\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == 2) {\n        //prevent only if button 2 is actually used\n        event.preventDefault()\n        break\n      }\n    }\n  }\n\n  private onPointerCancel = (): void => {\n    this._touchStart.splice(0, this._touchStart.length)\n    this._touchCurrent.splice(0, this._touchCurrent.length)\n    this._input = INPUT.NONE\n  }\n\n  private onPointerDown = (event: PointerEvent): void => {\n    if (event.button == 0 && event.isPrimary) {\n      this._downValid = true\n      this._downEvents.push(event)\n    } else {\n      this._downValid = false\n    }\n\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      this._touchStart.push(event)\n      this._touchCurrent.push(event)\n\n      switch (this._input) {\n        case INPUT.NONE:\n          //singleStart\n          this._input = INPUT.ONE_FINGER\n          this.onSinglePanStart(event, 'ROTATE')\n\n          window.addEventListener('pointermove', this.onPointerMove)\n          window.addEventListener('pointerup', this.onPointerUp)\n\n          break\n\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //doubleStart\n          this._input = INPUT.TWO_FINGER\n\n          this.onRotateStart()\n          this.onPinchStart()\n          this.onDoublePanStart()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //multipleStart\n          this._input = INPUT.MULT_FINGER\n          this.onTriplePanStart()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      this._mouseOp = this.getOpFromAction(event.button, modifier)\n      if (this._mouseOp) {\n        window.addEventListener('pointermove', this.onPointerMove)\n        window.addEventListener('pointerup', this.onPointerUp)\n\n        //singleStart\n        this._input = INPUT.CURSOR\n        this._button = event.button\n        this.onSinglePanStart(event, this._mouseOp)\n      }\n    }\n  }\n\n  private onPointerMove = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n          //singleMove\n          this.updateTouchEvent(event)\n\n          this.onSinglePanMove(event, STATE.ROTATE)\n          break\n\n        case INPUT.ONE_FINGER_SWITCHED:\n          const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio\n\n          if (movement >= this._switchSensibility) {\n            //singleMove\n            this._input = INPUT.ONE_FINGER\n            this.updateTouchEvent(event)\n\n            this.onSinglePanStart(event, 'ROTATE')\n            break\n          }\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //rotate/pan/pinchMove\n          this.updateTouchEvent(event)\n\n          this.onRotateMove()\n          this.onPinchMove()\n          this.onDoublePanMove()\n\n          break\n\n        case INPUT.MULT_FINGER:\n          //multMove\n          this.updateTouchEvent(event)\n\n          this.onTriplePanMove()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOpState = this.getOpStateFromAction(this._button, modifier)\n\n      if (mouseOpState) {\n        this.onSinglePanMove(event, mouseOpState)\n      }\n    }\n\n    //checkDistance\n    if (this._downValid) {\n      const movement =\n        this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio\n      if (movement > this._movementThreshold) {\n        this._downValid = false\n      }\n    }\n  }\n\n  private onPointerUp = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      const nTouch = this._touchCurrent.length\n\n      for (let i = 0; i < nTouch; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1)\n          this._touchStart.splice(i, 1)\n          break\n        }\n      }\n\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //singleEnd\n          window.removeEventListener('pointermove', this.onPointerMove)\n          window.removeEventListener('pointerup', this.onPointerUp)\n\n          this._input = INPUT.NONE\n          this.onSinglePanEnd()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //doubleEnd\n          this.onDoublePanEnd()\n          this.onPinchEnd()\n          this.onRotateEnd()\n\n          //switching to singleStart\n          this._input = INPUT.ONE_FINGER_SWITCHED\n\n          break\n\n        case INPUT.MULT_FINGER:\n          if (this._touchCurrent.length == 0) {\n            window.removeEventListener('pointermove', this.onPointerMove)\n            window.removeEventListener('pointerup', this.onPointerUp)\n\n            //multCancel\n            this._input = INPUT.NONE\n            this.onTriplePanEnd()\n          }\n\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      window.removeEventListener('pointermove', this.onPointerMove)\n      window.removeEventListener('pointerup', this.onPointerUp)\n\n      this._input = INPUT.NONE\n      this.onSinglePanEnd()\n      this._button = -1\n    }\n\n    if (event.isPrimary) {\n      if (this._downValid) {\n        const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp\n\n        if (downTime <= this._maxDownTime) {\n          if (this._nclicks == 0) {\n            //first valid click detected\n            this._nclicks = 1\n            this._clickStart = performance.now()\n          } else {\n            const clickInterval = event.timeStamp - this._clickStart\n            const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio\n\n            if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n              //second valid click detected\n              //fire double tap and reset values\n              this._nclicks = 0\n              this._downEvents.splice(0, this._downEvents.length)\n              this.onDoubleTap(event)\n            } else {\n              //new 'first click'\n              this._nclicks = 1\n              this._downEvents.shift()\n              this._clickStart = performance.now()\n            }\n          }\n        } else {\n          this._downValid = false\n          this._nclicks = 0\n          this._downEvents.splice(0, this._downEvents.length)\n        }\n      } else {\n        this._nclicks = 0\n        this._downEvents.splice(0, this._downEvents.length)\n      }\n    }\n  }\n\n  private onWheel = (event: WheelEvent): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOp = this.getOpFromAction('WHEEL', modifier)\n\n      if (mouseOp) {\n        event.preventDefault()\n        // @ts-ignore\n        this.dispatchEvent(_startEvent)\n\n        const notchDeltaY = 125 //distance of one notch of mouse wheel\n        let sgn = event.deltaY / notchDeltaY\n\n        let size = 1\n\n        if (sgn > 0) {\n          size = 1 / this.scaleFactor\n        } else if (sgn < 0) {\n          size = this.scaleFactor\n        }\n\n        switch (mouseOp) {\n          case 'ZOOM':\n            this.updateTbState(STATE.SCALE, true)\n\n            if (sgn > 0) {\n              size = 1 / Math.pow(this.scaleFactor, sgn)\n            } else if (sgn < 0) {\n              size = Math.pow(this.scaleFactor, -sgn)\n            }\n\n            if (this.cursorZoom && this.enablePan) {\n              let scalePoint\n\n              if (this.camera instanceof OrthographicCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .multiplyScalar(1 / this.camera.zoom)\n                  .add(this._gizmos.position)\n              }\n\n              if (this.camera instanceof PerspectiveCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .add(this._gizmos.position)\n              }\n\n              if (scalePoint !== undefined) this.applyTransformMatrix(this.applyScale(size, scalePoint))\n            } else {\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n\n          case 'FOV':\n            if (this.camera instanceof PerspectiveCamera) {\n              this.updateTbState(STATE.FOV, true)\n\n              //Vertigo effect\n\n              //\t  fov / 2\n              //\t\t|\\\n              //\t\t| \\\n              //\t\t|  \\\n              //\tx\t|\t\\\n              //\t\t| \t \\\n              //\t\t| \t  \\\n              //\t\t| _ _ _\\\n              //\t\t\ty\n\n              //check for iOs shift shortcut\n              if (event.deltaX != 0) {\n                sgn = event.deltaX / notchDeltaY\n\n                size = 1\n\n                if (sgn > 0) {\n                  size = 1 / Math.pow(this.scaleFactor, sgn)\n                } else if (sgn < 0) {\n                  size = Math.pow(this.scaleFactor, -sgn)\n                }\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              if (newFov > this.maxFov) {\n                newFov = this.maxFov\n              } else if (newFov < this.minFov) {\n                newFov = this.minFov\n              }\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n        }\n      }\n    }\n  }\n\n  private onSinglePanStart = (event: PointerEvent, operation: Operation): void => {\n    if (this.enabled && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.PAN, true)\n            const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            if (this.enableGrid) {\n              this.drawGrid()\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n          }\n\n          break\n\n        case 'ROTATE':\n          if (!this.enableRotate) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.ROTATE, true)\n            const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            this.activateGizmos(true)\n            if (this.enableAnimations) {\n              this._timePrev = this._timeCurrent = performance.now()\n              this._angleCurrent = this._anglePrev = 0\n              this._cursorPosPrev.copy(this._startCursorPosition)\n              this._cursorPosCurr.copy(this._cursorPosPrev)\n              this._wCurr = 0\n              this._wPrev = this._wCurr\n            }\n          }\n\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n          break\n\n        case 'FOV':\n          if (!this.enableZoom) return\n\n          if (this.camera instanceof PerspectiveCamera) {\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId)\n              this._animationId = -1\n              this._timeStart = -1\n\n              this.activateGizmos(false)\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n\n            this.updateTbState(STATE.FOV, true)\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n            this._currentCursorPosition.copy(this._startCursorPosition)\n          }\n          break\n\n        case 'ZOOM':\n          if (!this.enableZoom) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          this.updateTbState(STATE.SCALE, true)\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n          this._currentCursorPosition.copy(this._startCursorPosition)\n          break\n      }\n    }\n  }\n\n  private onSinglePanMove = (event: PointerEvent, opState: Symbol): void => {\n    if (this.enabled && this.domElement) {\n      const restart = opState != this._state\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan && this.camera) {\n            if (restart) {\n              //switch to pan operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n              if (this.enableGrid) {\n                this.drawGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with pan operation\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition))\n            }\n          }\n\n          break\n\n        case STATE.ROTATE:\n          if (this.enableRotate && this.camera) {\n            if (restart) {\n              //switch to rotate operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(true)\n            } else {\n              //continue with rotate operation\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition)\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition)\n              const amount = Math.max(distance / this._tbRadius, angle) //effective rotation angle\n\n              this.applyTransformMatrix(\n                this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount),\n              )\n\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent\n                this._timeCurrent = performance.now()\n                this._anglePrev = this._angleCurrent\n                this._angleCurrent = amount\n                this._cursorPosPrev.copy(this._cursorPosCurr)\n                this._cursorPosCurr.copy(this._currentCursorPosition)\n                this._wPrev = this._wCurr\n                this._wCurr = this.calculateAngularSpeed(\n                  this._anglePrev,\n                  this._angleCurrent,\n                  this._timePrev,\n                  this._timeCurrent,\n                )\n              }\n            }\n          }\n\n          break\n\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n          }\n\n          break\n\n        case STATE.FOV:\n          if (this.enableZoom && this.camera instanceof PerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with fov operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n              //adjusting distance\n              const direction = this._gizmos.position\n                .clone()\n                .sub(this.camera.position)\n                .normalize()\n                .multiplyScalar(newDistance / x)\n              this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n            }\n          }\n\n          break\n      }\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onSinglePanEnd = (): void => {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return\n      }\n\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2)\n\n          const self = this\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true)\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr)\n\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax))\n          })\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false)\n          this.activateGizmos(false)\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false)\n\n      if (this.enableGrid) {\n        this.disposeGrid()\n      }\n\n      this.activateGizmos(false)\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoubleTap = (event: PointerEvent): void => {\n    if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera)\n\n      if (hitP && this.enableAnimations) {\n        const self = this\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId)\n        }\n\n        this._timeStart = -1\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true)\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState)\n        })\n      } else if (hitP && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true)\n        this.focus(hitP, this.scaleFactor)\n        this.updateTbState(STATE.IDLE, false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoublePanStart = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.PAN, true)\n\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) {\n        this._startCursorPosition.copy(rayDir)\n      }\n      this._currentCursorPosition.copy(this._startCursorPosition)\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onDoublePanMove = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true)\n        this._startCursorPosition.copy(this._currentCursorPosition)\n      }\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) this._currentCursorPosition.copy(rayDir)\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true))\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onDoublePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onRotateStart = (): void => {\n    if (this.enabled && this.enableRotate) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.ZROTATE, true)\n\n      //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n      this._currentFingerRotation = this._startFingerRotation\n\n      this.camera?.getWorldDirection(this._rotationAxis) //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true)\n      }\n    }\n  }\n\n  private onRotateMove = (): void => {\n    if (this.enabled && this.enableRotate && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      let rotationPoint\n\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true)\n        this._startFingerRotation = this._currentFingerRotation\n      }\n\n      //this._currentFingerRotation = event.rotation;\n      this._currentFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState)\n      } else if (this.camera) {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n        rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n          ?.applyQuaternion(this.camera.quaternion)\n          .multiplyScalar(1 / this.camera.zoom)\n          .add(this._v3_2)\n      }\n\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation)\n\n      if (rotationPoint !== undefined) {\n        this.applyTransformMatrix(this.zRotate(rotationPoint, amount))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onRotateEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    this.activateGizmos(false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onPinchStart = (): void => {\n    if (this.enabled && this.enableZoom) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n      this.updateTbState(STATE.SCALE, true)\n\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1])\n      this._currentFingerDistance = this._startFingerDistance\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onPinchMove = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      const minDistance = 12 //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance\n        this.updateTbState(STATE.SCALE, true)\n      }\n\n      this._currentFingerDistance = Math.max(\n        this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]),\n        minDistance * this._devPxRatio,\n      )\n      const amount = this._currentFingerDistance / this._startFingerDistance\n\n      let scalePoint\n\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position\n      } else {\n        if (this.camera instanceof OrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .multiplyScalar(1 / this.camera.zoom)\n            .add(this._gizmos.position)\n        } else if (this.camera instanceof PerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .add(this._gizmos.position)\n        }\n      }\n\n      if (scalePoint !== undefined) {\n        this.applyTransformMatrix(this.applyScale(amount, scalePoint))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onPinchEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onTriplePanStart = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.SCALE, true)\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n      this._currentCursorPosition.copy(this._startCursorPosition)\n    }\n  }\n\n  private onTriplePanMove = (): void => {\n    if (this.enabled && this.enableZoom && this.camera && this.domElement) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n      let size = 1\n\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches)\n      }\n\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      const x = this._v3_1.distanceTo(this._gizmos.position)\n      let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n      //check min and max distance\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n      //calculate new fov\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n      //check min and max fov\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n      size = x / newDistance\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      this.setFov(newFov)\n      this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n      //adjusting distance\n      const direction = this._gizmos.position\n        .clone()\n        .sub(this.camera.position)\n        .normalize()\n        .multiplyScalar(newDistance / x)\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onTriplePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n    //this.dispatchEvent( _changeEvent );\n  }\n\n  /**\n   * Set _center's x/y coordinates\n   * @param {Number} clientX\n   * @param {Number} clientY\n   */\n  private setCenter = (clientX: number, clientY: number): void => {\n    _center.x = clientX\n    _center.y = clientY\n  }\n\n  /**\n   * Set default mouse actions\n   */\n  private initializeMouseActions = (): void => {\n    this.setMouseAction('PAN', 0, 'CTRL')\n    this.setMouseAction('PAN', 2)\n\n    this.setMouseAction('ROTATE', 0)\n\n    this.setMouseAction('ZOOM', 'WHEEL')\n    this.setMouseAction('ZOOM', 1)\n\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT')\n    this.setMouseAction('FOV', 1, 'SHIFT')\n  }\n\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n   */\n  private setMouseAction = (operation: Operation, mouse: MouseButtonType, key: ModifierKey | null = null): boolean => {\n    const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV']\n    const mouseInput = [0, 1, 2, 'WHEEL']\n    const keyInput = ['CTRL', 'SHIFT', null]\n    let state\n\n    if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n      //invalid parameters\n      return false\n    }\n\n    if (mouse == 'WHEEL') {\n      if (operation != 'ZOOM' && operation != 'FOV') {\n        //cannot associate 2D operation to 1D input\n        return false\n      }\n    }\n\n    switch (operation) {\n      case 'PAN':\n        state = STATE.PAN\n        break\n\n      case 'ROTATE':\n        state = STATE.ROTATE\n        break\n\n      case 'ZOOM':\n        state = STATE.SCALE\n        break\n\n      case 'FOV':\n        state = STATE.FOV\n        break\n    }\n\n    const action = {\n      operation: operation,\n      mouse: mouse,\n      key: key,\n      state: state,\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n        this.mouseActions.splice(i, 1, action)\n        return true\n      }\n    }\n\n    this.mouseActions.push(action)\n    return true\n  }\n\n  /**\n   * Return the operation associated to a mouse/keyboard combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns The operation if it has been found, null otherwise\n   */\n  private getOpFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Operation | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n   * @param {Number} mouse Mouse button\n   * @param {String} key Keyboard modifier\n   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n   */\n  private getOpStateFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Symbol | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.state\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.state\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Calculate the angle between two pointers\n   * @param {PointerEvent} p1\n   * @param {PointerEvent} p2\n   * @returns {Number} The angle between two pointers in degrees\n   */\n  private getAngle = (p1: PointerEvent, p2: PointerEvent): number => {\n    return (Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180) / Math.PI\n  }\n\n  /**\n   * Update a PointerEvent inside current pointerevents array\n   * @param {PointerEvent} event\n   */\n  private updateTouchEvent = (event: PointerEvent): void => {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event)\n        break\n      }\n    }\n  }\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  private applyTransformMatrix(transformation: Transformation | undefined): void {\n    if (transformation?.camera && this.camera) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera)\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.updateMatrix()\n\n      //update camera up vector\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion)\n      }\n    }\n\n    if (transformation?.gizmos) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos)\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n    }\n\n    if (\n      (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) &&\n      this.camera\n    ) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position)\n\n        const bb = new Box3()\n        bb.setFromObject(this._gizmos)\n        const sphere = new Sphere()\n        bb.getBoundingSphere(sphere)\n\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length())\n        const regularNearPosition = cameraDistance - this._initialNear\n\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition)\n        this.camera.near = cameraDistance - minNearPos\n\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length())\n        const regularFarPosition = cameraDistance - this._initialFar\n\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition)\n        this.camera.far = cameraDistance - minFarPos\n\n        this.camera.updateProjectionMatrix()\n      } else {\n        let update = false\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear\n          update = true\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar\n          update = true\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix()\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n  private calculateAngularSpeed = (p0: number, p1: number, t0: number, t1: number): number => {\n    const s = p1 - p0\n    const t = (t1 - t0) / 1000\n    if (t == 0) {\n      return 0\n    }\n\n    return s / t\n  }\n\n  /**\n   * Calculate the distance between two pointers\n   * @param {PointerEvent} p0 The first pointer\n   * @param {PointerEvent} p1 The second pointer\n   * @returns {number} The distance between the two pointers\n   */\n  private calculatePointersDistance = (p0: PointerEvent, p1: PointerEvent): number => {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2))\n  }\n\n  /**\n   * Calculate the rotation axis as the vector perpendicular between two vectors\n   * @param {Vector3} vec1 The first vector\n   * @param {Vector3} vec2 The second vector\n   * @returns {Vector3} The normalized rotation axis\n   */\n  private calculateRotationAxis = (vec1: Vector3, vec2: Vector3): Vector3 => {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState)\n    this._quat.setFromRotationMatrix(this._rotationMatrix)\n\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat)\n    return this._rotationAxis.normalize().clone()\n  }\n\n  /**\n   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n   * @param {Camera} camera\n   * @returns {Number} The trackball radius\n   */\n  private calculateTbRadius = (camera: Camera): number | undefined => {\n    const factor = 0.67\n    const distance = camera.position.distanceTo(this._gizmos.position)\n\n    if (camera instanceof PerspectiveCamera) {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5 //vertical fov/2 in radians\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)) //horizontal fov/2 in radians\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor\n    } else if (camera instanceof OrthographicCamera) {\n      return Math.min(camera.top, camera.right) * factor\n    }\n  }\n\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n   * @param {Vector3} point The point of interest\n   * @param {Number} size Scale factor\n   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n   */\n  private focus = (point: Vector3, size: number, amount = 1): void => {\n    if (this.camera) {\n      const focusPoint = point.clone()\n\n      //move center of camera (along with gizmos) towards point of interest\n      focusPoint.sub(this._gizmos.position).multiplyScalar(amount)\n      this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z)\n\n      const gizmoStateTemp = this._gizmoMatrixState.clone()\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      const cameraStateTemp = this._cameraMatrixState.clone()\n      this._cameraMatrixState.premultiply(this._translationMatrix)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      //apply zoom\n      if (this.enableZoom) {\n        this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n      }\n\n      this._gizmoMatrixState.copy(gizmoStateTemp)\n      this._cameraMatrixState.copy(cameraStateTemp)\n    }\n  }\n\n  /**\n   * Draw a grid and add it to the scene\n   */\n  private drawGrid = (): void => {\n    if (this.scene) {\n      const color = 0x888888\n      const multiplier = 3\n      let size, divisions, maxLength, tick\n\n      if (this.camera instanceof OrthographicCamera) {\n        const width = this.camera.right - this.camera.left\n        const height = this.camera.bottom - this.camera.top\n\n        maxLength = Math.max(width, height)\n        tick = maxLength / 20\n\n        size = (maxLength / this.camera.zoom) * multiplier\n        divisions = (size / tick) * this.camera.zoom\n      } else if (this.camera instanceof PerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position)\n        const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5\n        const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV))\n\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2\n        tick = maxLength / 20\n\n        size = maxLength * multiplier\n        divisions = size / tick\n      }\n\n      if (this._grid == null && this.camera) {\n        this._grid = new GridHelper(size, divisions, color, color)\n        this._grid.position.copy(this._gizmos.position)\n        this._gridPosition.copy(this._grid.position)\n        this._grid.quaternion.copy(this.camera.quaternion)\n        this._grid.rotateX(Math.PI * 0.5)\n\n        this.scene.add(this._grid)\n      }\n    }\n  }\n\n  public connect = (domElement: HTMLElement): void => {\n    // https://github.com/mrdoob/three.js/issues/20575\n\n    if ((domElement as any) === document) {\n      console.error(\n        'THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n      )\n    }\n    this.domElement = domElement\n    // disables touch scroll\n    // touch-action needs to be defined for pointer events to work on mobile\n    // https://stackoverflow.com/a/48254578\n    this.domElement.style.touchAction = 'none'\n    this.domElement.addEventListener('contextmenu', this.onContextMenu)\n    this.domElement.addEventListener('pointerdown', this.onPointerDown)\n    this.domElement.addEventListener('pointercancel', this.onPointerCancel)\n    this.domElement.addEventListener('wheel', this.onWheel)\n  }\n\n  /**\n   * Remove all listeners, stop animations and clean scene\n   */\n  public dispose = (): void => {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId)\n    }\n\n    this.domElement?.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement?.removeEventListener('pointercancel', this.onPointerCancel)\n    this.domElement?.removeEventListener('wheel', this.onWheel)\n    this.domElement?.removeEventListener('contextmenu', this.onContextMenu)\n\n    window.removeEventListener('pointermove', this.onPointerMove)\n    window.removeEventListener('pointerup', this.onPointerUp)\n\n    window.removeEventListener('resize', this.onWindowResize)\n\n    this.scene?.remove(this._gizmos)\n    this.disposeGrid()\n  }\n\n  /**\n   * remove the grid from the scene\n   */\n  private disposeGrid = (): void => {\n    if (this._grid && this.scene) {\n      this.scene.remove(this._grid)\n      this._grid = null\n    }\n  }\n\n  /**\n   * Compute the easing out cubic function for ease out effect in animation\n   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n   * @returns {Number} Result of easing out cubic at time t\n   */\n  private easeOutCubic = (t: number): number => {\n    return 1 - Math.pow(1 - t, 3)\n  }\n\n  /**\n   * Make rotation gizmos more or less visible\n   * @param {Boolean} isActive If true, make gizmos more visible\n   */\n  private activateGizmos = (isActive: boolean): void => {\n    for (const gizmo of this._gizmos.children) {\n      ;(gizmo as Mesh<BufferGeometry, Material>).material.setValues({ opacity: isActive ? 1 : 0.6 })\n    }\n  }\n\n  /**\n   * Calculate the cursor position in NDC\n   * @param {number} x Cursor horizontal coordinate within the canvas\n   * @param {number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor normalized position inside the canvas\n   */\n  private getCursorNDC = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    const canvasRect = canvas.getBoundingClientRect()\n    this._v2_1.setX(((cursorX - canvasRect.left) / canvasRect.width) * 2 - 1)\n    this._v2_1.setY(((canvasRect.bottom - cursorY) / canvasRect.height) * 2 - 1)\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n   * @param {Number} x Cursor horizontal coordinate within the canvas\n   * @param {Number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor position inside the canvas\n   */\n  private getCursorPosition = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n    if (this.camera instanceof OrthographicCamera) {\n      this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5\n      this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5\n    }\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Set the camera to be controlled\n   * @param {Camera} camera The virtual camera to be controlled\n   */\n  private setCamera = (camera: Camera | null): void => {\n    if (camera) {\n      camera.lookAt(this.target)\n      camera.updateMatrix()\n\n      //setting state\n      if (camera instanceof PerspectiveCamera) {\n        this._fov0 = camera.fov\n        this._fovState = camera.fov\n      }\n\n      this._cameraMatrixState0.copy(camera.matrix)\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraProjectionState.copy(camera.projectionMatrix)\n      this._zoom0 = camera.zoom\n      this._zoomState = this._zoom0\n\n      this._initialNear = camera.near\n      this._nearPos0 = camera.position.distanceTo(this.target) - camera.near\n      this._nearPos = this._initialNear\n\n      this._initialFar = camera.far\n      this._farPos0 = camera.position.distanceTo(this.target) - camera.far\n      this._farPos = this._initialFar\n\n      this._up0.copy(camera.up)\n      this._upState.copy(camera.up)\n\n      this.camera = camera\n\n      this.camera.updateProjectionMatrix()\n\n      //making gizmos\n      const tbRadius = this.calculateTbRadius(camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n    }\n  }\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  public setGizmosVisible(value: boolean): void {\n    this._gizmos.visible = value\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n  private makeGizmos = (tbCenter: Vector3, tbRadius: number): void => {\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius)\n    const points = curve.getPoints(this._curvePts)\n\n    //geometry\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    //material\n    const curveMaterialX = new LineBasicMaterial({ color: 0xff8080, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialY = new LineBasicMaterial({ color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialZ = new LineBasicMaterial({ color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 })\n\n    //line\n    const gizmoX = new Line(curveGeometry, curveMaterialX)\n    const gizmoY = new Line(curveGeometry, curveMaterialY)\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ)\n\n    const rotation = Math.PI * 0.5\n    gizmoX.rotation.x = rotation\n    gizmoY.rotation.y = rotation\n\n    //setting state\n    this._gizmoMatrixState0.identity().setPosition(tbCenter)\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n\n    if (this.camera && this.camera.zoom != 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.camera.zoom\n      this._scaleMatrix.makeScale(size, size, size)\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z)\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix)\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z)\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n    }\n\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n    this._gizmos.clear()\n\n    this._gizmos.add(gizmoX)\n    this._gizmos.add(gizmoY)\n    this._gizmos.add(gizmoZ)\n  }\n\n  /**\n   * Perform animation for focus operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} point Point of interest for focus operation\n   * @param {Matrix4} cameraMatrix Camera matrix\n   * @param {Matrix4} gizmoMatrix Gizmos matrix\n   */\n  private onFocusAnim = (time: number, point: Vector3, cameraMatrix: Matrix4, gizmoMatrix: Matrix4): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart\n      const animTime = deltaTime / this.focusAnimationTime\n\n      this._gizmoMatrixState.copy(gizmoMatrix)\n\n      if (animTime >= 1) {\n        //animation end\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n        this.focus(point, this.scaleFactor)\n\n        this._timeStart = -1\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      } else {\n        const amount = this.easeOutCubic(animTime)\n        const size = 1 - amount + this.scaleFactor * amount\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n        this.focus(point, size, amount)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone())\n        })\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n    }\n  }\n\n  /**\n   * Perform animation for rotation operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} rotationAxis Rotation axis\n   * @param {number} w0 Initial angular velocity\n   */\n  private onRotationAnim = (time: number, rotationAxis: Vector3, w0: number): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0\n      this._angleCurrent = 0\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000\n      const w = w0 + -this.dampingFactor * deltaTime\n\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent))\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0)\n        })\n      } else {\n        this._animationId = -1\n        this._timeStart = -1\n\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n  }\n\n  /**\n   * Perform pan operation moving camera between two points\n   * @param {Vector3} p0 Initial point\n   * @param {Vector3} p1 Ending point\n   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n   */\n  private pan = (p0: Vector3, p1: Vector3, adjust = false): Transformation => {\n    if (this.camera) {\n      const movement = p0.clone().sub(p1)\n\n      if (this.camera instanceof OrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / this.camera.zoom)\n      }\n\n      if (this.camera instanceof PerspectiveCamera && adjust) {\n        //adjust movement amount\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState0) //camera's initial position\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0) //gizmo's initial position\n        const distanceFactor =\n          this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position)\n        movement.multiplyScalar(1 / distanceFactor)\n      }\n\n      this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion)\n\n      this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_1)\n    }\n    return _transformation\n  }\n\n  /**\n   * Reset trackball\n   */\n  public reset = (): void => {\n    if (this.camera) {\n      this.camera.zoom = this._zoom0\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = this._fov0\n      }\n\n      this.camera.near = this._nearPos\n      this.camera.far = this._farPos\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.up.copy(this._up0)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n      this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n\n      this.camera.lookAt(this._gizmos.position)\n\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  /**\n   * Rotate the camera around an axis passing by trackball's center\n   * @param {Vector3} axis Rotation axis\n   * @param {number} angle Angle in radians\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n   */\n  private rotate = (axis: Vector3, angle: number): Transformation => {\n    const point = this._gizmos.position //rotation center\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n    this._rotationMatrix.makeRotationAxis(axis, -angle)\n\n    //rotate camera\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this.setTransformationMatrices(this._m4_1)\n\n    return _transformation\n  }\n\n  public copyState = (): void => {\n    if (this.camera) {\n      const state = JSON.stringify(\n        this.camera instanceof OrthographicCamera\n          ? {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            }\n          : {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraFov: this.camera.fov,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            },\n      )\n\n      navigator.clipboard.writeText(state)\n    }\n  }\n\n  public pasteState = (): void => {\n    const self = this\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value)\n    })\n  }\n\n  /**\n   * Save the current state of the control. This can later be recovered with .reset\n   */\n  public saveState = (): void => {\n    if (!this.camera) return\n\n    this._cameraMatrixState0.copy(this.camera.matrix)\n    this._gizmoMatrixState0.copy(this._gizmos.matrix)\n    this._nearPos = this.camera.near\n    this._farPos = this.camera.far\n    this._zoom0 = this.camera.zoom\n    this._up0.copy(this.camera.up)\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fov0 = this.camera.fov\n    }\n  }\n\n  /**\n   * Perform uniform scale operation around a given point\n   * @param {Number} size Scale factor\n   * @param {Vector3} point Point around which scale\n   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n   */\n  private applyScale = (size: number, point: Vector3, scaleGizmos = true): Transformation | undefined => {\n    if (!this.camera) return\n\n    const scalePoint = point.clone()\n    let sizeInverse = 1 / size\n\n    if (this.camera instanceof OrthographicCamera) {\n      //camera zoom\n      this.camera.zoom = this._zoomState\n      this.camera.zoom *= size\n\n      //check min and max zoom\n      if (this.camera.zoom > this.maxZoom) {\n        this.camera.zoom = this.maxZoom\n        sizeInverse = this._zoomState / this.maxZoom\n      } else if (this.camera.zoom < this.minZoom) {\n        this.camera.zoom = this.minZoom\n        sizeInverse = this._zoomState / this.minZoom\n      }\n\n      this.camera.updateProjectionMatrix()\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState) //gizmos position\n\n      //scale gizmos so they appear in the same spot having the same dimension\n      this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n      this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z)\n\n      this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix)\n      this._m4_2.multiply(this._translationMatrix)\n\n      //move camera and gizmos to obtain pinch effect\n      scalePoint.sub(this._v3_1)\n\n      const amount = scalePoint.clone().multiplyScalar(sizeInverse)\n      scalePoint.sub(amount)\n\n      this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z)\n      this._m4_2.premultiply(this._m4_1)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2)\n      return _transformation\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      //move camera\n      let distance = this._v3_1.distanceTo(scalePoint)\n      let amount = distance - distance * sizeInverse\n\n      //check min and max distance\n      const newDistance = distance - amount\n      if (newDistance < this.minDistance) {\n        sizeInverse = this.minDistance / distance\n        amount = distance - distance * sizeInverse\n      } else if (newDistance > this.maxDistance) {\n        sizeInverse = this.maxDistance / distance\n        amount = distance - distance * sizeInverse\n      }\n\n      let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount)\n\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      if (scaleGizmos) {\n        //scale gizmos so they appear in the same spot having the same dimension\n        const pos = this._v3_2\n\n        distance = pos.distanceTo(scalePoint)\n        amount = distance - distance * sizeInverse\n        direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount)\n\n        this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z)\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n\n        this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix)\n        this._m4_2.multiply(this._scaleMatrix)\n\n        this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z)\n\n        this._m4_2.multiply(this._translationMatrix)\n        this.setTransformationMatrices(this._m4_1, this._m4_2)\n      } else {\n        this.setTransformationMatrices(this._m4_1)\n      }\n\n      return _transformation\n    }\n  }\n\n  /**\n   * Set camera fov\n   * @param {Number} value fov to be setted\n   */\n  private setFov = (value: number): void => {\n    if (this.camera instanceof PerspectiveCamera) {\n      this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov)\n      this.camera.updateProjectionMatrix()\n    }\n  }\n\n  /**\n   * Set the trackball's center point\n   * @param {Number} x X coordinate\n   * @param {Number} y Y coordinate\n   * @param {Number} z Z coordinate\n   */\n  public setTarget = (x: number, y: number, z: number): void => {\n    if (this.camera) {\n      this.target.set(x, y, z)\n      this._gizmos.position.set(x, y, z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this.camera.lookAt(this.target)\n    }\n  }\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  private setTransformationMatrices(camera: Matrix4 | null = null, gizmos: Matrix4 | null = null): void {\n    if (camera) {\n      if (_transformation.camera) {\n        _transformation.camera.copy(camera)\n      } else {\n        _transformation.camera = camera.clone()\n      }\n    } else {\n      _transformation.camera = null\n    }\n\n    if (gizmos) {\n      if (_transformation.gizmos) {\n        _transformation.gizmos.copy(gizmos)\n      } else {\n        _transformation.gizmos = gizmos.clone()\n      }\n    } else {\n      _transformation.gizmos = null\n    }\n  }\n\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n  private zRotate = (point: Vector3, angle: number): Transformation => {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle)\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point) //vector from rotation center to gizmos position\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle) //apply rotation\n    this._v3_2.sub(this._v3_1)\n\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z)\n\n    this.setTransformationMatrices(this._m4_1, this._m4_2)\n    return _transformation\n  }\n\n  /**\n   * Unproject the cursor on the 3D object surface\n   * @param {Vector2} cursor Cursor coordinates in NDC\n   * @param {Camera} camera Virtual camera\n   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n   */\n  private unprojectOnObj = (cursor: Vector2, camera: Camera): Vector3 | null => {\n    if (!this.scene) return null\n\n    const raycaster = new Raycaster()\n    raycaster.near = camera.near\n    raycaster.far = camera.far\n    raycaster.setFromCamera(cursor, camera)\n\n    const intersect = raycaster.intersectObjects(this.scene.children, true)\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\n        return intersect[i].point.clone()\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Unproject the cursor on the trackball surface\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {number} tbRadius The trackball radius\n   * @returns {Vector3} The unprojected point on the trackball surface\n   */\n  private unprojectOnTbSurface = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    tbRadius: number,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      const x2 = Math.pow(this._v2_1.x, 2)\n      const y2 = Math.pow(this._v2_1.y, 2)\n      const r2 = Math.pow(this._tbRadius, 2)\n\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)))\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ((r2 * 0.5) / Math.sqrt(x2 + y2))\n      }\n\n      return this._v3_1\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      const radius2 = Math.pow(tbRadius, 2)\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n      let a = Math.pow(m, 2) + 1\n      let b = 2 * m * q\n      let c = Math.pow(q, 2) - radius2\n      let delta = Math.pow(b, 2) - 4 * a * c\n\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n        this._v2_1.setY(m * this._v2_1.x + q)\n\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle()\n\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45, return that point\n          //otherwise, calculate intersection point with hyperboloid\n\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n          rayDir.multiplyScalar(rayLength)\n          rayDir.z += cameraGizmoDistance\n          return rayDir\n        }\n      }\n\n      //intersection with hyperboloid\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n      a = m\n      b = q\n      c = -radius2 * 0.5\n      delta = Math.pow(b, 2) - 4 * a * c\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n      this._v2_1.setY(m * this._v2_1.x + q)\n\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z += cameraGizmoDistance\n      return rayDir\n    }\n  }\n\n  /**\n   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n   * @returns {Vector3} The unprojected point on the trackball plane\n   */\n  private unprojectOnTbPlane = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    initialDistance = false,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      return this._v3_1.clone()\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      //unproject cursor on the near plane\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n      let cameraGizmoDistance\n\n      if (initialDistance) {\n        cameraGizmoDistance = this._v3_1\n          .setFromMatrixPosition(this._cameraMatrixState0)\n          .distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0))\n      } else {\n        cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      }\n\n      /*\n       * calculate intersection point between unprojected ray and the plane\n       *|y = mx + q\n       *|y = 0\n       *\n       * x = -q/m\n       */\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(0, 0, 0)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n      const x = -q / m\n\n      const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2))\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z = 0\n      return rayDir\n    }\n  }\n\n  /**\n   * Update camera and gizmos state\n   */\n  private updateMatrixState = (): void => {\n    if (!this.camera) return\n\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.camera.matrix)\n    this._gizmoMatrixState.copy(this._gizmos.matrix)\n\n    if (this.camera instanceof OrthographicCamera) {\n      this._cameraProjectionState.copy(this.camera.projectionMatrix)\n      this.camera.updateProjectionMatrix()\n      this._zoomState = this.camera.zoom\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fovState = this.camera.fov\n    }\n  }\n\n  /**\n   * Update the trackball FSA\n   * @param {STATE} newState New state of the FSA\n   * @param {Boolean} updateMatrices If matriices state should be updated\n   */\n  private updateTbState = (newState: Symbol, updateMatrices: boolean): void => {\n    this._state = newState\n    if (updateMatrices) {\n      this.updateMatrixState()\n    }\n  }\n\n  public update = (): void => {\n    const EPS = 0.000001\n\n    // Update target and gizmos state\n    if (!this.target.equals(this._currentTarget) && this.camera) {\n      this._gizmos.position.set(this.target.x, this.target.y, this.target.z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this._currentTarget.copy(this.target)\n    }\n\n    if (!this.camera) return\n\n    //check min/max parameters\n    if (this.camera instanceof OrthographicCamera) {\n      //check zoom\n      if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom)\n        this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true))\n      }\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      //check distance\n      const distance = this.camera.position.distanceTo(this._gizmos.position)\n\n      if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance)\n        this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position))\n        this.updateMatrixState()\n      }\n\n      //check fov\n      if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n        this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov)\n        this.camera.updateProjectionMatrix()\n      }\n\n      const oldRadius = this._tbRadius\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n        const newRadius = this._tbRadius / scale\n        // @ts-ignore\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n        const points = curve.getPoints(this._curvePts)\n        const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n        for (const gizmo in this._gizmos.children) {\n          const child = this._gizmos.children[gizmo] as Mesh\n          child.geometry = curveGeometry\n        }\n      }\n    }\n\n    this.camera.lookAt(this._gizmos.position)\n  }\n\n  private setStateFromJSON = (json: string): void => {\n    const state = JSON.parse(json)\n\n    if (state.arcballState && this.camera) {\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      this.camera.up.copy(state.arcballState.cameraUp)\n      this.camera.near = state.arcballState.cameraNear\n      this.camera.far = state.arcballState.cameraFar\n\n      this.camera.zoom = state.arcballState.cameraZoom\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = state.arcballState.cameraFov\n      }\n\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0)\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n      this._gizmoMatrixState0.copy(gizmoTmp)\n\n      this.camera.lookAt(this._gizmos.position)\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n}\n\nexport { ArcballControls }\n"]},"metadata":{},"sourceType":"module"}