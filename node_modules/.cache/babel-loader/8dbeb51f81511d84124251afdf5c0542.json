{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Group, Color, Matrix4, BufferGeometry, Float32BufferAttribute, Mesh, MeshPhongMaterial, BufferAttribute, MeshStandardMaterial, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, LinearFilter, LinearMipmapLinearFilter, NearestFilter } from \"three\";\nimport { unzipSync } from \"fflate\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass ThreeMFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.availableExtensions = [];\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    const scope = this;\n    const textureLoader = new TextureLoader(this.manager);\n    function loadDocument(data2) {\n      let zip = null;\n      let file = null;\n      let relsName;\n      let modelRelsName;\n      const modelPartNames = [];\n      const texturesPartNames = [];\n      let modelRels;\n      const modelParts = {};\n      const printTicketParts = {};\n      const texturesParts = {};\n      const otherParts = {};\n      try {\n        zip = unzipSync(new Uint8Array(data2));\n      } catch (e) {\n        if (e instanceof ReferenceError) {\n          console.error(\"THREE.3MFLoader: fflate missing and file is compressed.\");\n          return null;\n        }\n      }\n      for (file in zip) {\n        if (file.match(/\\_rels\\/.rels$/)) {\n          relsName = file;\n        } else if (file.match(/3D\\/_rels\\/.*\\.model\\.rels$/)) {\n          modelRelsName = file;\n        } else if (file.match(/^3D\\/.*\\.model$/)) {\n          modelPartNames.push(file);\n        } else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) ;else if (file.match(/^3D\\/Textures?\\/.*/)) {\n          texturesPartNames.push(file);\n        } else if (file.match(/^3D\\/Other\\/.*/)) ;\n      }\n      const relsView = zip[relsName];\n      const relsFileText = decodeText(relsView);\n      const rels = parseRelsXml(relsFileText);\n      if (modelRelsName) {\n        const relsView2 = zip[modelRelsName];\n        const relsFileText2 = decodeText(relsView2);\n        modelRels = parseRelsXml(relsFileText2);\n      }\n      for (let i = 0; i < modelPartNames.length; i++) {\n        const modelPart = modelPartNames[i];\n        const view = zip[modelPart];\n        const fileText = decodeText(view);\n        const xmlData = new DOMParser().parseFromString(fileText, \"application/xml\");\n        if (xmlData.documentElement.nodeName.toLowerCase() !== \"model\") {\n          console.error(\"THREE.3MFLoader: Error loading 3MF - no 3MF document found: \", modelPart);\n        }\n        const modelNode = xmlData.querySelector(\"model\");\n        const extensions = {};\n        for (let i2 = 0; i2 < modelNode.attributes.length; i2++) {\n          const attr = modelNode.attributes[i2];\n          if (attr.name.match(/^xmlns:(.+)$/)) {\n            extensions[attr.value] = RegExp.$1;\n          }\n        }\n        const modelData = parseModelNode(modelNode);\n        modelData[\"xml\"] = modelNode;\n        if (0 < Object.keys(extensions).length) {\n          modelData[\"extensions\"] = extensions;\n        }\n        modelParts[modelPart] = modelData;\n      }\n      for (let i = 0; i < texturesPartNames.length; i++) {\n        const texturesPartName = texturesPartNames[i];\n        texturesParts[texturesPartName] = zip[texturesPartName].buffer;\n      }\n      return {\n        rels,\n        modelRels,\n        model: modelParts,\n        printTicket: printTicketParts,\n        texture: texturesParts,\n        other: otherParts\n      };\n    }\n    function parseRelsXml(relsFileText) {\n      const relationships = [];\n      const relsXmlData = new DOMParser().parseFromString(relsFileText, \"application/xml\");\n      const relsNodes = relsXmlData.querySelectorAll(\"Relationship\");\n      for (let i = 0; i < relsNodes.length; i++) {\n        const relsNode = relsNodes[i];\n        const relationship = {\n          target: relsNode.getAttribute(\"Target\"),\n          //required\n          id: relsNode.getAttribute(\"Id\"),\n          //required\n          type: relsNode.getAttribute(\"Type\")\n          //required\n        };\n        relationships.push(relationship);\n      }\n      return relationships;\n    }\n    function parseMetadataNodes(metadataNodes) {\n      const metadataData = {};\n      for (let i = 0; i < metadataNodes.length; i++) {\n        const metadataNode = metadataNodes[i];\n        const name = metadataNode.getAttribute(\"name\");\n        const validNames = [\"Title\", \"Designer\", \"Description\", \"Copyright\", \"LicenseTerms\", \"Rating\", \"CreationDate\", \"ModificationDate\"];\n        if (0 <= validNames.indexOf(name)) {\n          metadataData[name] = metadataNode.textContent;\n        }\n      }\n      return metadataData;\n    }\n    function parseBasematerialsNode(basematerialsNode) {\n      const basematerialsData = {\n        id: basematerialsNode.getAttribute(\"id\"),\n        // required\n        basematerials: []\n      };\n      const basematerialNodes = basematerialsNode.querySelectorAll(\"base\");\n      for (let i = 0; i < basematerialNodes.length; i++) {\n        const basematerialNode = basematerialNodes[i];\n        const basematerialData = parseBasematerialNode(basematerialNode);\n        basematerialData.index = i;\n        basematerialsData.basematerials.push(basematerialData);\n      }\n      return basematerialsData;\n    }\n    function parseTexture2DNode(texture2DNode) {\n      const texture2dData = {\n        id: texture2DNode.getAttribute(\"id\"),\n        // required\n        path: texture2DNode.getAttribute(\"path\"),\n        // required\n        contenttype: texture2DNode.getAttribute(\"contenttype\"),\n        // required\n        tilestyleu: texture2DNode.getAttribute(\"tilestyleu\"),\n        tilestylev: texture2DNode.getAttribute(\"tilestylev\"),\n        filter: texture2DNode.getAttribute(\"filter\")\n      };\n      return texture2dData;\n    }\n    function parseTextures2DGroupNode(texture2DGroupNode) {\n      const texture2DGroupData = {\n        id: texture2DGroupNode.getAttribute(\"id\"),\n        // required\n        texid: texture2DGroupNode.getAttribute(\"texid\"),\n        // required\n        displaypropertiesid: texture2DGroupNode.getAttribute(\"displaypropertiesid\")\n      };\n      const tex2coordNodes = texture2DGroupNode.querySelectorAll(\"tex2coord\");\n      const uvs = [];\n      for (let i = 0; i < tex2coordNodes.length; i++) {\n        const tex2coordNode = tex2coordNodes[i];\n        const u = tex2coordNode.getAttribute(\"u\");\n        const v = tex2coordNode.getAttribute(\"v\");\n        uvs.push(parseFloat(u), parseFloat(v));\n      }\n      texture2DGroupData[\"uvs\"] = new Float32Array(uvs);\n      return texture2DGroupData;\n    }\n    function parseColorGroupNode(colorGroupNode) {\n      const colorGroupData = {\n        id: colorGroupNode.getAttribute(\"id\"),\n        // required\n        displaypropertiesid: colorGroupNode.getAttribute(\"displaypropertiesid\")\n      };\n      const colorNodes = colorGroupNode.querySelectorAll(\"color\");\n      const colors = [];\n      const colorObject = new Color();\n      for (let i = 0; i < colorNodes.length; i++) {\n        const colorNode = colorNodes[i];\n        const color = colorNode.getAttribute(\"color\");\n        colorObject.setStyle(color.substring(0, 7));\n        colorObject.convertSRGBToLinear();\n        colors.push(colorObject.r, colorObject.g, colorObject.b);\n      }\n      colorGroupData[\"colors\"] = new Float32Array(colors);\n      return colorGroupData;\n    }\n    function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {\n      const metallicDisplaypropertiesData = {\n        id: metallicDisplaypropetiesNode.getAttribute(\"id\")\n        // required\n      };\n      const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll(\"pbmetallic\");\n      const metallicData = [];\n      for (let i = 0; i < metallicNodes.length; i++) {\n        const metallicNode = metallicNodes[i];\n        metallicData.push({\n          name: metallicNode.getAttribute(\"name\"),\n          // required\n          metallicness: parseFloat(metallicNode.getAttribute(\"metallicness\")),\n          // required\n          roughness: parseFloat(metallicNode.getAttribute(\"roughness\"))\n          // required\n        });\n      }\n      metallicDisplaypropertiesData.data = metallicData;\n      return metallicDisplaypropertiesData;\n    }\n    function parseBasematerialNode(basematerialNode) {\n      const basematerialData = {};\n      basematerialData[\"name\"] = basematerialNode.getAttribute(\"name\");\n      basematerialData[\"displaycolor\"] = basematerialNode.getAttribute(\"displaycolor\");\n      basematerialData[\"displaypropertiesid\"] = basematerialNode.getAttribute(\"displaypropertiesid\");\n      return basematerialData;\n    }\n    function parseMeshNode(meshNode) {\n      const meshData = {};\n      const vertices = [];\n      const vertexNodes = meshNode.querySelectorAll(\"vertices vertex\");\n      for (let i = 0; i < vertexNodes.length; i++) {\n        const vertexNode = vertexNodes[i];\n        const x = vertexNode.getAttribute(\"x\");\n        const y = vertexNode.getAttribute(\"y\");\n        const z = vertexNode.getAttribute(\"z\");\n        vertices.push(parseFloat(x), parseFloat(y), parseFloat(z));\n      }\n      meshData[\"vertices\"] = new Float32Array(vertices);\n      const triangleProperties = [];\n      const triangles = [];\n      const triangleNodes = meshNode.querySelectorAll(\"triangles triangle\");\n      for (let i = 0; i < triangleNodes.length; i++) {\n        const triangleNode = triangleNodes[i];\n        const v1 = triangleNode.getAttribute(\"v1\");\n        const v2 = triangleNode.getAttribute(\"v2\");\n        const v3 = triangleNode.getAttribute(\"v3\");\n        const p1 = triangleNode.getAttribute(\"p1\");\n        const p2 = triangleNode.getAttribute(\"p2\");\n        const p3 = triangleNode.getAttribute(\"p3\");\n        const pid = triangleNode.getAttribute(\"pid\");\n        const triangleProperty = {};\n        triangleProperty[\"v1\"] = parseInt(v1, 10);\n        triangleProperty[\"v2\"] = parseInt(v2, 10);\n        triangleProperty[\"v3\"] = parseInt(v3, 10);\n        triangles.push(triangleProperty[\"v1\"], triangleProperty[\"v2\"], triangleProperty[\"v3\"]);\n        if (p1) {\n          triangleProperty[\"p1\"] = parseInt(p1, 10);\n        }\n        if (p2) {\n          triangleProperty[\"p2\"] = parseInt(p2, 10);\n        }\n        if (p3) {\n          triangleProperty[\"p3\"] = parseInt(p3, 10);\n        }\n        if (pid) {\n          triangleProperty[\"pid\"] = pid;\n        }\n        if (0 < Object.keys(triangleProperty).length) {\n          triangleProperties.push(triangleProperty);\n        }\n      }\n      meshData[\"triangleProperties\"] = triangleProperties;\n      meshData[\"triangles\"] = new Uint32Array(triangles);\n      return meshData;\n    }\n    function parseComponentsNode(componentsNode) {\n      const components = [];\n      const componentNodes = componentsNode.querySelectorAll(\"component\");\n      for (let i = 0; i < componentNodes.length; i++) {\n        const componentNode = componentNodes[i];\n        const componentData = parseComponentNode(componentNode);\n        components.push(componentData);\n      }\n      return components;\n    }\n    function parseComponentNode(componentNode) {\n      const componentData = {};\n      componentData[\"objectId\"] = componentNode.getAttribute(\"objectid\");\n      const transform = componentNode.getAttribute(\"transform\");\n      if (transform) {\n        componentData[\"transform\"] = parseTransform(transform);\n      }\n      return componentData;\n    }\n    function parseTransform(transform) {\n      const t = [];\n      transform.split(\" \").forEach(function (s) {\n        t.push(parseFloat(s));\n      });\n      const matrix = new Matrix4();\n      matrix.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0, 0, 0, 1);\n      return matrix;\n    }\n    function parseObjectNode(objectNode) {\n      const objectData = {\n        type: objectNode.getAttribute(\"type\")\n      };\n      const id = objectNode.getAttribute(\"id\");\n      if (id) {\n        objectData[\"id\"] = id;\n      }\n      const pid = objectNode.getAttribute(\"pid\");\n      if (pid) {\n        objectData[\"pid\"] = pid;\n      }\n      const pindex = objectNode.getAttribute(\"pindex\");\n      if (pindex) {\n        objectData[\"pindex\"] = pindex;\n      }\n      const thumbnail = objectNode.getAttribute(\"thumbnail\");\n      if (thumbnail) {\n        objectData[\"thumbnail\"] = thumbnail;\n      }\n      const partnumber = objectNode.getAttribute(\"partnumber\");\n      if (partnumber) {\n        objectData[\"partnumber\"] = partnumber;\n      }\n      const name = objectNode.getAttribute(\"name\");\n      if (name) {\n        objectData[\"name\"] = name;\n      }\n      const meshNode = objectNode.querySelector(\"mesh\");\n      if (meshNode) {\n        objectData[\"mesh\"] = parseMeshNode(meshNode);\n      }\n      const componentsNode = objectNode.querySelector(\"components\");\n      if (componentsNode) {\n        objectData[\"components\"] = parseComponentsNode(componentsNode);\n      }\n      return objectData;\n    }\n    function parseResourcesNode(resourcesNode) {\n      const resourcesData = {};\n      resourcesData[\"basematerials\"] = {};\n      const basematerialsNodes = resourcesNode.querySelectorAll(\"basematerials\");\n      for (let i = 0; i < basematerialsNodes.length; i++) {\n        const basematerialsNode = basematerialsNodes[i];\n        const basematerialsData = parseBasematerialsNode(basematerialsNode);\n        resourcesData[\"basematerials\"][basematerialsData[\"id\"]] = basematerialsData;\n      }\n      resourcesData[\"texture2d\"] = {};\n      const textures2DNodes = resourcesNode.querySelectorAll(\"texture2d\");\n      for (let i = 0; i < textures2DNodes.length; i++) {\n        const textures2DNode = textures2DNodes[i];\n        const texture2DData = parseTexture2DNode(textures2DNode);\n        resourcesData[\"texture2d\"][texture2DData[\"id\"]] = texture2DData;\n      }\n      resourcesData[\"colorgroup\"] = {};\n      const colorGroupNodes = resourcesNode.querySelectorAll(\"colorgroup\");\n      for (let i = 0; i < colorGroupNodes.length; i++) {\n        const colorGroupNode = colorGroupNodes[i];\n        const colorGroupData = parseColorGroupNode(colorGroupNode);\n        resourcesData[\"colorgroup\"][colorGroupData[\"id\"]] = colorGroupData;\n      }\n      resourcesData[\"pbmetallicdisplayproperties\"] = {};\n      const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll(\"pbmetallicdisplayproperties\");\n      for (let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i++) {\n        const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i];\n        const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode);\n        resourcesData[\"pbmetallicdisplayproperties\"][pbmetallicdisplaypropertiesData[\"id\"]] = pbmetallicdisplaypropertiesData;\n      }\n      resourcesData[\"texture2dgroup\"] = {};\n      const textures2DGroupNodes = resourcesNode.querySelectorAll(\"texture2dgroup\");\n      for (let i = 0; i < textures2DGroupNodes.length; i++) {\n        const textures2DGroupNode = textures2DGroupNodes[i];\n        const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode);\n        resourcesData[\"texture2dgroup\"][textures2DGroupData[\"id\"]] = textures2DGroupData;\n      }\n      resourcesData[\"object\"] = {};\n      const objectNodes = resourcesNode.querySelectorAll(\"object\");\n      for (let i = 0; i < objectNodes.length; i++) {\n        const objectNode = objectNodes[i];\n        const objectData = parseObjectNode(objectNode);\n        resourcesData[\"object\"][objectData[\"id\"]] = objectData;\n      }\n      return resourcesData;\n    }\n    function parseBuildNode(buildNode) {\n      const buildData = [];\n      const itemNodes = buildNode.querySelectorAll(\"item\");\n      for (let i = 0; i < itemNodes.length; i++) {\n        const itemNode = itemNodes[i];\n        const buildItem = {\n          objectId: itemNode.getAttribute(\"objectid\")\n        };\n        const transform = itemNode.getAttribute(\"transform\");\n        if (transform) {\n          buildItem[\"transform\"] = parseTransform(transform);\n        }\n        buildData.push(buildItem);\n      }\n      return buildData;\n    }\n    function parseModelNode(modelNode) {\n      const modelData = {\n        unit: modelNode.getAttribute(\"unit\") || \"millimeter\"\n      };\n      const metadataNodes = modelNode.querySelectorAll(\"metadata\");\n      if (metadataNodes) {\n        modelData[\"metadata\"] = parseMetadataNodes(metadataNodes);\n      }\n      const resourcesNode = modelNode.querySelector(\"resources\");\n      if (resourcesNode) {\n        modelData[\"resources\"] = parseResourcesNode(resourcesNode);\n      }\n      const buildNode = modelNode.querySelector(\"build\");\n      if (buildNode) {\n        modelData[\"build\"] = parseBuildNode(buildNode);\n      }\n      return modelData;\n    }\n    function buildTexture(texture2dgroup, objects2, modelData, textureData) {\n      const texid = texture2dgroup.texid;\n      const texture2ds = modelData.resources.texture2d;\n      const texture2d = texture2ds[texid];\n      if (texture2d) {\n        const data2 = textureData[texture2d.path];\n        const type = texture2d.contenttype;\n        const blob = new Blob([data2], {\n          type\n        });\n        const sourceURI = URL.createObjectURL(blob);\n        const texture = textureLoader.load(sourceURI, function () {\n          URL.revokeObjectURL(sourceURI);\n        });\n        if (\"colorSpace\" in texture) texture.colorSpace = \"srgb\";else texture.encoding = 3001;\n        switch (texture2d.tilestyleu) {\n          case \"wrap\":\n            texture.wrapS = RepeatWrapping;\n            break;\n          case \"mirror\":\n            texture.wrapS = MirroredRepeatWrapping;\n            break;\n          case \"none\":\n          case \"clamp\":\n            texture.wrapS = ClampToEdgeWrapping;\n            break;\n          default:\n            texture.wrapS = RepeatWrapping;\n        }\n        switch (texture2d.tilestylev) {\n          case \"wrap\":\n            texture.wrapT = RepeatWrapping;\n            break;\n          case \"mirror\":\n            texture.wrapT = MirroredRepeatWrapping;\n            break;\n          case \"none\":\n          case \"clamp\":\n            texture.wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            texture.wrapT = RepeatWrapping;\n        }\n        switch (texture2d.filter) {\n          case \"auto\":\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearMipmapLinearFilter;\n            break;\n          case \"linear\":\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearFilter;\n            break;\n          case \"nearest\":\n            texture.magFilter = NearestFilter;\n            texture.minFilter = NearestFilter;\n            break;\n          default:\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearMipmapLinearFilter;\n        }\n        return texture;\n      } else {\n        return null;\n      }\n    }\n    function buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData) {\n      const objectPindex = objectData.pindex;\n      const materialMap = {};\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        const pindex = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectPindex;\n        if (materialMap[pindex] === void 0) materialMap[pindex] = [];\n        materialMap[pindex].push(triangleProperty);\n      }\n      const keys = Object.keys(materialMap);\n      const meshes = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const materialIndex = keys[i];\n        const trianglePropertiesProps = materialMap[materialIndex];\n        const basematerialData = basematerials.basematerials[materialIndex];\n        const material = getBuild(basematerialData, objects2, modelData, textureData, objectData, buildBasematerial);\n        const geometry = new BufferGeometry();\n        const positionData = [];\n        const vertices = meshData.vertices;\n        for (let j = 0, jl = trianglePropertiesProps.length; j < jl; j++) {\n          const triangleProperty = trianglePropertiesProps[j];\n          positionData.push(vertices[triangleProperty.v1 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v1 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v1 * 3 + 2]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 2]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 2]);\n        }\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n        const mesh = new Mesh(geometry, material);\n        meshes.push(mesh);\n      }\n      return meshes;\n    }\n    function buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData) {\n      const geometry = new BufferGeometry();\n      const positionData = [];\n      const uvData = [];\n      const vertices = meshData.vertices;\n      const uvs = texture2dgroup.uvs;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        positionData.push(vertices[triangleProperty.v1 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v1 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v1 * 3 + 2]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 2]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 2]);\n        uvData.push(uvs[triangleProperty.p1 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p1 * 2 + 1]);\n        uvData.push(uvs[triangleProperty.p2 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p2 * 2 + 1]);\n        uvData.push(uvs[triangleProperty.p3 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p3 * 2 + 1]);\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvData, 2));\n      const texture = getBuild(texture2dgroup, objects2, modelData, textureData, objectData, buildTexture);\n      const material = new MeshPhongMaterial({\n        map: texture,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData) {\n      const geometry = new BufferGeometry();\n      const positionData = [];\n      const colorData = [];\n      const vertices = meshData.vertices;\n      const colors = colorgroup.colors;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        const v1 = triangleProperty.v1;\n        const v2 = triangleProperty.v2;\n        const v3 = triangleProperty.v3;\n        positionData.push(vertices[v1 * 3 + 0]);\n        positionData.push(vertices[v1 * 3 + 1]);\n        positionData.push(vertices[v1 * 3 + 2]);\n        positionData.push(vertices[v2 * 3 + 0]);\n        positionData.push(vertices[v2 * 3 + 1]);\n        positionData.push(vertices[v2 * 3 + 2]);\n        positionData.push(vertices[v3 * 3 + 0]);\n        positionData.push(vertices[v3 * 3 + 1]);\n        positionData.push(vertices[v3 * 3 + 2]);\n        const p1 = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectData.pindex;\n        const p2 = triangleProperty.p2 !== void 0 ? triangleProperty.p2 : p1;\n        const p3 = triangleProperty.p3 !== void 0 ? triangleProperty.p3 : p1;\n        colorData.push(colors[p1 * 3 + 0]);\n        colorData.push(colors[p1 * 3 + 1]);\n        colorData.push(colors[p1 * 3 + 2]);\n        colorData.push(colors[p2 * 3 + 0]);\n        colorData.push(colors[p2 * 3 + 1]);\n        colorData.push(colors[p2 * 3 + 2]);\n        colorData.push(colors[p3 * 3 + 0]);\n        colorData.push(colors[p3 * 3 + 1]);\n        colorData.push(colors[p3 * 3 + 2]);\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n      geometry.setAttribute(\"color\", new Float32BufferAttribute(colorData, 3));\n      const material = new MeshPhongMaterial({\n        vertexColors: true,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildDefaultMesh(meshData) {\n      const geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(meshData[\"triangles\"], 1));\n      geometry.setAttribute(\"position\", new BufferAttribute(meshData[\"vertices\"], 3));\n      const material = new MeshPhongMaterial({\n        color: 11184895,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData) {\n      const keys = Object.keys(resourceMap);\n      const meshes = [];\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const resourceId = keys[i];\n        const triangleProperties = resourceMap[resourceId];\n        const resourceType = getResourceType(resourceId, modelData);\n        switch (resourceType) {\n          case \"material\":\n            const basematerials = modelData.resources.basematerials[resourceId];\n            const newMeshes = buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData);\n            for (let j = 0, jl = newMeshes.length; j < jl; j++) {\n              meshes.push(newMeshes[j]);\n            }\n            break;\n          case \"texture\":\n            const texture2dgroup = modelData.resources.texture2dgroup[resourceId];\n            meshes.push(buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData));\n            break;\n          case \"vertexColors\":\n            const colorgroup = modelData.resources.colorgroup[resourceId];\n            meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData));\n            break;\n          case \"default\":\n            meshes.push(buildDefaultMesh(meshData));\n            break;\n          default:\n            console.error(\"THREE.3MFLoader: Unsupported resource type.\");\n        }\n      }\n      return meshes;\n    }\n    function getResourceType(pid, modelData) {\n      if (modelData.resources.texture2dgroup[pid] !== void 0) {\n        return \"texture\";\n      } else if (modelData.resources.basematerials[pid] !== void 0) {\n        return \"material\";\n      } else if (modelData.resources.colorgroup[pid] !== void 0) {\n        return \"vertexColors\";\n      } else if (pid === \"default\") {\n        return \"default\";\n      } else {\n        return void 0;\n      }\n    }\n    function analyzeObject(modelData, meshData, objectData) {\n      const resourceMap = {};\n      const triangleProperties = meshData[\"triangleProperties\"];\n      const objectPid = objectData.pid;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        let pid = triangleProperty.pid !== void 0 ? triangleProperty.pid : objectPid;\n        if (pid === void 0) pid = \"default\";\n        if (resourceMap[pid] === void 0) resourceMap[pid] = [];\n        resourceMap[pid].push(triangleProperty);\n      }\n      return resourceMap;\n    }\n    function buildGroup(meshData, objects2, modelData, textureData, objectData) {\n      const group = new Group();\n      const resourceMap = analyzeObject(modelData, meshData, objectData);\n      const meshes = buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData);\n      for (let i = 0, l = meshes.length; i < l; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    }\n    function applyExtensions(extensions, meshData, modelXml) {\n      if (!extensions) {\n        return;\n      }\n      const availableExtensions = [];\n      const keys = Object.keys(extensions);\n      for (let i = 0; i < keys.length; i++) {\n        const ns = keys[i];\n        for (let j = 0; j < scope.availableExtensions.length; j++) {\n          const extension = scope.availableExtensions[j];\n          if (extension.ns === ns) {\n            availableExtensions.push(extension);\n          }\n        }\n      }\n      for (let i = 0; i < availableExtensions.length; i++) {\n        const extension = availableExtensions[i];\n        extension.apply(modelXml, extensions[extension[\"ns\"]], meshData);\n      }\n    }\n    function getBuild(data2, objects2, modelData, textureData, objectData, builder) {\n      if (data2.build !== void 0) return data2.build;\n      data2.build = builder(data2, objects2, modelData, textureData, objectData);\n      return data2.build;\n    }\n    function buildBasematerial(materialData, objects2, modelData) {\n      let material;\n      const displaypropertiesid = materialData.displaypropertiesid;\n      const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;\n      if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== void 0) {\n        const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid];\n        const metallicData = pbmetallicdisplayproperty.data[materialData.index];\n        material = new MeshStandardMaterial({\n          flatShading: true,\n          roughness: metallicData.roughness,\n          metalness: metallicData.metallicness\n        });\n      } else {\n        material = new MeshPhongMaterial({\n          flatShading: true\n        });\n      }\n      material.name = materialData.name;\n      const displaycolor = materialData.displaycolor;\n      const color = displaycolor.substring(0, 7);\n      material.color.setStyle(color);\n      material.color.convertSRGBToLinear();\n      if (displaycolor.length === 9) {\n        material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255;\n      }\n      return material;\n    }\n    function buildComposite(compositeData, objects2, modelData, textureData) {\n      const composite = new Group();\n      for (let j = 0; j < compositeData.length; j++) {\n        const component = compositeData[j];\n        let build2 = objects2[component.objectId];\n        if (build2 === void 0) {\n          buildObject(component.objectId, objects2, modelData, textureData);\n          build2 = objects2[component.objectId];\n        }\n        const object3D = build2.clone();\n        const transform = component.transform;\n        if (transform) {\n          object3D.applyMatrix4(transform);\n        }\n        composite.add(object3D);\n      }\n      return composite;\n    }\n    function buildObject(objectId, objects2, modelData, textureData) {\n      const objectData = modelData[\"resources\"][\"object\"][objectId];\n      if (objectData[\"mesh\"]) {\n        const meshData = objectData[\"mesh\"];\n        const extensions = modelData[\"extensions\"];\n        const modelXml = modelData[\"xml\"];\n        applyExtensions(extensions, meshData, modelXml);\n        objects2[objectData.id] = getBuild(meshData, objects2, modelData, textureData, objectData, buildGroup);\n      } else {\n        const compositeData = objectData[\"components\"];\n        objects2[objectData.id] = getBuild(compositeData, objects2, modelData, textureData, objectData, buildComposite);\n      }\n    }\n    function buildObjects(data3mf2) {\n      const modelsData = data3mf2.model;\n      const modelRels = data3mf2.modelRels;\n      const objects2 = {};\n      const modelsKeys = Object.keys(modelsData);\n      const textureData = {};\n      if (modelRels) {\n        for (let i = 0, l = modelRels.length; i < l; i++) {\n          const modelRel = modelRels[i];\n          const textureKey = modelRel.target.substring(1);\n          if (data3mf2.texture[textureKey]) {\n            textureData[modelRel.target] = data3mf2.texture[textureKey];\n          }\n        }\n      }\n      for (let i = 0; i < modelsKeys.length; i++) {\n        const modelsKey = modelsKeys[i];\n        const modelData = modelsData[modelsKey];\n        const objectIds = Object.keys(modelData[\"resources\"][\"object\"]);\n        for (let j = 0; j < objectIds.length; j++) {\n          const objectId = objectIds[j];\n          buildObject(objectId, objects2, modelData, textureData);\n        }\n      }\n      return objects2;\n    }\n    function fetch3DModelPart(rels) {\n      for (let i = 0; i < rels.length; i++) {\n        const rel = rels[i];\n        const extension = rel.target.split(\".\").pop();\n        if (extension.toLowerCase() === \"model\") return rel;\n      }\n    }\n    function build(objects2, data3mf2) {\n      const group = new Group();\n      const relationship = fetch3DModelPart(data3mf2[\"rels\"]);\n      const buildData = data3mf2.model[relationship[\"target\"].substring(1)][\"build\"];\n      for (let i = 0; i < buildData.length; i++) {\n        const buildItem = buildData[i];\n        const object3D = objects2[buildItem[\"objectId\"]];\n        const transform = buildItem[\"transform\"];\n        if (transform) {\n          object3D.applyMatrix4(transform);\n        }\n        group.add(object3D);\n      }\n      return group;\n    }\n    const data3mf = loadDocument(data);\n    const objects = buildObjects(data3mf);\n    return build(objects, data3mf);\n  }\n  addExtension(extension) {\n    this.availableExtensions.push(extension);\n  }\n}\nexport { ThreeMFLoader };","map":{"version":3,"sources":["../../src/loaders/3MFLoader.js"],"names":["data","relsView","relsFileText","i","objects","build","data3mf"],"mappings":"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","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  RepeatWrapping,\n  TextureLoader,\n} from 'three'\nimport { unzipSync } from 'fflate'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n *\n * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/\n *\n * The following features from the core specification are supported:\n *\n * - 3D Models\n * - Object Resources (Meshes and Components)\n * - Material Resources (Base Materials)\n *\n * 3MF Materials and Properties Extension are only partially supported.\n *\n * - Texture 2D\n * - Texture 2D Groups\n * - Color Groups (Vertex Colors)\n * - Metallic Display Properties (PBR)\n */\n\nclass ThreeMFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n    this.availableExtensions = []\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    const scope = this\n    const textureLoader = new TextureLoader(this.manager)\n\n    function loadDocument(data) {\n      let zip = null\n      let file = null\n\n      let relsName\n      let modelRelsName\n      const modelPartNames = []\n      const printTicketPartNames = []\n      const texturesPartNames = []\n      const otherPartNames = []\n\n      let modelRels\n      const modelParts = {}\n      const printTicketParts = {}\n      const texturesParts = {}\n      const otherParts = {}\n\n      try {\n        zip = unzipSync(new Uint8Array(data))\n      } catch (e) {\n        if (e instanceof ReferenceError) {\n          console.error('THREE.3MFLoader: fflate missing and file is compressed.')\n          return null\n        }\n      }\n\n      for (file in zip) {\n        if (file.match(/\\_rels\\/.rels$/)) {\n          relsName = file\n        } else if (file.match(/3D\\/_rels\\/.*\\.model\\.rels$/)) {\n          modelRelsName = file\n        } else if (file.match(/^3D\\/.*\\.model$/)) {\n          modelPartNames.push(file)\n        } else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) {\n          printTicketPartNames.push(file)\n        } else if (file.match(/^3D\\/Textures?\\/.*/)) {\n          texturesPartNames.push(file)\n        } else if (file.match(/^3D\\/Other\\/.*/)) {\n          otherPartNames.push(file)\n        }\n      }\n\n      //\n\n      const relsView = zip[relsName]\n      const relsFileText = decodeText(relsView)\n      const rels = parseRelsXml(relsFileText)\n\n      //\n\n      if (modelRelsName) {\n        const relsView = zip[modelRelsName]\n        const relsFileText = decodeText(relsView)\n        modelRels = parseRelsXml(relsFileText)\n      }\n\n      //\n\n      for (let i = 0; i < modelPartNames.length; i++) {\n        const modelPart = modelPartNames[i]\n        const view = zip[modelPart]\n\n        const fileText = decodeText(view)\n        const xmlData = new DOMParser().parseFromString(fileText, 'application/xml')\n\n        if (xmlData.documentElement.nodeName.toLowerCase() !== 'model') {\n          console.error('THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart)\n        }\n\n        const modelNode = xmlData.querySelector('model')\n        const extensions = {}\n\n        for (let i = 0; i < modelNode.attributes.length; i++) {\n          const attr = modelNode.attributes[i]\n          if (attr.name.match(/^xmlns:(.+)$/)) {\n            extensions[attr.value] = RegExp.$1\n          }\n        }\n\n        const modelData = parseModelNode(modelNode)\n        modelData['xml'] = modelNode\n\n        if (0 < Object.keys(extensions).length) {\n          modelData['extensions'] = extensions\n        }\n\n        modelParts[modelPart] = modelData\n      }\n\n      //\n\n      for (let i = 0; i < texturesPartNames.length; i++) {\n        const texturesPartName = texturesPartNames[i]\n        texturesParts[texturesPartName] = zip[texturesPartName].buffer\n      }\n\n      return {\n        rels: rels,\n        modelRels: modelRels,\n        model: modelParts,\n        printTicket: printTicketParts,\n        texture: texturesParts,\n        other: otherParts,\n      }\n    }\n\n    function parseRelsXml(relsFileText) {\n      const relationships = []\n\n      const relsXmlData = new DOMParser().parseFromString(relsFileText, 'application/xml')\n\n      const relsNodes = relsXmlData.querySelectorAll('Relationship')\n\n      for (let i = 0; i < relsNodes.length; i++) {\n        const relsNode = relsNodes[i]\n\n        const relationship = {\n          target: relsNode.getAttribute('Target'), //required\n          id: relsNode.getAttribute('Id'), //required\n          type: relsNode.getAttribute('Type'), //required\n        }\n\n        relationships.push(relationship)\n      }\n\n      return relationships\n    }\n\n    function parseMetadataNodes(metadataNodes) {\n      const metadataData = {}\n\n      for (let i = 0; i < metadataNodes.length; i++) {\n        const metadataNode = metadataNodes[i]\n        const name = metadataNode.getAttribute('name')\n        const validNames = [\n          'Title',\n          'Designer',\n          'Description',\n          'Copyright',\n          'LicenseTerms',\n          'Rating',\n          'CreationDate',\n          'ModificationDate',\n        ]\n\n        if (0 <= validNames.indexOf(name)) {\n          metadataData[name] = metadataNode.textContent\n        }\n      }\n\n      return metadataData\n    }\n\n    function parseBasematerialsNode(basematerialsNode) {\n      const basematerialsData = {\n        id: basematerialsNode.getAttribute('id'), // required\n        basematerials: [],\n      }\n\n      const basematerialNodes = basematerialsNode.querySelectorAll('base')\n\n      for (let i = 0; i < basematerialNodes.length; i++) {\n        const basematerialNode = basematerialNodes[i]\n        const basematerialData = parseBasematerialNode(basematerialNode)\n        basematerialData.index = i // the order and count of the material nodes form an implicit 0-based index\n        basematerialsData.basematerials.push(basematerialData)\n      }\n\n      return basematerialsData\n    }\n\n    function parseTexture2DNode(texture2DNode) {\n      const texture2dData = {\n        id: texture2DNode.getAttribute('id'), // required\n        path: texture2DNode.getAttribute('path'), // required\n        contenttype: texture2DNode.getAttribute('contenttype'), // required\n        tilestyleu: texture2DNode.getAttribute('tilestyleu'),\n        tilestylev: texture2DNode.getAttribute('tilestylev'),\n        filter: texture2DNode.getAttribute('filter'),\n      }\n\n      return texture2dData\n    }\n\n    function parseTextures2DGroupNode(texture2DGroupNode) {\n      const texture2DGroupData = {\n        id: texture2DGroupNode.getAttribute('id'), // required\n        texid: texture2DGroupNode.getAttribute('texid'), // required\n        displaypropertiesid: texture2DGroupNode.getAttribute('displaypropertiesid'),\n      }\n\n      const tex2coordNodes = texture2DGroupNode.querySelectorAll('tex2coord')\n\n      const uvs = []\n\n      for (let i = 0; i < tex2coordNodes.length; i++) {\n        const tex2coordNode = tex2coordNodes[i]\n        const u = tex2coordNode.getAttribute('u')\n        const v = tex2coordNode.getAttribute('v')\n\n        uvs.push(parseFloat(u), parseFloat(v))\n      }\n\n      texture2DGroupData['uvs'] = new Float32Array(uvs)\n\n      return texture2DGroupData\n    }\n\n    function parseColorGroupNode(colorGroupNode) {\n      const colorGroupData = {\n        id: colorGroupNode.getAttribute('id'), // required\n        displaypropertiesid: colorGroupNode.getAttribute('displaypropertiesid'),\n      }\n\n      const colorNodes = colorGroupNode.querySelectorAll('color')\n\n      const colors = []\n      const colorObject = new Color()\n\n      for (let i = 0; i < colorNodes.length; i++) {\n        const colorNode = colorNodes[i]\n        const color = colorNode.getAttribute('color')\n\n        colorObject.setStyle(color.substring(0, 7))\n        colorObject.convertSRGBToLinear() // color is in sRGB\n\n        colors.push(colorObject.r, colorObject.g, colorObject.b)\n      }\n\n      colorGroupData['colors'] = new Float32Array(colors)\n\n      return colorGroupData\n    }\n\n    function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {\n      const metallicDisplaypropertiesData = {\n        id: metallicDisplaypropetiesNode.getAttribute('id'), // required\n      }\n\n      const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll('pbmetallic')\n\n      const metallicData = []\n\n      for (let i = 0; i < metallicNodes.length; i++) {\n        const metallicNode = metallicNodes[i]\n\n        metallicData.push({\n          name: metallicNode.getAttribute('name'), // required\n          metallicness: parseFloat(metallicNode.getAttribute('metallicness')), // required\n          roughness: parseFloat(metallicNode.getAttribute('roughness')), // required\n        })\n      }\n\n      metallicDisplaypropertiesData.data = metallicData\n\n      return metallicDisplaypropertiesData\n    }\n\n    function parseBasematerialNode(basematerialNode) {\n      const basematerialData = {}\n\n      basematerialData['name'] = basematerialNode.getAttribute('name') // required\n      basematerialData['displaycolor'] = basematerialNode.getAttribute('displaycolor') // required\n      basematerialData['displaypropertiesid'] = basematerialNode.getAttribute('displaypropertiesid')\n\n      return basematerialData\n    }\n\n    function parseMeshNode(meshNode) {\n      const meshData = {}\n\n      const vertices = []\n      const vertexNodes = meshNode.querySelectorAll('vertices vertex')\n\n      for (let i = 0; i < vertexNodes.length; i++) {\n        const vertexNode = vertexNodes[i]\n        const x = vertexNode.getAttribute('x')\n        const y = vertexNode.getAttribute('y')\n        const z = vertexNode.getAttribute('z')\n\n        vertices.push(parseFloat(x), parseFloat(y), parseFloat(z))\n      }\n\n      meshData['vertices'] = new Float32Array(vertices)\n\n      const triangleProperties = []\n      const triangles = []\n      const triangleNodes = meshNode.querySelectorAll('triangles triangle')\n\n      for (let i = 0; i < triangleNodes.length; i++) {\n        const triangleNode = triangleNodes[i]\n        const v1 = triangleNode.getAttribute('v1')\n        const v2 = triangleNode.getAttribute('v2')\n        const v3 = triangleNode.getAttribute('v3')\n        const p1 = triangleNode.getAttribute('p1')\n        const p2 = triangleNode.getAttribute('p2')\n        const p3 = triangleNode.getAttribute('p3')\n        const pid = triangleNode.getAttribute('pid')\n\n        const triangleProperty = {}\n\n        triangleProperty['v1'] = parseInt(v1, 10)\n        triangleProperty['v2'] = parseInt(v2, 10)\n        triangleProperty['v3'] = parseInt(v3, 10)\n\n        triangles.push(triangleProperty['v1'], triangleProperty['v2'], triangleProperty['v3'])\n\n        // optional\n\n        if (p1) {\n          triangleProperty['p1'] = parseInt(p1, 10)\n        }\n\n        if (p2) {\n          triangleProperty['p2'] = parseInt(p2, 10)\n        }\n\n        if (p3) {\n          triangleProperty['p3'] = parseInt(p3, 10)\n        }\n\n        if (pid) {\n          triangleProperty['pid'] = pid\n        }\n\n        if (0 < Object.keys(triangleProperty).length) {\n          triangleProperties.push(triangleProperty)\n        }\n      }\n\n      meshData['triangleProperties'] = triangleProperties\n      meshData['triangles'] = new Uint32Array(triangles)\n\n      return meshData\n    }\n\n    function parseComponentsNode(componentsNode) {\n      const components = []\n\n      const componentNodes = componentsNode.querySelectorAll('component')\n\n      for (let i = 0; i < componentNodes.length; i++) {\n        const componentNode = componentNodes[i]\n        const componentData = parseComponentNode(componentNode)\n        components.push(componentData)\n      }\n\n      return components\n    }\n\n    function parseComponentNode(componentNode) {\n      const componentData = {}\n\n      componentData['objectId'] = componentNode.getAttribute('objectid') // required\n\n      const transform = componentNode.getAttribute('transform')\n\n      if (transform) {\n        componentData['transform'] = parseTransform(transform)\n      }\n\n      return componentData\n    }\n\n    function parseTransform(transform) {\n      const t = []\n      transform.split(' ').forEach(function (s) {\n        t.push(parseFloat(s))\n      })\n\n      const matrix = new Matrix4()\n      matrix.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0.0, 0.0, 0.0, 1.0)\n\n      return matrix\n    }\n\n    function parseObjectNode(objectNode) {\n      const objectData = {\n        type: objectNode.getAttribute('type'),\n      }\n\n      const id = objectNode.getAttribute('id')\n\n      if (id) {\n        objectData['id'] = id\n      }\n\n      const pid = objectNode.getAttribute('pid')\n\n      if (pid) {\n        objectData['pid'] = pid\n      }\n\n      const pindex = objectNode.getAttribute('pindex')\n\n      if (pindex) {\n        objectData['pindex'] = pindex\n      }\n\n      const thumbnail = objectNode.getAttribute('thumbnail')\n\n      if (thumbnail) {\n        objectData['thumbnail'] = thumbnail\n      }\n\n      const partnumber = objectNode.getAttribute('partnumber')\n\n      if (partnumber) {\n        objectData['partnumber'] = partnumber\n      }\n\n      const name = objectNode.getAttribute('name')\n\n      if (name) {\n        objectData['name'] = name\n      }\n\n      const meshNode = objectNode.querySelector('mesh')\n\n      if (meshNode) {\n        objectData['mesh'] = parseMeshNode(meshNode)\n      }\n\n      const componentsNode = objectNode.querySelector('components')\n\n      if (componentsNode) {\n        objectData['components'] = parseComponentsNode(componentsNode)\n      }\n\n      return objectData\n    }\n\n    function parseResourcesNode(resourcesNode) {\n      const resourcesData = {}\n\n      resourcesData['basematerials'] = {}\n      const basematerialsNodes = resourcesNode.querySelectorAll('basematerials')\n\n      for (let i = 0; i < basematerialsNodes.length; i++) {\n        const basematerialsNode = basematerialsNodes[i]\n        const basematerialsData = parseBasematerialsNode(basematerialsNode)\n        resourcesData['basematerials'][basematerialsData['id']] = basematerialsData\n      }\n\n      //\n\n      resourcesData['texture2d'] = {}\n      const textures2DNodes = resourcesNode.querySelectorAll('texture2d')\n\n      for (let i = 0; i < textures2DNodes.length; i++) {\n        const textures2DNode = textures2DNodes[i]\n        const texture2DData = parseTexture2DNode(textures2DNode)\n        resourcesData['texture2d'][texture2DData['id']] = texture2DData\n      }\n\n      //\n\n      resourcesData['colorgroup'] = {}\n      const colorGroupNodes = resourcesNode.querySelectorAll('colorgroup')\n\n      for (let i = 0; i < colorGroupNodes.length; i++) {\n        const colorGroupNode = colorGroupNodes[i]\n        const colorGroupData = parseColorGroupNode(colorGroupNode)\n        resourcesData['colorgroup'][colorGroupData['id']] = colorGroupData\n      }\n\n      //\n\n      resourcesData['pbmetallicdisplayproperties'] = {}\n      const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll('pbmetallicdisplayproperties')\n\n      for (let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i++) {\n        const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i]\n        const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode)\n        resourcesData['pbmetallicdisplayproperties'][\n          pbmetallicdisplaypropertiesData['id']\n        ] = pbmetallicdisplaypropertiesData\n      }\n\n      //\n\n      resourcesData['texture2dgroup'] = {}\n      const textures2DGroupNodes = resourcesNode.querySelectorAll('texture2dgroup')\n\n      for (let i = 0; i < textures2DGroupNodes.length; i++) {\n        const textures2DGroupNode = textures2DGroupNodes[i]\n        const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode)\n        resourcesData['texture2dgroup'][textures2DGroupData['id']] = textures2DGroupData\n      }\n\n      //\n\n      resourcesData['object'] = {}\n      const objectNodes = resourcesNode.querySelectorAll('object')\n\n      for (let i = 0; i < objectNodes.length; i++) {\n        const objectNode = objectNodes[i]\n        const objectData = parseObjectNode(objectNode)\n        resourcesData['object'][objectData['id']] = objectData\n      }\n\n      return resourcesData\n    }\n\n    function parseBuildNode(buildNode) {\n      const buildData = []\n      const itemNodes = buildNode.querySelectorAll('item')\n\n      for (let i = 0; i < itemNodes.length; i++) {\n        const itemNode = itemNodes[i]\n        const buildItem = {\n          objectId: itemNode.getAttribute('objectid'),\n        }\n        const transform = itemNode.getAttribute('transform')\n\n        if (transform) {\n          buildItem['transform'] = parseTransform(transform)\n        }\n\n        buildData.push(buildItem)\n      }\n\n      return buildData\n    }\n\n    function parseModelNode(modelNode) {\n      const modelData = { unit: modelNode.getAttribute('unit') || 'millimeter' }\n      const metadataNodes = modelNode.querySelectorAll('metadata')\n\n      if (metadataNodes) {\n        modelData['metadata'] = parseMetadataNodes(metadataNodes)\n      }\n\n      const resourcesNode = modelNode.querySelector('resources')\n\n      if (resourcesNode) {\n        modelData['resources'] = parseResourcesNode(resourcesNode)\n      }\n\n      const buildNode = modelNode.querySelector('build')\n\n      if (buildNode) {\n        modelData['build'] = parseBuildNode(buildNode)\n      }\n\n      return modelData\n    }\n\n    function buildTexture(texture2dgroup, objects, modelData, textureData) {\n      const texid = texture2dgroup.texid\n      const texture2ds = modelData.resources.texture2d\n      const texture2d = texture2ds[texid]\n\n      if (texture2d) {\n        const data = textureData[texture2d.path]\n        const type = texture2d.contenttype\n\n        const blob = new Blob([data], { type: type })\n        const sourceURI = URL.createObjectURL(blob)\n\n        const texture = textureLoader.load(sourceURI, function () {\n          URL.revokeObjectURL(sourceURI)\n        })\n\n        if ('colorSpace' in texture) texture.colorSpace = 'srgb'\n        else texture.encoding = 3001 // sRGBEncoding\n\n        // texture parameters\n\n        switch (texture2d.tilestyleu) {\n          case 'wrap':\n            texture.wrapS = RepeatWrapping\n            break\n\n          case 'mirror':\n            texture.wrapS = MirroredRepeatWrapping\n            break\n\n          case 'none':\n          case 'clamp':\n            texture.wrapS = ClampToEdgeWrapping\n            break\n\n          default:\n            texture.wrapS = RepeatWrapping\n        }\n\n        switch (texture2d.tilestylev) {\n          case 'wrap':\n            texture.wrapT = RepeatWrapping\n            break\n\n          case 'mirror':\n            texture.wrapT = MirroredRepeatWrapping\n            break\n\n          case 'none':\n          case 'clamp':\n            texture.wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            texture.wrapT = RepeatWrapping\n        }\n\n        switch (texture2d.filter) {\n          case 'auto':\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearMipmapLinearFilter\n            break\n\n          case 'linear':\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearFilter\n            break\n\n          case 'nearest':\n            texture.magFilter = NearestFilter\n            texture.minFilter = NearestFilter\n            break\n\n          default:\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearMipmapLinearFilter\n        }\n\n        return texture\n      } else {\n        return null\n      }\n    }\n\n    function buildBasematerialsMeshes(\n      basematerials,\n      triangleProperties,\n      meshData,\n      objects,\n      modelData,\n      textureData,\n      objectData,\n    ) {\n      const objectPindex = objectData.pindex\n\n      const materialMap = {}\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n        const pindex = triangleProperty.p1 !== undefined ? triangleProperty.p1 : objectPindex\n\n        if (materialMap[pindex] === undefined) materialMap[pindex] = []\n\n        materialMap[pindex].push(triangleProperty)\n      }\n\n      //\n\n      const keys = Object.keys(materialMap)\n      const meshes = []\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const materialIndex = keys[i]\n        const trianglePropertiesProps = materialMap[materialIndex]\n        const basematerialData = basematerials.basematerials[materialIndex]\n        const material = getBuild(basematerialData, objects, modelData, textureData, objectData, buildBasematerial)\n\n        //\n\n        const geometry = new BufferGeometry()\n\n        const positionData = []\n\n        const vertices = meshData.vertices\n\n        for (let j = 0, jl = trianglePropertiesProps.length; j < jl; j++) {\n          const triangleProperty = trianglePropertiesProps[j]\n\n          positionData.push(vertices[triangleProperty.v1 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v1 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v1 * 3 + 2])\n\n          positionData.push(vertices[triangleProperty.v2 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v2 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v2 * 3 + 2])\n\n          positionData.push(vertices[triangleProperty.v3 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v3 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v3 * 3 + 2])\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n\n        //\n\n        const mesh = new Mesh(geometry, material)\n        meshes.push(mesh)\n      }\n\n      return meshes\n    }\n\n    function buildTexturedMesh(\n      texture2dgroup,\n      triangleProperties,\n      meshData,\n      objects,\n      modelData,\n      textureData,\n      objectData,\n    ) {\n      // geometry\n\n      const geometry = new BufferGeometry()\n\n      const positionData = []\n      const uvData = []\n\n      const vertices = meshData.vertices\n      const uvs = texture2dgroup.uvs\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n\n        positionData.push(vertices[triangleProperty.v1 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v1 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v1 * 3 + 2])\n\n        positionData.push(vertices[triangleProperty.v2 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v2 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v2 * 3 + 2])\n\n        positionData.push(vertices[triangleProperty.v3 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v3 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v3 * 3 + 2])\n\n        //\n\n        uvData.push(uvs[triangleProperty.p1 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p1 * 2 + 1])\n\n        uvData.push(uvs[triangleProperty.p2 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p2 * 2 + 1])\n\n        uvData.push(uvs[triangleProperty.p3 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p3 * 2 + 1])\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvData, 2))\n\n      // material\n\n      const texture = getBuild(texture2dgroup, objects, modelData, textureData, objectData, buildTexture)\n\n      const material = new MeshPhongMaterial({ map: texture, flatShading: true })\n\n      // mesh\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects, modelData, objectData) {\n      // geometry\n\n      const geometry = new BufferGeometry()\n\n      const positionData = []\n      const colorData = []\n\n      const vertices = meshData.vertices\n      const colors = colorgroup.colors\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n\n        const v1 = triangleProperty.v1\n        const v2 = triangleProperty.v2\n        const v3 = triangleProperty.v3\n\n        positionData.push(vertices[v1 * 3 + 0])\n        positionData.push(vertices[v1 * 3 + 1])\n        positionData.push(vertices[v1 * 3 + 2])\n\n        positionData.push(vertices[v2 * 3 + 0])\n        positionData.push(vertices[v2 * 3 + 1])\n        positionData.push(vertices[v2 * 3 + 2])\n\n        positionData.push(vertices[v3 * 3 + 0])\n        positionData.push(vertices[v3 * 3 + 1])\n        positionData.push(vertices[v3 * 3 + 2])\n\n        //\n\n        const p1 = triangleProperty.p1 !== undefined ? triangleProperty.p1 : objectData.pindex\n        const p2 = triangleProperty.p2 !== undefined ? triangleProperty.p2 : p1\n        const p3 = triangleProperty.p3 !== undefined ? triangleProperty.p3 : p1\n\n        colorData.push(colors[p1 * 3 + 0])\n        colorData.push(colors[p1 * 3 + 1])\n        colorData.push(colors[p1 * 3 + 2])\n\n        colorData.push(colors[p2 * 3 + 0])\n        colorData.push(colors[p2 * 3 + 1])\n        colorData.push(colors[p2 * 3 + 2])\n\n        colorData.push(colors[p3 * 3 + 0])\n        colorData.push(colors[p3 * 3 + 1])\n        colorData.push(colors[p3 * 3 + 2])\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n      geometry.setAttribute('color', new Float32BufferAttribute(colorData, 3))\n\n      // material\n\n      const material = new MeshPhongMaterial({ vertexColors: true, flatShading: true })\n\n      // mesh\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildDefaultMesh(meshData) {\n      const geometry = new BufferGeometry()\n      geometry.setIndex(new BufferAttribute(meshData['triangles'], 1))\n      geometry.setAttribute('position', new BufferAttribute(meshData['vertices'], 3))\n\n      const material = new MeshPhongMaterial({ color: 0xaaaaff, flatShading: true })\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildMeshes(resourceMap, meshData, objects, modelData, textureData, objectData) {\n      const keys = Object.keys(resourceMap)\n      const meshes = []\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const resourceId = keys[i]\n        const triangleProperties = resourceMap[resourceId]\n        const resourceType = getResourceType(resourceId, modelData)\n\n        switch (resourceType) {\n          case 'material':\n            const basematerials = modelData.resources.basematerials[resourceId]\n            const newMeshes = buildBasematerialsMeshes(\n              basematerials,\n              triangleProperties,\n              meshData,\n              objects,\n              modelData,\n              textureData,\n              objectData,\n            )\n\n            for (let j = 0, jl = newMeshes.length; j < jl; j++) {\n              meshes.push(newMeshes[j])\n            }\n\n            break\n\n          case 'texture':\n            const texture2dgroup = modelData.resources.texture2dgroup[resourceId]\n            meshes.push(\n              buildTexturedMesh(\n                texture2dgroup,\n                triangleProperties,\n                meshData,\n                objects,\n                modelData,\n                textureData,\n                objectData,\n              ),\n            )\n            break\n\n          case 'vertexColors':\n            const colorgroup = modelData.resources.colorgroup[resourceId]\n            meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects, modelData, objectData))\n            break\n\n          case 'default':\n            meshes.push(buildDefaultMesh(meshData))\n            break\n\n          default:\n            console.error('THREE.3MFLoader: Unsupported resource type.')\n        }\n      }\n\n      return meshes\n    }\n\n    function getResourceType(pid, modelData) {\n      if (modelData.resources.texture2dgroup[pid] !== undefined) {\n        return 'texture'\n      } else if (modelData.resources.basematerials[pid] !== undefined) {\n        return 'material'\n      } else if (modelData.resources.colorgroup[pid] !== undefined) {\n        return 'vertexColors'\n      } else if (pid === 'default') {\n        return 'default'\n      } else {\n        return undefined\n      }\n    }\n\n    function analyzeObject(modelData, meshData, objectData) {\n      const resourceMap = {}\n\n      const triangleProperties = meshData['triangleProperties']\n\n      const objectPid = objectData.pid\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n        let pid = triangleProperty.pid !== undefined ? triangleProperty.pid : objectPid\n\n        if (pid === undefined) pid = 'default'\n\n        if (resourceMap[pid] === undefined) resourceMap[pid] = []\n\n        resourceMap[pid].push(triangleProperty)\n      }\n\n      return resourceMap\n    }\n\n    function buildGroup(meshData, objects, modelData, textureData, objectData) {\n      const group = new Group()\n\n      const resourceMap = analyzeObject(modelData, meshData, objectData)\n      const meshes = buildMeshes(resourceMap, meshData, objects, modelData, textureData, objectData)\n\n      for (let i = 0, l = meshes.length; i < l; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    }\n\n    function applyExtensions(extensions, meshData, modelXml) {\n      if (!extensions) {\n        return\n      }\n\n      const availableExtensions = []\n      const keys = Object.keys(extensions)\n\n      for (let i = 0; i < keys.length; i++) {\n        const ns = keys[i]\n\n        for (let j = 0; j < scope.availableExtensions.length; j++) {\n          const extension = scope.availableExtensions[j]\n\n          if (extension.ns === ns) {\n            availableExtensions.push(extension)\n          }\n        }\n      }\n\n      for (let i = 0; i < availableExtensions.length; i++) {\n        const extension = availableExtensions[i]\n        extension.apply(modelXml, extensions[extension['ns']], meshData)\n      }\n    }\n\n    function getBuild(data, objects, modelData, textureData, objectData, builder) {\n      if (data.build !== undefined) return data.build\n\n      data.build = builder(data, objects, modelData, textureData, objectData)\n\n      return data.build\n    }\n\n    function buildBasematerial(materialData, objects, modelData) {\n      let material\n\n      const displaypropertiesid = materialData.displaypropertiesid\n      const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties\n\n      if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== undefined) {\n        // metallic display property, use StandardMaterial\n\n        const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid]\n        const metallicData = pbmetallicdisplayproperty.data[materialData.index]\n\n        material = new MeshStandardMaterial({\n          flatShading: true,\n          roughness: metallicData.roughness,\n          metalness: metallicData.metallicness,\n        })\n      } else {\n        // otherwise use PhongMaterial\n\n        material = new MeshPhongMaterial({ flatShading: true })\n      }\n\n      material.name = materialData.name\n\n      // displaycolor MUST be specified with a value of a 6 or 8 digit hexadecimal number, e.g. \"#RRGGBB\" or \"#RRGGBBAA\"\n\n      const displaycolor = materialData.displaycolor\n\n      const color = displaycolor.substring(0, 7)\n      material.color.setStyle(color)\n      material.color.convertSRGBToLinear() // displaycolor is in sRGB\n\n      // process alpha if set\n\n      if (displaycolor.length === 9) {\n        material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255\n      }\n\n      return material\n    }\n\n    function buildComposite(compositeData, objects, modelData, textureData) {\n      const composite = new Group()\n\n      for (let j = 0; j < compositeData.length; j++) {\n        const component = compositeData[j]\n        let build = objects[component.objectId]\n\n        if (build === undefined) {\n          buildObject(component.objectId, objects, modelData, textureData)\n          build = objects[component.objectId]\n        }\n\n        const object3D = build.clone()\n\n        // apply component transform\n\n        const transform = component.transform\n\n        if (transform) {\n          object3D.applyMatrix4(transform)\n        }\n\n        composite.add(object3D)\n      }\n\n      return composite\n    }\n\n    function buildObject(objectId, objects, modelData, textureData) {\n      const objectData = modelData['resources']['object'][objectId]\n\n      if (objectData['mesh']) {\n        const meshData = objectData['mesh']\n\n        const extensions = modelData['extensions']\n        const modelXml = modelData['xml']\n\n        applyExtensions(extensions, meshData, modelXml)\n\n        objects[objectData.id] = getBuild(meshData, objects, modelData, textureData, objectData, buildGroup)\n      } else {\n        const compositeData = objectData['components']\n\n        objects[objectData.id] = getBuild(compositeData, objects, modelData, textureData, objectData, buildComposite)\n      }\n    }\n\n    function buildObjects(data3mf) {\n      const modelsData = data3mf.model\n      const modelRels = data3mf.modelRels\n      const objects = {}\n      const modelsKeys = Object.keys(modelsData)\n      const textureData = {}\n\n      // evaluate model relationships to textures\n\n      if (modelRels) {\n        for (let i = 0, l = modelRels.length; i < l; i++) {\n          const modelRel = modelRels[i]\n          const textureKey = modelRel.target.substring(1)\n\n          if (data3mf.texture[textureKey]) {\n            textureData[modelRel.target] = data3mf.texture[textureKey]\n          }\n        }\n      }\n\n      // start build\n\n      for (let i = 0; i < modelsKeys.length; i++) {\n        const modelsKey = modelsKeys[i]\n        const modelData = modelsData[modelsKey]\n\n        const objectIds = Object.keys(modelData['resources']['object'])\n\n        for (let j = 0; j < objectIds.length; j++) {\n          const objectId = objectIds[j]\n\n          buildObject(objectId, objects, modelData, textureData)\n        }\n      }\n\n      return objects\n    }\n\n    function fetch3DModelPart(rels) {\n      for (let i = 0; i < rels.length; i++) {\n        const rel = rels[i]\n        const extension = rel.target.split('.').pop()\n\n        if (extension.toLowerCase() === 'model') return rel\n      }\n    }\n\n    function build(objects, data3mf) {\n      const group = new Group()\n\n      const relationship = fetch3DModelPart(data3mf['rels'])\n      const buildData = data3mf.model[relationship['target'].substring(1)]['build']\n\n      for (let i = 0; i < buildData.length; i++) {\n        const buildItem = buildData[i]\n        const object3D = objects[buildItem['objectId']]\n\n        // apply transform\n\n        const transform = buildItem['transform']\n\n        if (transform) {\n          object3D.applyMatrix4(transform)\n        }\n\n        group.add(object3D)\n      }\n\n      return group\n    }\n\n    const data3mf = loadDocument(data)\n    const objects = buildObjects(data3mf)\n\n    return build(objects, data3mf)\n  }\n\n  addExtension(extension) {\n    this.availableExtensions.push(extension)\n  }\n}\n\nexport { ThreeMFLoader }\n"]},"metadata":{},"sourceType":"module"}