{"ast":null,"code":"import { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping } from \"three\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    str = str.replace(/^#.*?(\\n|\\r)/gm, \"\").replace(/^\\s*?(\\n|\\r)/gm, \"\").trim();\n    const lines = str.split(/[\\n\\r]+/g);\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error(\"LUT3dlLoader: Inconsistent grid size not supported.\");\n      }\n    }\n    const dataArray = new Array(size * size * size * 4);\n    let index = 0;\n    let maxOutputValue = 0;\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size;\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[4 * pixelIndex + 0] = r;\n      dataArray[4 * pixelIndex + 1] = g;\n      dataArray[4 * pixelIndex + 2] = b;\n      dataArray[4 * pixelIndex + 3] = 1;\n      index += 1;\n    }\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2, bits);\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0];\n      const g = dataArray[i + 1];\n      const b = dataArray[i + 2];\n      dataArray[i + 0] = 255 * r / maxBitValue;\n      dataArray[i + 1] = 255 * g / maxBitValue;\n      dataArray[i + 2] = 255 * b / maxBitValue;\n    }\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBAFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBAFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUT3dlLoader };","map":{"version":3,"sources":["../../src/loaders/LUT3dlLoader.js"],"names":[],"mappings":"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","sourcesContent":["// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\n// https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258\nimport { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, ClampToEdgeWrapping, LinearFilter } from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nexport class LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('text')\n    loader.load(\n      url,\n      (text) => {\n        try {\n          onLoad(this.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          this.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str\n      .replace(/^#.*?(\\n|\\r)/gm, '')\n      .replace(/^\\s*?(\\n|\\r)/gm, '')\n      .trim()\n\n    const lines = str.split(/[\\n\\r]+/g)\n\n    // first line is the positions on the grid that are provided by the LUT\n    const gridLines = lines[0]\n      .trim()\n      .split(/\\s+/g)\n      .map((e) => parseFloat(e))\n    const gridStep = gridLines[1] - gridLines[0]\n    const size = gridLines.length\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.')\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 4)\n    let index = 0\n    let maxOutputValue = 0.0\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim()\n      const split = line.split(/\\s/g)\n\n      const r = parseFloat(split[0])\n      const g = parseFloat(split[1])\n      const b = parseFloat(split[2])\n      maxOutputValue = Math.max(maxOutputValue, r, g, b)\n\n      const bLayer = index % size\n      const gLayer = Math.floor(index / size) % size\n      const rLayer = Math.floor(index / (size * size)) % size\n\n      // b grows first, then g, then r\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer\n      dataArray[4 * pixelIndex + 0] = r\n      dataArray[4 * pixelIndex + 1] = g\n      dataArray[4 * pixelIndex + 2] = b\n      dataArray[4 * pixelIndex + 3] = 1.0\n      index += 1\n    }\n\n    // Find the apparent bit depth of the stored RGB values and map the\n    // values to [ 0, 255 ].\n    const bits = Math.ceil(Math.log2(maxOutputValue))\n    const maxBitValue = Math.pow(2.0, bits)\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0]\n      const g = dataArray[i + 1]\n      const b = dataArray[i + 2]\n      dataArray[i + 0] = (255 * r) / maxBitValue // r\n      dataArray[i + 1] = (255 * g) / maxBitValue // g\n      dataArray[i + 2] = (255 * b) / maxBitValue // b\n    }\n\n    const data = new Uint8Array(dataArray)\n    const texture = new DataTexture()\n    texture.image.data = data\n    texture.image.width = size\n    texture.image.height = size * size\n    texture.format = RGBAFormat\n    texture.type = UnsignedByteType\n    texture.magFilter = LinearFilter\n    texture.minFilter = LinearFilter\n    texture.wrapS = ClampToEdgeWrapping\n    texture.wrapT = ClampToEdgeWrapping\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const texture3D = new Data3DTexture()\n    texture3D.image.data = data\n    texture3D.image.width = size\n    texture3D.image.height = size\n    texture3D.image.depth = size\n    texture3D.format = RGBAFormat\n    texture3D.type = UnsignedByteType\n    texture3D.magFilter = LinearFilter\n    texture3D.minFilter = LinearFilter\n    texture3D.wrapS = ClampToEdgeWrapping\n    texture3D.wrapT = ClampToEdgeWrapping\n    texture3D.wrapR = ClampToEdgeWrapping\n    texture3D.generateMipmaps = false\n    texture3D.needsUpdate = true\n\n    return {\n      size,\n      texture,\n      texture3D,\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}