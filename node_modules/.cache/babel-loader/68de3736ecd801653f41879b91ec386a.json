{"ast":null,"code":"import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(1953125e-9, 0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 imageCoord = vUv;\", \"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"\t\timageCoord += uImageIncrement;\", \"\t}\", \"\tgl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n  buildKernel: function (sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"sources":["../../src/shaders/ConvolutionShader.ts"],"names":["sigma"],"mappings":";AA0BO,MAAM,iBAAA,GAAwC;EACnD,OAAA,EAAS;IACP,iBAAA,EAAmB,MAAA;IACnB,eAAA,EAAiB;EACnB,CAAA;EAEA,QAAA,EAAU;IACR,QAAA,EAAU;MAAE,KAAA,EAAO;IAAK,CAAA;IACxB,eAAA,EAAiB;MAAE,KAAA,EAAO,IAAI,OAAA,CAAQ,UAAA,EAAa,CAAG;IAAE,CAAA;IACxD,OAAA,EAAS;MAAE,KAAA,EAAO;IAAG;EACvB,CAAA;EAEA,YAAA,EAAc,CACZ,+BAAA,EAEA,mBAAA,EAEA,eAAA,EAEA,sEAAA,EACA,4EAAA,EAEA,GAAA,CAAA,CACA,IAAA,CAAK,IAAI,CAAA;EAEX,cAAA,EAAgB,CACd,2CAAA,EAEA,6BAAA,EACA,+BAAA,EAEA,mBAAA,EAEA,eAAA,EAEA,yBAAA,EACA,yCAAA,EAEA,gDAAA,EAEA,4DAAA,EACA,kCAAA,EAEA,IAAA,EAEA,sBAAA,EAEA,GAAA,CAAA,CACA,IAAA,CAAK,IAAI,CAAA;EAEX,WAAA,EAAa,SAAA,CAAU,KAAA,EAAO;IAGnB,SAAA,KAAA,CAAM,CAAA,EAAWA,MAAAA,EAAuB;MAC/C,OAAO,IAAA,CAAK,GAAA,CAAI,EAAE,CAAA,GAAI,CAAA,CAAA,IAAM,CAAA,GAAMA,MAAAA,GAAQA,MAAAA,CAAM,CAAA;IAClD;IAEA,MAAM,cAAA,GAAiB,EAAA;IAEjB,MAAA,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,KAAA,GAAQ,CAAG,CAAA,GAAI,CAAA,EAAG,cAAc,CAAA;IAEpE,MAAA,SAAA,GAAA,CAAa,UAAA,GAAa,CAAA,IAAK,GAAA;IAE/B,MAAA,MAAA,GAAmB,IAAI,KAAA,CAAM,UAAU,CAAA;IAE7C,IAAI,GAAA,GAAM,CAAA;IAEV,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,EAAY,EAAE,CAAA,EAAG;MACnC,MAAA,CAAO,CAAC,CAAA,GAAI,KAAA,CAAM,CAAA,GAAI,SAAA,EAAW,KAAK,CAAA;MACtC,GAAA,IAAO,MAAA,CAAO,CAAC,CAAA;IACjB;IAIA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,EAAY,EAAE,CAAA,EAAG,MAAA,CAAO,CAAC,CAAA,IAAK,GAAA;IAE3C,OAAA,MAAA;EACT;AACF,CAAA","sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ConvolutionShaderDefines = {\n  KERNEL_SIZE_FLOAT: string\n  KERNEL_SIZE_INT: string\n}\n\nexport type ConvolutionShaderUniforms = {\n  cKernel: IUniform<number[]>\n  tDiffuse: IUniform<Texture | null>\n  uImageIncrement: IUniform<Vector2>\n}\n\nexport interface IConvolutionShader extends IShader<ConvolutionShaderUniforms, ConvolutionShaderDefines> {\n  buildKernel: (sigma: number) => number[]\n}\n\nexport const ConvolutionShader: IConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: new Vector2(0.001953125, 0.0) },\n    cKernel: { value: [] },\n  },\n\n  vertexShader: [\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float cKernel[ KERNEL_SIZE_INT ];',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 imageCoord = vUv;',\n    '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );',\n\n    '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',\n\n    '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',\n    '\t\timageCoord += uImageIncrement;',\n\n    '\t}',\n\n    '\tgl_FragColor = sum;',\n\n    '}',\n  ].join('\\n'),\n\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n    function gauss(x: number, sigma: number): number {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma))\n    }\n\n    const kMaxKernelSize = 25\n\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize)\n\n    const halfWidth = (kernelSize - 1) * 0.5\n\n    const values: number[] = new Array(kernelSize)\n\n    let sum = 0.0\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma)\n      sum += values[i]\n    }\n\n    // normalize the kernel\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum\n\n    return values\n  },\n}\n"]},"metadata":{},"sourceType":"module"}