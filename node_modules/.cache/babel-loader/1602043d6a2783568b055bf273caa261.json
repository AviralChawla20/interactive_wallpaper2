{"ast":null,"code":"import { Vector4, Vector3 } from \"three\";\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1;\n  if (u >= U[n]) {\n    return n - 1;\n  }\n  if (u <= U[p]) {\n    return p;\n  }\n  let low = p;\n  let high = n;\n  let mid = Math.floor((low + high) / 2);\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n    mid = Math.floor((low + high) / 2);\n  }\n  return mid;\n}\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = [];\n  const left = [];\n  const right = [];\n  N[0] = 1;\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1];\n      const lv = left[j - r];\n      const temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    N[j] = saved;\n  }\n  return N;\n}\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U);\n  const N = calcBasisFunctions(span, u, p, U);\n  const C = new Vector4(0, 0, 0, 0);\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j];\n    const Nj = N[j];\n    const wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n  return C;\n}\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = [];\n  for (let i = 0; i <= p; ++i) zeroArr[i] = 0;\n  const ders = [];\n  for (let i = 0; i <= n; ++i) ders[i] = zeroArr.slice(0);\n  const ndu = [];\n  for (let i = 0; i <= p; ++i) ndu[i] = zeroArr.slice(0);\n  ndu[0][0] = 1;\n  const left = zeroArr.slice(0);\n  const right = zeroArr.slice(0);\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r2 = 0; r2 < j; ++r2) {\n      const rv = right[r2 + 1];\n      const lv = left[j - r2];\n      ndu[j][r2] = rv + lv;\n      const temp = ndu[r2][j - 1] / ndu[j][r2];\n      ndu[r2][j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    ndu[j][j] = saved;\n  }\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p];\n  }\n  for (let r2 = 0; r2 <= p; ++r2) {\n    let s1 = 0;\n    let s2 = 1;\n    const a = [];\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0);\n    }\n    a[0][0] = 1;\n    for (let k = 1; k <= n; ++k) {\n      let d = 0;\n      const rk = r2 - k;\n      const pk = p - k;\n      if (r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n      const j1 = rk >= -1 ? 1 : -rk;\n      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;\n      for (let j3 = j1; j3 <= j2; ++j3) {\n        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];\n        d += a[s2][j3] * ndu[rk + j3][pk];\n      }\n      if (r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];\n        d += a[s2][k] * ndu[r2][pk];\n      }\n      ders[k][r2] = d;\n      const j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n  let r = p;\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r;\n    }\n    r *= p - k;\n  }\n  return ders;\n}\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p;\n  const CK = [];\n  const span = findSpan(p, u, U);\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);\n  const Pw = [];\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone();\n    const w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n    CK[k] = point;\n  }\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0);\n  }\n  return CK;\n}\nfunction calcKoverI(k, i) {\n  let nom = 1;\n  for (let j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n  let denom = 1;\n  for (let j = 2; j <= i; ++j) {\n    denom *= j;\n  }\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j;\n  }\n  return nom / denom;\n}\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length;\n  const Aders = [];\n  const wders = [];\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i];\n    Aders[i] = new Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n  const CK = [];\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone();\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));\n    }\n    CK[k] = v.divideScalar(wders[0]);\n  }\n  return CK;\n}\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd);\n  return calcRationalCurveDerivatives(Pders);\n}\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  const uspan = findSpan(p, u, U);\n  const vspan = findSpan(q, v, V);\n  const Nu = calcBasisFunctions(uspan, u, p, U);\n  const Nv = calcBasisFunctions(vspan, v, q, V);\n  const temp = [];\n  for (let l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0);\n    for (let k = 0; k <= p; ++k) {\n      const point = P[uspan - p + k][vspan - q + l].clone();\n      const w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      temp[l].add(point.multiplyScalar(Nu[k]));\n    }\n  }\n  const Sw = new Vector4(0, 0, 0, 0);\n  for (let l = 0; l <= q; ++l) {\n    Sw.add(temp[l].multiplyScalar(Nv[l]));\n  }\n  Sw.divideScalar(Sw.w);\n  target.set(Sw.x, Sw.y, Sw.z);\n}\nexport { calcBSplineDerivatives, calcBSplinePoint, calcBasisFunctionDerivatives, calcBasisFunctions, calcKoverI, calcNURBSDerivatives, calcRationalCurveDerivatives, calcSurfacePoint, findSpan };","map":{"version":3,"sources":["../../src/curves/NURBSUtils.js"],"names":["r","j"],"mappings":"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","sourcesContent":["import { Vector3, Vector4 } from 'three'\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\nFinds knot vector span.\n\np : degree\nu : parametric value\nU : knot vector\n\nreturns the span\n*/\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1\n\n  if (u >= U[n]) {\n    return n - 1\n  }\n\n  if (u <= U[p]) {\n    return p\n  }\n\n  let low = p\n  let high = n\n  let mid = Math.floor((low + high) / 2)\n\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid\n    } else {\n      low = mid\n    }\n\n    mid = Math.floor((low + high) / 2)\n  }\n\n  return mid\n}\n\n/*\nCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nU    : knot vector\n\nreturns array[p+1] with basis functions values.\n*/\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = []\n  const left = []\n  const right = []\n  N[0] = 1.0\n\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j]\n    right[j] = U[span + j] - u\n\n    let saved = 0.0\n\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1]\n      const lv = left[j - r]\n      const temp = N[r] / (rv + lv)\n      N[r] = saved + rv * temp\n      saved = lv * temp\n    }\n\n    N[j] = saved\n  }\n\n  return N\n}\n\n/*\nCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\np : degree of B-Spline\nU : knot vector\nP : control points (x, y, z, w)\nu : parametric point\n\nreturns point for given u\n*/\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U)\n  const N = calcBasisFunctions(span, u, p, U)\n  const C = new Vector4(0, 0, 0, 0)\n\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j]\n    const Nj = N[j]\n    const wNj = point.w * Nj\n    C.x += point.x * wNj\n    C.y += point.y * wNj\n    C.z += point.z * wNj\n    C.w += point.w * Nj\n  }\n\n  return C\n}\n\n/*\nCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nn    : number of derivatives to calculate\nU    : knot vector\n\nreturns array[n+1][p+1] with basis functions derivatives\n*/\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = []\n  for (let i = 0; i <= p; ++i) zeroArr[i] = 0.0\n\n  const ders = []\n\n  for (let i = 0; i <= n; ++i) ders[i] = zeroArr.slice(0)\n\n  const ndu = []\n\n  for (let i = 0; i <= p; ++i) ndu[i] = zeroArr.slice(0)\n\n  ndu[0][0] = 1.0\n\n  const left = zeroArr.slice(0)\n  const right = zeroArr.slice(0)\n\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j]\n    right[j] = U[span + j] - u\n\n    let saved = 0.0\n\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1]\n      const lv = left[j - r]\n      ndu[j][r] = rv + lv\n\n      const temp = ndu[r][j - 1] / ndu[j][r]\n      ndu[r][j] = saved + rv * temp\n      saved = lv * temp\n    }\n\n    ndu[j][j] = saved\n  }\n\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p]\n  }\n\n  for (let r = 0; r <= p; ++r) {\n    let s1 = 0\n    let s2 = 1\n\n    const a = []\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0)\n    }\n\n    a[0][0] = 1.0\n\n    for (let k = 1; k <= n; ++k) {\n      let d = 0.0\n      const rk = r - k\n      const pk = p - k\n\n      if (r >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk]\n        d = a[s2][0] * ndu[rk][pk]\n      }\n\n      const j1 = rk >= -1 ? 1 : -rk\n      const j2 = r - 1 <= pk ? k - 1 : p - r\n\n      for (let j = j1; j <= j2; ++j) {\n        a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j]\n        d += a[s2][j] * ndu[rk + j][pk]\n      }\n\n      if (r <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r]\n        d += a[s2][k] * ndu[r][pk]\n      }\n\n      ders[k][r] = d\n\n      const j = s1\n      s1 = s2\n      s2 = j\n    }\n  }\n\n  let r = p\n\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r\n    }\n\n    r *= p - k\n  }\n\n  return ders\n}\n\n/*\n\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points\n\tu  : Parametric points\n\tnd : number of derivatives\n\n\treturns array[d+1] with derivatives\n\t*/\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p\n  const CK = []\n  const span = findSpan(p, u, U)\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U)\n  const Pw = []\n\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone()\n    const w = point.w\n\n    point.x *= w\n    point.y *= w\n    point.z *= w\n\n    Pw[i] = point\n  }\n\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0])\n\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]))\n    }\n\n    CK[k] = point\n  }\n\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0)\n  }\n\n  return CK\n}\n\n/*\nCalculate \"K over I\"\n\nreturns k!/(i!(k-i)!)\n*/\nfunction calcKoverI(k, i) {\n  let nom = 1\n\n  for (let j = 2; j <= k; ++j) {\n    nom *= j\n  }\n\n  let denom = 1\n\n  for (let j = 2; j <= i; ++j) {\n    denom *= j\n  }\n\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j\n  }\n\n  return nom / denom\n}\n\n/*\nCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\nPders : result of function calcBSplineDerivatives\n\nreturns array with derivatives for rational curve.\n*/\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length\n  const Aders = []\n  const wders = []\n\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i]\n    Aders[i] = new Vector3(point.x, point.y, point.z)\n    wders[i] = point.w\n  }\n\n  const CK = []\n\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone()\n\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]))\n    }\n\n    CK[k] = v.divideScalar(wders[0])\n  }\n\n  return CK\n}\n\n/*\nCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\np  : degree\nU  : knot vector\nP  : control points in homogeneous space\nu  : parametric points\nnd : number of derivatives\n\nreturns array with derivatives.\n*/\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd)\n  return calcRationalCurveDerivatives(Pders)\n}\n\n/*\nCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\np1, p2 : degrees of B-Spline surface\nU1, U2 : knot vectors\nP      : control points (x, y, z, w)\nu, v   : parametric values\n\nreturns point for given (u, v)\n*/\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  const uspan = findSpan(p, u, U)\n  const vspan = findSpan(q, v, V)\n  const Nu = calcBasisFunctions(uspan, u, p, U)\n  const Nv = calcBasisFunctions(vspan, v, q, V)\n  const temp = []\n\n  for (let l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0)\n    for (let k = 0; k <= p; ++k) {\n      const point = P[uspan - p + k][vspan - q + l].clone()\n      const w = point.w\n      point.x *= w\n      point.y *= w\n      point.z *= w\n      temp[l].add(point.multiplyScalar(Nu[k]))\n    }\n  }\n\n  const Sw = new Vector4(0, 0, 0, 0)\n  for (let l = 0; l <= q; ++l) {\n    Sw.add(temp[l].multiplyScalar(Nv[l]))\n  }\n\n  Sw.divideScalar(Sw.w)\n  target.set(Sw.x, Sw.y, Sw.z)\n}\n\nexport {\n  findSpan,\n  calcBasisFunctions,\n  calcBSplinePoint,\n  calcBasisFunctionDerivatives,\n  calcBSplineDerivatives,\n  calcKoverI,\n  calcRationalCurveDerivatives,\n  calcNURBSDerivatives,\n  calcSurfacePoint,\n}\n"]},"metadata":{},"sourceType":"module"}