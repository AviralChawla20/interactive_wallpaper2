{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Group, Bone, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping, Skeleton } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml2, name) {\n      const array = [];\n      const childNodes = xml2.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text2) {\n      if (text2.length === 0) return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text2) {\n      return text2.substring(1);\n    }\n    function generateId() {\n      return \"three_default_\" + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n    function parseAsset(xml2) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n      };\n    }\n    function parseAssetUnit(xml2) {\n      if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n        return parseFloat(xml2.getAttribute(\"meter\"));\n      } else {\n        return 1;\n      }\n    }\n    function parseAssetUpAxis(xml2) {\n      return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n    }\n    function parseLibrary(xml2, libraryName, nodeName, parser) {\n      const library2 = getElementsByTagName(xml2, libraryName)[0];\n      if (library2 !== void 0) {\n        const elements = getElementsByTagName(library2, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n    function getBuild(data, builder) {\n      if (data.build !== void 0) return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n    function parseAnimation(xml2) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n        switch (child.nodeName) {\n          case \"source\":\n            id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"sampler\":\n            id = child.getAttribute(\"id\");\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case \"channel\":\n            id = child.getAttribute(\"target\");\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case \"animation\":\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml2) {\n      const data = {};\n      const target = xml2.getAttribute(\"target\");\n      let parts = target.split(\"/\");\n      const id = parts.shift();\n      let sid = parts.shift();\n      const arraySyntax = sid.indexOf(\"(\") !== -1;\n      const memberSyntax = sid.indexOf(\".\") !== -1;\n      if (memberSyntax) {\n        parts = sid.split(\".\");\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        const indices = sid.split(\"(\");\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml2.getAttribute(\"source\"));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n      switch (transform) {\n        case \"matrix\":\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === void 0) data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case \"translate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"rotate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"scale\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      }\n      keyframes.sort(ascending);\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n      }\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === void 0) {\n          keyframe.value[property] = null;\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n    function parseAnimationClip(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"id\") || \"default\",\n        start: parseFloat(xml2.getAttribute(\"start\") || 0),\n        end: parseFloat(xml2.getAttribute(\"end\") || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"instance_animation\":\n            data.animations.push(parseId(child.getAttribute(\"url\")));\n            break;\n        }\n      }\n      library.clips[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations2 = data.animations;\n      for (let i = 0, il = animations2.length; i < il; i++) {\n        const animationTracks = getAnimation(animations2[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n    function parseController(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"skin\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            data.skin = parseSkin(child);\n            break;\n          case \"morph\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n            break;\n        }\n      }\n      library.controllers[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSkin(xml2) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"bind_shape_matrix\":\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case \"source\":\n            const id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"joints\":\n            data.joints = parseJoints(child);\n            break;\n          case \"vertex_weights\":\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            data.inputs[semantic] = {\n              id,\n              offset\n            };\n            break;\n          case \"vcount\":\n            data.vcount = parseInts(child.textContent);\n            break;\n          case \"v\":\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== void 0) {\n        build.skin = buildSkin(data.skin);\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i];\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        }\n        vertexSkinData.sort(descending);\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== void 0) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name,\n          boneInverse\n        });\n      }\n      return build;\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n    function parseImage(xml2) {\n      const data = {\n        init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n      };\n      library.images[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== void 0) return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== void 0) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    }\n    function parseEffect(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"profile_COMMON\":\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseEffectProfileCOMMON(xml2) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"newparam\":\n            parseEffectNewparam(child, data);\n            break;\n          case \"technique\":\n            data.technique = parseEffectTechnique(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml2, data) {\n      const sid = xml2.getAttribute(\"sid\");\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"surface\":\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case \"sampler2D\":\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"init_from\":\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"source\":\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"constant\":\n          case \"lambert\":\n          case \"blinn\":\n          case \"phong\":\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"emission\":\n          case \"diffuse\":\n          case \"specular\":\n          case \"bump\":\n          case \"ambient\":\n          case \"shininess\":\n          case \"transparency\":\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case \"transparent\":\n            data[child.nodeName] = {\n              opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"color\":\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case \"float\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml2) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"extra\":\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"repeatU\":\n          case \"repeatV\":\n          case \"offsetU\":\n          case \"offsetV\":\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"wrapU\":\n          case \"wrapV\":\n            if (child.textContent.toUpperCase() === \"TRUE\") {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === \"FALSE\") {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"double_sided\":\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml2) {\n      var data = {};\n      for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n        var child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              texcoord: child.getAttribute(\"texcoord\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n    function parseMaterial(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"instance_effect\":\n            data.url = parseId(child.getAttribute(\"url\"));\n            break;\n        }\n      }\n      library.materials[xml2.getAttribute(\"id\")] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case \"tga\":\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case \"phong\":\n        case \"blinn\":\n          material = new MeshPhongMaterial();\n          break;\n        case \"lambert\":\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || \"\";\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n        if (sampler !== void 0) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n          image = getImage(textureObject.id);\n        }\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== void 0) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n              const technique2 = extra.technique;\n              texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n              texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case \"diffuse\":\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n          case \"specular\":\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n          case \"bump\":\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n          case \"ambient\":\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n          case \"shininess\":\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n          case \"emission\":\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n      let transparent = parameters[\"transparent\"];\n      let transparency = parameters[\"transparency\"];\n      if (transparency === void 0 && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n      if (transparent === void 0 && transparency) {\n        transparent = {\n          opaque: \"A_ONE\",\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        if (transparent.data.texture) {\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case \"A_ONE\":\n              material.opacity = color[3] * transparency.float;\n              break;\n            case \"RGB_ZERO\":\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case \"A_ZERO\":\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case \"RGB_ONE\":\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1) material.transparent = true;\n        }\n      }\n      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case \"double_sided\":\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case \"bump\":\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n    function parseCamera(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"optics\":\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseCameraOptics(xml2) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"technique_common\":\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"perspective\":\n          case \"orthographic\":\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"xfov\":\n          case \"yfov\":\n          case \"xmag\":\n          case \"ymag\":\n          case \"znear\":\n          case \"zfar\":\n          case \"aspect_ratio\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case \"perspective\":\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        case \"orthographic\":\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n          // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || \"\";\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== void 0) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    }\n    function parseLight(xml2) {\n      let data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseLightTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"directional\":\n          case \"point\":\n          case \"spot\":\n          case \"ambient\":\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"color\":\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case \"falloff_angle\":\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case \"quadratic_attenuation\":\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case \"directional\":\n          light = new DirectionalLight();\n          break;\n        case \"point\":\n          light = new PointLight();\n          break;\n        case \"spot\":\n          light = new SpotLight();\n          break;\n        case \"ambient\":\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== void 0) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    }\n    function parseGeometry(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml2, \"mesh\")[0];\n      if (mesh === void 0) return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute(\"id\");\n        switch (child.nodeName) {\n          case \"source\":\n            data.sources[id] = parseSource(child);\n            break;\n          case \"vertices\":\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case \"polygons\":\n            console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n            break;\n          case \"lines\":\n          case \"linestrips\":\n          case \"polylist\":\n          case \"triangles\":\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSource(xml2) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"float_array\":\n            data.array = parseFloats(child.textContent);\n            break;\n          case \"Name_array\":\n            data.array = parseStrings(child.textContent);\n            break;\n          case \"technique_common\":\n            const accessor = getElementsByTagName(child, \"accessor\")[0];\n            if (accessor !== void 0) {\n              data.stride = parseInt(accessor.getAttribute(\"stride\"));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml2) {\n      const primitive = {\n        type: xml2.nodeName,\n        material: xml2.getAttribute(\"material\"),\n        count: parseInt(xml2.getAttribute(\"count\")),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            const set = parseInt(child.getAttribute(\"set\"));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id,\n              offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n            break;\n          case \"vcount\":\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case \"p\":\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === void 0) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count2 = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count2++;\n        }\n      }\n      if (count2 > 0 && count2 < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {};\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n        checkUVCoordinates(primitiveType);\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position2 = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv1 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n        let count2 = 0;\n        switch (primitive.type) {\n          case \"lines\":\n          case \"linestrips\":\n            count2 = primitive.count * 2;\n            break;\n          case \"triangles\":\n            count2 = primitive.count * 3;\n            break;\n          case \"polylist\":\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count2 += 3;\n                  break;\n                case 4:\n                  count2 += 6;\n                  break;\n                default:\n                  count2 += (vc - 2) * 3;\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n        }\n        geometry.addGroup(start, count2, p);\n        start += count2;\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case \"VERTEX\":\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case \"POSITION\":\n                    const prevLength = position2.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                    position2.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count3 = (position2.array.length - prevLength) / position2.stride;\n                      for (let i = 0; i < count3; i++) {\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case \"NORMAL\":\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case \"COLOR\":\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD1\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv1.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case \"NORMAL\":\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case \"COLOR\":\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD1\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv1.array);\n              uv1.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n      if (position2.array.length > 0) {\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n      }\n      if (color.array.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv1.array.length > 0) geometry.setAttribute(UV1, new Float32BufferAttribute(uv1.array, uv1.stride));\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== void 0) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count2 = vcount[i];\n          if (count2 === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count2 === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count2 > 4) {\n            for (let k = 1, kl = count2 - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count2;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n    function parseKinematicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== void 0) return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"joint\":\n            data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n            break;\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml2) {\n      let data;\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"prismatic\":\n          case \"revolute\":\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml2.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case \"limits\":\n            const max = child.getElementsByTagName(\"max\")[0];\n            const min = child.getElementsByTagName(\"min\")[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n      data.middlePosition = (data.limits.min + data.limits.max) / 2;\n      return data;\n    }\n    function parseKinematicsLink(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"attachment_full\":\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml2) {\n      const data = {\n        joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml2) {\n      const data = {\n        type: xml2.nodeName\n      };\n      const array = parseFloats(xml2.textContent);\n      switch (data.type) {\n        case \"matrix\":\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case \"translate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case \"rotate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n    function parsePhysicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"rigid_body\":\n            data.rigidBodies[child.getAttribute(\"name\")] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n            break;\n        }\n      }\n      library.physicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function parsePhysicsRigidBody(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"inertia\":\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case \"mass\":\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n    function parseKinematicsScene(xml2) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"bind_joint_axis\":\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml2) {\n      const data = {\n        target: xml2.getAttribute(\"target\").split(\"/\").pop()\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const param = child.getElementsByTagName(\"param\")[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== void 0) return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          const parentVisualElement = targetElement.parentElement;\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute(\"name\");\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object,\n              transforms: buildTransformList(visualElement),\n              joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n            } else if (joint.static) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case \"revolute\":\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case \"prismatic\":\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case \"matrix\":\n                      matrix.multiply(transform.obj);\n                      break;\n                    case \"translate\":\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case \"scale\":\n                      matrix.scale(transform.obj);\n                      break;\n                    case \"rotate\":\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector2;\n        switch (child.nodeName) {\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            const matrix2 = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: matrix2\n            });\n            break;\n          case \"translate\":\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2\n            });\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2,\n              angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n    function prepareNodes(xml2) {\n      const elements = xml2.getElementsByTagName(\"node\");\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute(\"id\") === false) {\n          element.setAttribute(\"id\", generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        type: xml2.getAttribute(\"type\"),\n        id: xml2.getAttribute(\"id\"),\n        sid: xml2.getAttribute(\"sid\"),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n        switch (child.nodeName) {\n          case \"node\":\n            data.nodes.push(child.getAttribute(\"id\"));\n            parseNode(child);\n            break;\n          case \"instance_camera\":\n            data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_controller\":\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case \"instance_light\":\n            data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_geometry\":\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case \"instance_node\":\n            data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"translate\":\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"extra\":\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml2) {\n      const data = {\n        id: parseId(xml2.getAttribute(\"url\")),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"bind_material\":\n            const instances = child.getElementsByTagName(\"instance_material\");\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute(\"symbol\");\n              const target = instance.getAttribute(\"target\");\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case \"skeleton\":\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j2 = 0; j2 < children.length; j2++) {\n            const child = children[j2];\n            if (child.type === \"JOINT\") {\n              const root2 = getNode(child.id);\n              buildBoneHierarchy(root2, joints, boneData);\n            }\n          }\n        } else {\n          console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n        }\n      }\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse;\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === void 0) {\n            boneInverse = new Matrix4();\n          }\n          boneData.push({\n            bone: object,\n            boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix2 = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object2 = newObjects[j];\n          if (object2.isSkinnedMesh) {\n            object2.bind(skeleton, controller.skin.bindMatrix);\n            object2.normalizeSkinWeights();\n          }\n          objects.push(object2);\n        }\n      }\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === \"JOINT\" ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === \"JOINT\" ? data.sid : data.name;\n      object.matrix.copy(matrix2);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 16711935\n    });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === void 0) {\n          console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n        if (materials.length === 0) {\n          if (type === \"lines\" || type === \"linestrips\") {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n        const skinning = geometry.data.attributes.skinIndex !== void 0;\n        const material = materials.length === 1 ? materials[0] : materials;\n        let object;\n        switch (type) {\n          case \"lines\":\n            object = new LineSegments(geometry.data, material);\n            break;\n          case \"linestrips\":\n            object = new Line(geometry.data, material);\n            break;\n          case \"triangles\":\n          case \"polylist\":\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== void 0;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n    function parseVisualScene(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        children: []\n      };\n      prepareNodes(xml2);\n      const elements = getElementsByTagName(xml2, \"node\");\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== void 0;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n    function parseScene(xml2) {\n      const instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n      return getVisualScene(parseId(instance.getAttribute(\"url\")));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip(\"default\", -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    function parserErrorToText(parserError2) {\n      let result = \"\";\n      const stack = [parserError2];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += \"\\n\";\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n    const xml = new DOMParser().parseFromString(text, \"application/xml\");\n    const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n    const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n    if (parserError !== void 0) {\n      const errorElement = getElementsByTagName(parserError, \"div\")[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n      return null;\n    }\n    const version = collada.getAttribute(\"version\");\n    console.log(\"THREE.ColladaLoader: File version\", version);\n    const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n    parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n    parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n    parseLibrary(collada, \"library_images\", \"image\", parseImage);\n    parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n    parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n    parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n    parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n    parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n    parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n    parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n    parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n    parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n    parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n    scene.animations = animations;\n    if (asset.upAxis === \"Z_UP\") {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n        return animations;\n      },\n      kinematics,\n      library,\n      scene\n    };\n  }\n}\nexport { ColladaLoader };","map":{"version":3,"sources":["../../src/loaders/ColladaLoader.js"],"names":["xml","text","library","animations","technique","count","position","vector","matrix","j","root","object","parserError"],"mappings":"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","sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  Line,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Scene,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  TextureLoader,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { UV1 } from '../_polyfill/uv1'\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n\n      const array = []\n      const childNodes = xml.childNodes\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i]\n\n        if (child.nodeName === name) {\n          array.push(child)\n        }\n      }\n\n      return array\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i]\n      }\n\n      return array\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i])\n      }\n\n      return array\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i])\n      }\n\n      return array\n    }\n\n    function parseId(text) {\n      return text.substring(1)\n    }\n\n    function generateId() {\n      return 'three_default_' + count++\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0\n    }\n\n    // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0]),\n      }\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'))\n      } else {\n        return 1 // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP'\n    }\n\n    // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0]\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName)\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i])\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name]\n        object.build = builder(data[name])\n      }\n    }\n\n    // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build\n\n      data.build = builder(data)\n\n      return data.build\n    }\n\n    // animation\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {},\n      }\n\n      let hasChildren = false\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let id\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'sampler':\n            id = child.getAttribute('id')\n            data.samplers[id] = parseAnimationSampler(child)\n            break\n\n          case 'channel':\n            id = child.getAttribute('target')\n            data.channels[id] = parseAnimationChannel(child)\n            break\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child)\n            hasChildren = true\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {}\n\n      const target = xml.getAttribute('target')\n\n      // parsing SID Addressing Syntax\n\n      let parts = target.split('/')\n\n      const id = parts.shift()\n      let sid = parts.shift()\n\n      // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1\n      const memberSyntax = sid.indexOf('.') !== -1\n\n      if (memberSyntax) {\n        //  member selection access\n\n        parts = sid.split('.')\n        sid = parts.shift()\n        data.member = parts.shift()\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        const indices = sid.split('(')\n        sid = indices.shift()\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''))\n        }\n\n        data.indices = indices\n      }\n\n      data.id = id\n      data.sid = sid\n\n      data.arraySyntax = arraySyntax\n      data.memberSyntax = memberSyntax\n\n      data.sampler = parseId(xml.getAttribute('source'))\n\n      return data\n    }\n\n    function buildAnimation(data) {\n      const tracks = []\n\n      const channels = data.channels\n      const samplers = data.samplers\n      const sources = data.sources\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target]\n          const sampler = samplers[channel.sampler]\n\n          const inputId = sampler.inputs.INPUT\n          const outputId = sampler.inputs.OUTPUT\n\n          const inputSource = sources[inputId]\n          const outputSource = sources[outputId]\n\n          const animation = buildAnimationChannel(channel, inputSource, outputSource)\n\n          createKeyframeTracks(animation, tracks)\n        }\n      }\n\n      return tracks\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation)\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id]\n      const object3D = getNode(node.id)\n\n      const transform = node.transforms[channel.sid]\n      const defaultMatrix = node.matrix.clone().transpose()\n\n      let time, stride\n      let i, il, j, jl\n\n      const data = {}\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i]\n            stride = i * outputSource.stride\n\n            if (data[time] === undefined) data[time] = {}\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride]\n              const index = channel.indices[0] + 4 * channel.indices[1]\n\n              data[time][index] = value\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j]\n              }\n            }\n          }\n\n          break\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix)\n\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes,\n      }\n\n      return animation\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []\n\n      // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] })\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending)\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i])\n      }\n\n      return keyframes\n\n      // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time\n      }\n    }\n\n    const position = new Vector3()\n    const scale = new Vector3()\n    const quaternion = new Quaternion()\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes\n      const name = animation.name\n\n      const times = []\n      const positionData = []\n      const quaternionData = []\n      const scaleData = []\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        const time = keyframe.time\n        const value = keyframe.value\n\n        matrix.fromArray(value).transpose()\n        matrix.decompose(position, quaternion, scale)\n\n        times.push(time)\n        positionData.push(position.x, position.y, position.z)\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w)\n        scaleData.push(scale.x, scale.y, scale.z)\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData))\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData))\n      }\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData))\n\n      return tracks\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe\n\n      let empty = true\n      let i, l\n\n      // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i]\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null // mark as missing\n        } else {\n          empty = false\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i]\n\n          keyframe.value[property] = defaultValue\n        }\n      } else {\n        // filling gaps\n\n        createMissingKeyframes(keyframes, property)\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property)\n          next = getNext(keyframes, i, property)\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property]\n            continue\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property]\n            continue\n          }\n\n          interpolate(keyframe, prev, next, property)\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i--\n      }\n\n      return null\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i++\n      }\n\n      return null\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property]\n        return\n      }\n\n      key.value[property] =\n        ((key.time - prev.time) * (next.value[property] - prev.value[property])) / (next.time - prev.time) +\n        prev.value[property]\n    }\n\n    // animation clips\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: [],\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')))\n            break\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = []\n\n      const name = data.name\n      const duration = data.end - data.start || -1\n      const animations = data.animations\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i])\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j])\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks)\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip)\n    }\n\n    // controller\n\n    function parseController(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'))\n            data.skin = parseSkin(child)\n            break\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'))\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.')\n            break\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent)\n            break\n\n          case 'source':\n            const id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'joints':\n            data.joints = parseJoints(child)\n            break\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            const offset = parseInt(child.getAttribute('offset'))\n            data.inputs[semantic] = { id: id, offset: offset }\n            break\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent)\n            break\n\n          case 'v':\n            data.v = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id,\n      }\n\n      const geometry = library.geometries[build.id]\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin)\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices\n        geometry.sources.skinWeights = build.skin.weights\n      }\n\n      return build\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4\n\n      const build = {\n        joints: [], // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n      }\n\n      const sources = data.sources\n      const vertexWeights = data.vertexWeights\n\n      const vcount = vertexWeights.vcount\n      const v = vertexWeights.v\n      const jointOffset = vertexWeights.inputs.JOINT.offset\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset\n\n      const jointSource = data.sources[data.joints.inputs.JOINT]\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX]\n\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array\n      let stride = 0\n\n      let i, j, l\n\n      // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i] // this is the amount of joints that affect a single vertex\n        const vertexSkinData = []\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset]\n          const weightId = v[stride + weightOffset]\n          const skinWeight = weights[weightId]\n\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight })\n\n          stride += 2\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending)\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j]\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index)\n            build.weights.array.push(d.weight)\n          } else {\n            build.indices.array.push(0)\n            build.weights.array.push(0)\n          }\n        }\n      }\n\n      // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose()\n      } else {\n        build.bindMatrix = new Matrix4().identity()\n      }\n\n      // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i]\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose()\n\n        build.joints.push({ name: name, boneInverse: boneInverse })\n      }\n\n      return build\n\n      // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController)\n    }\n\n    // image\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent,\n      }\n\n      library.images[xml.getAttribute('id')] = data\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build\n\n      return data.init_from\n    }\n\n    function getImage(id) {\n      const data = library.images[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id)\n\n      return null\n    }\n\n    // effect\n\n    function parseEffect(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child)\n            break\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data)\n            break\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid')\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child)\n            break\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName\n            data.parameters = parseEffectParameters(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child)\n            break\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent)\n            break\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'texture':\n            data[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data)\n            break\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent)\n            }\n\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent)\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {}\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildEffect(data) {\n      return data\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect)\n    }\n\n    // material\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'))\n            break\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data\n    }\n\n    function getTextureLoader(image) {\n      let loader\n\n      let extension = image.slice(((image.lastIndexOf('.') - 1) >>> 0) + 2) // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase()\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader\n          break\n\n        default:\n          loader = textureLoader\n      }\n\n      return loader\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url)\n      const technique = effect.profile.technique\n\n      let material\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial()\n          break\n\n        case 'lambert':\n          material = new MeshLambertMaterial()\n          break\n\n        default:\n          material = new MeshBasicMaterial()\n          break\n      }\n\n      material.name = data.name || ''\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id]\n        let image = null\n\n        // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source]\n          image = getImage(surface.init_from)\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).')\n          image = getImage(textureObject.id)\n        }\n\n        // create texture if image is avaiable\n\n        if (image !== null) {\n          const loader = getTextureLoader(image)\n\n          if (loader !== undefined) {\n            const texture = loader.load(image)\n\n            const extra = textureObject.extra\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique\n\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping\n\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0)\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1)\n            } else {\n              texture.wrapS = RepeatWrapping\n              texture.wrapT = RepeatWrapping\n            }\n\n            return texture\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image)\n\n            return null\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id)\n\n          return null\n        }\n      }\n\n      const parameters = technique.parameters\n\n      for (const key in parameters) {\n        const parameter = parameters[key]\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color)\n            if (parameter.texture) material.map = getTexture(parameter.texture)\n            break\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color)\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture)\n            break\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture)\n            break\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture)\n            break\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float\n            break\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color)\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture)\n            break\n        }\n      }\n\n      //\n\n      let transparent = parameters['transparent']\n      let transparency = parameters['transparency']\n\n      // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1,\n        }\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1],\n          },\n        }\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true\n        } else {\n          const color = transparent.data.color\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float\n              break\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float\n              break\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float\n              break\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float\n              break\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque)\n          }\n\n          if (material.opacity < 1) material.transparent = true\n        }\n      }\n\n      //\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique\n\n        for (const k in techniques) {\n          const v = techniques[k]\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide\n              break\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture)\n              material.normalScale = new Vector2(1, 1)\n              break\n          }\n        }\n      }\n\n      return material\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial)\n    }\n\n    // camera\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child)\n            break\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child)\n        }\n      }\n\n      return {}\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName\n            data.parameters = parseCameraParameters(child)\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildCamera(data) {\n      let camera\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag\n          let xmag = data.optics.parameters.xmag\n          const aspectRatio = data.optics.parameters.aspect_ratio\n\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag\n\n          xmag *= 0.5\n          ymag *= 0.5\n\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag, // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        default:\n          camera = new PerspectiveCamera()\n          break\n      }\n\n      camera.name = data.name || ''\n\n      return camera\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id)\n\n      return null\n    }\n\n    // light\n\n    function parseLight(xml) {\n      let data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child)\n            break\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName\n            data.parameters = parseLightParameters(child)\n        }\n      }\n\n      return data\n    }\n\n    function parseLightParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent)\n            data.color = new Color().fromArray(array)\n            break\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent)\n            break\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent)\n            data.distance = f ? Math.sqrt(1 / f) : 0\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildLight(data) {\n      let light\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight()\n          break\n\n        case 'point':\n          light = new PointLight()\n          break\n\n        case 'spot':\n          light = new SpotLight()\n          break\n\n        case 'ambient':\n          light = new AmbientLight()\n          break\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color)\n      if (data.parameters.distance) light.distance = data.parameters.distance\n\n      return light\n    }\n\n    function getLight(id) {\n      const data = library.lights[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id)\n\n      return null\n    }\n\n    // geometry\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: [],\n      }\n\n      const mesh = getElementsByTagName(xml, 'mesh')[0]\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if (mesh === undefined) return\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        const id = child.getAttribute('id')\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child)\n            break\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName)\n            break\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child))\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent)\n            break\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent)\n            break\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0]\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'))\n            }\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'))\n      }\n\n      return data\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false,\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            const offset = parseInt(child.getAttribute('offset'))\n            const set = parseInt(child.getAttribute('set'))\n            const inputname = set > 0 ? semantic + set : semantic\n            primitive.inputs[inputname] = { id: id, offset: offset }\n            primitive.stride = Math.max(primitive.stride, offset + 1)\n            if (semantic === 'TEXCOORD') primitive.hasUV = true\n            break\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent)\n            break\n\n          case 'p':\n            primitive.p = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return primitive\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {}\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i]\n\n        if (build[primitive.type] === undefined) build[primitive.type] = []\n\n        build[primitive.type].push(primitive)\n      }\n\n      return build\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i]\n\n        if (primitive.hasUV === true) {\n          count++\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {}\n\n      const sources = data.sources\n      const vertices = data.vertices\n      const primitives = data.primitives\n\n      if (primitives.length === 0) return {}\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives)\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType)\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices)\n      }\n\n      return build\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {}\n\n      const position = { array: [], stride: 0 }\n      const normal = { array: [], stride: 0 }\n      const uv = { array: [], stride: 0 }\n      const uv1 = { array: [], stride: 0 }\n      const color = { array: [], stride: 0 }\n\n      const skinIndex = { array: [], stride: 4 }\n      const skinWeight = { array: [], stride: 4 }\n\n      const geometry = new BufferGeometry()\n\n      const materialKeys = []\n\n      let start = 0\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p]\n        const inputs = primitive.inputs\n\n        // groups\n\n        let count = 0\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2\n            break\n\n          case 'triangles':\n            count = primitive.count * 3\n            break\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g]\n\n              switch (vc) {\n                case 3:\n                  count += 3 // single triangle\n                  break\n\n                case 4:\n                  count += 6 // quad, subdivided into two triangles\n                  break\n\n                default:\n                  count += (vc - 2) * 3 // polylist with more than four vertices\n                  break\n              }\n            }\n\n            break\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type)\n        }\n\n        geometry.addGroup(start, count, p)\n        start += count\n\n        // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material)\n        }\n\n        // geometry data\n\n        for (const name in inputs) {\n          const input = inputs[name]\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key]\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length\n                    buildGeometryData(primitive, sources[id], input.offset, position.array)\n                    position.stride = sources[id].stride\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array)\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array)\n                    }\n\n                    // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n\n                        uv.array.push(0, 0)\n                      }\n                    }\n\n                    break\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array)\n                    normal.stride = sources[id].stride\n                    break\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array)\n                    color.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv1.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key)\n                }\n              }\n\n              break\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array)\n              normal.stride = sources[input.id].stride\n              break\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array)\n              color.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array)\n              uv.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv1.array)\n              uv1.stride = sources[input.id].stride\n              break\n          }\n        }\n      }\n\n      // build geometry\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride))\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride))\n      }\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride))\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride))\n      if (uv1.array.length > 0) geometry.setAttribute(UV1, new Float32BufferAttribute(uv1.array, uv1.stride))\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride))\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride))\n      }\n\n      build.data = geometry\n      build.type = primitives[0].type\n      build.materialKeys = materialKeys\n\n      return build\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p\n      const stride = primitive.stride\n      const vcount = primitive.vcount\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride\n        const length = index + sourceStride\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index])\n        }\n      }\n\n      const sourceArray = source.array\n      const sourceStride = source.stride\n\n      if (primitive.vcount !== undefined) {\n        let index = 0\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i]\n\n          if (count === 4) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n            const d = index + stride * 3\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(d)\n            pushVector(b)\n            pushVector(c)\n            pushVector(d)\n          } else if (count === 3) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(c)\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0\n              const b = index + stride * k\n              const c = index + stride * (k + 1)\n\n              pushVector(a)\n              pushVector(b)\n              pushVector(c)\n            }\n          }\n\n          index += stride * count\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i)\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry)\n    }\n\n    // kinematics\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data)\n            break\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel)\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child)\n            break\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0,\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent)\n            data.axis.fromArray(array)\n            break\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0]\n            const min = child.getElementsByTagName('min')[0]\n\n            data.limits.max = parseFloat(max.textContent)\n            data.limits.min = parseFloat(min.textContent)\n            break\n        }\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true\n      }\n\n      // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0\n\n      return data\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName,\n      }\n\n      const array = parseFloats(xml.textContent)\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4()\n          data.obj.fromArray(array).transpose()\n          break\n\n        case 'translate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          break\n\n        case 'rotate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          data.angle = MathUtils.degToRad(array[3])\n          break\n      }\n\n      return data\n    }\n\n    // physics\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {}\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')])\n            break\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data)\n            break\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent)\n            break\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0]\n            break\n        }\n      }\n    }\n\n    // scene\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child))\n            break\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop(),\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0]\n            data.axis = param.textContent\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0]\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene)\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0]\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0]\n      const visualSceneId = Object.keys(library.visualScenes)[0]\n\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return\n\n      const kinematicsModel = getKinematicsModel(kinematicsModelId)\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId)\n      const visualScene = getVisualScene(visualSceneId)\n\n      const bindJointAxis = kinematicsScene.bindJointAxis\n      const jointMap = {}\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]')\n\n        if (targetElement) {\n          // get the parent of the transform element\n\n          const parentVisualElement = targetElement.parentElement\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement)\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name')\n        const joint = kinematicsModel.joints[jointIndex]\n\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition,\n            }\n          }\n        })\n      }\n\n      const m0 = new Matrix4()\n\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            return jointData.position\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\")\n          }\n        },\n\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            const joint = jointData.joint\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                'THREE.ColladaLoader: Joint ' +\n                jointIndex +\n                ' value ' +\n                value +\n                ' outside of limits (min: ' +\n                joint.limits.min +\n                ', max: ' +\n                joint.limits.max +\n                ').',\n              )\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.')\n            } else {\n              const object = jointData.object\n              const axis = joint.axis\n              const transforms = jointData.transforms\n\n              matrix.identity()\n\n              // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)))\n                      break\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value))\n                      break\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type)\n                      break\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj)\n                      break\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z))\n                      break\n\n                    case 'scale':\n                      matrix.scale(transform.obj)\n                      break\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle))\n                      break\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix)\n              object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n              jointMap[jointIndex].position = value\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.')\n          }\n        },\n      }\n    }\n\n    function buildTransformList(node) {\n      const transforms = []\n\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]')\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array, vector\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            const matrix = new Matrix4().fromArray(array).transpose()\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix,\n            })\n            break\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n            })\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            const angle = MathUtils.degToRad(array[3])\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle,\n            })\n            break\n        }\n      }\n\n      return transforms\n    }\n\n    // nodes\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node')\n\n      // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i]\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId())\n        }\n      }\n    }\n\n    const matrix = new Matrix4()\n    const vector = new Vector3()\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'))\n            parseNode(child)\n            break\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child))\n            break\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child))\n            break\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            data.matrix.multiply(matrix.fromArray(array).transpose())\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'translate':\n            array = parseFloats(child.textContent)\n            vector.fromArray(array)\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            const angle = MathUtils.degToRad(array[3])\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'scale':\n            array = parseFloats(child.textContent)\n            data.matrix.scale(vector.fromArray(array))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'extra':\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn(\n          'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.',\n          data.id,\n        )\n      } else {\n        library.nodes[data.id] = data\n      }\n\n      return data\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material')\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j]\n              const symbol = instance.getAttribute('symbol')\n              const target = instance.getAttribute('target')\n\n              data.materials[symbol] = parseId(target)\n            }\n\n            break\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent))\n            break\n\n          default:\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = []\n      const sortedBoneData = []\n\n      let i, j, data\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i]\n\n        let root\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton)\n          buildBoneHierarchy(root, joints, boneData)\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          const visualScene = library.visualScenes[skeleton]\n          const children = visualScene.children\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j]\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id)\n              buildBoneHierarchy(root, joints, boneData)\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton)\n        }\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j]\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data\n            data.processed = true\n            break\n          }\n        }\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i]\n\n        if (data.processed === false) {\n          sortedBoneData.push(data)\n          data.processed = true\n        }\n      }\n\n      // setup arrays for skeleton creation\n\n      const bones = []\n      const boneInverses = []\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i]\n\n        bones.push(data.bone)\n        boneInverses.push(data.boneInverse)\n      }\n\n      return new Skeleton(bones, boneInverses)\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse\n\n          // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i]\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse\n              break\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new Matrix4()\n          }\n\n          boneData.push({ bone: object, boneInverse: boneInverse, processed: false })\n        }\n      })\n    }\n\n    function buildNode(data) {\n      const objects = []\n\n      const matrix = data.matrix\n      const nodes = data.nodes\n      const type = data.type\n      const instanceCameras = data.instanceCameras\n      const instanceControllers = data.instanceControllers\n      const instanceLights = data.instanceLights\n      const instanceGeometries = data.instanceGeometries\n      const instanceNodes = data.instanceNodes\n\n      // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]))\n      }\n\n      // instance cameras\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i])\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone())\n        }\n      }\n\n      // instance controllers\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i]\n        const controller = getController(instance.id)\n        const geometries = getGeometry(controller.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        const skeletons = instance.skeletons\n        const joints = controller.skin.joints\n\n        const skeleton = buildSkeleton(skeletons, joints)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j]\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix)\n            object.normalizeSkinWeights()\n          }\n\n          objects.push(object)\n        }\n      }\n\n      // instance lights\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i])\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone())\n        }\n      }\n\n      // instance geometries\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j])\n        }\n      }\n\n      // instance nodes\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone())\n      }\n\n      let object\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0]\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group()\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i])\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name\n      object.matrix.copy(matrix)\n      object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n      return object\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({ color: 0xff00ff })\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = []\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]]\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i])\n          materials.push(fallbackMaterial)\n        } else {\n          materials.push(getMaterial(id))\n        }\n      }\n\n      return materials\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = []\n\n      for (const type in geometries) {\n        const geometry = geometries[type]\n\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials)\n\n        // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial())\n          } else {\n            materials.push(new MeshPhongMaterial())\n          }\n        }\n\n        // regard skinning\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined\n\n        // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials\n\n        // now create a specific 3D object\n\n        let object\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material)\n            break\n\n          case 'linestrips':\n            object = new Line(geometry.data, material)\n            break\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material)\n            } else {\n              object = new Mesh(geometry.data, material)\n            }\n\n            break\n        }\n\n        objects.push(object)\n      }\n\n      return objects\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode)\n    }\n\n    // visual scenes\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: [],\n      }\n\n      prepareNodes(xml)\n\n      const elements = getElementsByTagName(xml, 'node')\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]))\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group()\n      group.name = data.name\n\n      const children = data.children\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n\n        group.add(getNode(child.id))\n      }\n\n      return group\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene)\n    }\n\n    // scenes\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0]\n      return getVisualScene(parseId(instance.getAttribute('url')))\n    }\n\n    function setupAnimations() {\n      const clips = library.clips\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n\n          const tracks = []\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id)\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i])\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks))\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id))\n        }\n      }\n    }\n\n    // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n    function parserErrorToText(parserError) {\n      let result = ''\n      const stack = [parserError]\n\n      while (stack.length) {\n        const node = stack.shift()\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent\n        } else {\n          result += '\\n'\n          stack.push.apply(stack, node.childNodes)\n        }\n      }\n\n      return result.trim()\n    }\n\n    if (text.length === 0) {\n      return { scene: new Scene() }\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml')\n\n    const collada = getElementsByTagName(xml, 'COLLADA')[0]\n\n    const parserError = xml.getElementsByTagName('parsererror')[0]\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n\n      const errorElement = getElementsByTagName(parserError, 'div')[0]\n      let errorText\n\n      if (errorElement) {\n        errorText = errorElement.textContent\n      } else {\n        errorText = parserErrorToText(parserError)\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText)\n\n      return null\n    }\n\n    // metadata\n\n    const version = collada.getAttribute('version')\n    console.log('THREE.ColladaLoader: File version', version)\n\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0])\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    let tgaLoader\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager)\n      tgaLoader.setPath(this.resourcePath || path)\n    }\n\n    //\n\n    const animations = []\n    let kinematics = {}\n    let count = 0\n\n    //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {},\n    }\n\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation)\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip)\n    parseLibrary(collada, 'library_controllers', 'controller', parseController)\n    parseLibrary(collada, 'library_images', 'image', parseImage)\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect)\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial)\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera)\n    parseLibrary(collada, 'library_lights', 'light', parseLight)\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry)\n    parseLibrary(collada, 'library_nodes', 'node', parseNode)\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene)\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel)\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel)\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene)\n\n    buildLibrary(library.animations, buildAnimation)\n    buildLibrary(library.clips, buildAnimationClip)\n    buildLibrary(library.controllers, buildController)\n    buildLibrary(library.images, buildImage)\n    buildLibrary(library.effects, buildEffect)\n    buildLibrary(library.materials, buildMaterial)\n    buildLibrary(library.cameras, buildCamera)\n    buildLibrary(library.lights, buildLight)\n    buildLibrary(library.geometries, buildGeometry)\n    buildLibrary(library.visualScenes, buildVisualScene)\n\n    setupAnimations()\n    setupKinematics()\n\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0])\n    scene.animations = animations\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n    }\n\n    scene.scale.multiplyScalar(asset.unit)\n\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.')\n        return animations\n      },\n      kinematics: kinematics,\n      library: library,\n      scene: scene,\n    }\n  }\n}\n\nexport { ColladaLoader }\n"]},"metadata":{},"sourceType":"module"}