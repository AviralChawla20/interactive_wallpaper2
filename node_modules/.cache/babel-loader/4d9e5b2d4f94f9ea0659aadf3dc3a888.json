{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Box3, Sphere, BufferAttribute, Vector2 } from \"three\";\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n    return buffergeometry;\n  }\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      const cb = new Vector3(),\n        ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors;\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [],\n      changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    }\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    }\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n    buffergeometry.groups = geometry.groups;\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    }\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n  computeLineDistances() {\n    console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n}\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport { Face3, Geometry };","map":{"version":3,"sources":["../../src/deprecated/Geometry.js"],"names":[],"mappings":";AAgBA,MAAM,GAAA,GAAM,IAAI,OAAA,CAAS,CAAA;AACzB,MAAM,IAAA,GAAO,IAAI,QAAA,CAAU,CAAA;AAC3B,MAAM,OAAA,GAAU,IAAI,OAAA,CAAS,CAAA;AAE7B,MAAM,QAAA,SAAiB,eAAA,CAAgB;EACrC,OAAO,8BAAA,CAA+B,MAAA,EAAQ;IAC5C,IAAI,cAAA,GAAiB,IAAI,cAAA,CAAgB,CAAA;IAEzC,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA;IAExB,IAAI,MAAA,CAAO,QAAA,IAAY,MAAA,CAAO,MAAA,EAAQ;MACpC,MAAM,SAAA,GAAY,IAAI,sBAAA,CAAuB,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG,CAAC,CAAA;MAC5E,MAAM,MAAA,GAAS,IAAI,sBAAA,CAAuB,QAAA,CAAS,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,CAAC,CAAA;MAEvE,cAAA,CAAe,YAAA,CAAa,UAAA,EAAY,SAAA,CAAU,iBAAA,CAAkB,QAAA,CAAS,QAAQ,CAAC,CAAA;MACtF,cAAA,CAAe,YAAA,CAAa,OAAA,EAAS,MAAA,CAAO,eAAA,CAAgB,QAAA,CAAS,MAAM,CAAC,CAAA;MAE5E,IAAI,QAAA,CAAS,aAAA,IAAiB,QAAA,CAAS,aAAA,CAAc,MAAA,KAAW,QAAA,CAAS,QAAA,CAAS,MAAA,EAAQ;QACxF,MAAM,aAAA,GAAgB,IAAI,sBAAA,CAAuB,QAAA,CAAS,aAAA,CAAc,MAAA,EAAQ,CAAC,CAAA;QAEjF,cAAA,CAAe,YAAA,CAAa,cAAA,EAAgB,aAAA,CAAc,SAAA,CAAU,QAAA,CAAS,aAAa,CAAC,CAAA;MAC5F;MAED,IAAI,QAAA,CAAS,cAAA,KAAmB,IAAA,EAAM;QACpC,cAAA,CAAe,cAAA,GAAiB,QAAA,CAAS,cAAA,CAAe,KAAA,CAAO,CAAA;MAChE;MAED,IAAI,QAAA,CAAS,WAAA,KAAgB,IAAA,EAAM;QACjC,cAAA,CAAe,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,KAAA,CAAO,CAAA;MAC1D;IACP,CAAA,MAAA,IAAe,MAAA,CAAO,MAAA,EAAQ;MACxB,cAAA,GAAiB,QAAA,CAAS,gBAAA,CAAkB,CAAA;IAC7C;IAED,OAAO,cAAA;EACR;EAED,WAAA,CAAA,EAAc;IACZ,KAAA,CAAO,CAAA;IACP,IAAA,CAAK,UAAA,GAAa,IAAA;IAClB,IAAA,CAAK,IAAA,GAAO,SAAA,CAAU,YAAA,CAAc,CAAA;IAEpC,IAAA,CAAK,IAAA,GAAO,EAAA;IACZ,IAAA,CAAK,IAAA,GAAO,UAAA;IAEZ,IAAA,CAAK,QAAA,GAAW,EAAE;IAClB,IAAA,CAAK,MAAA,GAAS,EAAE;IAChB,IAAA,CAAK,KAAA,GAAQ,EAAE;IACf,IAAA,CAAK,aAAA,GAAgB,CAAC,EAAE,CAAA;IAExB,IAAA,CAAK,YAAA,GAAe,EAAE;IACtB,IAAA,CAAK,YAAA,GAAe,EAAE;IAEtB,IAAA,CAAK,WAAA,GAAc,EAAE;IACrB,IAAA,CAAK,WAAA,GAAc,EAAE;IAErB,IAAA,CAAK,aAAA,GAAgB,EAAE;IAEvB,IAAA,CAAK,WAAA,GAAc,IAAA;IACnB,IAAA,CAAK,cAAA,GAAiB,IAAA;IAItB,IAAA,CAAK,kBAAA,GAAqB,KAAA;IAC1B,IAAA,CAAK,kBAAA,GAAqB,KAAA;IAC1B,IAAA,CAAK,aAAA,GAAgB,KAAA;IACrB,IAAA,CAAK,iBAAA,GAAoB,KAAA;IACzB,IAAA,CAAK,gBAAA,GAAmB,KAAA;IACxB,IAAA,CAAK,uBAAA,GAA0B,KAAA;IAC/B,IAAA,CAAK,gBAAA,GAAmB,KAAA;EACzB;EAED,YAAA,CAAa,MAAA,EAAQ;IACnB,MAAM,YAAA,GAAe,IAAI,OAAA,CAAA,CAAA,CAAU,eAAA,CAAgB,MAAM,CAAA;IAEzD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACtD,MAAM,MAAA,GAAS,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;MAC9B,MAAA,CAAO,YAAA,CAAa,MAAM,CAAA;IAC3B;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MACzB,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,YAAY,CAAA,CAAE,SAAA,CAAW,CAAA;MAElD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC3D,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,YAAA,CAAa,YAAY,CAAA,CAAE,SAAA,CAAW,CAAA;MAC7D;IACF;IAED,IAAI,IAAA,CAAK,WAAA,KAAgB,IAAA,EAAM;MAC7B,IAAA,CAAK,kBAAA,CAAoB,CAAA;IAC1B;IAED,IAAI,IAAA,CAAK,cAAA,KAAmB,IAAA,EAAM;MAChC,IAAA,CAAK,qBAAA,CAAuB,CAAA;IAC7B;IAED,IAAA,CAAK,kBAAA,GAAqB,IAAA;IAC1B,IAAA,CAAK,iBAAA,GAAoB,IAAA;IAEzB,OAAO,IAAA;EACR;EAED,OAAA,CAAQ,KAAA,EAAO;IAGb,GAAA,CAAI,aAAA,CAAc,KAAK,CAAA;IAEvB,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;IAErB,OAAO,IAAA;EACR;EAED,OAAA,CAAQ,KAAA,EAAO;IAGb,GAAA,CAAI,aAAA,CAAc,KAAK,CAAA;IAEvB,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;IAErB,OAAO,IAAA;EACR;EAED,OAAA,CAAQ,KAAA,EAAO;IAGb,GAAA,CAAI,aAAA,CAAc,KAAK,CAAA;IAEvB,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;IAErB,OAAO,IAAA;EACR;EAED,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;IAGjB,GAAA,CAAI,eAAA,CAAgB,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;IAE3B,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;IAErB,OAAO,IAAA;EACR;EAED,KAAA,CAAM,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;IAGb,GAAA,CAAI,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;IAErB,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;IAErB,OAAO,IAAA;EACR;EAED,MAAA,CAAO,MAAA,EAAQ;IACb,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;IAElB,IAAA,CAAK,YAAA,CAAc,CAAA;IAEnB,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAM,CAAA;IAE7B,OAAO,IAAA;EACR;EAED,kBAAA,CAAmB,QAAA,EAAU;IAC3B,MAAM,KAAA,GAAQ,IAAA;IAEd,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,KAAU,IAAA,GAAO,QAAA,CAAS,KAAA,GAAQ,KAAA,CAAA;IACzD,MAAM,UAAA,GAAa,QAAA,CAAS,UAAA;IAE5B,IAAI,UAAA,CAAW,QAAA,KAAa,KAAA,CAAA,EAAW;MACrC,OAAA,CAAQ,KAAA,CAAM,kFAAkF,CAAA;MAChG,OAAO,IAAA;IACR;IAED,MAAM,QAAA,GAAW,UAAA,CAAW,QAAA;IAC5B,MAAM,MAAA,GAAS,UAAA,CAAW,MAAA;IAC1B,MAAM,KAAA,GAAQ,UAAA,CAAW,KAAA;IACzB,MAAM,EAAA,GAAK,UAAA,CAAW,EAAA;IACtB,MAAM,GAAA,GAAM,UAAA,CAAW,GAAA;IAEvB,IAAI,GAAA,KAAQ,KAAA,CAAA,EAAW,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,EAAE;IAEjD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,KAAA,EAAO,CAAA,EAAA,EAAK;MACvC,KAAA,CAAM,QAAA,CAAS,IAAA,CAAK,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,QAAA,EAAU,CAAC,CAAC,CAAA;MAElE,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;QACvB,KAAA,CAAM,MAAA,CAAO,IAAA,CAAK,IAAI,KAAA,CAAO,CAAA,CAAC,mBAAA,CAAoB,KAAA,EAAO,CAAC,CAAC,CAAA;MAC5D;IACF;IAED,SAAS,OAAA,CAAQ,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,aAAA,EAAe;MACvC,MAAM,YAAA,GACJ,KAAA,KAAU,KAAA,CAAA,GAAY,EAAA,GAAK,CAAC,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAA,CAAA,EAAS,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAA,CAAA,EAAS,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;MAEvG,MAAM,aAAA,GACJ,MAAA,KAAW,KAAA,CAAA,GACP,EAAE,GACF,CACE,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,MAAA,EAAQ,CAAC,CAAA,EAC3C,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,MAAA,EAAQ,CAAC,CAAA,EAC3C,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,MAAA,EAAQ,CAAC,CAAA,CAC5C;MAEP,MAAM,IAAA,GAAO,IAAI,KAAA,CAAM,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,aAAA,EAAe,YAAA,EAAc,aAAa,CAAA;MAE1E,KAAA,CAAM,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;MAErB,IAAI,EAAA,KAAO,KAAA,CAAA,EAAW;QACpB,KAAA,CAAM,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,CAC1B,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,EAAA,EAAI,CAAC,CAAA,EACvC,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,EAAA,EAAI,CAAC,CAAA,EACvC,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,EAAA,EAAI,CAAC,CAAA,CACxC,CAAA;MACF;MAED,IAAI,GAAA,KAAQ,KAAA,CAAA,EAAW;QACrB,KAAA,CAAM,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,CAC1B,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,GAAA,EAAK,CAAC,CAAA,EACxC,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,GAAA,EAAK,CAAC,CAAA,EACxC,IAAI,OAAA,CAAS,CAAA,CAAC,mBAAA,CAAoB,GAAA,EAAK,CAAC,CAAA,CACzC,CAAA;MACF;IACF;IAED,MAAM,MAAA,GAAS,QAAA,CAAS,MAAA;IAExB,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;MACrB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,EAAK;QACtC,MAAM,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA;QAEtB,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA;QACpB,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA;QAEpB,KAAA,IAAS,CAAA,GAAI,KAAA,EAAO,EAAA,GAAK,KAAA,GAAQ,KAAA,EAAO,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,CAAA,EAAG;UACtD,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;YACvB,OAAA,CAAQ,KAAA,CAAM,IAAA,CAAK,CAAC,CAAA,EAAG,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,EAAG,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,EAAG,KAAA,CAAM,aAAa,CAAA;UAC5F,CAAA,MAAiB;YACL,OAAA,CAAQ,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,KAAA,CAAM,aAAa,CAAA;UAC7C;QACF;MACF;IACP,CAAA,MAAW;MACL,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;QACvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,KAAA,EAAO,CAAA,IAAK,CAAA,EAAG;UACvC,OAAA,CAAQ,KAAA,CAAM,IAAA,CAAK,CAAC,CAAA,EAAG,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,EAAG,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAC,CAAA;QAC5D;MACT,CAAA,MAAa;QACL,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,KAAA,EAAO,CAAA,IAAK,CAAA,EAAG;UAC1C,OAAA,CAAQ,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA;QACxB;MACF;IACF;IAED,IAAA,CAAK,kBAAA,CAAoB,CAAA;IAEzB,IAAI,QAAA,CAAS,WAAA,KAAgB,IAAA,EAAM;MACjC,IAAA,CAAK,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,KAAA,CAAO,CAAA;IAChD;IAED,IAAI,QAAA,CAAS,cAAA,KAAmB,IAAA,EAAM;MACpC,IAAA,CAAK,cAAA,GAAiB,QAAA,CAAS,cAAA,CAAe,KAAA,CAAO,CAAA;IACtD;IAED,OAAO,IAAA;EACR;EAED,MAAA,CAAA,EAAS;IACP,IAAA,CAAK,kBAAA,CAAoB,CAAA;IAEzB,IAAA,CAAK,WAAA,CAAY,SAAA,CAAU,OAAO,CAAA,CAAE,MAAA,CAAQ,CAAA;IAE5C,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAC,CAAA;IAE9C,OAAO,IAAA;EACR;EAED,SAAA,CAAA,EAAY;IACV,IAAA,CAAK,qBAAA,CAAuB,CAAA;IAE5B,MAAM,MAAA,GAAS,IAAA,CAAK,cAAA,CAAe,MAAA;IACnC,MAAM,MAAA,GAAS,IAAA,CAAK,cAAA,CAAe,MAAA;IAEnC,MAAM,CAAA,GAAI,MAAA,KAAW,CAAA,GAAI,CAAA,GAAI,CAAA,GAAM,MAAA;IAEnC,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;IAC5B,MAAA,CAAO,GAAA,CAAI,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA,GAAI,MAAA,CAAO,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA,GAAI,MAAA,CAAO,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA,GAAI,MAAA,CAAO,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;IAE7F,IAAA,CAAK,YAAA,CAAa,MAAM,CAAA;IAExB,OAAO,IAAA;EACR;EAED,kBAAA,CAAA,EAAqB;IACnB,MAAM,EAAA,GAAK,IAAI,OAAA,CAAS,CAAA;MACtB,EAAA,GAAK,IAAI,OAAA,CAAS,CAAA;IAEpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;MAC/B,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;MAC/B,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;MAE/B,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;MACpB,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;MACpB,EAAA,CAAG,KAAA,CAAM,EAAE,CAAA;MAEX,EAAA,CAAG,SAAA,CAAW,CAAA;MAEd,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,EAAE,CAAA;IACpB;EACF;EAED,oBAAA,CAAqB,YAAA,GAAe,IAAA,EAAM;IACxC,MAAM,QAAA,GAAW,IAAI,KAAA,CAAM,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA;IAE/C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACtD,QAAA,CAAS,CAAC,CAAA,GAAI,IAAI,OAAA,CAAS,CAAA;IAC5B;IAED,IAAI,YAAA,EAAc;MAIhB,MAAM,EAAA,GAAK,IAAI,OAAA,CAAS,CAAA;QACtB,EAAA,GAAK,IAAI,OAAA,CAAS,CAAA;MAEpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;QAEzB,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;QAC/B,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;QAC/B,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;QAE/B,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;QACpB,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;QACpB,EAAA,CAAG,KAAA,CAAM,EAAE,CAAA;QAEX,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,EAAE,CAAA;QACvB,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,EAAE,CAAA;QACvB,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,EAAE,CAAA;MACxB;IACP,CAAA,MAAW;MACL,IAAA,CAAK,kBAAA,CAAoB,CAAA;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;QAEzB,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA;QAChC,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA;QAChC,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA;MACjC;IACF;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACtD,QAAA,CAAS,CAAC,CAAA,CAAE,SAAA,CAAW,CAAA;IACxB;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,MAAM,aAAA,GAAgB,IAAA,CAAK,aAAA;MAE3B,IAAI,aAAA,CAAc,MAAA,KAAW,CAAA,EAAG;QAC9B,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAC,CAAA;QACtC,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAC,CAAA;QACtC,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAC,CAAA;MAC9C,CAAA,MAAa;QACL,aAAA,CAAc,CAAC,CAAA,GAAI,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;QAC3C,aAAA,CAAc,CAAC,CAAA,GAAI,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;QAC3C,aAAA,CAAc,CAAC,CAAA,GAAI,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;MAC5C;IACF;IAED,IAAI,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;MACzB,IAAA,CAAK,iBAAA,GAAoB,IAAA;IAC1B;EACF;EAED,wBAAA,CAAA,EAA2B;IACzB,IAAA,CAAK,kBAAA,CAAoB,CAAA;IAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,MAAM,aAAA,GAAgB,IAAA,CAAK,aAAA;MAE3B,IAAI,aAAA,CAAc,MAAA,KAAW,CAAA,EAAG;QAC9B,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;QACjC,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;QACjC,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;MACzC,CAAA,MAAa;QACL,aAAA,CAAc,CAAC,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,KAAA,CAAO,CAAA;QACtC,aAAA,CAAc,CAAC,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,KAAA,CAAO,CAAA;QACtC,aAAA,CAAc,CAAC,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,KAAA,CAAO,CAAA;MACvC;IACF;IAED,IAAI,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG;MACzB,IAAA,CAAK,iBAAA,GAAoB,IAAA;IAC1B;EACF;EAED,mBAAA,CAAA,EAAsB;IAKpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,IAAI,CAAC,IAAA,CAAK,oBAAA,EAAsB;QAC9B,IAAA,CAAK,oBAAA,GAAuB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAO,CAAA;MACvD,CAAA,MAAa;QACL,IAAA,CAAK,oBAAA,CAAqB,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;MAC3C;MAED,IAAI,CAAC,IAAA,CAAK,uBAAA,EAAyB,IAAA,CAAK,uBAAA,GAA0B,EAAE;MAEpE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC3D,IAAI,CAAC,IAAA,CAAK,uBAAA,CAAwB,CAAC,CAAA,EAAG;UACpC,IAAA,CAAK,uBAAA,CAAwB,CAAC,CAAA,GAAI,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;QACzE,CAAA,MAAe;UACL,IAAA,CAAK,uBAAA,CAAwB,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC,CAAA;QAC3D;MACF;IACF;IAID,MAAM,MAAA,GAAS,IAAI,QAAA,CAAU,CAAA;IAC7B,MAAA,CAAO,KAAA,GAAQ,IAAA,CAAK,KAAA;IAEpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,YAAA,CAAa,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAG1D,IAAI,CAAC,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,EAAG;QACzB,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,GAAI,CAAE,CAAA;QACzB,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,GAAc,EAAE;QACrC,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA,GAAgB,EAAE;QAEvC,MAAM,cAAA,GAAiB,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA;QAC5C,MAAM,gBAAA,GAAmB,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA;QAE9C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACnD,MAAM,UAAA,GAAa,IAAI,OAAA,CAAS,CAAA;UAChC,MAAM,aAAA,GAAgB;YACpB,CAAA,EAAG,IAAI,OAAA,CAAS,CAAA;YAChB,CAAA,EAAG,IAAI,OAAA,CAAS,CAAA;YAChB,CAAA,EAAG,IAAI,OAAA,CAAS;UACjB,CAAA;UAED,cAAA,CAAe,IAAA,CAAK,UAAU,CAAA;UAC9B,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA;QACpC;MACF;MAED,MAAM,YAAA,GAAe,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA;MAIxC,MAAA,CAAO,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,QAAA;MAIvC,MAAA,CAAO,kBAAA,CAAoB,CAAA;MAC3B,MAAA,CAAO,oBAAA,CAAsB,CAAA;MAI7B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;QAEzB,MAAM,UAAA,GAAa,YAAA,CAAa,WAAA,CAAY,CAAC,CAAA;QAC7C,MAAM,aAAA,GAAgB,YAAA,CAAa,aAAA,CAAc,CAAC,CAAA;QAElD,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;QAE3B,aAAA,CAAc,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC,CAAA;QAC1C,aAAA,CAAc,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC,CAAA;QAC1C,aAAA,CAAc,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC,CAAA;MAC3C;IACF;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,oBAAA;MACnB,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,uBAAA;IAC3B;EACF;EAED,kBAAA,CAAA,EAAqB;IACnB,IAAI,IAAA,CAAK,WAAA,KAAgB,IAAA,EAAM;MAC7B,IAAA,CAAK,WAAA,GAAc,IAAI,IAAA,CAAM,CAAA;IAC9B;IAED,IAAA,CAAK,WAAA,CAAY,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;EAC7C;EAED,qBAAA,CAAA,EAAwB;IACtB,IAAI,IAAA,CAAK,cAAA,KAAmB,IAAA,EAAM;MAChC,IAAA,CAAK,cAAA,GAAiB,IAAI,MAAA,CAAQ,CAAA;IACnC;IAED,IAAA,CAAK,cAAA,CAAe,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;EAChD;EAED,KAAA,CAAM,QAAA,EAAU,MAAA,EAAQ,mBAAA,GAAsB,CAAA,EAAG;IAC/C,IAAI,EAAE,QAAA,IAAY,QAAA,CAAS,UAAA,CAAA,EAAa;MACtC,OAAA,CAAQ,KAAA,CAAM,qEAAA,EAAuE,QAAQ,CAAA;MAC7F;IACD;IAED,IAAI,YAAA;IACJ,MAAM,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,MAAA;MACjC,SAAA,GAAY,IAAA,CAAK,QAAA;MACjB,SAAA,GAAY,QAAA,CAAS,QAAA;MACrB,MAAA,GAAS,IAAA,CAAK,KAAA;MACd,MAAA,GAAS,QAAA,CAAS,KAAA;MAClB,OAAA,GAAU,IAAA,CAAK,MAAA;MACf,OAAA,GAAU,QAAA,CAAS,MAAA;IAErB,IAAI,MAAA,KAAW,KAAA,CAAA,EAAW;MACxB,YAAA,GAAe,IAAI,OAAA,CAAA,CAAA,CAAU,eAAA,CAAgB,MAAM,CAAA;IACpD;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,SAAA,CAAU,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAClD,MAAM,MAAA,GAAS,SAAA,CAAU,CAAC,CAAA;MAE1B,MAAM,UAAA,GAAa,MAAA,CAAO,KAAA,CAAO,CAAA;MAEjC,IAAI,MAAA,KAAW,KAAA,CAAA,EAAW,UAAA,CAAW,YAAA,CAAa,MAAM,CAAA;MAExD,SAAA,CAAU,IAAA,CAAK,UAAU,CAAA;IAC1B;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAChD,OAAA,CAAQ,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA,CAAK,CAAE,CAAA;IAChC;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/C,MAAM,IAAA,GAAO,MAAA,CAAO,CAAC,CAAA;MACrB,IAAI,MAAA,EAAQ,KAAA;MACZ,MAAM,iBAAA,GAAoB,IAAA,CAAK,aAAA;QAC7B,gBAAA,GAAmB,IAAA,CAAK,YAAA;MAE1B,MAAM,QAAA,GAAW,IAAI,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,YAAA,EAAc,IAAA,CAAK,CAAA,GAAI,YAAA,EAAc,IAAA,CAAK,CAAA,GAAI,YAAY,CAAA;MAC9F,QAAA,CAAS,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;MAEhC,IAAI,YAAA,KAAiB,KAAA,CAAA,EAAW;QAC9B,QAAA,CAAS,MAAA,CAAO,YAAA,CAAa,YAAY,CAAA,CAAE,SAAA,CAAW,CAAA;MACvD;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,iBAAA,CAAkB,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC1D,MAAA,GAAS,iBAAA,CAAkB,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;QAErC,IAAI,YAAA,KAAiB,KAAA,CAAA,EAAW;UAC9B,MAAA,CAAO,YAAA,CAAa,YAAY,CAAA,CAAE,SAAA,CAAW,CAAA;QAC9C;QAED,QAAA,CAAS,aAAA,CAAc,IAAA,CAAK,MAAM,CAAA;MACnC;MAED,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,KAAK,CAAA;MAE9B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,gBAAA,CAAiB,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACzD,KAAA,GAAQ,gBAAA,CAAiB,CAAC,CAAA;QAC1B,QAAA,CAAS,YAAA,CAAa,IAAA,CAAK,KAAA,CAAM,KAAA,CAAK,CAAE,CAAA;MACzC;MAED,QAAA,CAAS,aAAA,GAAgB,IAAA,CAAK,aAAA,GAAgB,mBAAA;MAE9C,MAAA,CAAO,IAAA,CAAK,QAAQ,CAAA;IACrB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/D,MAAM,cAAA,GAAiB,QAAA,CAAS,aAAA,CAAc,CAAC,CAAA;MAE/C,IAAI,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,KAAM,KAAA,CAAA,EAAW,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,EAAE;MAEnE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,cAAA,CAAe,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACvD,MAAM,IAAA,GAAO,cAAA,CAAe,CAAC,CAAA;UAC3B,OAAA,GAAU,EAAE;QAEd,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UAC7C,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA,CAAE,KAAA,CAAK,CAAE,CAAA;QAC7B;QAED,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;MACnC;IACF;EACF;EAED,SAAA,CAAU,IAAA,EAAM;IACd,IAAI,EAAE,IAAA,IAAQ,IAAA,CAAK,MAAA,CAAA,EAAS;MAC1B,OAAA,CAAQ,KAAA,CAAM,iEAAA,EAAmE,IAAI,CAAA;MACrF;IACD;IAED,IAAI,IAAA,CAAK,gBAAA,EAAkB,IAAA,CAAK,YAAA,CAAc,CAAA;IAE9C,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,MAAM,CAAA;EACtC;EAAA;AAAA;AAAA;AAAA;AAAA;EAQD,aAAA,CAAc,eAAA,GAAkB,CAAA,EAAG;IACjC,MAAM,WAAA,GAAc,CAAE,CAAA;IACtB,MAAM,MAAA,GAAS,EAAE;MACf,OAAA,GAAU,EAAE;IAEd,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,eAAe,CAAA;IAE9C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACtD,MAAM,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;MACzB,MAAM,GAAA,GAAM,GAAG,IAAA,CAAK,KAAA,CAAM,CAAA,CAAE,CAAA,GAAI,SAAS,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,CAAA,CAAE,CAAA,GAAI,SAAS,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,CAAA,CAAE,CAAA,GAAI,SAAS,CAAA,EAAA;MAEvG,IAAI,WAAA,CAAY,GAAG,CAAA,KAAM,KAAA,CAAA,EAAW;QAClC,WAAA,CAAY,GAAG,CAAA,GAAI,CAAA;QACnB,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,CAAC,CAAC,CAAA;QAC5B,OAAA,CAAQ,CAAC,CAAA,GAAI,MAAA,CAAO,MAAA,GAAS,CAAA;MACrC,CAAA,MAAa;QAEL,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,WAAA,CAAY,GAAG,CAAC,CAAA;MACtC;IACF;IAID,MAAM,mBAAA,GAAsB,EAAE;IAE9B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,IAAA,CAAK,CAAA,GAAI,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA;MACvB,IAAA,CAAK,CAAA,GAAI,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA;MACvB,IAAA,CAAK,CAAA,GAAI,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA;MAEvB,MAAM,OAAA,GAAU,CAAC,IAAA,CAAK,CAAA,EAAG,IAAA,CAAK,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA;MAIvC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QAC1B,IAAI,OAAA,CAAQ,CAAC,CAAA,KAAM,OAAA,CAAA,CAAS,CAAA,GAAI,CAAA,IAAK,CAAC,CAAA,EAAG;UACvC,mBAAA,CAAoB,IAAA,CAAK,CAAC,CAAA;UAC1B;QACD;MACF;IACF;IAED,KAAA,IAAS,CAAA,GAAI,mBAAA,CAAoB,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;MACxD,MAAM,GAAA,GAAM,mBAAA,CAAoB,CAAC,CAAA;MAEjC,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,GAAA,EAAK,CAAC,CAAA;MAExB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC3D,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,MAAA,CAAO,GAAA,EAAK,CAAC,CAAA;MACpC;IACF;IAID,MAAM,IAAA,GAAO,IAAA,CAAK,QAAA,CAAS,MAAA,GAAS,MAAA,CAAO,MAAA;IAC3C,IAAA,CAAK,QAAA,GAAW,MAAA;IAChB,OAAO,IAAA;EACR;EAED,aAAA,CAAc,MAAA,EAAQ;IACpB,IAAA,CAAK,QAAA,GAAW,EAAE;IAElB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;MAC7C,MAAM,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA;MACtB,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,IAAI,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,KAAA,CAAM,CAAA,EAAG,KAAA,CAAM,CAAA,IAAK,CAAC,CAAC,CAAA;IAC/D;IAED,OAAO,IAAA;EACR;EAED,wBAAA,CAAA,EAA2B;IACzB,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA;IACnB,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA;IAIrB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC/B,KAAA,CAAM,CAAC,CAAA,CAAE,GAAA,GAAM,CAAA;IAChB;IAID,SAAS,iBAAA,CAAkB,CAAA,EAAG,CAAA,EAAG;MAC/B,OAAO,CAAA,CAAE,aAAA,GAAgB,CAAA,CAAE,aAAA;IAC5B;IAED,KAAA,CAAM,IAAA,CAAK,iBAAiB,CAAA;IAI5B,MAAM,IAAA,GAAO,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA;IACjC,MAAM,IAAA,GAAO,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA;IAEjC,IAAI,OAAA,EAAS,OAAA;IAEb,IAAI,IAAA,IAAQ,IAAA,CAAK,MAAA,KAAW,MAAA,EAAQ,OAAA,GAAU,EAAE;IAChD,IAAI,IAAA,IAAQ,IAAA,CAAK,MAAA,KAAW,MAAA,EAAQ,OAAA,GAAU,EAAE;IAEhD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC/B,MAAM,EAAA,GAAK,KAAA,CAAM,CAAC,CAAA,CAAE,GAAA;MAEpB,IAAI,OAAA,EAAS,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,EAAE,CAAC,CAAA;MAClC,IAAI,OAAA,EAAS,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,EAAE,CAAC,CAAA;IACnC;IAED,IAAI,OAAA,EAAS,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,OAAA;IACrC,IAAI,OAAA,EAAS,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,OAAA;EACtC;EAED,MAAA,CAAA,EAAS;IACP,MAAM,IAAA,GAAO;MACX,QAAA,EAAU;QACR,OAAA,EAAS,GAAA;QACT,IAAA,EAAM,UAAA;QACN,SAAA,EAAW;MACZ;IACF,CAAA;IAID,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,IAAA;IACjB,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,IAAA;IACjB,IAAI,IAAA,CAAK,IAAA,KAAS,EAAA,EAAI,IAAA,CAAK,IAAA,GAAO,IAAA,CAAK,IAAA;IAEvC,IAAI,IAAA,CAAK,UAAA,KAAe,KAAA,CAAA,EAAW;MACjC,MAAM,UAAA,GAAa,IAAA,CAAK,UAAA;MAExB,KAAA,IAAS,GAAA,IAAO,UAAA,EAAY;QAC1B,IAAI,UAAA,CAAW,GAAG,CAAA,KAAM,KAAA,CAAA,EAAW,IAAA,CAAK,GAAG,CAAA,GAAI,UAAA,CAAW,GAAG,CAAA;MAC9D;MAED,OAAO,IAAA;IACR;IAED,MAAM,QAAA,GAAW,EAAE;IAEnB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC7C,MAAM,MAAA,GAAS,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;MAC9B,QAAA,CAAS,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAC,CAAA;IAC3C;IAED,MAAM,KAAA,GAAQ,EAAE;IAChB,MAAM,OAAA,GAAU,EAAE;IAClB,MAAM,WAAA,GAAc,CAAE,CAAA;IACtB,MAAM,MAAA,GAAS,EAAE;IACjB,MAAM,UAAA,GAAa,CAAE,CAAA;IACrB,MAAM,GAAA,GAAM,EAAE;IACd,MAAM,OAAA,GAAU,CAAE,CAAA;IAElB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC1C,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;MAEzB,MAAM,WAAA,GAAc,IAAA;MACpB,MAAM,SAAA,GAAY,KAAA;MAClB,MAAM,eAAA,GAAkB,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,CAAC,CAAA,KAAM,KAAA,CAAA;MACrD,MAAM,aAAA,GAAgB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAQ,CAAA,GAAG,CAAA;MAC7C,MAAM,mBAAA,GAAsB,IAAA,CAAK,aAAA,CAAc,MAAA,GAAS,CAAA;MACxD,MAAM,YAAA,GAAe,IAAA,CAAK,KAAA,CAAM,CAAA,KAAM,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,CAAA,KAAM,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,CAAA,KAAM,CAAA;MAClF,MAAM,kBAAA,GAAqB,IAAA,CAAK,YAAA,CAAa,MAAA,GAAS,CAAA;MAEtD,IAAI,QAAA,GAAW,CAAA;MAEf,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,CAAC,CAAA;MAChC,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,WAAW,CAAA;MAC1C,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,SAAS,CAAA;MACxC,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,eAAe,CAAA;MAC9C,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,aAAa,CAAA;MAC5C,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,mBAAmB,CAAA;MAClD,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,YAAY,CAAA;MAC3C,QAAA,GAAW,MAAA,CAAO,QAAA,EAAU,CAAA,EAAG,kBAAkB,CAAA;MAEjD,KAAA,CAAM,IAAA,CAAK,QAAQ,CAAA;MACnB,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,CAAA,EAAG,IAAA,CAAK,CAAA,EAAG,IAAA,CAAK,CAAC,CAAA;MACjC,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,aAAa,CAAA;MAE7B,IAAI,eAAA,EAAiB;QACnB,MAAM,aAAA,GAAgB,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,CAAC,CAAA;QAE7C,KAAA,CAAM,IAAA,CAAK,UAAA,CAAW,aAAA,CAAc,CAAC,CAAC,CAAA,EAAG,UAAA,CAAW,aAAA,CAAc,CAAC,CAAC,CAAA,EAAG,UAAA,CAAW,aAAA,CAAc,CAAC,CAAC,CAAC,CAAA;MACpG;MAED,IAAI,aAAA,EAAe;QACjB,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK,MAAM,CAAC,CAAA;MACvC;MAED,IAAI,mBAAA,EAAqB;QACvB,MAAM,aAAA,GAAgB,IAAA,CAAK,aAAA;QAE3B,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,aAAA,CAAc,CAAC,CAAC,CAAA,EAAG,cAAA,CAAe,aAAA,CAAc,CAAC,CAAC,CAAA,EAAG,cAAA,CAAe,aAAA,CAAc,CAAC,CAAC,CAAC,CAAA;MAChH;MAED,IAAI,YAAA,EAAc;QAChB,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,KAAK,CAAC,CAAA;MACrC;MAED,IAAI,kBAAA,EAAoB;QACtB,MAAM,YAAA,GAAe,IAAA,CAAK,YAAA;QAE1B,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,YAAA,CAAa,CAAC,CAAC,CAAA,EAAG,aAAA,CAAc,YAAA,CAAa,CAAC,CAAC,CAAA,EAAG,aAAA,CAAc,YAAA,CAAa,CAAC,CAAC,CAAC,CAAA;MAC1G;IACF;IAED,SAAS,MAAA,CAAO,KAAA,EAAO,QAAA,EAAU,OAAA,EAAS;MACxC,OAAO,OAAA,GAAU,KAAA,GAAS,CAAA,IAAK,QAAA,GAAY,KAAA,GAAQ,EAAE,CAAA,IAAK,QAAA,CAAA;IAC3D;IAED,SAAS,cAAA,CAAe,MAAA,EAAQ;MAC9B,MAAM,IAAA,GAAO,MAAA,CAAO,CAAA,CAAE,QAAA,CAAQ,CAAA,GAAK,MAAA,CAAO,CAAA,CAAE,QAAA,CAAU,CAAA,GAAG,MAAA,CAAO,CAAA,CAAE,QAAA,CAAU,CAAA;MAE5E,IAAI,WAAA,CAAY,IAAI,CAAA,KAAM,KAAA,CAAA,EAAW;QACnC,OAAO,WAAA,CAAY,IAAI,CAAA;MACxB;MAED,WAAA,CAAY,IAAI,CAAA,GAAI,OAAA,CAAQ,MAAA,GAAS,CAAA;MACrC,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAC,CAAA;MAEzC,OAAO,WAAA,CAAY,IAAI,CAAA;IACxB;IAED,SAAS,aAAA,CAAc,KAAA,EAAO;MAC5B,MAAM,IAAA,GAAO,KAAA,CAAM,CAAA,CAAE,QAAA,CAAQ,CAAA,GAAK,KAAA,CAAM,CAAA,CAAE,QAAA,CAAU,CAAA,GAAG,KAAA,CAAM,CAAA,CAAE,QAAA,CAAU,CAAA;MAEzE,IAAI,UAAA,CAAW,IAAI,CAAA,KAAM,KAAA,CAAA,EAAW;QAClC,OAAO,UAAA,CAAW,IAAI,CAAA;MACvB;MAED,UAAA,CAAW,IAAI,CAAA,GAAI,MAAA,CAAO,MAAA;MAC1B,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,MAAA,CAAA,CAAQ,CAAA;MAE1B,OAAO,UAAA,CAAW,IAAI,CAAA;IACvB;IAED,SAAS,UAAA,CAAW,EAAA,EAAI;MACtB,MAAM,IAAA,GAAO,EAAA,CAAG,CAAA,CAAE,QAAA,CAAQ,CAAA,GAAK,EAAA,CAAG,CAAA,CAAE,QAAA,CAAU,CAAA;MAE9C,IAAI,OAAA,CAAQ,IAAI,CAAA,KAAM,KAAA,CAAA,EAAW;QAC/B,OAAO,OAAA,CAAQ,IAAI,CAAA;MACpB;MAED,OAAA,CAAQ,IAAI,CAAA,GAAI,GAAA,CAAI,MAAA,GAAS,CAAA;MAC7B,GAAA,CAAI,IAAA,CAAK,EAAA,CAAG,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA;MAEnB,OAAO,OAAA,CAAQ,IAAI,CAAA;IACpB;IAED,IAAA,CAAK,IAAA,GAAO,CAAE,CAAA;IAEd,IAAA,CAAK,IAAA,CAAK,QAAA,GAAW,QAAA;IACrB,IAAA,CAAK,IAAA,CAAK,OAAA,GAAU,OAAA;IACpB,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,MAAA;IAC1C,IAAI,GAAA,CAAI,MAAA,GAAS,CAAA,EAAG,IAAA,CAAK,IAAA,CAAK,GAAA,GAAM,CAAC,GAAG,CAAA;IACxC,IAAA,CAAK,IAAA,CAAK,KAAA,GAAQ,KAAA;IAElB,OAAO,IAAA;EACR;EAED,KAAA,CAAA,EAAQ;IAyBN,OAAO,IAAI,QAAA,CAAQ,CAAA,CAAG,IAAA,CAAK,IAAI,CAAA;EAChC;EAED,IAAA,CAAK,MAAA,EAAQ;IAGX,IAAA,CAAK,QAAA,GAAW,EAAE;IAClB,IAAA,CAAK,MAAA,GAAS,EAAE;IAChB,IAAA,CAAK,KAAA,GAAQ,EAAE;IACf,IAAA,CAAK,aAAA,GAAgB,CAAC,EAAE,CAAA;IACxB,IAAA,CAAK,YAAA,GAAe,EAAE;IACtB,IAAA,CAAK,YAAA,GAAe,EAAE;IACtB,IAAA,CAAK,WAAA,GAAc,EAAE;IACrB,IAAA,CAAK,WAAA,GAAc,EAAE;IACrB,IAAA,CAAK,aAAA,GAAgB,EAAE;IACvB,IAAA,CAAK,WAAA,GAAc,IAAA;IACnB,IAAA,CAAK,cAAA,GAAiB,IAAA;IAItB,IAAA,CAAK,IAAA,GAAO,MAAA,CAAO,IAAA;IAInB,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA;IAExB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACjD,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;IACvC;IAID,MAAM,MAAA,GAAS,MAAA,CAAO,MAAA;IAEtB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/C,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;IACnC;IAID,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA;IAErB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;IACjC;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC7D,MAAM,aAAA,GAAgB,MAAA,CAAO,aAAA,CAAc,CAAC,CAAA;MAE5C,IAAI,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,KAAM,KAAA,CAAA,EAAW;QACvC,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,EAAE;MAC3B;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACtD,MAAM,GAAA,GAAM,aAAA,CAAc,CAAC,CAAA;UACzB,OAAA,GAAU,EAAE;QAEd,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UAC5C,MAAM,EAAA,GAAK,GAAA,CAAI,CAAC,CAAA;UAEhB,OAAA,CAAQ,IAAA,CAAK,EAAA,CAAG,KAAA,CAAA,CAAO,CAAA;QACxB;QAED,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;MACnC;IACF;IAID,MAAM,YAAA,GAAe,MAAA,CAAO,YAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACrD,MAAM,WAAA,GAAc,CAAE,CAAA;MACtB,WAAA,CAAY,IAAA,GAAO,YAAA,CAAa,CAAC,CAAA,CAAE,IAAA;MAInC,IAAI,YAAA,CAAa,CAAC,CAAA,CAAE,QAAA,KAAa,KAAA,CAAA,EAAW;QAC1C,WAAA,CAAY,QAAA,GAAW,EAAE;QAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,CAAC,CAAA,CAAE,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACjE,WAAA,CAAY,QAAA,CAAS,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;QAC9D;MACF;MAID,IAAI,YAAA,CAAa,CAAC,CAAA,CAAE,OAAA,KAAY,KAAA,CAAA,EAAW;QACzC,WAAA,CAAY,OAAA,GAAU,EAAE;QAExB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,CAAC,CAAA,CAAE,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UAChE,WAAA,CAAY,OAAA,CAAQ,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;QAC5D;MACF;MAED,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,WAAW,CAAA;IACnC;IAID,MAAM,YAAA,GAAe,MAAA,CAAO,YAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACrD,MAAM,WAAA,GAAc,CAAE,CAAA;MAItB,IAAI,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA,KAAkB,KAAA,CAAA,EAAW;QAC/C,WAAA,CAAY,aAAA,GAAgB,EAAE;QAE9B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACtE,MAAM,eAAA,GAAkB,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA,CAAc,CAAC,CAAA;UACvD,MAAM,gBAAA,GAAmB,CAAE,CAAA;UAE3B,gBAAA,CAAiB,CAAA,GAAI,eAAA,CAAgB,CAAA,CAAE,KAAA,CAAO,CAAA;UAC9C,gBAAA,CAAiB,CAAA,GAAI,eAAA,CAAgB,CAAA,CAAE,KAAA,CAAO,CAAA;UAC9C,gBAAA,CAAiB,CAAA,GAAI,eAAA,CAAgB,CAAA,CAAE,KAAA,CAAO,CAAA;UAE9C,WAAA,CAAY,aAAA,CAAc,IAAA,CAAK,gBAAgB,CAAA;QAChD;MACF;MAID,IAAI,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,KAAgB,KAAA,CAAA,EAAW;QAC7C,WAAA,CAAY,WAAA,GAAc,EAAE;QAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACpE,WAAA,CAAY,WAAA,CAAY,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;QACpE;MACF;MAED,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,WAAW,CAAA;IACnC;IAID,MAAM,WAAA,GAAc,MAAA,CAAO,WAAA;IAE3B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,WAAA,CAAY,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;IAC7C;IAID,MAAM,WAAA,GAAc,MAAA,CAAO,WAAA;IAE3B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,WAAA,CAAY,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA,CAAE,KAAA,CAAA,CAAO,CAAA;IAC7C;IAID,MAAM,aAAA,GAAgB,MAAA,CAAO,aAAA;IAE7B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACtD,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC,CAAA;IACzC;IAID,MAAM,WAAA,GAAc,MAAA,CAAO,WAAA;IAE3B,IAAI,WAAA,KAAgB,IAAA,EAAM;MACxB,IAAA,CAAK,WAAA,GAAc,WAAA,CAAY,KAAA,CAAO,CAAA;IACvC;IAID,MAAM,cAAA,GAAiB,MAAA,CAAO,cAAA;IAE9B,IAAI,cAAA,KAAmB,IAAA,EAAM;MAC3B,IAAA,CAAK,cAAA,GAAiB,cAAA,CAAe,KAAA,CAAO,CAAA;IAC7C;IAID,IAAA,CAAK,kBAAA,GAAqB,MAAA,CAAO,kBAAA;IACjC,IAAA,CAAK,kBAAA,GAAqB,MAAA,CAAO,kBAAA;IACjC,IAAA,CAAK,aAAA,GAAgB,MAAA,CAAO,aAAA;IAC5B,IAAA,CAAK,iBAAA,GAAoB,MAAA,CAAO,iBAAA;IAChC,IAAA,CAAK,gBAAA,GAAmB,MAAA,CAAO,gBAAA;IAC/B,IAAA,CAAK,uBAAA,GAA0B,MAAA,CAAO,uBAAA;IACtC,IAAA,CAAK,gBAAA,GAAmB,MAAA,CAAO,gBAAA;IAE/B,OAAO,IAAA;EACR;EAED,gBAAA,CAAA,EAAmB;IACjB,MAAM,QAAA,GAAW,IAAI,cAAA,CAAA,CAAA,CAAiB,YAAA,CAAa,IAAI,CAAA;IAEvD,MAAM,cAAA,GAAiB,IAAI,cAAA,CAAgB,CAAA;IAE3C,MAAM,SAAA,GAAY,IAAI,YAAA,CAAa,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA;IAC/D,cAAA,CAAe,YAAA,CAAa,UAAA,EAAY,IAAI,eAAA,CAAgB,SAAA,EAAW,CAAC,CAAA,CAAE,iBAAA,CAAkB,QAAA,CAAS,QAAQ,CAAC,CAAA;IAE9G,IAAI,QAAA,CAAS,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;MAC/B,MAAM,OAAA,GAAU,IAAI,YAAA,CAAa,QAAA,CAAS,OAAA,CAAQ,MAAA,GAAS,CAAC,CAAA;MAC5D,cAAA,CAAe,YAAA,CAAa,QAAA,EAAU,IAAI,eAAA,CAAgB,OAAA,EAAS,CAAC,CAAA,CAAE,iBAAA,CAAkB,QAAA,CAAS,OAAO,CAAC,CAAA;IAC1G;IAED,IAAI,QAAA,CAAS,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;MAC9B,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,QAAA,CAAS,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA;MAC1D,cAAA,CAAe,YAAA,CAAa,OAAA,EAAS,IAAI,eAAA,CAAgB,MAAA,EAAQ,CAAC,CAAA,CAAE,eAAA,CAAgB,QAAA,CAAS,MAAM,CAAC,CAAA;IACrG;IAED,IAAI,QAAA,CAAS,GAAA,CAAI,MAAA,GAAS,CAAA,EAAG;MAC3B,MAAM,GAAA,GAAM,IAAI,YAAA,CAAa,QAAA,CAAS,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA;MACpD,cAAA,CAAe,YAAA,CAAa,IAAA,EAAM,IAAI,eAAA,CAAgB,GAAA,EAAK,CAAC,CAAA,CAAE,iBAAA,CAAkB,QAAA,CAAS,GAAG,CAAC,CAAA;IAC9F;IAED,IAAI,QAAA,CAAS,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG;MAC5B,MAAM,IAAA,GAAO,IAAI,YAAA,CAAa,QAAA,CAAS,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;MACtD,cAAA,CAAe,YAAA,CAAa,KAAA,EAAO,IAAI,eAAA,CAAgB,IAAA,EAAM,CAAC,CAAA,CAAE,iBAAA,CAAkB,QAAA,CAAS,IAAI,CAAC,CAAA;IACjG;IAID,cAAA,CAAe,MAAA,GAAS,QAAA,CAAS,MAAA;IAIjC,KAAA,IAAS,IAAA,IAAQ,QAAA,CAAS,YAAA,EAAc;MACtC,MAAM,KAAA,GAAQ,EAAE;MAChB,MAAM,YAAA,GAAe,QAAA,CAAS,YAAA,CAAa,IAAI,CAAA;MAE/C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,MAAA,EAAQ,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;QACnD,MAAM,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA;QAElC,MAAM,SAAA,GAAY,IAAI,sBAAA,CAAuB,WAAA,CAAY,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG,CAAC,CAAA;QAC3E,SAAA,CAAU,IAAA,GAAO,WAAA,CAAY,IAAA;QAE7B,KAAA,CAAM,IAAA,CAAK,SAAA,CAAU,iBAAA,CAAkB,WAAA,CAAY,IAAI,CAAC,CAAA;MACzD;MAED,cAAA,CAAe,eAAA,CAAgB,IAAI,CAAA,GAAI,KAAA;IACxC;IAID,IAAI,QAAA,CAAS,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG;MACnC,MAAM,WAAA,GAAc,IAAI,sBAAA,CAAuB,QAAA,CAAS,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG,CAAC,CAAA;MACjF,cAAA,CAAe,YAAA,CAAa,WAAA,EAAa,WAAA,CAAY,iBAAA,CAAkB,QAAA,CAAS,WAAW,CAAC,CAAA;IAC7F;IAED,IAAI,QAAA,CAAS,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG;MACnC,MAAM,WAAA,GAAc,IAAI,sBAAA,CAAuB,QAAA,CAAS,WAAA,CAAY,MAAA,GAAS,CAAA,EAAG,CAAC,CAAA;MACjF,cAAA,CAAe,YAAA,CAAa,YAAA,EAAc,WAAA,CAAY,iBAAA,CAAkB,QAAA,CAAS,WAAW,CAAC,CAAA;IAC9F;IAID,IAAI,QAAA,CAAS,cAAA,KAAmB,IAAA,EAAM;MACpC,cAAA,CAAe,cAAA,GAAiB,QAAA,CAAS,cAAA,CAAe,KAAA,CAAO,CAAA;IAChE;IAED,IAAI,QAAA,CAAS,WAAA,KAAgB,IAAA,EAAM;MACjC,cAAA,CAAe,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,KAAA,CAAO,CAAA;IAC1D;IAED,OAAO,cAAA;EACR;EAED,eAAA,CAAA,EAAkB;IAChB,OAAA,CAAQ,KAAA,CAAM,sDAAsD,CAAA;EACrE;EAED,oBAAA,CAAA,EAAuB;IACrB,OAAA,CAAQ,KAAA,CACN,0GACD,CAAA;EACF;EAED,WAAA,CAAY,MAAA,EAAQ;IAClB,OAAA,CAAQ,IAAA,CAAK,qEAAqE,CAAA;IAClF,OAAO,IAAA,CAAK,YAAA,CAAa,MAAM,CAAA;EAChC;EAED,OAAA,CAAA,EAAU;IACR,IAAA,CAAK,aAAA,CAAc;MAAE,IAAA,EAAM;IAAS,CAAE,CAAA;EACvC;AACH;AAEA,MAAM,cAAA,CAAe;EACnB,WAAA,CAAA,EAAc;IACZ,IAAA,CAAK,QAAA,GAAW,EAAE;IAClB,IAAA,CAAK,OAAA,GAAU,EAAE;IACjB,IAAA,CAAK,MAAA,GAAS,EAAE;IAChB,IAAA,CAAK,GAAA,GAAM,EAAE;IACb,IAAA,CAAK,IAAA,GAAO,EAAE;IAEd,IAAA,CAAK,MAAA,GAAS,EAAE;IAEhB,IAAA,CAAK,YAAA,GAAe,CAAE,CAAA;IAEtB,IAAA,CAAK,WAAA,GAAc,EAAE;IACrB,IAAA,CAAK,WAAA,GAAc,EAAE;IAIrB,IAAA,CAAK,WAAA,GAAc,IAAA;IACnB,IAAA,CAAK,cAAA,GAAiB,IAAA;IAItB,IAAA,CAAK,kBAAA,GAAqB,KAAA;IAC1B,IAAA,CAAK,iBAAA,GAAoB,KAAA;IACzB,IAAA,CAAK,gBAAA,GAAmB,KAAA;IACxB,IAAA,CAAK,aAAA,GAAgB,KAAA;IACrB,IAAA,CAAK,gBAAA,GAAmB,KAAA;EACzB;EAED,aAAA,CAAc,QAAA,EAAU;IACtB,MAAM,MAAA,GAAS,EAAE;IAEjB,IAAI,KAAA,EAAO,CAAA;IACX,IAAI,aAAA,GAAgB,KAAA,CAAA;IAEpB,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA;IAEvB,KAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;MACjC,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;MAIpB,IAAI,IAAA,CAAK,aAAA,KAAkB,aAAA,EAAe;QACxC,aAAA,GAAgB,IAAA,CAAK,aAAA;QAErB,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;UACvB,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,CAAA,GAAI,KAAA,CAAM,KAAA;UAC5B,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;QAClB;QAED,KAAA,GAAQ;UACN,KAAA,EAAO,CAAA,GAAI,CAAA;UACX;QACD,CAAA;MACF;IACF;IAED,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;MACvB,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,CAAA,GAAI,KAAA,CAAM,KAAA;MAC5B,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;IAClB;IAED,IAAA,CAAK,MAAA,GAAS,MAAA;EACf;EAED,YAAA,CAAa,QAAA,EAAU;IACrB,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA;IACvB,MAAM,QAAA,GAAW,QAAA,CAAS,QAAA;IAC1B,MAAM,aAAA,GAAgB,QAAA,CAAS,aAAA;IAE/B,MAAM,eAAA,GAAkB,aAAA,CAAc,CAAC,CAAA,IAAK,aAAA,CAAc,CAAC,CAAA,CAAE,MAAA,GAAS,CAAA;IACtE,MAAM,gBAAA,GAAmB,aAAA,CAAc,CAAC,CAAA,IAAK,aAAA,CAAc,CAAC,CAAA,CAAE,MAAA,GAAS,CAAA;IAIvE,MAAM,YAAA,GAAe,QAAA,CAAS,YAAA;IAC9B,MAAM,kBAAA,GAAqB,YAAA,CAAa,MAAA;IAExC,IAAI,oBAAA;IAEJ,IAAI,kBAAA,GAAqB,CAAA,EAAG;MAC1B,oBAAA,GAAuB,EAAE;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,kBAAA,EAAoB,CAAA,EAAA,EAAK;QAC3C,oBAAA,CAAqB,CAAC,CAAA,GAAI;UACxB,IAAA,EAAM,YAAA,CAAa,CAAC,CAAA,CAAE,IAAA;UACtB,IAAA,EAAM;QACP,CAAA;MACF;MAED,IAAA,CAAK,YAAA,CAAa,QAAA,GAAW,oBAAA;IAC9B;IAED,MAAM,YAAA,GAAe,QAAA,CAAS,YAAA;IAC9B,MAAM,kBAAA,GAAqB,YAAA,CAAa,MAAA;IAExC,IAAI,kBAAA;IAEJ,IAAI,kBAAA,GAAqB,CAAA,EAAG;MAC1B,kBAAA,GAAqB,EAAE;MAEvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,kBAAA,EAAoB,CAAA,EAAA,EAAK;QAC3C,kBAAA,CAAmB,CAAC,CAAA,GAAI;UACtB,IAAA,EAAM,YAAA,CAAa,CAAC,CAAA,CAAE,IAAA;UACtB,IAAA,EAAM;QACP,CAAA;MACF;MAED,IAAA,CAAK,YAAA,CAAa,MAAA,GAAS,kBAAA;IAC5B;IAID,MAAM,WAAA,GAAc,QAAA,CAAS,WAAA;IAC7B,MAAM,WAAA,GAAc,QAAA,CAAS,WAAA;IAE7B,MAAM,cAAA,GAAiB,WAAA,CAAY,MAAA,KAAW,QAAA,CAAS,MAAA;IACvD,MAAM,cAAA,GAAiB,WAAA,CAAY,MAAA,KAAW,QAAA,CAAS,MAAA;IAIvD,IAAI,QAAA,CAAS,MAAA,GAAS,CAAA,IAAK,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;MAC7C,OAAA,CAAQ,KAAA,CAAM,8DAA8D,CAAA;IAC7E;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;MACrC,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;MAEpB,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,EAAG,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA,EAAG,QAAA,CAAS,IAAA,CAAK,CAAC,CAAC,CAAA;MAEvE,MAAM,aAAA,GAAgB,IAAA,CAAK,aAAA;MAE3B,IAAI,aAAA,CAAc,MAAA,KAAW,CAAA,EAAG;QAC9B,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,EAAG,aAAA,CAAc,CAAC,CAAA,EAAG,aAAA,CAAc,CAAC,CAAC,CAAA;MAC9E,CAAA,MAAa;QACL,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;QAEpB,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,MAAA,EAAQ,MAAA,EAAQ,MAAM,CAAA;MACzC;MAED,MAAM,YAAA,GAAe,IAAA,CAAK,YAAA;MAE1B,IAAI,YAAA,CAAa,MAAA,KAAW,CAAA,EAAG;QAC7B,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,EAAG,YAAA,CAAa,CAAC,CAAA,EAAG,YAAA,CAAa,CAAC,CAAC,CAAA;MAC1E,CAAA,MAAa;QACL,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA;QAEnB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,EAAO,KAAA,EAAO,KAAK,CAAA;MACrC;MAED,IAAI,eAAA,KAAoB,IAAA,EAAM;QAC5B,MAAM,SAAA,GAAY,aAAA,CAAc,CAAC,CAAA,CAAE,CAAC,CAAA;QAEpC,IAAI,SAAA,KAAc,KAAA,CAAA,EAAW;UAC3B,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA,EAAG,SAAA,CAAU,CAAC,CAAA,EAAG,SAAA,CAAU,CAAC,CAAC,CAAA;QAChE,CAAA,MAAe;UACL,OAAA,CAAQ,IAAA,CAAK,0DAAA,EAA4D,CAAC,CAAA;UAE1E,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,IAAI,OAAA,CAAS,CAAA,EAAE,IAAI,OAAA,CAAO,CAAA,EAAI,IAAI,OAAA,CAAA,CAAS,CAAA;QAC1D;MACF;MAED,IAAI,gBAAA,KAAqB,IAAA,EAAM;QAC7B,MAAM,SAAA,GAAY,aAAA,CAAc,CAAC,CAAA,CAAE,CAAC,CAAA;QAEpC,IAAI,SAAA,KAAc,KAAA,CAAA,EAAW;UAC3B,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA,EAAG,SAAA,CAAU,CAAC,CAAA,EAAG,SAAA,CAAU,CAAC,CAAC,CAAA;QACjE,CAAA,MAAe;UACL,OAAA,CAAQ,IAAA,CAAK,2DAAA,EAA6D,CAAC,CAAA;UAE3E,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,IAAI,OAAA,CAAS,CAAA,EAAE,IAAI,OAAA,CAAO,CAAA,EAAI,IAAI,OAAA,CAAA,CAAS,CAAA;QAC3D;MACF;MAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,kBAAA,EAAoB,CAAA,EAAA,EAAK;QAC3C,MAAM,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAE,QAAA;QAEpC,oBAAA,CAAqB,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAC,CAAA;MAChG;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,kBAAA,EAAoB,CAAA,EAAA,EAAK;QAC3C,MAAM,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAE,aAAA,CAAc,CAAC,CAAA;QAEnD,kBAAA,CAAmB,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EAAG,WAAA,CAAY,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA;MAC5E;MAID,IAAI,cAAA,EAAgB;QAClB,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAC,CAAA;MACpF;MAED,IAAI,cAAA,EAAgB;QAClB,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,CAAC,CAAC,CAAA;MACpF;IACF;IAED,IAAA,CAAK,aAAA,CAAc,QAAQ,CAAA;IAE3B,IAAA,CAAK,kBAAA,GAAqB,QAAA,CAAS,kBAAA;IACnC,IAAA,CAAK,iBAAA,GAAoB,QAAA,CAAS,iBAAA;IAClC,IAAA,CAAK,gBAAA,GAAmB,QAAA,CAAS,gBAAA;IACjC,IAAA,CAAK,aAAA,GAAgB,QAAA,CAAS,aAAA;IAC9B,IAAA,CAAK,gBAAA,GAAmB,QAAA,CAAS,gBAAA;IAEjC,IAAI,QAAA,CAAS,cAAA,KAAmB,IAAA,EAAM;MACpC,IAAA,CAAK,cAAA,GAAiB,QAAA,CAAS,cAAA,CAAe,KAAA,CAAO,CAAA;IACtD;IAED,IAAI,QAAA,CAAS,WAAA,KAAgB,IAAA,EAAM;MACjC,IAAA,CAAK,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,KAAA,CAAO,CAAA;IAChD;IAED,OAAO,IAAA;EACR;AACH;AAEA,MAAM,KAAA,CAAM;EACV,WAAA,CAAY,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,MAAA,EAAQ,KAAA,EAAO,aAAA,GAAgB,CAAA,EAAG;IACrD,IAAA,CAAK,CAAA,GAAI,CAAA;IACT,IAAA,CAAK,CAAA,GAAI,CAAA;IACT,IAAA,CAAK,CAAA,GAAI,CAAA;IAET,IAAA,CAAK,MAAA,GAAS,MAAA,IAAU,MAAA,CAAO,SAAA,GAAY,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;IACjE,IAAA,CAAK,aAAA,GAAgB,KAAA,CAAM,OAAA,CAAQ,MAAM,CAAA,GAAI,MAAA,GAAS,EAAE;IAExD,IAAA,CAAK,KAAA,GAAQ,KAAA,IAAS,KAAA,CAAM,OAAA,GAAU,KAAA,GAAQ,IAAI,KAAA,CAAO,CAAA;IACzD,IAAA,CAAK,YAAA,GAAe,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,KAAA,GAAQ,EAAE;IAErD,IAAA,CAAK,aAAA,GAAgB,aAAA;EACtB;EAED,KAAA,CAAA,EAAQ;IACN,OAAO,IAAI,IAAA,CAAK,WAAA,CAAA,CAAA,CAAc,IAAA,CAAK,IAAI,CAAA;EACxC;EAED,IAAA,CAAK,MAAA,EAAQ;IACX,IAAA,CAAK,CAAA,GAAI,MAAA,CAAO,CAAA;IAChB,IAAA,CAAK,CAAA,GAAI,MAAA,CAAO,CAAA;IAChB,IAAA,CAAK,CAAA,GAAI,MAAA,CAAO,CAAA;IAEhB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;IAC9B,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAA,CAAO,KAAK,CAAA;IAE5B,IAAA,CAAK,aAAA,GAAgB,MAAA,CAAO,aAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,aAAA,CAAc,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC7D,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,MAAA,CAAO,aAAA,CAAc,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;IACxD;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,YAAA,CAAa,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC5D,IAAA,CAAK,YAAA,CAAa,CAAC,CAAA,GAAI,MAAA,CAAO,YAAA,CAAa,CAAC,CAAA,CAAE,KAAA,CAAO,CAAA;IACtD;IAED,OAAO,IAAA;EACR;AACH","sourcesContent":["import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  EventDispatcher,\n  Float32BufferAttribute,\n  Matrix3,\n  Matrix4,\n  MathUtils,\n  Object3D,\n  Sphere,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst _m1 = new Matrix4()\nconst _obj = new Object3D()\nconst _offset = new Vector3()\n\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry()\n\n    const geometry = object.geometry\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3)\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3)\n\n      buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices))\n      buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors))\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1)\n\n        buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances))\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone()\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry()\n    }\n\n    return buffergeometry\n  }\n\n  constructor() {\n    super()\n    this.isGeometry = true\n    this.uuid = MathUtils.generateUUID()\n\n    this.name = ''\n    this.type = 'Geometry'\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n\n    this.morphTargets = []\n    this.morphNormals = []\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    this.lineDistances = []\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.elementsNeedUpdate = false\n    this.verticesNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.lineDistancesNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i]\n      vertex.applyMatrix4(matrix)\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n      face.normal.applyMatrix3(normalMatrix).normalize()\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    this.verticesNeedUpdate = true\n    this.normalsNeedUpdate = true\n\n    return this\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector)\n\n    _obj.updateMatrix()\n\n    this.applyMatrix4(_obj.matrix)\n\n    return this\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this\n\n    const index = geometry.index !== null ? geometry.index : undefined\n    const attributes = geometry.attributes\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.')\n      return this\n    }\n\n    const position = attributes.position\n    const normal = attributes.normal\n    const color = attributes.color\n    const uv = attributes.uv\n    const uv2 = attributes.uv2\n\n    if (uv2 !== undefined) this.faceVertexUvs[1] = []\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i))\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i))\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors =\n        color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()]\n\n      const vertexNormals =\n        normal === undefined\n          ? []\n          : [\n              new Vector3().fromBufferAttribute(normal, a),\n              new Vector3().fromBufferAttribute(normal, b),\n              new Vector3().fromBufferAttribute(normal, c),\n            ]\n\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex)\n\n      scope.faces.push(face)\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c),\n        ])\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c),\n        ])\n      }\n    }\n\n    const groups = geometry.groups\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i]\n\n        const start = group.start\n        const count = group.count\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex)\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex)\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2))\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2)\n        }\n      }\n    }\n\n    this.computeFaceNormals()\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    return this\n  }\n\n  center() {\n    this.computeBoundingBox()\n\n    this.boundingBox.getCenter(_offset).negate()\n\n    this.translate(_offset.x, _offset.y, _offset.z)\n\n    return this\n  }\n\n  normalize() {\n    this.computeBoundingSphere()\n\n    const center = this.boundingSphere.center\n    const radius = this.boundingSphere.radius\n\n    const s = radius === 0 ? 1 : 1.0 / radius\n\n    const matrix = new Matrix4()\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1)\n\n    this.applyMatrix4(matrix)\n\n    return this\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vA = this.vertices[face.a]\n      const vB = this.vertices[face.b]\n      const vC = this.vertices[face.c]\n\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab)\n\n      cb.normalize()\n\n      face.normal.copy(cb)\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length)\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3()\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n\n      const cb = new Vector3(),\n        ab = new Vector3()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const vA = this.vertices[face.a]\n        const vB = this.vertices[face.b]\n        const vC = this.vertices[face.c]\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        vertices[face.a].add(cb)\n        vertices[face.b].add(cb)\n        vertices[face.c].add(cb)\n      }\n    } else {\n      this.computeFaceNormals()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        vertices[face.a].add(face.normal)\n        vertices[face.b].add(face.normal)\n        vertices[face.c].add(face.normal)\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize()\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a])\n        vertexNormals[1].copy(vertices[face.b])\n        vertexNormals[2].copy(vertices[face.c])\n      } else {\n        vertexNormals[0] = vertices[face.a].clone()\n        vertexNormals[1] = vertices[face.b].clone()\n        vertexNormals[2] = vertices[face.c].clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal)\n        vertexNormals[1].copy(face.normal)\n        vertexNormals[2].copy(face.normal)\n      } else {\n        vertexNormals[0] = face.normal.clone()\n        vertexNormals[1] = face.normal.clone()\n        vertexNormals[2] = face.normal.clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone()\n      } else {\n        face.__originalFaceNormal.copy(face.normal)\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = []\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone()\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i])\n        }\n      }\n    }\n\n    // use temp geometry to compute face and vertex normals for each morph\n\n    const tmpGeo = new Geometry()\n    tmpGeo.faces = this.faces\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {}\n        this.morphNormals[i].faceNormals = []\n        this.morphNormals[i].vertexNormals = []\n\n        const dstNormalsFace = this.morphNormals[i].faceNormals\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3()\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3(),\n          }\n\n          dstNormalsFace.push(faceNormal)\n          dstNormalsVertex.push(vertexNormals)\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]\n\n      // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices\n\n      // compute morph normals\n\n      tmpGeo.computeFaceNormals()\n      tmpGeo.computeVertexNormals()\n\n      // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const faceNormal = morphNormals.faceNormals[f]\n        const vertexNormals = morphNormals.vertexNormals[f]\n\n        faceNormal.copy(face.normal)\n\n        vertexNormals.a.copy(face.vertexNormals[0])\n        vertexNormals.b.copy(face.vertexNormals[1])\n        vertexNormals.c.copy(face.vertexNormals[2])\n      }\n    }\n\n    // restore original normals\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      face.normal = face.__originalFaceNormal\n      face.vertexNormals = face.__originalVertexNormals\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    this.boundingBox.setFromPoints(this.vertices)\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices)\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry)\n      return\n    }\n\n    let normalMatrix\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix)\n    }\n\n    // vertices\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i]\n\n      const vertexCopy = vertex.clone()\n\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix)\n\n      vertices1.push(vertexCopy)\n    }\n\n    // colors\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone())\n    }\n\n    // faces\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i]\n      let normal, color\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors\n\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset)\n      faceCopy.normal.copy(face.normal)\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize()\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone()\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize()\n        }\n\n        faceCopy.vertexNormals.push(normal)\n      }\n\n      faceCopy.color.copy(face.color)\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j]\n        faceCopy.vertexColors.push(color.clone())\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset\n\n      faces1.push(faceCopy)\n    }\n\n    // uvs\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = []\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh)\n      return\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix()\n\n    this.merge(mesh.geometry, mesh.matrix)\n  }\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {} // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n    const unique = [],\n      changes = []\n\n    const precision = Math.pow(10, precisionPoints)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i]\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i\n        unique.push(this.vertices[i])\n        changes[i] = unique.length - 1\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]]\n      }\n    }\n\n    // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n    const faceIndicesToRemove = []\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n\n      face.a = changes[face.a]\n      face.b = changes[face.b]\n      face.c = changes[face.c]\n\n      const indices = [face.a, face.b, face.c]\n\n      // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i)\n          break\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i]\n\n      this.faces.splice(idx, 1)\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1)\n      }\n    }\n\n    // Use unique set of vertices\n\n    const diff = this.vertices.length - unique.length\n    this.vertices = unique\n    return diff\n  }\n\n  setFromPoints(points) {\n    this.vertices = []\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i]\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0))\n    }\n\n    return this\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces\n    const length = faces.length\n\n    // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i\n    }\n\n    // sort faces\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex\n    }\n\n    faces.sort(materialIndexSort)\n\n    // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0]\n    const uvs2 = this.faceVertexUvs[1]\n\n    let newUvs1, newUvs2\n\n    if (uvs1 && uvs1.length === length) newUvs1 = []\n    if (uvs2 && uvs2.length === length) newUvs2 = []\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id\n\n      if (newUvs1) newUvs1.push(uvs1[id])\n      if (newUvs2) newUvs2.push(uvs2[id])\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON',\n      },\n    }\n\n    // standard Geometry serialization\n\n    data.uuid = this.uuid\n    data.type = this.type\n    if (this.name !== '') data.name = this.name\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key]\n      }\n\n      return data\n    }\n\n    const vertices = []\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i]\n      vertices.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    const faces = []\n    const normals = []\n    const normalsHash = {}\n    const colors = []\n    const colorsHash = {}\n    const uvs = []\n    const uvsHash = {}\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      const hasMaterial = true\n      const hasFaceUv = false // deprecated\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined\n      const hasFaceNormal = face.normal.length() > 0\n      const hasFaceVertexNormal = face.vertexNormals.length > 0\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1\n      const hasFaceVertexColor = face.vertexColors.length > 0\n\n      let faceType = 0\n\n      faceType = setBit(faceType, 0, 0) // isQuad\n      faceType = setBit(faceType, 1, hasMaterial)\n      faceType = setBit(faceType, 2, hasFaceUv)\n      faceType = setBit(faceType, 3, hasFaceVertexUv)\n      faceType = setBit(faceType, 4, hasFaceNormal)\n      faceType = setBit(faceType, 5, hasFaceVertexNormal)\n      faceType = setBit(faceType, 6, hasFaceColor)\n      faceType = setBit(faceType, 7, hasFaceVertexColor)\n\n      faces.push(faceType)\n      faces.push(face.a, face.b, face.c)\n      faces.push(face.materialIndex)\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i]\n\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal))\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals\n\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color))\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors\n\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | (1 << position) : value & ~(1 << position)\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString()\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash]\n      }\n\n      normalsHash[hash] = normals.length / 3\n      normals.push(normal.x, normal.y, normal.z)\n\n      return normalsHash[hash]\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString()\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash]\n      }\n\n      colorsHash[hash] = colors.length\n      colors.push(color.getHex())\n\n      return colorsHash[hash]\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString()\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash]\n      }\n\n      uvsHash[hash] = uvs.length / 2\n      uvs.push(uv.x, uv.y)\n\n      return uvsHash[hash]\n    }\n\n    data.data = {}\n\n    data.data.vertices = vertices\n    data.data.normals = normals\n    if (colors.length > 0) data.data.colors = colors\n    if (uvs.length > 0) data.data.uvs = [uvs] // temporal backward compatibility\n    data.data.faces = faces\n\n    return data\n  }\n\n  clone() {\n    /*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n    return new Geometry().copy(this)\n  }\n\n  copy(source) {\n    // reset\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n    this.morphTargets = []\n    this.morphNormals = []\n    this.skinWeights = []\n    this.skinIndices = []\n    this.lineDistances = []\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // name\n\n    this.name = source.name\n\n    // vertices\n\n    const vertices = source.vertices\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone())\n    }\n\n    // colors\n\n    const colors = source.colors\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone())\n    }\n\n    // faces\n\n    const faces = source.faces\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone())\n    }\n\n    // face vertex uvs\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = []\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k]\n\n          uvsCopy.push(uv.clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n\n    // morph targets\n\n    const morphTargets = source.morphTargets\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {}\n      morphTarget.name = morphTargets[i].name\n\n      // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = []\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone())\n        }\n      }\n\n      // normals\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = []\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone())\n        }\n      }\n\n      this.morphTargets.push(morphTarget)\n    }\n\n    // morph normals\n\n    const morphNormals = source.morphNormals\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}\n\n      // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = []\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j]\n          const destVertexNormal = {}\n\n          destVertexNormal.a = srcVertexNormal.a.clone()\n          destVertexNormal.b = srcVertexNormal.b.clone()\n          destVertexNormal.c = srcVertexNormal.c.clone()\n\n          morphNormal.vertexNormals.push(destVertexNormal)\n        }\n      }\n\n      // face normals\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = []\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone())\n        }\n      }\n\n      this.morphNormals.push(morphNormal)\n    }\n\n    // skin weights\n\n    const skinWeights = source.skinWeights\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone())\n    }\n\n    // skin indices\n\n    const skinIndices = source.skinIndices\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone())\n    }\n\n    // line distances\n\n    const lineDistances = source.lineDistances\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i])\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone()\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone()\n    }\n\n    // update flags\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate\n    this.verticesNeedUpdate = source.verticesNeedUpdate\n    this.uvsNeedUpdate = source.uvsNeedUpdate\n    this.normalsNeedUpdate = source.normalsNeedUpdate\n    this.colorsNeedUpdate = source.colorsNeedUpdate\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate\n    this.groupsNeedUpdate = source.groupsNeedUpdate\n\n    return this\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this)\n\n    const buffergeometry = new BufferGeometry()\n\n    const positions = new Float32Array(geometry.vertices.length * 3)\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices))\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3)\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals))\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3)\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors))\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2)\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs))\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2)\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2))\n    }\n\n    // groups\n\n    buffergeometry.groups = geometry.groups\n\n    // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = []\n      const morphTargets = geometry.morphTargets[name]\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i]\n\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3)\n        attribute.name = morphTarget.name\n\n        array.push(attribute.copyVector3sArray(morphTarget.data))\n      }\n\n      buffergeometry.morphAttributes[name] = array\n    }\n\n    // skinning\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4)\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices))\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4)\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights))\n    }\n\n    //\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return buffergeometry\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.')\n  }\n\n  computeLineDistances() {\n    console.error(\n      'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',\n    )\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().')\n    return this.applyMatrix4(matrix)\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' })\n  }\n}\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n    this.uvs2 = []\n\n    this.groups = []\n\n    this.morphTargets = {}\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    // this.lineDistances = [];\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.verticesNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  computeGroups(geometry) {\n    const groups = []\n\n    let group, i\n    let materialIndex = undefined\n\n    const faces = geometry.faces\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start\n          groups.push(group)\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex,\n        }\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start\n      groups.push(group)\n    }\n\n    this.groups = groups\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces\n    const vertices = geometry.vertices\n    const faceVertexUvs = geometry.faceVertexUvs\n\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0\n\n    // morphs\n\n    const morphTargets = geometry.morphTargets\n    const morphTargetsLength = morphTargets.length\n\n    let morphTargetsPosition\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = []\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.position = morphTargetsPosition\n    }\n\n    const morphNormals = geometry.morphNormals\n    const morphNormalsLength = morphNormals.length\n\n    let morphTargetsNormal\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = []\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.normal = morphTargetsNormal\n    }\n\n    // skins\n\n    const skinIndices = geometry.skinIndices\n    const skinWeights = geometry.skinWeights\n\n    const hasSkinIndices = skinIndices.length === vertices.length\n    const hasSkinWeights = skinWeights.length === vertices.length\n\n    //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.')\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c])\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2])\n      } else {\n        const normal = face.normal\n\n        this.normals.push(normal, normal, normal)\n      }\n\n      const vertexColors = face.vertexColors\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2])\n      } else {\n        const color = face.color\n\n        this.colors.push(color, color, color)\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i)\n\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i)\n\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      // morphs\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices\n\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i]\n\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c)\n      }\n\n      // skins\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c])\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])\n      }\n    }\n\n    this.computeGroups(geometry)\n\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return this\n  }\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.normal = normal && normal.isVector3 ? normal : new Vector3()\n    this.vertexNormals = Array.isArray(normal) ? normal : []\n\n    this.color = color && color.isColor ? color : new Color()\n    this.vertexColors = Array.isArray(color) ? color : []\n\n    this.materialIndex = materialIndex\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  copy(source) {\n    this.a = source.a\n    this.b = source.b\n    this.c = source.c\n\n    this.normal.copy(source.normal)\n    this.color.copy(source.color)\n\n    this.materialIndex = source.materialIndex\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone()\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone()\n    }\n\n    return this\n  }\n}\n\nexport { Face3, Geometry }\n"]},"metadata":{},"sourceType":"module"}