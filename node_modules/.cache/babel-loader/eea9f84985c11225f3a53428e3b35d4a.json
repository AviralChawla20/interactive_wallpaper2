{"ast":null,"code":"import { Curve, Vector4, Vector3 } from \"three\";\nimport { calcBSplinePoint, calcNURBSDerivatives } from \"./NURBSUtils.js\";\nclass NURBSCurve extends Curve {\n  constructor(degree, knots, controlPoints, startKnot, endKnot) {\n    super();\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = [];\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || this.knots.length - 1;\n    for (let i = 0; i < controlPoints.length; ++i) {\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3();\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);\n    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n    if (hpoint.w != 1) {\n      hpoint.divideScalar(hpoint.w);\n    }\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3();\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n}\nexport { NURBSCurve };","map":{"version":3,"sources":["../../src/curves/NURBSCurve.js"],"names":["NURBSUtils.calcBSplinePoint","NURBSUtils.calcNURBSDerivatives"],"mappings":";;AAYA,MAAM,UAAA,SAAmB,KAAA,CAAM;EAC7B,WAAA,CACE,MAAA,EACA,KAAA,EACA,aAAA,EACA,SAAA,EACA,OAAA,EACA;IACA,KAAA,CAAO,CAAA;IAEP,IAAA,CAAK,MAAA,GAAS,MAAA;IACd,IAAA,CAAK,KAAA,GAAQ,KAAA;IACb,IAAA,CAAK,aAAA,GAAgB,EAAE;IAEvB,IAAA,CAAK,SAAA,GAAY,SAAA,IAAa,CAAA;IAC9B,IAAA,CAAK,OAAA,GAAU,OAAA,IAAW,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAA;IAC9C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,aAAA,CAAc,MAAA,EAAQ,EAAE,CAAA,EAAG;MAE7C,MAAM,KAAA,GAAQ,aAAA,CAAc,CAAC,CAAA;MAC7B,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,IAAI,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,KAAA,CAAM,CAAA,EAAG,KAAA,CAAM,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA;IACvE;EACF;EAED,QAAA,CAAS,CAAA,EAAG,cAAA,EAAgB;IAC1B,MAAM,KAAA,GAAQ,cAAA,IAAkB,IAAI,OAAA,CAAS,CAAA;IAE7C,MAAM,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,OAAO,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA,CAAA;IAGhG,MAAM,MAAA,GAASA,gBAAAA,CAA4B,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,aAAA,EAAe,CAAC,CAAA;IAEzF,IAAI,MAAA,CAAO,CAAA,IAAK,CAAA,EAAK;MAEnB,MAAA,CAAO,YAAA,CAAa,MAAA,CAAO,CAAC,CAAA;IAC7B;IAED,OAAO,KAAA,CAAM,GAAA,CAAI,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAC,CAAA;EAC9C;EAED,UAAA,CAAW,CAAA,EAAG,cAAA,EAAgB;IAC5B,MAAM,OAAA,GAAU,cAAA,IAAkB,IAAI,OAAA,CAAS,CAAA;IAE/C,MAAM,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,GAAI,CAAA,IAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAA;IAC/E,MAAM,IAAA,GAAOC,oBAAAA,CAAgC,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,aAAA,EAAe,CAAA,EAAG,CAAC,CAAA;IAC9F,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,CAAA,CAAE,SAAA,CAAW,CAAA;IAEjC,OAAO,OAAA;EACR;AACH","sourcesContent":["import { Curve, Vector3, Vector4 } from 'three'\nimport * as NURBSUtils from '../curves/NURBSUtils'\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n  constructor(\n    degree,\n    knots /* array of reals */,\n    controlPoints /* array of Vector(2|3|4) */,\n    startKnot /* index in knots */,\n    endKnot /* index in knots */,\n  ) {\n    super()\n\n    this.degree = degree\n    this.knots = knots\n    this.controlPoints = []\n    // Used by periodic NURBS to remove hidden spans\n    this.startKnot = startKnot || 0\n    this.endKnot = endKnot || this.knots.length - 1\n    for (let i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      const point = controlPoints[i]\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w)\n    }\n  }\n\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3()\n\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]) // linear mapping t->u\n\n    // following results in (wx, wy, wz, w) homogeneous point\n    const hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u)\n\n    if (hpoint.w != 1.0) {\n      // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n      hpoint.divideScalar(hpoint.w)\n    }\n\n    return point.set(hpoint.x, hpoint.y, hpoint.z)\n  }\n\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3()\n\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0])\n    const ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1)\n    tangent.copy(ders[1]).normalize()\n\n    return tangent\n  }\n}\n\nexport { NURBSCurve }\n"]},"metadata":{},"sourceType":"module"}