{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nlet bigEndianPlatform = null;\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2),\n      uint8Array = new Uint8Array(buffer),\n      uint16Array = new Uint16Array(buffer);\n    uint8Array[0] = 170;\n    uint8Array[1] = 187;\n    bigEndianPlatform = uint16Array[0] === 43707;\n  }\n  return bigEndianPlatform;\n}\nconst InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];\nconst getMethods = {\n  Uint16Array: \"getUint16\",\n  Uint32Array: \"getUint32\",\n  Int16Array: \"getInt16\",\n  Int32Array: \"getInt32\",\n  Float32Array: \"getFloat32\",\n  Float64Array: \"getFloat64\"\n};\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT;\n  let result;\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length);\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n      getMethod = getMethods[viewType.name],\n      littleEndian = !fromBigEndian;\n    result = new viewType(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n    }\n  }\n  return result;\n}\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer),\n    version = array[0];\n  let flags = array[1];\n  const indexedGeometry = !!(flags >> 7 & 1),\n    indicesType = flags >> 6 & 1,\n    bigEndian = (flags >> 5 & 1) === 1,\n    attributesNumber = flags & 31;\n  let valuesNumber = 0,\n    indicesNumber = 0;\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n  }\n  if (version === 0) {\n    throw new Error(\"PRWM decoder: Invalid format version: 0\");\n  } else if (version !== 1) {\n    throw new Error(\"PRWM decoder: Unsupported format version: \" + version);\n  }\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error(\"PRWM decoder: Indices type must be set to 0 for non-indexed geometries\");\n    } else if (indicesNumber !== 0) {\n      throw new Error(\"PRWM decoder: Number of indices must be set to 0 for non-indexed geometries\");\n    }\n  }\n  let pos = 8;\n  const attributes = {};\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = \"\";\n    while (pos < array.length) {\n      const char = array[pos];\n      pos++;\n      if (char === 0) {\n        break;\n      } else {\n        attributeName += String.fromCharCode(char);\n      }\n    }\n    flags = array[pos];\n    const attributeType = flags >> 7 & 1;\n    const cardinality = (flags >> 4 & 3) + 1;\n    const encodingType = flags & 15;\n    const arrayType = InvertedEncodingTypes[encodingType];\n    pos++;\n    pos = Math.ceil(pos / 4) * 4;\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality,\n      values\n    };\n  }\n  pos = Math.ceil(pos / 4) * 4;\n  let indices = null;\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n  }\n  return {\n    version,\n    attributes,\n    indices\n  };\n}\nclass PRWMLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? \"be\" : \"le\");\n    loader.load(url, function (arrayBuffer) {\n      try {\n        onLoad(scope.parse(arrayBuffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(arrayBuffer) {\n    const data = decodePrwm(arrayBuffer),\n      attributesKey = Object.keys(data.attributes),\n      bufferGeometry = new BufferGeometry();\n    for (let i = 0; i < attributesKey.length; i++) {\n      const attribute = data.attributes[attributesKey[i]];\n      bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n    }\n    if (data.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n    }\n    return bufferGeometry;\n  }\n  static isBigEndianPlatform() {\n    return isBigEndianPlatform();\n  }\n}\nexport { PRWMLoader };","map":{"version":3,"sources":["../../src/loaders/PRWMLoader.js"],"names":[],"mappings":"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","sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nlet bigEndianPlatform = null\n\n/**\n * Check if the endianness of the platform is big-endian (most significant bit first)\n * @returns {boolean} True if big-endian, false if little-endian\n */\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2),\n      uint8Array = new Uint8Array(buffer),\n      uint16Array = new Uint16Array(buffer)\n\n    uint8Array[0] = 0xaa // set first byte\n    uint8Array[1] = 0xbb // set second byte\n    bigEndianPlatform = uint16Array[0] === 0xaabb\n  }\n\n  return bigEndianPlatform\n}\n\n// match the values defined in the spec to the TypedArray types\nconst InvertedEncodingTypes = [\n  null,\n  Float32Array,\n  null,\n  Int8Array,\n  Int16Array,\n  null,\n  Int32Array,\n  Uint8Array,\n  Uint16Array,\n  null,\n  Uint32Array,\n]\n\n// define the method to use on a DataView, corresponding the TypedArray type\nconst getMethods = {\n  Uint16Array: 'getUint16',\n  Uint32Array: 'getUint32',\n  Int16Array: 'getInt16',\n  Int32Array: 'getInt32',\n  Float32Array: 'getFloat32',\n  Float64Array: 'getFloat64',\n}\n\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT\n  let result\n\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length)\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n      getMethod = getMethods[viewType.name],\n      littleEndian = !fromBigEndian\n\n    result = new viewType(length)\n\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian)\n    }\n  }\n\n  return result\n}\n\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer),\n    version = array[0]\n\n  let flags = array[1]\n\n  const indexedGeometry = !!((flags >> 7) & 0x01),\n    indicesType = (flags >> 6) & 0x01,\n    bigEndian = ((flags >> 5) & 0x01) === 1,\n    attributesNumber = flags & 0x1f\n\n  let valuesNumber = 0,\n    indicesNumber = 0\n\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4]\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7]\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16)\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16)\n  }\n\n  /** PRELIMINARY CHECKS **/\n\n  if (version === 0) {\n    throw new Error('PRWM decoder: Invalid format version: 0')\n  } else if (version !== 1) {\n    throw new Error('PRWM decoder: Unsupported format version: ' + version)\n  }\n\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries')\n    } else if (indicesNumber !== 0) {\n      throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries')\n    }\n  }\n\n  /** PARSING **/\n\n  let pos = 8\n\n  const attributes = {}\n\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = ''\n\n    while (pos < array.length) {\n      const char = array[pos]\n      pos++\n\n      if (char === 0) {\n        break\n      } else {\n        attributeName += String.fromCharCode(char)\n      }\n    }\n\n    flags = array[pos]\n\n    const attributeType = (flags >> 7) & 0x01\n    const cardinality = ((flags >> 4) & 0x03) + 1\n    const encodingType = flags & 0x0f\n    const arrayType = InvertedEncodingTypes[encodingType]\n\n    pos++\n\n    // padding to next multiple of 4\n    pos = Math.ceil(pos / 4) * 4\n\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian)\n\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber\n\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality: cardinality,\n      values: values,\n    }\n  }\n\n  pos = Math.ceil(pos / 4) * 4\n\n  let indices = null\n\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian)\n  }\n\n  return {\n    version: version,\n    attributes: attributes,\n    indices: indices,\n  }\n}\n\n// Define the public interface\n\nclass PRWMLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le')\n\n    loader.load(\n      url,\n      function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(arrayBuffer) {\n    const data = decodePrwm(arrayBuffer),\n      attributesKey = Object.keys(data.attributes),\n      bufferGeometry = new BufferGeometry()\n\n    for (let i = 0; i < attributesKey.length; i++) {\n      const attribute = data.attributes[attributesKey[i]]\n      bufferGeometry.setAttribute(\n        attributesKey[i],\n        new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized),\n      )\n    }\n\n    if (data.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1))\n    }\n\n    return bufferGeometry\n  }\n\n  static isBigEndianPlatform() {\n    return isBigEndianPlatform()\n  }\n}\n\nexport { PRWMLoader }\n"]},"metadata":{},"sourceType":"module"}