{"ast":null,"code":"import { Matrix3, OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, REVISION, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from \"three\";\nclass AnaglyphEffect {\n  constructor(renderer, width = 512, height = 512) {\n    this.colorMatrixLeft = new Matrix3().fromArray([0.4561, -0.0400822, -0.0152161, 0.500484, -0.0378246, -0.0205971, 0.176381, -0.0157589, -546856e-8]);\n    this.colorMatrixRight = new Matrix3().fromArray([-0.0434706, 0.378476, -0.0721527, -0.0879388, 0.73364, -0.112961, -155529e-8, -0.0184503, 1.2264]);\n    const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const _scene = new Scene();\n    const _stereo = new StereoCamera();\n    const _params = {\n      minFilter: LinearFilter,\n      magFilter: NearestFilter,\n      format: RGBAFormat\n    };\n    const _renderTargetL = new WebGLRenderTarget(width, height, _params);\n    const _renderTargetR = new WebGLRenderTarget(width, height, _params);\n    const _material = new ShaderMaterial({\n      uniforms: {\n        mapLeft: {\n          value: _renderTargetL.texture\n        },\n        mapRight: {\n          value: _renderTargetR.texture\n        },\n        colorMatrixLeft: {\n          value: this.colorMatrixLeft\n        },\n        colorMatrixRight: {\n          value: this.colorMatrixRight\n        }\n      },\n      vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = vec2( uv.x, uv.y );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n      fragmentShader: [\"uniform sampler2D mapLeft;\", \"uniform sampler2D mapRight;\", \"varying vec2 vUv;\", \"uniform mat3 colorMatrixLeft;\", \"uniform mat3 colorMatrixRight;\", \"void main() {\", \"\tvec2 uv = vUv;\", \"\tvec4 colorL = texture2D( mapLeft, uv );\", \"\tvec4 colorR = texture2D( mapRight, uv );\", \"\tvec3 color = clamp(\", \"\t\t\tcolorMatrixLeft * colorL.rgb +\", \"\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );\", \"\tgl_FragColor = vec4(\", \"\t\t\tcolor.r, color.g, color.b,\", \"\t\t\tmax( colorL.a, colorR.a ) );\", \"\t#include <tonemapping_fragment>\", `\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>`, \"}\"].join(\"\\n\")\n    });\n    const _mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n    _scene.add(_mesh);\n    this.setSize = function (width2, height2) {\n      renderer.setSize(width2, height2);\n      const pixelRatio = renderer.getPixelRatio();\n      _renderTargetL.setSize(width2 * pixelRatio, height2 * pixelRatio);\n      _renderTargetR.setSize(width2 * pixelRatio, height2 * pixelRatio);\n    };\n    this.render = function (scene, camera) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n      _stereo.update(camera);\n      renderer.setRenderTarget(_renderTargetL);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraL);\n      renderer.setRenderTarget(_renderTargetR);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraR);\n      renderer.setRenderTarget(null);\n      renderer.render(_scene, _camera);\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n    this.dispose = function () {\n      _renderTargetL.dispose();\n      _renderTargetR.dispose();\n      _mesh.geometry.dispose();\n      _mesh.material.dispose();\n    };\n  }\n}\nexport { AnaglyphEffect };","map":{"version":3,"sources":["../../src/effects/AnaglyphEffect.js"],"names":["width","height"],"mappings":"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","sourcesContent":["import {\n  LinearFilter,\n  Matrix3,\n  Mesh,\n  NearestFilter,\n  OrthographicCamera,\n  PlaneGeometry,\n  RGBAFormat,\n  Scene,\n  ShaderMaterial,\n  StereoCamera,\n  WebGLRenderTarget,\n  REVISION,\n} from 'three'\n\nclass AnaglyphEffect {\n  constructor(renderer, width = 512, height = 512) {\n    // Dubois matrices from https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.6968&rep=rep1&type=pdf#page=4\n\n    this.colorMatrixLeft = new Matrix3().fromArray([\n      0.4561,\n      -0.0400822,\n      -0.0152161,\n      0.500484,\n      -0.0378246,\n      -0.0205971,\n      0.176381,\n      -0.0157589,\n      -0.00546856,\n    ])\n\n    this.colorMatrixRight = new Matrix3().fromArray([\n      -0.0434706,\n      0.378476,\n      -0.0721527,\n      -0.0879388,\n      0.73364,\n      -0.112961,\n      -0.00155529,\n      -0.0184503,\n      1.2264,\n    ])\n\n    const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n\n    const _scene = new Scene()\n\n    const _stereo = new StereoCamera()\n\n    const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat }\n\n    const _renderTargetL = new WebGLRenderTarget(width, height, _params)\n    const _renderTargetR = new WebGLRenderTarget(width, height, _params)\n\n    const _material = new ShaderMaterial({\n      uniforms: {\n        mapLeft: { value: _renderTargetL.texture },\n        mapRight: { value: _renderTargetR.texture },\n\n        colorMatrixLeft: { value: this.colorMatrixLeft },\n        colorMatrixRight: { value: this.colorMatrixRight },\n      },\n\n      vertexShader: [\n        'varying vec2 vUv;',\n\n        'void main() {',\n\n        '\tvUv = vec2( uv.x, uv.y );',\n        '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n        '}',\n      ].join('\\n'),\n\n      fragmentShader: [\n        'uniform sampler2D mapLeft;',\n        'uniform sampler2D mapRight;',\n        'varying vec2 vUv;',\n\n        'uniform mat3 colorMatrixLeft;',\n        'uniform mat3 colorMatrixRight;',\n\n        'void main() {',\n\n        '\tvec2 uv = vUv;',\n\n        '\tvec4 colorL = texture2D( mapLeft, uv );',\n        '\tvec4 colorR = texture2D( mapRight, uv );',\n\n        '\tvec3 color = clamp(',\n        '\t\t\tcolorMatrixLeft * colorL.rgb +',\n        '\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );',\n\n        '\tgl_FragColor = vec4(',\n        '\t\t\tcolor.r, color.g, color.b,',\n        '\t\t\tmax( colorL.a, colorR.a ) );',\n\n        '\t#include <tonemapping_fragment>',\n        `\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>`,\n\n        '}',\n      ].join('\\n'),\n    })\n\n    const _mesh = new Mesh(new PlaneGeometry(2, 2), _material)\n    _scene.add(_mesh)\n\n    this.setSize = function (width, height) {\n      renderer.setSize(width, height)\n\n      const pixelRatio = renderer.getPixelRatio()\n\n      _renderTargetL.setSize(width * pixelRatio, height * pixelRatio)\n      _renderTargetR.setSize(width * pixelRatio, height * pixelRatio)\n    }\n\n    this.render = function (scene, camera) {\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      _stereo.update(camera)\n\n      renderer.setRenderTarget(_renderTargetL)\n      renderer.clear()\n      renderer.render(scene, _stereo.cameraL)\n\n      renderer.setRenderTarget(_renderTargetR)\n      renderer.clear()\n      renderer.render(scene, _stereo.cameraR)\n\n      renderer.setRenderTarget(null)\n      renderer.render(_scene, _camera)\n\n      renderer.setRenderTarget(currentRenderTarget)\n    }\n\n    this.dispose = function () {\n      _renderTargetL.dispose()\n      _renderTargetR.dispose()\n      _mesh.geometry.dispose()\n      _mesh.material.dispose()\n    }\n  }\n}\n\nexport { AnaglyphEffect }\n"]},"metadata":{},"sourceType":"module"}