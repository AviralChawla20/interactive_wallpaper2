{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute, Vector3, Float32BufferAttribute } from \"three\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass STLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function isBinary(data2) {\n      const reader = new DataView(data2);\n      const face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n      const n_faces = reader.getUint32(80, true);\n      const expect = 80 + 32 / 8 + n_faces * face_size;\n      if (expect === reader.byteLength) {\n        return true;\n      }\n      const solid = [115, 111, 108, 105, 100];\n      for (let off = 0; off < 5; off++) {\n        if (matchDataViewAt(solid, reader, off)) return false;\n      }\n      return true;\n    }\n    function matchDataViewAt(query, reader, offset) {\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i, false)) return false;\n      }\n      return true;\n    }\n    function parseBinary(data2) {\n      const reader = new DataView(data2);\n      const faces = reader.getUint32(80, true);\n      let r,\n        g,\n        b,\n        hasColors = false,\n        colors;\n      let defaultR, defaultG, defaultB, alpha;\n      for (let index = 0; index < 80 - 10; index++) {\n        if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {\n          hasColors = true;\n          colors = new Float32Array(faces * 3 * 3);\n          defaultR = reader.getUint8(index + 6) / 255;\n          defaultG = reader.getUint8(index + 7) / 255;\n          defaultB = reader.getUint8(index + 8) / 255;\n          alpha = reader.getUint8(index + 9) / 255;\n        }\n      }\n      const dataOffset = 84;\n      const faceLength = 12 * 4 + 2;\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array(faces * 3 * 3);\n      const normals = new Float32Array(faces * 3 * 3);\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength;\n        const normalX = reader.getFloat32(start, true);\n        const normalY = reader.getFloat32(start + 4, true);\n        const normalZ = reader.getFloat32(start + 8, true);\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true);\n          if ((packedColor & 32768) === 0) {\n            r = (packedColor & 31) / 31;\n            g = (packedColor >> 5 & 31) / 31;\n            b = (packedColor >> 10 & 31) / 31;\n          } else {\n            r = defaultR;\n            g = defaultG;\n            b = defaultB;\n          }\n        }\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12;\n          const componentIdx = face * 3 * 3 + (i - 1) * 3;\n          vertices[componentIdx] = reader.getFloat32(vertexstart, true);\n          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\n          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\n          normals[componentIdx] = normalX;\n          normals[componentIdx + 1] = normalY;\n          normals[componentIdx + 2] = normalZ;\n          if (hasColors) {\n            colors[componentIdx] = r;\n            colors[componentIdx + 1] = g;\n            colors[componentIdx + 2] = b;\n          }\n        }\n      }\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n      if (hasColors) {\n        geometry.setAttribute(\"color\", new BufferAttribute(colors, 3));\n        geometry.hasColors = true;\n        geometry.alpha = alpha;\n      }\n      return geometry;\n    }\n    function parseASCII(data2) {\n      const geometry = new BufferGeometry();\n      const patternSolid = /solid([\\s\\S]*?)endsolid/g;\n      const patternFace = /facet([\\s\\S]*?)endfacet/g;\n      let faceCounter = 0;\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n      const patternVertex = new RegExp(\"vertex\" + patternFloat + patternFloat + patternFloat, \"g\");\n      const patternNormal = new RegExp(\"normal\" + patternFloat + patternFloat + patternFloat, \"g\");\n      const vertices = [];\n      const normals = [];\n      const normal = new Vector3();\n      let result;\n      let groupCount = 0;\n      let startVertex = 0;\n      let endVertex = 0;\n      while ((result = patternSolid.exec(data2)) !== null) {\n        startVertex = endVertex;\n        const solid = result[0];\n        while ((result = patternFace.exec(solid)) !== null) {\n          let vertexCountPerFace = 0;\n          let normalCountPerFace = 0;\n          const text = result[0];\n          while ((result = patternNormal.exec(text)) !== null) {\n            normal.x = parseFloat(result[1]);\n            normal.y = parseFloat(result[2]);\n            normal.z = parseFloat(result[3]);\n            normalCountPerFace++;\n          }\n          while ((result = patternVertex.exec(text)) !== null) {\n            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n            normals.push(normal.x, normal.y, normal.z);\n            vertexCountPerFace++;\n            endVertex++;\n          }\n          if (normalCountPerFace !== 1) {\n            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter);\n          }\n          if (vertexCountPerFace !== 3) {\n            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter);\n          }\n          faceCounter++;\n        }\n        const start = startVertex;\n        const count = endVertex - startVertex;\n        geometry.addGroup(start, count, groupCount);\n        groupCount++;\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      return geometry;\n    }\n    function ensureString(buffer) {\n      if (typeof buffer !== \"string\") {\n        return decodeText(new Uint8Array(buffer));\n      }\n      return buffer;\n    }\n    function ensureBinary(buffer) {\n      if (typeof buffer === \"string\") {\n        const array_buffer = new Uint8Array(buffer.length);\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 255;\n        }\n        return array_buffer.buffer || array_buffer;\n      } else {\n        return buffer;\n      }\n    }\n    const binData = ensureBinary(data);\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n  }\n}\nexport { STLLoader };","map":{"version":3,"sources":["../../src/loaders/STLLoader.js"],"names":["data"],"mappings":";;AA8DA,MAAM,SAAA,SAAkB,MAAA,CAAO;EAC7B,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;EACd;EAED,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,KAAA,GAAQ,IAAA;IAEd,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;IAC1C,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA;IACxB,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;IACpC,MAAA,CAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA;IAC1C,MAAA,CAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA;IAE9C,MAAA,CAAO,IAAA,CACL,GAAA,EACA,UAAU,IAAA,EAAM;MACd,IAAI;QACF,MAAA,CAAO,KAAA,CAAM,KAAA,CAAM,IAAI,CAAC,CAAA;MACzB,CAAA,CAAA,OAAQ,CAAA,EAAP;QACA,IAAI,OAAA,EAAS;UACX,OAAA,CAAQ,CAAC,CAAA;QACrB,CAAA,MAAiB;UACL,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAChB;QAED,KAAA,CAAM,OAAA,CAAQ,SAAA,CAAU,GAAG,CAAA;MAC5B;IACF,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAED,KAAA,CAAM,IAAA,EAAM;IACV,SAAS,QAAA,CAASA,KAAAA,EAAM;MACtB,MAAM,MAAA,GAAS,IAAI,QAAA,CAASA,KAAI,CAAA;MAChC,MAAM,SAAA,GAAa,EAAA,GAAK,CAAA,GAAK,CAAA,GAAK,EAAA,GAAK,CAAA,GAAK,CAAA,GAAI,CAAA,GAAI,EAAA,GAAK,CAAA;MACzD,MAAM,OAAA,GAAU,MAAA,CAAO,SAAA,CAAU,EAAA,EAAI,IAAI,CAAA;MACzC,MAAM,MAAA,GAAS,EAAA,GAAK,EAAA,GAAK,CAAA,GAAI,OAAA,GAAU,SAAA;MAEvC,IAAI,MAAA,KAAW,MAAA,CAAO,UAAA,EAAY;QAChC,OAAO,IAAA;MACR;MAYD,MAAM,KAAA,GAAQ,CAAC,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAA;MAEtC,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,GAAM,CAAA,EAAG,GAAA,EAAA,EAAO;QAGhC,IAAI,eAAA,CAAgB,KAAA,EAAO,MAAA,EAAQ,GAAG,CAAA,EAAG,OAAO,KAAA;MACjD;MAID,OAAO,IAAA;IACR;IAED,SAAS,eAAA,CAAgB,KAAA,EAAO,MAAA,EAAQ,MAAA,EAAQ;MAG9C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC9C,IAAI,KAAA,CAAM,CAAC,CAAA,KAAM,MAAA,CAAO,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG,KAAK,CAAA,EAAG,OAAO,KAAA;MAC7D;MAED,OAAO,IAAA;IACR;IAED,SAAS,WAAA,CAAYA,KAAAA,EAAM;MACzB,MAAM,MAAA,GAAS,IAAI,QAAA,CAASA,KAAI,CAAA;MAChC,MAAM,KAAA,GAAQ,MAAA,CAAO,SAAA,CAAU,EAAA,EAAI,IAAI,CAAA;MAEvC,IAAI,CAAA;QACF,CAAA;QACA,CAAA;QACA,SAAA,GAAY,KAAA;QACZ,MAAA;MACF,IAAI,QAAA,EAAU,QAAA,EAAU,QAAA,EAAU,KAAA;MAKlC,KAAA,IAAS,KAAA,GAAQ,CAAA,EAAG,KAAA,GAAQ,EAAA,GAAK,EAAA,EAAI,KAAA,EAAA,EAAS;QAC5C,IACE,MAAA,CAAO,SAAA,CAAU,KAAA,EAAO,KAAK,CAAA,IAAK,UAAA,IAClC,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,IAAK,EAAA,IAC9B,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,IAAK,EAAA,EAC9B;UACA,SAAA,GAAY,IAAA;UACZ,MAAA,GAAS,IAAI,YAAA,CAAa,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA;UAEvC,QAAA,GAAW,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAA;UACxC,QAAA,GAAW,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAA;UACxC,QAAA,GAAW,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAA;UACxC,KAAA,GAAQ,MAAA,CAAO,QAAA,CAAS,KAAA,GAAQ,CAAC,CAAA,GAAI,GAAA;QACtC;MACF;MAED,MAAM,UAAA,GAAa,EAAA;MACnB,MAAM,UAAA,GAAa,EAAA,GAAK,CAAA,GAAI,CAAA;MAE5B,MAAM,QAAA,GAAW,IAAI,cAAA,CAAgB,CAAA;MAErC,MAAM,QAAA,GAAW,IAAI,YAAA,CAAa,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA;MAC/C,MAAM,OAAA,GAAU,IAAI,YAAA,CAAa,KAAA,GAAQ,CAAA,GAAI,CAAC,CAAA;MAE9C,KAAA,IAAS,IAAA,GAAO,CAAA,EAAG,IAAA,GAAO,KAAA,EAAO,IAAA,EAAA,EAAQ;QACvC,MAAM,KAAA,GAAQ,UAAA,GAAa,IAAA,GAAO,UAAA;QAClC,MAAM,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,KAAA,EAAO,IAAI,CAAA;QAC7C,MAAM,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,KAAA,GAAQ,CAAA,EAAG,IAAI,CAAA;QACjD,MAAM,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,KAAA,GAAQ,CAAA,EAAG,IAAI,CAAA;QAEjD,IAAI,SAAA,EAAW;UACb,MAAM,WAAA,GAAc,MAAA,CAAO,SAAA,CAAU,KAAA,GAAQ,EAAA,EAAI,IAAI,CAAA;UAErD,IAAA,CAAK,WAAA,GAAc,KAAA,MAAY,CAAA,EAAG;YAGhC,CAAA,GAAA,CAAK,WAAA,GAAc,EAAA,IAAQ,EAAA;YAC3B,CAAA,GAAA,CAAM,WAAA,IAAe,CAAA,GAAK,EAAA,IAAQ,EAAA;YAClC,CAAA,GAAA,CAAM,WAAA,IAAe,EAAA,GAAM,EAAA,IAAQ,EAAA;UAC/C,CAAA,MAAiB;YACL,CAAA,GAAI,QAAA;YACJ,CAAA,GAAI,QAAA;YACJ,CAAA,GAAI,QAAA;UACL;QACF;QAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;UAC3B,MAAM,WAAA,GAAc,KAAA,GAAQ,CAAA,GAAI,EAAA;UAChC,MAAM,YAAA,GAAe,IAAA,GAAO,CAAA,GAAI,CAAA,GAAA,CAAK,CAAA,GAAI,CAAA,IAAK,CAAA;UAE9C,QAAA,CAAS,YAAY,CAAA,GAAI,MAAA,CAAO,UAAA,CAAW,WAAA,EAAa,IAAI,CAAA;UAC5D,QAAA,CAAS,YAAA,GAAe,CAAC,CAAA,GAAI,MAAA,CAAO,UAAA,CAAW,WAAA,GAAc,CAAA,EAAG,IAAI,CAAA;UACpE,QAAA,CAAS,YAAA,GAAe,CAAC,CAAA,GAAI,MAAA,CAAO,UAAA,CAAW,WAAA,GAAc,CAAA,EAAG,IAAI,CAAA;UAEpE,OAAA,CAAQ,YAAY,CAAA,GAAI,OAAA;UACxB,OAAA,CAAQ,YAAA,GAAe,CAAC,CAAA,GAAI,OAAA;UAC5B,OAAA,CAAQ,YAAA,GAAe,CAAC,CAAA,GAAI,OAAA;UAE5B,IAAI,SAAA,EAAW;YACb,MAAA,CAAO,YAAY,CAAA,GAAI,CAAA;YACvB,MAAA,CAAO,YAAA,GAAe,CAAC,CAAA,GAAI,CAAA;YAC3B,MAAA,CAAO,YAAA,GAAe,CAAC,CAAA,GAAI,CAAA;UAC5B;QACF;MACF;MAED,QAAA,CAAS,YAAA,CAAa,UAAA,EAAY,IAAI,eAAA,CAAgB,QAAA,EAAU,CAAC,CAAC,CAAA;MAClE,QAAA,CAAS,YAAA,CAAa,QAAA,EAAU,IAAI,eAAA,CAAgB,OAAA,EAAS,CAAC,CAAC,CAAA;MAE/D,IAAI,SAAA,EAAW;QACb,QAAA,CAAS,YAAA,CAAa,OAAA,EAAS,IAAI,eAAA,CAAgB,MAAA,EAAQ,CAAC,CAAC,CAAA;QAC7D,QAAA,CAAS,SAAA,GAAY,IAAA;QACrB,QAAA,CAAS,KAAA,GAAQ,KAAA;MAClB;MAED,OAAO,QAAA;IACR;IAED,SAAS,UAAA,CAAWA,KAAAA,EAAM;MACxB,MAAM,QAAA,GAAW,IAAI,cAAA,CAAgB,CAAA;MACrC,MAAM,YAAA,GAAe,0BAAA;MACrB,MAAM,WAAA,GAAc,0BAAA;MACpB,IAAI,WAAA,GAAc,CAAA;MAElB,MAAM,YAAA,GAAe,gDAAA,CAAiD,MAAA;MACtE,MAAM,aAAA,GAAgB,IAAI,MAAA,CAAO,QAAA,GAAW,YAAA,GAAe,YAAA,GAAe,YAAA,EAAc,GAAG,CAAA;MAC3F,MAAM,aAAA,GAAgB,IAAI,MAAA,CAAO,QAAA,GAAW,YAAA,GAAe,YAAA,GAAe,YAAA,EAAc,GAAG,CAAA;MAE3F,MAAM,QAAA,GAAW,EAAE;MACnB,MAAM,OAAA,GAAU,EAAE;MAElB,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;MAE5B,IAAI,MAAA;MAEJ,IAAI,UAAA,GAAa,CAAA;MACjB,IAAI,WAAA,GAAc,CAAA;MAClB,IAAI,SAAA,GAAY,CAAA;MAEhB,OAAA,CAAQ,MAAA,GAAS,YAAA,CAAa,IAAA,CAAKA,KAAI,CAAA,MAAO,IAAA,EAAM;QAClD,WAAA,GAAc,SAAA;QAEd,MAAM,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA;QAEtB,OAAA,CAAQ,MAAA,GAAS,WAAA,CAAY,IAAA,CAAK,KAAK,CAAA,MAAO,IAAA,EAAM;UAClD,IAAI,kBAAA,GAAqB,CAAA;UACzB,IAAI,kBAAA,GAAqB,CAAA;UAEzB,MAAM,IAAA,GAAO,MAAA,CAAO,CAAC,CAAA;UAErB,OAAA,CAAQ,MAAA,GAAS,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA,MAAO,IAAA,EAAM;YACnD,MAAA,CAAO,CAAA,GAAI,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAA;YAC/B,MAAA,CAAO,CAAA,GAAI,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAA;YAC/B,MAAA,CAAO,CAAA,GAAI,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAA;YAC/B,kBAAA,EAAA;UACD;UAED,OAAA,CAAQ,MAAA,GAAS,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA,MAAO,IAAA,EAAM;YACnD,QAAA,CAAS,IAAA,CAAK,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAA,EAAG,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAA,EAAG,UAAA,CAAW,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA;YACjF,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAA,EAAG,MAAA,CAAO,CAAC,CAAA;YACzC,kBAAA,EAAA;YACA,SAAA,EAAA;UACD;UAID,IAAI,kBAAA,KAAuB,CAAA,EAAG;YAC5B,OAAA,CAAQ,KAAA,CAAM,wEAAA,GAA2E,WAAW,CAAA;UACrG;UAID,IAAI,kBAAA,KAAuB,CAAA,EAAG;YAC5B,OAAA,CAAQ,KAAA,CAAM,0EAAA,GAA6E,WAAW,CAAA;UACvG;UAED,WAAA,EAAA;QACD;QAED,MAAM,KAAA,GAAQ,WAAA;QACd,MAAM,KAAA,GAAQ,SAAA,GAAY,WAAA;QAE1B,QAAA,CAAS,QAAA,CAAS,KAAA,EAAO,KAAA,EAAO,UAAU,CAAA;QAC1C,UAAA,EAAA;MACD;MAED,QAAA,CAAS,YAAA,CAAa,UAAA,EAAY,IAAI,sBAAA,CAAuB,QAAA,EAAU,CAAC,CAAC,CAAA;MACzE,QAAA,CAAS,YAAA,CAAa,QAAA,EAAU,IAAI,sBAAA,CAAuB,OAAA,EAAS,CAAC,CAAC,CAAA;MAEtE,OAAO,QAAA;IACR;IAED,SAAS,YAAA,CAAa,MAAA,EAAQ;MAC5B,IAAI,OAAO,MAAA,KAAW,QAAA,EAAU;QAC9B,OAAO,UAAA,CAAW,IAAI,UAAA,CAAW,MAAM,CAAC,CAAA;MACzC;MAED,OAAO,MAAA;IACR;IAED,SAAS,YAAA,CAAa,MAAA,EAAQ;MAC5B,IAAI,OAAO,MAAA,KAAW,QAAA,EAAU;QAC9B,MAAM,YAAA,GAAe,IAAI,UAAA,CAAW,MAAA,CAAO,MAAM,CAAA;QACjD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,EAAK;UACtC,YAAA,CAAa,CAAC,CAAA,GAAI,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA,GAAI,GAAA;QAC1C;QAED,OAAO,YAAA,CAAa,MAAA,IAAU,YAAA;MACtC,CAAA,MAAa;QACL,OAAO,MAAA;MACR;IACF;IAID,MAAM,OAAA,GAAU,YAAA,CAAa,IAAI,CAAA;IAEjC,OAAO,QAAA,CAAS,OAAO,CAAA,GAAI,WAAA,CAAY,OAAO,CAAA,GAAI,UAAA,CAAW,YAAA,CAAa,IAAI,CAAC,CAAA;EAChF;AACH","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  LoaderUtils,\n  Vector3,\n} from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\n\nclass STLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function isBinary(data) {\n      const reader = new DataView(data)\n      const face_size = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8\n      const n_faces = reader.getUint32(80, true)\n      const expect = 80 + 32 / 8 + n_faces * face_size\n\n      if (expect === reader.byteLength) {\n        return true\n      }\n\n      // An ASCII STL data must begin with 'solid ' as the first six bytes.\n      // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n      // plentiful.  So, check the first 5 bytes for 'solid'.\n\n      // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n      // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n      // Search for \"solid\" to start anywhere after those prefixes.\n\n      // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n      const solid = [115, 111, 108, 105, 100]\n\n      for (let off = 0; off < 5; off++) {\n        // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n        if (matchDataViewAt(solid, reader, off)) return false\n      }\n\n      // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n      return true\n    }\n\n    function matchDataViewAt(query, reader, offset) {\n      // Check if each byte in query matches the corresponding byte from the current offset\n\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i, false)) return false\n      }\n\n      return true\n    }\n\n    function parseBinary(data) {\n      const reader = new DataView(data)\n      const faces = reader.getUint32(80, true)\n\n      let r,\n        g,\n        b,\n        hasColors = false,\n        colors\n      let defaultR, defaultG, defaultB, alpha\n\n      // process STL header\n      // check for default color in header (\"COLOR=rgba\" sequence).\n\n      for (let index = 0; index < 80 - 10; index++) {\n        if (\n          reader.getUint32(index, false) == 0x434f4c4f /*COLO*/ &&\n          reader.getUint8(index + 4) == 0x52 /*'R'*/ &&\n          reader.getUint8(index + 5) == 0x3d /*'='*/\n        ) {\n          hasColors = true\n          colors = new Float32Array(faces * 3 * 3)\n\n          defaultR = reader.getUint8(index + 6) / 255\n          defaultG = reader.getUint8(index + 7) / 255\n          defaultB = reader.getUint8(index + 8) / 255\n          alpha = reader.getUint8(index + 9) / 255\n        }\n      }\n\n      const dataOffset = 84\n      const faceLength = 12 * 4 + 2\n\n      const geometry = new BufferGeometry()\n\n      const vertices = new Float32Array(faces * 3 * 3)\n      const normals = new Float32Array(faces * 3 * 3)\n\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength\n        const normalX = reader.getFloat32(start, true)\n        const normalY = reader.getFloat32(start + 4, true)\n        const normalZ = reader.getFloat32(start + 8, true)\n\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true)\n\n          if ((packedColor & 0x8000) === 0) {\n            // facet has its own unique color\n\n            r = (packedColor & 0x1f) / 31\n            g = ((packedColor >> 5) & 0x1f) / 31\n            b = ((packedColor >> 10) & 0x1f) / 31\n          } else {\n            r = defaultR\n            g = defaultG\n            b = defaultB\n          }\n        }\n\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12\n          const componentIdx = face * 3 * 3 + (i - 1) * 3\n\n          vertices[componentIdx] = reader.getFloat32(vertexstart, true)\n          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true)\n          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true)\n\n          normals[componentIdx] = normalX\n          normals[componentIdx + 1] = normalY\n          normals[componentIdx + 2] = normalZ\n\n          if (hasColors) {\n            colors[componentIdx] = r\n            colors[componentIdx + 1] = g\n            colors[componentIdx + 2] = b\n          }\n        }\n      }\n\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new BufferAttribute(normals, 3))\n\n      if (hasColors) {\n        geometry.setAttribute('color', new BufferAttribute(colors, 3))\n        geometry.hasColors = true\n        geometry.alpha = alpha\n      }\n\n      return geometry\n    }\n\n    function parseASCII(data) {\n      const geometry = new BufferGeometry()\n      const patternSolid = /solid([\\s\\S]*?)endsolid/g\n      const patternFace = /facet([\\s\\S]*?)endfacet/g\n      let faceCounter = 0\n\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source\n      const patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g')\n      const patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g')\n\n      const vertices = []\n      const normals = []\n\n      const normal = new Vector3()\n\n      let result\n\n      let groupCount = 0\n      let startVertex = 0\n      let endVertex = 0\n\n      while ((result = patternSolid.exec(data)) !== null) {\n        startVertex = endVertex\n\n        const solid = result[0]\n\n        while ((result = patternFace.exec(solid)) !== null) {\n          let vertexCountPerFace = 0\n          let normalCountPerFace = 0\n\n          const text = result[0]\n\n          while ((result = patternNormal.exec(text)) !== null) {\n            normal.x = parseFloat(result[1])\n            normal.y = parseFloat(result[2])\n            normal.z = parseFloat(result[3])\n            normalCountPerFace++\n          }\n\n          while ((result = patternVertex.exec(text)) !== null) {\n            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]))\n            normals.push(normal.x, normal.y, normal.z)\n            vertexCountPerFace++\n            endVertex++\n          }\n\n          // every face have to own ONE valid normal\n\n          if (normalCountPerFace !== 1) {\n            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter)\n          }\n\n          // each face have to own THREE valid vertices\n\n          if (vertexCountPerFace !== 3) {\n            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter)\n          }\n\n          faceCounter++\n        }\n\n        const start = startVertex\n        const count = endVertex - startVertex\n\n        geometry.addGroup(start, count, groupCount)\n        groupCount++\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n\n      return geometry\n    }\n\n    function ensureString(buffer) {\n      if (typeof buffer !== 'string') {\n        return decodeText(new Uint8Array(buffer))\n      }\n\n      return buffer\n    }\n\n    function ensureBinary(buffer) {\n      if (typeof buffer === 'string') {\n        const array_buffer = new Uint8Array(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 0xff // implicitly assumes little-endian\n        }\n\n        return array_buffer.buffer || array_buffer\n      } else {\n        return buffer\n      }\n    }\n\n    // start\n\n    const binData = ensureBinary(data)\n\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data))\n  }\n}\n\nexport { STLLoader }\n"]},"metadata":{},"sourceType":"module"}