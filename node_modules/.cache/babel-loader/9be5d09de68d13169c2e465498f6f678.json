{"ast":null,"code":"import { Texture, DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, LinearFilter, DataUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nconst hasColorSpace = \"colorSpace\" in new Texture();\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE) lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n) p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);else wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);else wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function (dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10,\n        fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\"NO_COMPRESSION\", \"RLE_COMPRESSION\", \"ZIPS_COMPRESSION\", \"ZIP_COMPRESSION\", \"PIZ_COMPRESSION\", \"PXR24_COMPRESSION\", \"B44_COMPRESSION\", \"B44A_COMPRESSION\", \"DWAA_COMPRESSION\", \"DWAB_COMPRESSION\"];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return {\n        xMin,\n        yMin,\n        xMax,\n        yMax\n      };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~4) != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++) parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = RGBAFormat;else EXRDecoder2.format = RedFormat;\n      if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";else EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace;else texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport { EXRLoader };","map":{"version":3,"sources":["../../src/loaders/EXRLoader.js"],"names":["uInt8Array","buffer","comp","offset","type","y","x","tmpOffset","EXRHeader","EXRDecoder"],"mappings":"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","sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nconst hasColorSpace = 'colorSpace' in new Texture()\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"]},"metadata":{},"sourceType":"module"}