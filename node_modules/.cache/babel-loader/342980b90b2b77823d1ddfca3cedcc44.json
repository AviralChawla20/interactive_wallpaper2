{"ast":null,"code":"import { Loader, FileLoader, NumberKeyframeTrack, AnimationClip, BufferAttribute } from \"three\";\nclass MDDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(url, function (data) {\n      onLoad(scope.parse(data));\n    }, onProgress, onError);\n  }\n  parse(data) {\n    const view = new DataView(data);\n    const totalFrames = view.getUint32(0);\n    const totalPoints = view.getUint32(4);\n    let offset = 8;\n    const times = new Float32Array(totalFrames);\n    const values = new Float32Array(totalFrames * totalFrames).fill(0);\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset);\n      offset += 4;\n      values[totalFrames * i + i] = 1;\n    }\n    const track = new NumberKeyframeTrack(\".morphTargetInfluences\", times, values);\n    const clip = new AnimationClip(\"default\", times[times.length - 1], [track]);\n    const morphTargets = [];\n    for (let i = 0; i < totalFrames; i++) {\n      const morphTarget = new Float32Array(totalPoints * 3);\n      for (let j = 0; j < totalPoints; j++) {\n        const stride = j * 3;\n        morphTarget[stride + 0] = view.getFloat32(offset);\n        offset += 4;\n        morphTarget[stride + 1] = view.getFloat32(offset);\n        offset += 4;\n        morphTarget[stride + 2] = view.getFloat32(offset);\n        offset += 4;\n      }\n      const attribute = new BufferAttribute(morphTarget, 3);\n      attribute.name = \"morph_\" + i;\n      morphTargets.push(attribute);\n    }\n    return {\n      morphTargets,\n      clip\n    };\n  }\n}\nexport { MDDLoader };","map":{"version":3,"sources":["../../src/loaders/MDDLoader.js"],"names":[],"mappings":";AAcA,MAAM,SAAA,SAAkB,MAAA,CAAO;EAC7B,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;EACd;EAED,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,KAAA,GAAQ,IAAA;IAEd,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;IAC1C,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA;IACxB,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;IACpC,MAAA,CAAO,IAAA,CACL,GAAA,EACA,UAAU,IAAA,EAAM;MACd,MAAA,CAAO,KAAA,CAAM,KAAA,CAAM,IAAI,CAAC,CAAA;IACzB,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAED,KAAA,CAAM,IAAA,EAAM;IACV,MAAM,IAAA,GAAO,IAAI,QAAA,CAAS,IAAI,CAAA;IAE9B,MAAM,WAAA,GAAc,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;IACpC,MAAM,WAAA,GAAc,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;IAEpC,IAAI,MAAA,GAAS,CAAA;IAIb,MAAM,KAAA,GAAQ,IAAI,YAAA,CAAa,WAAW,CAAA;IAC1C,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,WAAA,GAAc,WAAW,CAAA,CAAE,IAAA,CAAK,CAAC,CAAA;IAEjE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,EAAa,CAAA,EAAA,EAAK;MACpC,KAAA,CAAM,CAAC,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;MACjC,MAAA,IAAU,CAAA;MACV,MAAA,CAAO,WAAA,GAAc,CAAA,GAAI,CAAC,CAAA,GAAI,CAAA;IAC/B;IAED,MAAM,KAAA,GAAQ,IAAI,mBAAA,CAAoB,wBAAA,EAA0B,KAAA,EAAO,MAAM,CAAA;IAC7E,MAAM,IAAA,GAAO,IAAI,aAAA,CAAc,SAAA,EAAW,KAAA,CAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,EAAG,CAAC,KAAK,CAAC,CAAA;IAI1E,MAAM,YAAA,GAAe,EAAE;IAEvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,EAAa,CAAA,EAAA,EAAK;MACpC,MAAM,WAAA,GAAc,IAAI,YAAA,CAAa,WAAA,GAAc,CAAC,CAAA;MAEpD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,EAAa,CAAA,EAAA,EAAK;QACpC,MAAM,MAAA,GAAS,CAAA,GAAI,CAAA;QAEnB,WAAA,CAAY,MAAA,GAAS,CAAC,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;QAChD,MAAA,IAAU,CAAA;QACV,WAAA,CAAY,MAAA,GAAS,CAAC,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;QAChD,MAAA,IAAU,CAAA;QACV,WAAA,CAAY,MAAA,GAAS,CAAC,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;QAChD,MAAA,IAAU,CAAA;MACX;MAED,MAAM,SAAA,GAAY,IAAI,eAAA,CAAgB,WAAA,EAAa,CAAC,CAAA;MACpD,SAAA,CAAU,IAAA,GAAO,QAAA,GAAW,CAAA;MAE5B,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA;IAC5B;IAED,OAAO;MACL,YAAA;MACA;IACD,CAAA;EACF;AACH","sourcesContent":["/**\n * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * number of frames (a single uint32)\n * number of vertices (a single uint32)\n * time values for each frame (sequence of float32)\n * vertex data for each frame (sequence of float32)\n */\n\nimport { AnimationClip, BufferAttribute, FileLoader, Loader, NumberKeyframeTrack } from 'three'\n\nclass MDDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.load(\n      url,\n      function (data) {\n        onLoad(scope.parse(data))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    const view = new DataView(data)\n\n    const totalFrames = view.getUint32(0)\n    const totalPoints = view.getUint32(4)\n\n    let offset = 8\n\n    // animation clip\n\n    const times = new Float32Array(totalFrames)\n    const values = new Float32Array(totalFrames * totalFrames).fill(0)\n\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset)\n      offset += 4\n      values[totalFrames * i + i] = 1\n    }\n\n    const track = new NumberKeyframeTrack('.morphTargetInfluences', times, values)\n    const clip = new AnimationClip('default', times[times.length - 1], [track])\n\n    // morph targets\n\n    const morphTargets = []\n\n    for (let i = 0; i < totalFrames; i++) {\n      const morphTarget = new Float32Array(totalPoints * 3)\n\n      for (let j = 0; j < totalPoints; j++) {\n        const stride = j * 3\n\n        morphTarget[stride + 0] = view.getFloat32(offset)\n        offset += 4 // x\n        morphTarget[stride + 1] = view.getFloat32(offset)\n        offset += 4 // y\n        morphTarget[stride + 2] = view.getFloat32(offset)\n        offset += 4 // z\n      }\n\n      const attribute = new BufferAttribute(morphTarget, 3)\n      attribute.name = 'morph_' + i\n\n      morphTargets.push(attribute)\n    }\n\n    return {\n      morphTargets: morphTargets,\n      clip: clip,\n    }\n  }\n}\n\nexport { MDDLoader }\n"]},"metadata":{},"sourceType":"module"}