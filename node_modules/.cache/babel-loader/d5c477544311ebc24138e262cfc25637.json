{"ast":null,"code":"import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0) return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1) geometryData.type = \"points\";else if (polygonDimensions[0] === 2) geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\") this.parseMaterialIndices(finalOffset);else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size()) return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0) return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active) return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\"| \".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? \" {\" : \"\", this.skipped ? \"SKIPPED\" : \"\", this.node == 0 && this.skipped ? \"}\" : \"\");\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active) return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport { IFFParser };","map":{"version":3,"sources":["../../../src/loaders/lwo/IFFParser.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nimport { LWO2Parser } from './LWO2Parser'\nimport { LWO3Parser } from './LWO3Parser'\n\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger()\n    // this.debugger.enable(); // un-comment to log IFF hierarchy.\n  }\n\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer)\n\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: [],\n    }\n\n    // start out at the top level to add any data before first layer is encountered\n    this.currentLayer = this.tree\n    this.currentForm = this.tree\n\n    this.parseTopForm()\n\n    if (this.tree.format === undefined) return\n\n    if (this.tree.format === 'LWO2') {\n      this.parser = new LWO2Parser(this)\n      while (!this.reader.endOfFile()) this.parser.parseBlock()\n    } else if (this.tree.format === 'LWO3') {\n      this.parser = new LWO3Parser(this)\n      while (!this.reader.endOfFile()) this.parser.parseBlock()\n    }\n\n    this.debugger.offset = this.reader.offset\n    this.debugger.closeForms()\n\n    return this.tree\n  }\n\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset\n\n    var topForm = this.reader.getIDTag()\n\n    if (topForm !== 'FORM') {\n      console.warn('LWOLoader: Top-level FORM missing.')\n      return\n    }\n\n    var length = this.reader.getUint32()\n\n    this.debugger.dataOffset = this.reader.offset\n    this.debugger.length = length\n\n    var type = this.reader.getIDTag()\n\n    if (type === 'LWO2') {\n      this.tree.format = type\n    } else if (type === 'LWO3') {\n      this.tree.format = type\n    }\n\n    this.debugger.node = 0\n    this.debugger.nodeID = type\n    this.debugger.log()\n\n    return\n  }\n\n  ///\n  // FORM PARSING METHODS\n  ///\n\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag()\n\n    switch (type) {\n      // SKIPPED FORMS\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n\n      case 'ISEQ': // Image sequence\n      case 'ANIM': // plug in animation\n      case 'STCC': // Color-cycling Still\n      case 'VPVL':\n      case 'VPRM':\n      case 'NROT':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n      case 'WRPH': // image wrap h\n      case 'FUNC':\n      case 'FALL':\n      case 'OPAC':\n      case 'GRAD': // gradient texture\n      case 'ENVS':\n      case 'VMOP':\n      case 'VMBG':\n\n      // Car Material FORMS\n      case 'OMAX':\n      case 'STEX':\n      case 'CKBG':\n      case 'CKEY':\n      case 'VMLA':\n      case 'VMLB':\n        this.debugger.skipped = true\n        this.skipForm(length) // not currently supported\n        break\n\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n      case 'META':\n      case 'NNDS':\n      case 'NODS':\n      case 'NDTA':\n      case 'ADAT':\n      case 'AOVS':\n      case 'BLOK':\n\n      // used by texture nodes\n      case 'IBGC': // imageBackgroundColor\n      case 'IOPC': // imageOpacity\n      case 'IIMG': // hold reference to image path\n      case 'TXTR':\n        // this.setupForm( type, length );\n        this.debugger.length = 4\n        this.debugger.skipped = true\n        break\n\n      case 'IFAL': // imageFallof\n      case 'ISCL': // imageScale\n      case 'IPOS': // imagePosition\n      case 'IROT': // imageRotation\n      case 'IBMP':\n      case 'IUTD':\n      case 'IVTD':\n        this.parseTextureNodeAttribute(type)\n        break\n\n      case 'ENVL':\n        this.parseEnvelope(length)\n        break\n\n      // CLIP FORM AND SUB FORMS\n\n      case 'CLIP':\n        if (this.tree.format === 'LWO2') {\n          this.parseForm(length)\n        } else {\n          this.parseClip(length)\n        }\n\n        break\n\n      case 'STIL':\n        this.parseImage()\n        break\n\n      case 'XREF': // clone of another STIL\n        this.reader.skip(8) // unknown\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString(), // internal unique ref\n        }\n        break\n\n      // Not in spec, used by texture nodes\n\n      case 'IMST':\n        this.parseImageStateForm(length)\n        break\n\n      // SURF FORM AND SUB FORMS\n\n      case 'SURF':\n        this.parseSurfaceForm(length)\n        break\n\n      case 'VALU': // Not in spec\n        this.parseValueForm(length)\n        break\n\n      case 'NTAG':\n        this.parseSubNode(length)\n        break\n\n      case 'ATTR': // BSDF Node Attributes\n      case 'SATR': // Standard Node Attributes\n        this.setupForm('attributes', length)\n        break\n\n      case 'NCON':\n        this.parseConnections(length)\n        break\n\n      case 'SSHA':\n        this.parentForm = this.currentForm\n        this.currentForm = this.currentSurface\n        this.setupForm('surfaceShader', length)\n        break\n\n      case 'SSHD':\n        this.setupForm('surfaceShaderData', length)\n        break\n\n      case 'ENTR': // Not in spec\n        this.parseEntryForm(length)\n        break\n\n      // Image Map Layer\n\n      case 'IMAP':\n        this.parseImageMap(length)\n        break\n\n      case 'TAMP':\n        this.parseXVAL('amplitude', length)\n        break\n\n      //Texture Mapping Form\n\n      case 'TMAP':\n        this.setupForm('textureMap', length)\n        break\n\n      case 'CNTR':\n        this.parseXVAL3('center', length)\n        break\n\n      case 'SIZE':\n        this.parseXVAL3('scale', length)\n        break\n\n      case 'ROTA':\n        this.parseXVAL3('rotation', length)\n        break\n\n      default:\n        this.parseUnknownForm(type, length)\n    }\n\n    this.debugger.node = 0\n    this.debugger.nodeID = type\n    this.debugger.log()\n  }\n\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode\n\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {}\n      this.currentForm = this.currentForm[type]\n    } else {\n      // should never see this unless there's a bug in the reader\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm)\n\n      this.currentForm = this.currentForm[type]\n    }\n  }\n\n  skipForm(length) {\n    this.reader.skip(length - 4)\n  }\n\n  parseUnknownForm(type, length) {\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length)\n\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4)\n    this.reader.skip(length - 4)\n  }\n\n  parseSurfaceForm(length) {\n    this.reader.skip(8) // unknown Uint32 x2\n\n    var name = this.reader.getString()\n\n    var surface = {\n      attributes: {}, // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString(),\n    }\n\n    this.tree.materials[name] = surface\n    this.currentSurface = surface\n\n    this.parentForm = this.tree.materials\n    this.currentForm = surface\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString()\n\n    var surface = {\n      attributes: {}, // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      nodes: {},\n      source: this.reader.getString(),\n    }\n\n    this.tree.materials[name] = surface\n    this.currentSurface = surface\n\n    this.parentForm = this.tree.materials\n    this.currentForm = surface\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  parseSubNode(length) {\n    // parse the NRNM CHUNK of the subnode FORM to get\n    // a meaningful name for the subNode\n    // some subnodes can be renamed, but Input and Surface cannot\n\n    this.reader.skip(8) // NRNM + length\n    var name = this.reader.getString()\n\n    var node = {\n      name: name,\n    }\n    this.currentForm = node\n    this.currentNode = node\n\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    this.currentForm = this.currentSurface.connections\n  }\n\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8) // NAME + length\n    var name = this.reader.getString()\n    this.currentForm = this.currentNode.attributes\n\n    this.setupForm(name, length)\n  }\n\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8) // unknown + length\n\n    var valueType = this.reader.getString()\n\n    if (valueType === 'double') {\n      this.currentForm.value = this.reader.getUint64()\n    } else if (valueType === 'int') {\n      this.currentForm.value = this.reader.getUint32()\n    } else if (valueType === 'vparam') {\n      this.reader.skip(24)\n      this.currentForm.value = this.reader.getFloat64()\n    } else if (valueType === 'vparam3') {\n      this.reader.skip(24)\n      this.currentForm.value = this.reader.getFloat64Array(3)\n    }\n  }\n\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8) // unknown\n\n    this.currentForm.mipMapLevel = this.reader.getFloat32()\n  }\n\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    if (!this.currentForm.maps) this.currentForm.maps = []\n\n    var map = {}\n    this.currentForm.maps.push(map)\n    this.currentForm = map\n\n    this.reader.skip(10) // unknown, could be an issue if it contains a VX\n  }\n\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28) // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n    this.reader.skip(20) // FORM + length + VPVL + float32 + Uint32\n\n    switch (type) {\n      case 'ISCL':\n        this.currentNode.scale = this.reader.getFloat32Array(3)\n        break\n      case 'IPOS':\n        this.currentNode.position = this.reader.getFloat32Array(3)\n        break\n      case 'IROT':\n        this.currentNode.rotation = this.reader.getFloat32Array(3)\n        break\n      case 'IFAL':\n        this.currentNode.falloff = this.reader.getFloat32Array(3)\n        break\n\n      case 'IBMP':\n        this.currentNode.amplitude = this.reader.getFloat32()\n        break\n      case 'IUTD':\n        this.currentNode.uTiles = this.reader.getFloat32()\n        break\n      case 'IVTD':\n        this.currentNode.vTiles = this.reader.getFloat32()\n        break\n    }\n\n    this.reader.skip(2) // unknown\n  }\n\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4) // skipping  entirely for now\n  }\n\n  ///\n  // CHUNK PARSING METHODS\n  ///\n\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag()\n\n    // inside surface node\n    if (tag === 'FORM') {\n      this.reader.skip(16)\n\n      this.currentNode.fileName = this.reader.getString()\n\n      return\n    }\n\n    // otherwise top level\n    this.reader.setOffset(this.reader.offset - 4)\n\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    this.reader.skip(8) // unknown\n\n    var texture = {\n      index: this.reader.getUint32(),\n    }\n    this.tree.textures.push(texture)\n    this.currentForm = texture\n  }\n\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: '',\n    }\n\n    // seach STIL block\n    while (true) {\n      var tag = this.reader.getIDTag()\n      var n_length = this.reader.getUint16()\n      if (tag === 'STIL') {\n        texture.fileName = this.reader.getString()\n        break\n      }\n\n      if (n_length >= length) {\n        break\n      }\n    }\n\n    this.tree.textures.push(texture)\n    this.currentForm = texture\n  }\n\n  parseImage() {\n    this.reader.skip(8) // unknown\n    this.currentForm.fileName = this.reader.getString()\n  }\n\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4\n    this.reader.skip(8)\n\n    this.currentForm[type] = this.reader.getFloat32()\n\n    this.reader.setOffset(endOffset) // set end offset directly to skip optional envelope\n  }\n\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4\n    this.reader.skip(8)\n\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32(),\n    }\n\n    this.reader.setOffset(endOffset)\n  }\n\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {}\n\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString(),\n    }\n  }\n\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(), // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3), // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString(),\n    }\n\n    this.tree.layers.push(layer)\n    this.currentLayer = layer\n\n    var parsedLength = 16 + stringOffset(this.currentLayer.name) // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n\n    // if we have not reached then end of the layer block, there must be a parent defined\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1 // omitted or -1 for no parent\n  }\n\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = []\n    for (var i = 0; i < length / 4; i += 3) {\n      // z -> -z to match three.js right handed coords\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32())\n    }\n  }\n\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length\n\n    var channelName = this.reader.getString()\n\n    if (this.reader.offset === finalOffset) {\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n      this.currentForm.UVChannel = channelName\n      return\n    }\n\n    // otherwise reset to initial length and parse normal VMAP CHUNK\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName))\n\n    var type = this.reader.getIDTag()\n\n    this.reader.getUint16() // dimension\n    var name = this.reader.getString()\n\n    var remainingLength = length - 6 - stringOffset(name)\n\n    switch (type) {\n      case 'TXUV':\n        this.parseUVMapping(name, finalOffset, discontinuous)\n        break\n      case 'MORF':\n      case 'SPOT':\n        this.parseMorphTargets(name, finalOffset, type) // can't be discontinuous\n        break\n      // unsupported VMAPs\n      case 'APSL':\n      case 'NORM':\n      case 'WGHT':\n      case 'MNVW':\n      case 'PICK':\n      case 'RGB ':\n      case 'RGBA':\n        this.reader.skip(remainingLength)\n        break\n      default:\n        console.warn('LWOLoader: unknown vertex map type: ' + type)\n        this.reader.skip(remainingLength)\n    }\n  }\n\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = []\n    var polyIndices = []\n    var uvs = []\n\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex())\n\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex())\n\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32())\n    }\n\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {}\n\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices: uvIndices,\n        polyIndices: polyIndices,\n        uvs: uvs,\n      }\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {}\n\n      this.currentLayer.uvs[name] = {\n        uvIndices: uvIndices,\n        uvs: uvs,\n      }\n    }\n  }\n\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = []\n    var points = []\n\n    type = type === 'MORF' ? 'relative' : 'absolute'\n\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex())\n      // z -> -z to match three.js right handed coords\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32())\n    }\n\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {}\n\n    this.currentLayer.morphTargets[name] = {\n      indices: indices,\n      points: points,\n      type: type,\n    }\n  }\n\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length\n    var type = this.reader.getIDTag()\n\n    var indices = []\n\n    // hold a list of polygon sizes, to be split up later\n    var polygonDimensions = []\n\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16()\n\n      //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n      numverts = numverts & 1023 // remaining ten low order bits are vertex num\n      polygonDimensions.push(numverts)\n\n      for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex())\n    }\n\n    var geometryData = {\n      type: type,\n      vertexIndices: indices,\n      polygonDimensions: polygonDimensions,\n      points: this.currentPoints,\n    }\n\n    // Note: assuming that all polys will be lines or points if the first is\n    if (polygonDimensions[0] === 1) geometryData.type = 'points'\n    else if (polygonDimensions[0] === 2) geometryData.type = 'lines'\n\n    this.currentLayer.geometry = geometryData\n  }\n\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length)\n  }\n\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length\n    var type = this.reader.getIDTag()\n    if (type === 'SURF') this.parseMaterialIndices(finalOffset)\n    else {\n      //PART, SMGP, COLR not supported\n\n      this.reader.skip(length - 4)\n    }\n  }\n\n  parseMaterialIndices(finalOffset) {\n    // array holds polygon index followed by material index\n    this.currentLayer.geometry.materialIndices = []\n\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex()\n      var materialIndex = this.reader.getUint16()\n\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex)\n    }\n  }\n\n  parseUnknownCHUNK(blockID, length) {\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length)\n\n    // print the chunk plus some bytes padding either side\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n    var data = this.reader.getString(length)\n\n    this.currentForm[blockID] = data\n  }\n}\n\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this._textDecoder = new TextDecoder()\n    this._bytes = new Uint8Array(buffer)\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset\n    } else {\n      console.error('LWOLoader: invalid buffer offset')\n    }\n  }\n\n  endOfFile() {\n    if (this.offset >= this.size()) return true\n    return false\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  getUint8() {\n    var value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getUint16() {\n    var value = this.dv.getUint16(this.offset)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getUint64() {\n    var low, high\n\n    high = this.getUint32()\n    low = this.getUint32()\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    var a = []\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    var a = []\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8()\n\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8()\n    }\n\n    return firstByte * 256 + this.getUint8()\n  }\n\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4)\n  }\n\n  getString(size) {\n    if (size === 0) return\n\n    const start = this.offset\n\n    let result\n    let length\n\n    if (size) {\n      length = size\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size))\n    } else {\n      // use 1:1 mapping of buffer to avoid redundant new array creation.\n      length = this._bytes.indexOf(0, start) - start\n\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length))\n\n      // account for null byte in length\n      length++\n\n      // if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too\n      length += length % 2\n    }\n\n    this.skip(length)\n\n    return result\n  }\n\n  getStringArray(size) {\n    var a = this.getString(size)\n    a = a.split('\\0')\n\n    return a.filter(Boolean) // return array with any empty strings removed\n  }\n}\n\n// ************** DEBUGGER  **************\n\nclass Debugger {\n  constructor() {\n    this.active = false\n    this.depth = 0\n    this.formList = []\n  }\n\n  enable() {\n    this.active = true\n  }\n\n  log() {\n    if (!this.active) return\n\n    var nodeType\n\n    switch (this.node) {\n      case 0:\n        nodeType = 'FORM'\n        break\n\n      case 1:\n        nodeType = 'CHK'\n        break\n\n      case 2:\n        nodeType = 'S-CHK'\n        break\n    }\n\n    console.log(\n      '| '.repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? ' {' : '',\n      this.skipped ? 'SKIPPED' : '',\n      this.node == 0 && this.skipped ? '}' : '',\n    )\n\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1\n      this.formList.push(this.dataOffset + this.length)\n    }\n\n    this.skipped = false\n  }\n\n  closeForms() {\n    if (!this.active) return\n\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1\n        console.log('| '.repeat(this.depth) + '}')\n        this.formList.splice(-1, 1)\n      }\n    }\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isEven(num) {\n  return num % 2\n}\n\n// calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0)\n}\n\n// for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)))\n}\n\nexport { IFFParser }\n"]},"metadata":{},"sourceType":"module"}