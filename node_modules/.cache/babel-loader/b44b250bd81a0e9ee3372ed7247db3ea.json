{"ast":null,"code":"import { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from \"three\";\nconst _object_pattern = /^[og]\\s*(.+)?/;\nconst _material_library_pattern = /^mtllib /;\nconst _material_use_pattern = /^usemtl /;\nconst _map_use_pattern = /^usemap /;\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\nconst _ab = new Vector3();\nconst _cb = new Vector3();\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n    materials: {},\n    materialLibraries: [],\n    startObject: function (name, fromDeclaration) {\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration !== false;\n        return;\n      }\n      const previousMaterial = this.object && typeof this.object.currentMaterial === \"function\" ? this.object.currentMaterial() : void 0;\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n      this.object = {\n        name: name || \"\",\n        fromDeclaration: fromDeclaration !== false,\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false\n        },\n        materials: [],\n        smooth: true,\n        startMaterial: function (name2, libraries) {\n          const previous = this._finalize(false);\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n          }\n          const material = {\n            index: this.materials.length,\n            name: name2 || \"\",\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : \"\",\n            smooth: previous !== void 0 ? previous.smooth : this.smooth,\n            groupStart: previous !== void 0 ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === \"number\" ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false\n              };\n              cloned.clone = this.clone.bind(cloned);\n              return cloned;\n            }\n          };\n          this.materials.push(material);\n          return material;\n        },\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n          }\n          return void 0;\n        },\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial();\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n          }\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1);\n              }\n            }\n          }\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: \"\",\n              smooth: this.smooth\n            });\n          }\n          return lastMultiMaterial;\n        }\n      };\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n        const declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n      this.objects.push(this.object);\n    },\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n    },\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    },\n    addVertex: function (a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addVertexPoint: function (a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addVertexLine: function (a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addNormal: function (a, b, c) {\n      const src = this.normals;\n      const dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.normals;\n      _vA.fromArray(src, a);\n      _vB.fromArray(src, b);\n      _vC.fromArray(src, c);\n      _cb.subVectors(_vC, _vB);\n      _ab.subVectors(_vA, _vB);\n      _cb.cross(_ab);\n      _cb.normalize();\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n    },\n    addColor: function (a, b, c) {\n      const src = this.colors;\n      const dst = this.object.geometry.colors;\n      if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addUV: function (a, b, c) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    },\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs;\n      dst.push(0, 0);\n      dst.push(0, 0);\n      dst.push(0, 0);\n    },\n    addUVLine: function (a) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    },\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length;\n      let ia = this.parseVertexIndex(a, vLen);\n      let ib = this.parseVertexIndex(b, vLen);\n      let ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n      this.addColor(ia, ib, ic);\n      if (na !== void 0 && na !== \"\") {\n        const nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = this.parseNormalIndex(nb, nLen);\n        ic = this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      } else {\n        this.addFaceNormal(ia, ib, ic);\n      }\n      if (ua !== void 0 && ua !== \"\") {\n        const uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n        this.object.geometry.hasUVIndices = true;\n      } else {\n        this.addDefaultUV();\n      }\n    },\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = \"Points\";\n      const vLen = this.vertices.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen);\n        this.addVertexPoint(index);\n        this.addColor(index);\n      }\n    },\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = \"Line\";\n      const vLen = this.vertices.length;\n      const uvLen = this.uvs.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n      }\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n      }\n    }\n  };\n  state.startObject(\"\", false);\n  return state;\n}\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = null;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setMaterials(materials) {\n    this.materials = materials;\n    return this;\n  }\n  parse(text) {\n    const state = new ParserState();\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    if (text.indexOf(\"\\\\\\n\") !== -1) {\n      text = text.replace(/\\\\\\n/g, \"\");\n    }\n    const lines = text.split(\"\\n\");\n    let line = \"\",\n      lineFirstChar = \"\";\n    let lineLength = 0;\n    let result = [];\n    const trimLeft = typeof \"\".trimLeft === \"function\";\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i];\n      line = trimLeft ? line.trimLeft() : line.trim();\n      lineLength = line.length;\n      if (lineLength === 0) continue;\n      lineFirstChar = line.charAt(0);\n      if (lineFirstChar === \"#\") continue;\n      if (lineFirstChar === \"v\") {\n        const data = line.split(/\\s+/);\n        switch (data[0]) {\n          case \"v\":\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n            } else {\n              state.colors.push(void 0, void 0, void 0);\n            }\n            break;\n          case \"vn\":\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n            break;\n          case \"vt\":\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n            break;\n        }\n      } else if (lineFirstChar === \"f\") {\n        const lineData = line.substr(1).trim();\n        const vertexData = lineData.split(/\\s+/);\n        const faceVertices = [];\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j];\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split(\"/\");\n            faceVertices.push(vertexParts);\n          }\n        }\n        const v1 = faceVertices[0];\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j];\n          const v3 = faceVertices[j + 1];\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n        }\n      } else if (lineFirstChar === \"l\") {\n        const lineParts = line.substring(1).trim().split(\" \");\n        let lineVertices = [];\n        const lineUVs = [];\n        if (line.indexOf(\"/\") === -1) {\n          lineVertices = lineParts;\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split(\"/\");\n            if (parts[0] !== \"\") lineVertices.push(parts[0]);\n            if (parts[1] !== \"\") lineUVs.push(parts[1]);\n          }\n        }\n        state.addLineGeometry(lineVertices, lineUVs);\n      } else if (lineFirstChar === \"p\") {\n        const lineData = line.substr(1).trim();\n        const pointData = lineData.split(\" \");\n        state.addPointGeometry(pointData);\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        const name = (\" \" + result[0].substr(1).trim()).substr(1);\n        state.startObject(name);\n      } else if (_material_use_pattern.test(line)) {\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n      } else if (_material_library_pattern.test(line)) {\n        state.materialLibraries.push(line.substring(7).trim());\n      } else if (_map_use_pattern.test(line)) {\n        console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n      } else if (lineFirstChar === \"s\") {\n        result = line.split(\" \");\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase();\n          state.object.smooth = value !== \"0\" && value !== \"off\";\n        } else {\n          state.object.smooth = true;\n        }\n        const material = state.object.currentMaterial();\n        if (material) material.smooth = state.object.smooth;\n      } else {\n        if (line === \"\\0\") continue;\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n      }\n    }\n    state.finalize();\n    const container = new Group();\n    container.materialLibraries = [].concat(state.materialLibraries);\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i];\n        const geometry = object.geometry;\n        const materials = object.materials;\n        const isLine = geometry.type === \"Line\";\n        const isPoints = geometry.type === \"Points\";\n        let hasVertexColors = false;\n        if (geometry.vertices.length === 0) continue;\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(geometry.vertices, 3));\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute(\"normal\", new Float32BufferAttribute(geometry.normals, 3));\n        }\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true;\n          buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(geometry.colors, 3));\n        }\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute(\"uv\", new Float32BufferAttribute(geometry.uvs, 2));\n        }\n        const createdMaterials = [];\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi];\n          const materialHash = sourceMaterial.name + \"_\" + sourceMaterial.smooth + \"_\" + hasVertexColors;\n          let material = state.materials[materialHash];\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name);\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial();\n              Material.prototype.copy.call(materialLine, material);\n              materialLine.color.copy(material.color);\n              material = materialLine;\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({\n                size: 10,\n                sizeAttenuation: false\n              });\n              Material.prototype.copy.call(materialPoints, material);\n              materialPoints.color.copy(material.color);\n              materialPoints.map = material.map;\n              material = materialPoints;\n            }\n          }\n          if (material === void 0) {\n            if (isLine) {\n              material = new LineBasicMaterial();\n            } else if (isPoints) {\n              material = new PointsMaterial({\n                size: 1,\n                sizeAttenuation: false\n              });\n            } else {\n              material = new MeshPhongMaterial();\n            }\n            material.name = sourceMaterial.name;\n            material.flatShading = sourceMaterial.smooth ? false : true;\n            material.vertexColors = hasVertexColors;\n            state.materials[materialHash] = material;\n          }\n          createdMaterials.push(material);\n        }\n        let mesh;\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials);\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0]);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0]);\n          }\n        }\n        mesh.name = object.name;\n        container.add(mesh);\n      }\n    } else {\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({\n          size: 1,\n          sizeAttenuation: false\n        });\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(state.vertices, 3));\n        if (state.colors.length > 0 && state.colors[0] !== void 0) {\n          buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(state.colors, 3));\n          material.vertexColors = true;\n        }\n        const points = new Points(buffergeometry, material);\n        container.add(points);\n      }\n    }\n    return container;\n  }\n}\nexport { OBJLoader };","map":{"version":3,"sources":["../../src/loaders/OBJLoader.js"],"names":["name"],"mappings":"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","sourcesContent":["import {\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Material,\n  Mesh,\n  MeshPhongMaterial,\n  Points,\n  PointsMaterial,\n  Vector3,\n} from 'three'\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /\n// usemap map_name\nconst _map_use_pattern = /^usemap /\n\nconst _vA = new Vector3()\nconst _vB = new Vector3()\nconst _vC = new Vector3()\n\nconst _ab = new Vector3()\nconst _cb = new Vector3()\n\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n\n    materials: {},\n    materialLibraries: [],\n\n    startObject: function (name, fromDeclaration) {\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\n      // file. We need to use it for the first parsed g/o to keep things in sync.\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name\n        this.object.fromDeclaration = fromDeclaration !== false\n        return\n      }\n\n      const previousMaterial =\n        this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n\n      this.object = {\n        name: name || '',\n        fromDeclaration: fromDeclaration !== false,\n\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false,\n        },\n        materials: [],\n        smooth: true,\n\n        startMaterial: function (name, libraries) {\n          const previous = this._finalize(false)\n\n          // New usemtl declaration overwrites an inherited material, except if faces were declared\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1)\n          }\n\n          const material = {\n            index: this.materials.length,\n            name: name || '',\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === 'number' ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n              }\n              cloned.clone = this.clone.bind(cloned)\n              return cloned\n            },\n          }\n\n          this.materials.push(material)\n\n          return material\n        },\n\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1]\n          }\n\n          return undefined\n        },\n\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial()\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart\n            lastMultiMaterial.inherited = false\n          }\n\n          // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1)\n              }\n            }\n          }\n\n          // Guarantee at least one empty material, this makes the creation later more straight forward.\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: '',\n              smooth: this.smooth,\n            })\n          }\n\n          return lastMultiMaterial\n        },\n      }\n\n      // Inherit previous objects material.\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\n      // overwrite the inherited material. Exception being that there was already face declarations\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        const declared = previousMaterial.clone(0)\n        declared.inherited = true\n        this.object.materials.push(declared)\n      }\n\n      this.objects.push(this.object)\n    },\n\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n    },\n\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 2) * 2\n    },\n\n    addVertex: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addVertexPoint: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addVertexLine: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addNormal: function (a, b, c) {\n      const src = this.normals\n      const dst = this.object.geometry.normals\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.normals\n\n      _vA.fromArray(src, a)\n      _vB.fromArray(src, b)\n      _vC.fromArray(src, c)\n\n      _cb.subVectors(_vC, _vB)\n      _ab.subVectors(_vA, _vB)\n      _cb.cross(_ab)\n\n      _cb.normalize()\n\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n    },\n\n    addColor: function (a, b, c) {\n      const src = this.colors\n      const dst = this.object.geometry.colors\n\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2])\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2])\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addUV: function (a, b, c) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n      dst.push(src[b + 0], src[b + 1])\n      dst.push(src[c + 0], src[c + 1])\n    },\n\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs\n\n      dst.push(0, 0)\n      dst.push(0, 0)\n      dst.push(0, 0)\n    },\n\n    addUVLine: function (a) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n    },\n\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length\n\n      let ia = this.parseVertexIndex(a, vLen)\n      let ib = this.parseVertexIndex(b, vLen)\n      let ic = this.parseVertexIndex(c, vLen)\n\n      this.addVertex(ia, ib, ic)\n      this.addColor(ia, ib, ic)\n\n      // normals\n\n      if (na !== undefined && na !== '') {\n        const nLen = this.normals.length\n\n        ia = this.parseNormalIndex(na, nLen)\n        ib = this.parseNormalIndex(nb, nLen)\n        ic = this.parseNormalIndex(nc, nLen)\n\n        this.addNormal(ia, ib, ic)\n      } else {\n        this.addFaceNormal(ia, ib, ic)\n      }\n\n      // uvs\n\n      if (ua !== undefined && ua !== '') {\n        const uvLen = this.uvs.length\n\n        ia = this.parseUVIndex(ua, uvLen)\n        ib = this.parseUVIndex(ub, uvLen)\n        ic = this.parseUVIndex(uc, uvLen)\n\n        this.addUV(ia, ib, ic)\n\n        this.object.geometry.hasUVIndices = true\n      } else {\n        // add placeholder values (for inconsistent face definitions)\n\n        this.addDefaultUV()\n      }\n    },\n\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = 'Points'\n\n      const vLen = this.vertices.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen)\n\n        this.addVertexPoint(index)\n        this.addColor(index)\n      }\n    },\n\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = 'Line'\n\n      const vLen = this.vertices.length\n      const uvLen = this.uvs.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen))\n      }\n\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen))\n      }\n    },\n  }\n\n  state.startObject('', false)\n\n  return state\n}\n\n//\n\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.materials = null\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterials(materials) {\n    this.materials = materials\n\n    return this\n  }\n\n  parse(text) {\n    const state = new ParserState()\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    if (text.indexOf('\\\\\\n') !== -1) {\n      // join lines separated by a line continuation character (\\)\n      text = text.replace(/\\\\\\n/g, '')\n    }\n\n    const lines = text.split('\\n')\n    let line = '',\n      lineFirstChar = ''\n    let lineLength = 0\n    let result = []\n\n    // Faster to just trim left side of the line. Use if available.\n    const trimLeft = typeof ''.trimLeft === 'function'\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i]\n\n      line = trimLeft ? line.trimLeft() : line.trim()\n\n      lineLength = line.length\n\n      if (lineLength === 0) continue\n\n      lineFirstChar = line.charAt(0)\n\n      // @todo invoke passed in handler if any\n      if (lineFirstChar === '#') continue\n\n      if (lineFirstChar === 'v') {\n        const data = line.split(/\\s+/)\n\n        switch (data[0]) {\n          case 'v':\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]))\n            } else {\n              // if no colors are defined, add placeholders so color and vertex indices match\n\n              state.colors.push(undefined, undefined, undefined)\n            }\n\n            break\n          case 'vn':\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            break\n          case 'vt':\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]))\n            break\n        }\n      } else if (lineFirstChar === 'f') {\n        const lineData = line.substr(1).trim()\n        const vertexData = lineData.split(/\\s+/)\n        const faceVertices = []\n\n        // Parse the face vertex data into an easy to work with format\n\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j]\n\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split('/')\n            faceVertices.push(vertexParts)\n          }\n        }\n\n        // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n        const v1 = faceVertices[0]\n\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j]\n          const v3 = faceVertices[j + 1]\n\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2])\n        }\n      } else if (lineFirstChar === 'l') {\n        const lineParts = line.substring(1).trim().split(' ')\n        let lineVertices = []\n        const lineUVs = []\n\n        if (line.indexOf('/') === -1) {\n          lineVertices = lineParts\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split('/')\n\n            if (parts[0] !== '') lineVertices.push(parts[0])\n            if (parts[1] !== '') lineUVs.push(parts[1])\n          }\n        }\n\n        state.addLineGeometry(lineVertices, lineUVs)\n      } else if (lineFirstChar === 'p') {\n        const lineData = line.substr(1).trim()\n        const pointData = lineData.split(' ')\n\n        state.addPointGeometry(pointData)\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        // o object_name\n        // or\n        // g group_name\n\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        // let name = result[ 0 ].substr( 1 ).trim();\n        const name = (' ' + result[0].substr(1).trim()).substr(1)\n\n        state.startObject(name)\n      } else if (_material_use_pattern.test(line)) {\n        // material\n\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries)\n      } else if (_material_library_pattern.test(line)) {\n        // mtl file\n\n        state.materialLibraries.push(line.substring(7).trim())\n      } else if (_map_use_pattern.test(line)) {\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n        console.warn(\n          'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.',\n        )\n      } else if (lineFirstChar === 's') {\n        result = line.split(' ')\n\n        // smooth shading\n\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n        // but does not define a usemtl for each face set.\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n        // where explicit usemtl defines geometry groups.\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n        /*\n         * http://paulbourke.net/dataformats/obj/\n         * or\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n         *\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n         * than 0.\"\n         */\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase()\n          state.object.smooth = value !== '0' && value !== 'off'\n        } else {\n          // ZBrush can produce \"s\" lines #11707\n          state.object.smooth = true\n        }\n\n        const material = state.object.currentMaterial()\n        if (material) material.smooth = state.object.smooth\n      } else {\n        // Handle null terminated files without exception\n        if (line === '\\0') continue\n\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"')\n      }\n    }\n\n    state.finalize()\n\n    const container = new Group()\n    container.materialLibraries = [].concat(state.materialLibraries)\n\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0)\n\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i]\n        const geometry = object.geometry\n        const materials = object.materials\n        const isLine = geometry.type === 'Line'\n        const isPoints = geometry.type === 'Points'\n        let hasVertexColors = false\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3))\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3))\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3))\n        }\n\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2))\n        }\n\n        // Create materials\n\n        const createdMaterials = []\n\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi]\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors\n          let material = state.materials[materialHash]\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name)\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial()\n              Material.prototype.copy.call(materialLine, material)\n              materialLine.color.copy(material.color)\n              material = materialLine\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false })\n              Material.prototype.copy.call(materialPoints, material)\n              materialPoints.color.copy(material.color)\n              materialPoints.map = material.map\n              material = materialPoints\n            }\n          }\n\n          if (material === undefined) {\n            if (isLine) {\n              material = new LineBasicMaterial()\n            } else if (isPoints) {\n              material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n            } else {\n              material = new MeshPhongMaterial()\n            }\n\n            material.name = sourceMaterial.name\n            material.flatShading = sourceMaterial.smooth ? false : true\n            material.vertexColors = hasVertexColors\n\n            state.materials[materialHash] = material\n          }\n\n          createdMaterials.push(material)\n        }\n\n        // Create mesh\n\n        let mesh\n\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi]\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi)\n          }\n\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials)\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials)\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials)\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0])\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0])\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0])\n          }\n        }\n\n        mesh.name = object.name\n\n        container.add(mesh)\n      }\n    } else {\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3))\n\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3))\n          material.vertexColors = true\n        }\n\n        const points = new Points(buffergeometry, material)\n        container.add(points)\n      }\n    }\n\n    return container\n  }\n}\n\nexport { OBJLoader }\n"]},"metadata":{},"sourceType":"module"}