{"ast":null,"code":"import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function () {\n        return index;\n      },\n      set: function (value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    const canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap) canvasMap.colorSpace = \"srgb\";else canvasMap.encoding = 3001;\n    const material = new MeshBasicMaterial({\n      map: canvasMap,\n      side: DoubleSide,\n      transparent: true\n    });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n    const iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer;\n    const imgData = ctx.getImageData(0, 0, iLength, jLength);\n    const data = imgData.data;\n    const volumeData = volume.data;\n    const upperThreshold = volume.upperThreshold;\n    const lowerThreshold = volume.lowerThreshold;\n    const windowLow = volume.windowLow;\n    const windowHigh = volume.windowHigh;\n    let pixelCount = 0;\n    if (volume.dataType === \"label\") {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          const color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 255;\n          data[4 * pixelCount + 1] = color >> 16 & 255;\n          data[4 * pixelCount + 2] = color >> 8 & 255;\n          data[4 * pixelCount + 3] = color & 255;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)];\n          let alpha = 255;\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  }\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n    if (this.geometry) this.geometry.dispose();\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry;\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n    this.geometryNeedsUpdate = false;\n  }\n}\nexport { VolumeSlice };","map":{"version":3,"sources":["../../src/misc/VolumeSlice.js"],"names":[],"mappings":"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","sourcesContent":["import { ClampToEdgeWrapping, DoubleSide, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Texture } from 'three'\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this\n    /**\n     * @member {Volume} volume The associated volume\n     */\n    this.volume = volume\n    /**\n     * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n     */\n    index = index || 0\n    Object.defineProperty(this, 'index', {\n      get: function () {\n        return index\n      },\n      set: function (value) {\n        index = value\n        slice.geometryNeedsUpdate = true\n        return index\n      },\n    })\n    /**\n     * @member {String} axis The normal axis\n     */\n    this.axis = axis || 'z'\n\n    /**\n     * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctx Context of the canvas\n     */\n    this.canvas = document.createElement('canvas')\n    /**\n     * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n     */\n    this.canvasBuffer = document.createElement('canvas')\n    this.updateGeometry()\n\n    const canvasMap = new Texture(this.canvas)\n    canvasMap.minFilter = LinearFilter\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping\n    if ('colorSpace' in canvasMap) canvasMap.colorSpace = 'srgb'\n    else canvasMap.encoding = 3001 // sRGBEncoding\n    const material = new MeshBasicMaterial({ map: canvasMap, side: DoubleSide, transparent: true })\n    /**\n     * @member {Mesh} mesh The mesh ready to get used in the scene\n     */\n    this.mesh = new Mesh(this.geometry, material)\n    this.mesh.matrixAutoUpdate = false\n    /**\n     * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n     */\n    this.geometryNeedsUpdate = true\n    this.repaint()\n\n    /**\n     * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n     */\n\n    /**\n     * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n     */\n\n    /**\n     * @member {Function} sliceAccess Function that allow the slice to access right data\n     * @see Volume.extractPerpendicularPlane\n     * @param {Number} i The first coordinate\n     * @param {Number} j The second coordinate\n     * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n     */\n  }\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry()\n    }\n\n    const iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer\n\n    // get the imageData and pixel array from the canvas\n    const imgData = ctx.getImageData(0, 0, iLength, jLength)\n    const data = imgData.data\n    const volumeData = volume.data\n    const upperThreshold = volume.upperThreshold\n    const lowerThreshold = volume.lowerThreshold\n    const windowLow = volume.windowLow\n    const windowHigh = volume.windowHigh\n\n    // manipulate some pixel elements\n    let pixelCount = 0\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)]\n          label = label >= this.colorMap.length ? (label % this.colorMap.length) + 1 : label\n          const color = this.colorMap[label]\n          data[4 * pixelCount] = (color >> 24) & 0xff\n          data[4 * pixelCount + 1] = (color >> 16) & 0xff\n          data[4 * pixelCount + 2] = (color >> 8) & 0xff\n          data[4 * pixelCount + 3] = color & 0xff\n          pixelCount++\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)]\n          let alpha = 0xff\n          //apply threshold\n          alpha = upperThreshold >= value ? (lowerThreshold <= value ? alpha : 0) : 0\n          //apply window level\n          value = Math.floor((255 * (value - windowLow)) / (windowHigh - windowLow))\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0\n\n          data[4 * pixelCount] = value\n          data[4 * pixelCount + 1] = value\n          data[4 * pixelCount + 2] = value\n          data[4 * pixelCount + 3] = alpha\n          pixelCount++\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0)\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height)\n\n    this.mesh.material.map.needsUpdate = true\n  }\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index)\n    this.sliceAccess = extracted.sliceAccess\n    this.jLength = extracted.jLength\n    this.iLength = extracted.iLength\n    this.matrix = extracted.matrix\n\n    this.canvas.width = extracted.planeWidth\n    this.canvas.height = extracted.planeHeight\n    this.canvasBuffer.width = this.iLength\n    this.canvasBuffer.height = this.jLength\n    this.ctx = this.canvas.getContext('2d')\n    this.ctxBuffer = this.canvasBuffer.getContext('2d')\n\n    if (this.geometry) this.geometry.dispose() // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight)\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry\n      //reset mesh matrix\n      this.mesh.matrix.identity()\n      this.mesh.applyMatrix4(this.matrix)\n    }\n\n    this.geometryNeedsUpdate = false\n  }\n}\n\nexport { VolumeSlice }\n"]},"metadata":{},"sourceType":"module"}