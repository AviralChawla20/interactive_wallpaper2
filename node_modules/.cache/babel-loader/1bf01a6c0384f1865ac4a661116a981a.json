{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from \"three\";\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n};\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o;\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\nconst getUniforms = splineTexture => ({\n  spineTexture: {\n    value: splineTexture\n  },\n  pathOffset: {\n    type: \"f\",\n    value: 0\n  },\n  // time of path curve\n  pathSegment: {\n    type: \"f\",\n    value: 1\n  },\n  // fractional length of path\n  spineOffset: {\n    type: \"f\",\n    value: 161\n  },\n  spineLength: {\n    type: \"f\",\n    value: 400\n  },\n  flow: {\n    type: \"i\",\n    value: 1\n  }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`.replace(\"#include <beginnormal_vertex>\", \"\").replace(\"#include <defaultnormal_vertex>\", \"\").replace(\"#include <begin_vertex>\", \"\").replace(/void\\s*main\\s*\\(\\)\\s*\\{/, /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace(\"#include <project_vertex>\", /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    __publicField(this, \"curveArray\");\n    __publicField(this, \"curveLengthArray\");\n    __publicField(this, \"object3D\");\n    __publicField(this, \"splineTexure\");\n    __publicField(this, \"uniforms\");\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error(\"Index out of range for Flow\");\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n}\nconst matrix = new Matrix4();\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n    __publicField(this, \"offsets\");\n    __publicField(this, \"whichCurve\");\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error(\"curve index being set is Not a Number (NaN)\");\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n}\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"sources":["../../src/modifiers/CurveModifier.ts"],"names":[],"mappings":"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","sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4\nconst TEXTURE_WIDTH = 1024\nconst TEXTURE_HEIGHT = 4\n\nimport {\n  DataTexture,\n  RGBAFormat,\n  FloatType,\n  RepeatWrapping,\n  Mesh,\n  InstancedMesh,\n  NearestFilter,\n  DynamicDrawUsage,\n  Matrix4,\n  Material,\n  Curve,\n  BufferGeometry,\n} from 'three'\n\nimport type { IUniform } from 'three'\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport const initSplineTexture = (numberOfCurves = 1): DataTexture => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS)\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType)\n\n  dataTexture.wrapS = RepeatWrapping\n  dataTexture.wrapT = RepeatWrapping\n  dataTexture.magFilter = NearestFilter\n  dataTexture.needsUpdate = true\n\n  return dataTexture\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport const updateSplineTexture = <TCurve extends Curve<any>>(\n  texture: DataTexture,\n  splineCurve: TCurve,\n  offset = 0,\n): void => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4))\n  splineCurve.arcLengthDivisions = numberOfPoints / 2\n  splineCurve.updateArcLengths()\n  const points = splineCurve.getSpacedPoints(numberOfPoints)\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true)\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH)\n    const rowIndex = i % TEXTURE_WIDTH\n\n    let pt = points[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.tangents[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.normals[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.binormals[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset)\n  }\n\n  texture.needsUpdate = true\n}\n\nconst setTextureValue = (texture: DataTexture, index: number, x: number, y: number, z: number, o: number): void => {\n  const image = texture.image\n  const { data } = image\n  const i = CHANNELS * TEXTURE_WIDTH * o // Row Offset\n  data[index * CHANNELS + i + 0] = x\n  data[index * CHANNELS + i + 1] = y\n  data[index * CHANNELS + i + 2] = z\n  data[index * CHANNELS + i + 3] = 1\n}\n\nexport interface INumericUniform extends IUniform {\n  type: 'f' | 'i'\n  value: number\n}\n\nexport type CurveModifierUniforms = {\n  spineTexture: IUniform<DataTexture>\n  pathOffset: INumericUniform\n  pathSegment: INumericUniform\n  spineOffset: INumericUniform\n  spineLength: INumericUniform\n  flow: INumericUniform\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport const getUniforms = (splineTexture: DataTexture): CurveModifierUniforms => ({\n  spineTexture: { value: splineTexture },\n  pathOffset: { type: 'f', value: 0 }, // time of path curve\n  pathSegment: { type: 'f', value: 1 }, // fractional length of path\n  spineOffset: { type: 'f', value: 161 },\n  spineLength: { type: 'f', value: 400 },\n  flow: { type: 'i', value: 1 },\n})\n\nexport type ModifiedMaterial<TMaterial extends Material> = TMaterial & {\n  __ok: boolean\n}\n\nexport function modifyShader<TMaterial extends Material = Material>(\n  material: ModifiedMaterial<TMaterial>,\n  uniforms: CurveModifierUniforms,\n  numberOfCurves = 1,\n): void {\n  if (material.__ok) return\n  material.__ok = true\n\n  material.onBeforeCompile = (shader: { vertexShader: string; uniforms: { [uniform: string]: IUniform } }): void => {\n    if ((shader as any).__modified) return\n    ;(shader as any).__modified = true\n\n    Object.assign(shader.uniforms, uniforms)\n\n    const vertexShader = /* glsl */ `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n      // chunk import moved in front of modified shader below\n      .replace('#include <beginnormal_vertex>', '')\n\n      // vec3 transformedNormal declaration overriden below\n      .replace('#include <defaultnormal_vertex>', '')\n\n      // vec3 transformed declaration overriden below\n      .replace('#include <begin_vertex>', '')\n\n      // shader override\n      .replace(\n        /void\\s*main\\s*\\(\\)\\s*\\{/,\n        /* glsl */ `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`,\n      )\n      .replace(\n        '#include <project_vertex>',\n        /* glsl */ `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`,\n      )\n\n    shader.vertexShader = vertexShader\n  }\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport class Flow<TMesh extends Mesh = Mesh> {\n  public curveArray: Curve<any>[]\n  public curveLengthArray: number[]\n\n  public object3D: TMesh\n  public splineTexure: DataTexture\n  public uniforms: CurveModifierUniforms\n\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh: TMesh, numberOfCurves = 1) {\n    const obj3D = mesh.clone() as TMesh\n    const splineTexure = initSplineTexture(numberOfCurves)\n    const uniforms = getUniforms(splineTexure)\n\n    obj3D.traverse((child) => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone()\n        modifyShader(child.material, uniforms, numberOfCurves)\n      }\n    })\n\n    this.curveArray = new Array(numberOfCurves)\n    this.curveLengthArray = new Array(numberOfCurves)\n\n    this.object3D = obj3D\n    this.splineTexure = splineTexure\n    this.uniforms = uniforms\n  }\n\n  public updateCurve<TCurve extends Curve<any>>(index: number, curve: TCurve): void {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow')\n    const curveLength = curve.getLength()\n    this.uniforms.spineLength.value = curveLength\n    this.curveLengthArray[index] = curveLength\n    this.curveArray[index] = curve\n    updateSplineTexture(this.splineTexure, curve, index)\n  }\n\n  public moveAlongCurve(amount: number): void {\n    this.uniforms.pathOffset.value += amount\n  }\n}\nconst matrix = new Matrix4()\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport class InstancedFlow<\n  TGeometry extends BufferGeometry = BufferGeometry,\n  TMaterial extends Material = Material\n> extends Flow<InstancedMesh<TGeometry, TMaterial>> {\n  public offsets: number[]\n  public whichCurve: number[]\n\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count: number, curveCount: number, geometry: TGeometry, material: TMaterial) {\n    const mesh = new InstancedMesh(geometry, material, count)\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage)\n    mesh.frustumCulled = false\n    super(mesh, curveCount)\n\n    this.offsets = new Array(count).fill(0)\n    this.whichCurve = new Array(count).fill(0)\n  }\n\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  private writeChanges(index: number): void {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index])\n    this.object3D.setMatrixAt(index, matrix)\n    this.object3D.instanceMatrix.needsUpdate = true\n  }\n\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  public moveIndividualAlongCurve(index: number, offset: number): void {\n    this.offsets[index] += offset\n    this.writeChanges(index)\n  }\n\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  public setCurve(index: number, curveNo: number): void {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)')\n    this.whichCurve[index] = curveNo\n    this.writeChanges(index)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}