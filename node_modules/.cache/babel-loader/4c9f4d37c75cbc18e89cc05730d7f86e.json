{"ast":null,"code":"import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + `\tgl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`;\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = `varying vec2 v${UV1 === \"uv1\" ? UV1 : \"Uv2\"};\n` + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\nvec3 texelOld = texture2D(previousShadowMap, v${UV1 === \"uv1\" ? UV1 : \"Uv2\"}).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms;\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute(\"uv\")) {\n        console.warn(\"All lightmap objects need UVs!\");\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1e3 + ob;\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object\n      });\n      this.compiled = false;\n    }\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv1 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute(UV1, uv1);\n      objects[box.index].geometry.getAttribute(UV1).needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    }\n    const oldTarget = this.renderer.getRenderTarget();\n    this.blurringPlane.visible = blurEdges;\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget);\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    }\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = void 0) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn(\"Call this after adding the objects!\");\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != void 0) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3\n    };\n    blurMaterial.onBeforeCompile = shader => {\n      shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`;\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms;\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = \"Blurring Plane\";\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport { ProgressiveLightMap };","map":{"version":3,"sources":["../../src/misc/ProgressiveLightmap.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Scene,\n  WebGLRenderTarget,\n  FloatType,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  DoubleSide,\n  PlaneGeometry,\n  Mesh,\n} from 'three'\nimport potpack from 'potpack'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer\n    this.res = res\n    this.lightMapContainers = []\n    this.compiled = false\n    this.scene = new Scene()\n    this.scene.background = null\n    this.tinyTarget = new WebGLRenderTarget(1, 1)\n    this.buffer1Active = false\n    this.firstUpdate = true\n    this.warned = false\n\n    // Create the Progressive LightMap Texture\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format })\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format })\n\n    // Inject some spicy new logic into a standard phong material\n    this.uvMat = new MeshPhongMaterial()\n    this.uvMat.uniforms = {}\n    this.uvMat.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_LIGHTMAP\\n' +\n        shader.vertexShader.slice(0, -1) +\n        `\tgl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        `varying vec2 v${UV1 === 'uv1' ? UV1 : 'Uv2'};\\n` +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\\nvec3 texelOld = texture2D(previousShadowMap, v${UV1 === 'uv1' ? UV1 : 'Uv2'}).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture }\n      shader.uniforms.averagingWindow = { value: 100 }\n\n      this.uvMat.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      this.uvMat.userData.shader = shader\n\n      this.compiled = true\n    }\n  }\n\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = []\n    const padding = 3 / this.res\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]\n\n      // If this object is a light, simply add it to the internal scene\n      if (object.isLight) {\n        this.scene.attach(object)\n        continue\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!')\n        continue\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1)\n      }\n\n      // Apply the lightmap to the object\n      object.material.lightMap = this.progressiveLightMap2.texture\n      object.material.dithering = true\n      object.castShadow = true\n      object.receiveShadow = true\n      object.renderOrder = 1000 + ob\n\n      // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n      this.uv_boxes.push({ w: 1 + padding * 2, h: 1 + padding * 2, index: ob })\n\n      this.lightMapContainers.push({ basicMat: object.material, object: object })\n\n      this.compiled = false\n    }\n\n    // Pack the objects' lightmap UVs into the same global space\n    const dimensions = potpack(this.uv_boxes)\n    this.uv_boxes.forEach((box) => {\n      const uv1 = objects[box.index].geometry.getAttribute('uv').clone()\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h\n      }\n\n      objects[box.index].geometry.setAttribute(UV1, uv1)\n      objects[box.index].geometry.getAttribute(UV1).needsUpdate = true\n    })\n  }\n\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return\n    }\n\n    // Store the original Render Target\n    const oldTarget = this.renderer.getRenderTarget()\n\n    // The blurring plane applies blur to the seams of the lightmap\n    this.blurringPlane.visible = blurEdges\n\n    // Steal the Object3D from the real world to our special dimension\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent\n      this.scene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Render once normally to initialize everything\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget) // Tiny for Speed\n      this.renderer.render(this.scene, camera)\n      this.firstUpdate = false\n    }\n\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = { value: blendWindow }\n      this.lightMapContainers[l].object.material = this.uvMat\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled\n      this.lightMapContainers[l].object.frustumCulled = false\n    }\n\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1\n\n    // Render the object's surface maps\n    this.renderer.setRenderTarget(activeMap)\n    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.buffer1Active = !this.buffer1Active\n    this.renderer.render(this.scene, camera)\n\n    // Restore the object's Real-time Material and add it back to the original world\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Restore the original Render Target\n    this.renderer.setRenderTarget(oldTarget)\n  }\n\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!')\n        this.warned = true\n      }\n\n      return\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide,\n      })\n      this.labelPlane = new PlaneGeometry(100, 100)\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial)\n      this.labelMesh.position.y = 250\n      this.lightMapContainers[0].object.parent.add(this.labelMesh)\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position)\n    }\n\n    this.labelMesh.visible = visible\n  }\n\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial()\n    blurMaterial.uniforms = {\n      previousShadowMap: { value: null },\n      pixelOffset: { value: 1.0 / res },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0,\n    }\n    blurMaterial.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'\n\n      // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        '#define USE_UV\\n' +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`\n\n      // Set the LightMap Accumulation Buffer\n      shader.uniforms.previousShadowMap = { value: lightMap.texture }\n      shader.uniforms.pixelOffset = { value: 0.5 / res }\n      blurMaterial.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      blurMaterial.userData.shader = shader\n\n      this.compiled = true\n    }\n\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial)\n    this.blurringPlane.name = 'Blurring Plane'\n    this.blurringPlane.frustumCulled = false\n    this.blurringPlane.renderOrder = 0\n    this.blurringPlane.material.depthWrite = false\n    this.scene.add(this.blurringPlane)\n  }\n}\n\nexport { ProgressiveLightMap }\n"]},"metadata":{},"sourceType":"module"}