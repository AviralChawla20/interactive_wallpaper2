{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer();\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n  return `data:${blob.type || \"\"};base64,${data}`;\n}\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader: (/* glsl */\n    `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `),\n    fragmentShader: (/* glsl */\n    `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `)\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\n/**\n * Static utility functions\n */\n__publicField(GLTFExporter, \"Utils\", {\n  insertKeyframe: function (track, time) {\n    const tolerance = 1e-3;\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n});\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(resolve => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign({\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, {\n      type: \"application/octet-stream\"\n    });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      blob.arrayBuffer().then(result => {\n        const binaryChunk = getPaddedArrayBuffer(result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        glbBlob.arrayBuffer().then(onDone);\n      });\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then(uri => {\n          json.buffers[0].uri = uri;\n          onDone(json);\n        });\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return blob.arrayBuffer().then(result => {\n      const buffer = getPaddedArrayBuffer(result);\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength\n      };\n      writer.byteOffset += buffer.byteLength;\n      return json.bufferViews.push(bufferViewDef) - 1;\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n    }\n    if (start === void 0) start = 0;\n    if (count === void 0) count = attribute.count;\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType\n      };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {\n          imageDef.bufferView = bufferViewIndex;\n        }));\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(getToBlobPromise(canvas, mimeType).then(readAsDataURL).then(uri => {\n            imageDef.uri = uri;\n          }));\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\") mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== \"\") materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      ...(version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      }),\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\") continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0) return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: void 0,\n      count: void 0\n    }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized) attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\") cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\") nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null) children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\") sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = {\n        index: writer.processTexture(material.anisotropyMap)\n      };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nexport { GLTFExporter };","map":{"version":3,"sources":["../../src/exporters/GLTFExporter.js"],"names":["uids","nodeIndex"],"mappings":"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","sourcesContent":["import {\n  REVISION,\n  BufferAttribute,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  MathUtils,\n  Matrix4,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  PropertyBinding,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  Texture,\n  CompressedTexture,\n  Vector3,\n  PlaneGeometry,\n  ShaderMaterial,\n  Uniform,\n  Mesh,\n  PerspectiveCamera,\n  WebGLRenderer,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer()\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)))\n  return `data:${blob.type || ''};base64,${data}`\n}\n\nlet _renderer\nlet fullscreenQuadGeometry\nlet fullscreenQuadMaterial\nlet fullscreenQuad\n\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: /* glsl */ `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `,\n      fragmentShader: /* glsl */ `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `,\n    })\n\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture\n  fullscreenQuadMaterial.defines.IS_SRGB =\n    'colorSpace' in texture ? texture.colorSpace === 'srgb' : texture.encoding === 3001\n  fullscreenQuadMaterial.needsUpdate = true\n\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial)\n    fullscreenQuad.frustrumCulled = false\n  }\n\n  const _camera = new PerspectiveCamera()\n  const _scene = new Scene()\n  _scene.add(fullscreenQuad)\n\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false })\n  }\n\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize))\n  renderer.clear()\n  renderer.render(_scene, _camera)\n\n  const readableTexture = new Texture(renderer.domElement)\n\n  readableTexture.minFilter = texture.minFilter\n  readableTexture.magFilter = texture.magFilter\n  readableTexture.wrapS = texture.wrapS\n  readableTexture.wrapT = texture.wrapT\n  readableTexture.name = texture.name\n\n  if (_renderer) {\n    _renderer.dispose()\n    _renderer = null\n  }\n\n  return readableTexture\n}\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    'byte',\n    'byte normalized',\n    'unsigned byte',\n    'unsigned byte normalized',\n    'short',\n    'short normalized',\n    'unsigned short',\n    'unsigned short normalized',\n  ],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short'],\n}\n\nclass GLTFExporter {\n  /**\n   * Static utility functions\n   */\n  static Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001 // 1ms\n      const valueSize = track.getValueSize()\n\n      const times = new track.TimeBufferType(track.times.length + 1)\n      const values = new track.ValueBufferType(track.values.length + valueSize)\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize))\n\n      let index\n\n      if (track.times.length === 0) {\n        times[0] = time\n\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0\n        }\n\n        index = 0\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0\n\n        times[0] = time\n        times.set(track.times, 1)\n\n        values.set(interpolant.evaluate(time), 0)\n        values.set(track.values, valueSize)\n\n        index = 0\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1\n        }\n\n        times[times.length - 1] = time\n        times.set(track.times, 0)\n\n        values.set(track.values, 0)\n        values.set(interpolant.evaluate(time), track.values.length)\n\n        index = times.length - 1\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i\n\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0)\n            times[i + 1] = time\n            times.set(track.times.slice(i + 1), i + 2)\n\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0)\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize)\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize)\n\n            index = i + 1\n\n            break\n          }\n        }\n      }\n\n      track.times = times\n      track.values = values\n\n      return index\n    },\n\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = []\n      const mergedTracks = {}\n      const sourceTracks = clip.tracks\n\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i]\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name)\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName)\n\n        if (\n          sourceTrackBinding.propertyName !== 'morphTargetInfluences' ||\n          sourceTrackBinding.propertyIndex === undefined\n        ) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack)\n          continue\n        }\n\n        if (\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear\n        ) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.')\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.')\n\n          sourceTrack = sourceTrack.clone()\n          sourceTrack.setInterpolation(InterpolateLinear)\n        }\n\n        const targetCount = sourceTrackNode.morphTargetInfluences.length\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex]\n\n        if (targetIndex === undefined) {\n          throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex)\n        }\n\n        let mergedTrack\n\n        // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone()\n\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length)\n\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j]\n          }\n\n          // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n          mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences'\n          mergedTrack.values = values\n\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack\n          tracks.push(mergedTrack)\n\n          continue\n        }\n\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1))\n\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]\n\n        // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j])\n        }\n\n        // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j])\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j]\n        }\n      }\n\n      clip.tracks = tracks\n\n      return clip\n    },\n  }\n\n  constructor() {\n    this.pluginCallbacks = []\n\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer)\n    })\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter()\n    const plugins = []\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer))\n    }\n\n    writer.setPlugins(plugins)\n    writer.write(input, onDone, options).catch(onError)\n  }\n\n  parseAsync(input, options) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options)\n    })\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497,\n}\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization'\n\nconst THREE_TO_WEBGL = {}\n\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights',\n}\n\nconst DEFAULT_SPECULAR_COLOR = new Color()\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12\nconst GLB_HEADER_MAGIC = 0x46546c67\nconst GLB_VERSION = 2\n\nconst GLB_CHUNK_PREFIX_BYTES = 8\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return (\n    array1.length === array2.length &&\n    array1.every(function (element, index) {\n      return element === array2[index]\n    })\n  )\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\n  }\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a]\n      } else {\n        if (a === 0) value = attribute.getX(i)\n        else if (a === 1) value = attribute.getY(i)\n        else if (a === 2) value = attribute.getZ(i)\n        else if (a === 3) value = attribute.getW(i)\n\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array)\n        }\n      }\n\n      output.min[a] = Math.min(output.min[a], value)\n      output.max[a] = Math.max(output.max[a], value)\n    }\n  }\n\n  return output\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength)\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength)\n    array.set(new Uint8Array(arrayBuffer))\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte\n      }\n    }\n\n    return array.buffer\n  }\n\n  return arrayBuffer\n}\n\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1)\n  }\n\n  return document.createElement('canvas')\n}\n\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType))\n  }\n\n  let quality\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8\n  }\n\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality,\n  })\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = []\n\n    this.options = {}\n    this.pending = []\n    this.buffers = []\n\n    this.byteOffset = 0\n    this.buffers = []\n    this.nodeMap = new Map()\n    this.skins = []\n\n    this.extensionsUsed = {}\n    this.extensionsRequired = {}\n\n    this.uids = new Map()\n    this.uid = 0\n\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter',\n      },\n    }\n\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map(),\n    }\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false,\n      },\n      options,\n    )\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true\n    }\n\n    this.processInput(input)\n\n    await Promise.all(this.pending)\n\n    const writer = this\n    const buffers = writer.buffers\n    const json = writer.json\n    options = writer.options\n\n    const extensionsUsed = writer.extensionsUsed\n    const extensionsRequired = writer.extensionsRequired\n\n    // Merge buffers.\n    const blob = new Blob(buffers, { type: 'application/octet-stream' })\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed)\n    const extensionsRequiredList = Object.keys(extensionsRequired)\n\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size\n\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      blob.arrayBuffer().then((result) => {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(result)\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true)\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true)\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20)\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true)\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true)\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES)\n        const headerView = new DataView(header)\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true)\n        headerView.setUint32(4, GLB_VERSION, true)\n        const totalByteLength =\n          GLB_HEADER_BYTES +\n          jsonChunkPrefix.byteLength +\n          jsonChunk.byteLength +\n          binaryChunkPrefix.byteLength +\n          binaryChunk.byteLength\n        headerView.setUint32(8, totalByteLength, true)\n\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream',\n        })\n\n        glbBlob.arrayBuffer().then(onDone)\n      })\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri\n          onDone(json)\n        })\n      } else {\n        onDone(json)\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return\n\n    const options = this.options\n    const extensionsUsed = this.extensionsUsed\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData))\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {}\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName]\n          extensionsUsed[extensionName] = true\n        }\n\n        delete json.gltfExtensions\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" +\n          object.name +\n          \"' \" +\n          \"won't be serialized because of JSON.stringify error - \" +\n          error.message,\n      )\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map()\n\n      uids.set(true, this.uid++)\n      uids.set(false, this.uid++)\n\n      this.uids.set(attribute, uids)\n    }\n\n    const uids = this.uids.get(attribute)\n\n    return uids.get(isRelativeCopy)\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return false\n\n    const v = new Vector3()\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal)\n\n    const attribute = normal.clone()\n    const v = new Vector3()\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i)\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0)\n      } else {\n        v.normalize()\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z)\n    }\n\n    cache.attributesNormalized.set(normal, attribute)\n\n    return attribute\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false\n    const transformDef = {}\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray()\n      didTransform = true\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation\n      didTransform = true\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray()\n      didTransform = true\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {}\n      mapDef.extensions['KHR_texture_transform'] = transformDef\n      this.extensionsUsed['KHR_texture_transform'] = true\n    }\n  }\n\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap\n\n    function getEncodingConversion(map) {\n      if ('colorSpace' in map ? map.colorSpace === 'srgb' : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)\n        }\n      }\n\n      return function LinearToLinear(c) {\n        return c\n      }\n    }\n\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.')\n\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap)\n    }\n\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap)\n    }\n\n    const metalness = metalnessMap ? metalnessMap.image : null\n    const roughness = roughnessMap ? roughnessMap.image : null\n\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0)\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0)\n\n    const canvas = getCanvas()\n    canvas.width = width\n    canvas.height = height\n\n    const context = canvas.getContext('2d')\n    context.fillStyle = '#00ffff'\n    context.fillRect(0, 0, width, height)\n\n    const composite = context.getImageData(0, 0, width, height)\n\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(metalnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(roughnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    context.putImageData(composite, 0, 0)\n\n    //\n\n    const reference = metalnessMap || roughnessMap\n\n    const texture = reference.clone()\n\n    // TODO Use new Source() instead?\n    texture.source = new Texture(canvas).source\n    if ('colorSpace' in texture) texture.colorSpace = ''\n    else texture.encoding = 3000\n    texture.channel = (metalnessMap || roughnessMap).channel\n\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.')\n    }\n\n    return texture\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json\n    const buffers = this.buffers\n\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }]\n\n    // All buffers are merged before export.\n    buffers.push(buffer)\n\n    return 0\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize\n\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1\n\n        break\n\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2\n\n        break\n\n      default:\n        componentSize = 4\n    }\n\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize)\n    const dataView = new DataView(new ArrayBuffer(byteLength))\n    let offset = 0\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a]\n        } else {\n          if (a === 0) value = attribute.getX(i)\n          else if (a === 1) value = attribute.getY(i)\n          else if (a === 2) value = attribute.getZ(i)\n          else if (a === 3) value = attribute.getW(i)\n\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array)\n          }\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value)\n        }\n\n        offset += componentSize\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength,\n    }\n\n    if (target !== undefined) bufferViewDef.target = target\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize\n    }\n\n    this.byteOffset += byteLength\n\n    json.bufferViews.push(bufferViewDef)\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0,\n    }\n\n    return output\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this\n    const json = writer.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result)\n\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength,\n      }\n\n      writer.byteOffset += buffer.byteLength\n      return json.bufferViews.push(bufferViewDef) - 1\n    })\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json\n\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4',\n    }\n\n    let componentType\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE\n    } else {\n      throw new Error(\n        'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name,\n      )\n    }\n\n    if (start === undefined) start = 0\n    if (count === undefined) count = attribute.count\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null\n\n    const minMax = getMinMax(attribute, start, count)\n    let bufferViewTarget\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget =\n        attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget)\n\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize],\n    }\n\n    if (attribute.normalized === true) accessorDef.normalized = true\n    if (!json.accessors) json.accessors = []\n\n    return json.accessors.push(accessorDef) - 1\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this\n      const cache = writer.cache\n      const json = writer.json\n      const options = writer.options\n      const pending = writer.pending\n\n      if (!cache.images.has(image)) cache.images.set(image, {})\n\n      const cachedImages = cache.images.get(image)\n\n      const key = mimeType + ':flipY/' + flipY.toString()\n\n      if (cachedImages[key] !== undefined) return cachedImages[key]\n\n      if (!json.images) json.images = []\n\n      const imageDef = { mimeType: mimeType }\n\n      const canvas = getCanvas()\n\n      canvas.width = Math.min(image.width, options.maxTextureSize)\n      canvas.height = Math.min(image.height, options.maxTextureSize)\n\n      const ctx = canvas.getContext('2d')\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height)\n        ctx.scale(1, -1)\n      }\n\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format)\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image)\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4)\n\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0]\n          data[i + 1] = image.data[i + 1]\n          data[i + 2] = image.data[i + 2]\n          data[i + 3] = image.data[i + 3]\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0)\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height)\n      }\n\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType)\n            .then((blob) => writer.processBufferViewImage(blob))\n            .then((bufferViewIndex) => {\n              imageDef.bufferView = bufferViewIndex\n            }),\n        )\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType)\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType)\n              .then(readAsDataURL)\n              .then((uri) => {\n                imageDef.uri = uri\n              }),\n          )\n        }\n      }\n\n      const index = json.images.push(imageDef) - 1\n      cachedImages[key] = index\n      return index\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.')\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json\n\n    if (!json.samplers) json.samplers = []\n\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT],\n    }\n\n    return json.samplers.push(samplerDef) - 1\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this\n    const options = writer.options\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.textures.has(map)) return cache.textures.get(map)\n\n    if (!json.textures) json.textures = []\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize)\n    }\n\n    let mimeType = map.userData.mimeType\n\n    if (mimeType === 'image/webp') mimeType = 'image/png'\n\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType),\n    }\n\n    if (map.name) textureDef.name = map.name\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef)\n    })\n\n    const index = json.textures.push(textureDef) - 1\n    cache.textures.set(map, index)\n    return index\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.materials.has(material)) return cache.materials.get(material)\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.')\n      return null\n    }\n\n    if (!json.materials) json.materials = []\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = { pbrMetallicRoughness: {} }\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.')\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity])\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap)\n\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel,\n      }\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture)\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel,\n      }\n      this.applyTextureTransform(baseColorMapDef, material.map)\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef\n    }\n\n    if (material.emissive) {\n      const emissive = material.emissive\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b)\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray()\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel,\n        }\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap)\n        materialDef.emissiveTexture = emissiveMapDef\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel,\n      }\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap)\n      materialDef.normalTexture = normalMapDef\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel,\n      }\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap)\n      materialDef.occlusionTexture = occlusionMapDef\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND'\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK'\n        materialDef.alphaCutoff = material.alphaTest\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true\n    if (material.name !== '') materialDef.name = material.name\n\n    this.serializeUserData(material, materialDef)\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef)\n    })\n\n    const index = json.materials.push(materialDef) - 1\n    cache.materials.set(material, index)\n    return index\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache\n    const json = this.json\n\n    const meshCacheKeyParts = [mesh.geometry.uuid]\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid)\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid)\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':')\n\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey)\n\n    const geometry = mesh.geometry\n\n    let mode\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES\n    }\n\n    const meshDef = {}\n    const attributes = {}\n    const primitives = []\n    const targets = []\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      ...(version >= 152\n        ? {\n            uv: 'TEXCOORD_0',\n            uv1: 'TEXCOORD_1',\n            uv2: 'TEXCOORD_2',\n            uv3: 'TEXCOORD_3',\n          }\n        : {\n            uv: 'TEXCOORD_0',\n            uv2: 'TEXCOORD_1',\n          }),\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0',\n    }\n\n    const originalNormal = geometry.getAttribute('normal')\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.')\n\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal))\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue\n\n      const attribute = geometry.attributes[attributeName]\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase()\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/\n\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute))\n        continue\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null\n      const array = attribute.array\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.')\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized)\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry)\n\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute)\n        }\n\n        attributes[attributeName] = accessor\n        cache.attributes.set(this.getUID(attribute), accessor)\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal)\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = []\n      const targetNames = []\n      const reverseDictionary = {}\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {}\n        let warned = false\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.')\n              warned = true\n            }\n\n            continue\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i]\n          const gltfAttributeName = attributeName.toUpperCase()\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName]\n\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true))\n            continue\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone()\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j))\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j))\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j))\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j))\n              }\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry)\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName])\n        }\n\n        targets.push(target)\n\n        weights.push(mesh.morphTargetInfluences[i])\n\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i])\n      }\n\n      meshDef.weights = weights\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {}\n        meshDef.extras.targetNames = targetNames\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material)\n\n    if (isMultiMaterial && geometry.groups.length === 0) return null\n\n    const materials = isMultiMaterial ? mesh.material : [mesh.material]\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }]\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes,\n      }\n\n      this.serializeUserData(geometry, primitive)\n\n      if (targets.length > 0) primitive.targets = targets\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index)\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey)\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count)\n          cache.attributes.set(cacheKey, primitive.indices)\n        }\n\n        if (primitive.indices === null) delete primitive.indices\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex])\n\n      if (material !== null) primitive.material = material\n\n      primitives.push(primitive)\n    }\n\n    meshDef.primitives = primitives\n\n    if (!json.meshes) json.meshes = []\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef)\n    })\n\n    const index = json.meshes.push(meshDef) - 1\n    cache.meshes.set(meshCacheKey, index)\n    return index\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return\n\n    let attrType = undefined\n\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte'\n\n        break\n\n      case Uint8Array:\n        attrType = 'unsigned byte'\n\n        break\n\n      case Int16Array:\n        attrType = 'short'\n\n        break\n\n      case Uint16Array:\n        attrType = 'unsigned short'\n\n        break\n\n      default:\n        return\n    }\n\n    if (attribute.normalized) attrType += ' normalized'\n\n    const attrNamePrefix = attributeName.split('_', 1)[0]\n\n    if (\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] &&\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)\n    ) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true\n    }\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json\n\n    if (!json.cameras) json.cameras = []\n\n    const isOrtho = camera.isOrthographicCamera\n\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective',\n    }\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type\n\n    return json.cameras.push(cameraDef) - 1\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    if (!json.animations) json.animations = []\n\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root)\n\n    const tracks = clip.tracks\n    const channels = []\n    const samplers = []\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i]\n      const trackBinding = PropertyBinding.parseTrackName(track.name)\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName)\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName]\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex)\n        } else {\n          trackNode = undefined\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name)\n        return null\n      }\n\n      const inputItemSize = 1\n      let outputItemSize = track.values.length / track.times.length\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length\n      }\n\n      let interpolation\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP'\n      } else {\n        interpolation = 'LINEAR'\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation,\n      })\n\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty,\n        },\n      })\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels,\n    })\n\n    return json.animations.length - 1\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    const node = json.nodes[nodeMap.get(object)]\n\n    const skeleton = object.skeleton\n\n    if (skeleton === undefined) return null\n\n    const rootJoint = object.skeleton.bones[0]\n\n    if (rootJoint === undefined) return null\n\n    const joints = []\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16)\n    const temporaryBoneInverse = new Matrix4()\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]))\n      temporaryBoneInverse.copy(skeleton.boneInverses[i])\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16)\n    }\n\n    if (json.skins === undefined) json.skins = []\n\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint),\n    })\n\n    const skinIndex = (node.skin = json.skins.length - 1)\n\n    return skinIndex\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json\n    const options = this.options\n    const nodeMap = this.nodeMap\n\n    if (!json.nodes) json.nodes = []\n\n    const nodeDef = {}\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray()\n      const position = object.position.toArray()\n      const scale = object.scale.toArray()\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix()\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name)\n\n    this.serializeUserData(object, nodeDef)\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object)\n\n      if (meshIndex !== null) nodeDef.mesh = meshIndex\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object)\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object)\n\n    if (object.children.length > 0) {\n      const children = []\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i]\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child)\n\n          if (nodeIndex !== null) children.push(nodeIndex)\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef)\n    })\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1\n    nodeMap.set(object, nodeIndex)\n    return nodeIndex\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json\n    const options = this.options\n\n    if (!json.scenes) {\n      json.scenes = []\n      json.scene = 0\n    }\n\n    const sceneDef = {}\n\n    if (scene.name !== '') sceneDef.name = scene.name\n\n    json.scenes.push(sceneDef)\n\n    const nodes = []\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i]\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child)\n\n        if (nodeIndex !== null) nodes.push(nodeIndex)\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes\n\n    this.serializeUserData(scene, sceneDef)\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene()\n    scene.name = 'AuxScene'\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i])\n    }\n\n    this.processScene(scene)\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options\n\n    input = input instanceof Array ? input : [input]\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input)\n    })\n\n    const objectsWithoutScene = []\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i])\n      } else {\n        objectsWithoutScene.push(input[i])\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene)\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i])\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0])\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input)\n    })\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i])\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_lights_punctual'\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light)\n      return\n    }\n\n    const writer = this.writer\n    const json = writer.json\n    const extensionsUsed = writer.extensionsUsed\n\n    const lightDef = {}\n\n    if (light.name) lightDef.name = light.name\n\n    lightDef.color = light.color.toArray()\n\n    lightDef.intensity = light.intensity\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional'\n    } else if (light.isPointLight) {\n      lightDef.type = 'point'\n\n      if (light.distance > 0) lightDef.range = light.distance\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot'\n\n      if (light.distance > 0) lightDef.range = light.distance\n\n      lightDef.spot = {}\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0\n      lightDef.spot.outerConeAngle = light.angle\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn(\n        'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.',\n      )\n    }\n\n    if (\n      light.target &&\n      (light.target.parent !== light ||\n        light.target.position.x !== 0 ||\n        light.target.position.y !== 0 ||\n        light.target.position.z !== -1)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Light direction may be lost. For best results, ' +\n          'make light.target a child of the light with position 0,0,-1.',\n      )\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {}\n      json.extensions[this.name] = { lights: [] }\n      extensionsUsed[this.name] = true\n    }\n\n    const lights = json.extensions[this.name].lights\n    lights.push(lightDef)\n\n    nodeDef.extensions = nodeDef.extensions || {}\n    nodeDef.extensions[this.name] = { light: lights.length - 1 }\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_unlit'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = {}\n\n    extensionsUsed[this.name] = true\n\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_clearcoat'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.clearcoatFactor = material.clearcoat\n\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap)\n      extensionDef.clearcoatTexture = clearcoatMapDef\n    }\n\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness\n\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap)\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef\n    }\n\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap)\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_iridescence'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.iridescenceFactor = material.iridescence\n\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap)\n      extensionDef.iridescenceTexture = iridescenceMapDef\n    }\n\n    extensionDef.iridescenceIor = material.iridescenceIOR\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0]\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1]\n\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap)\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_transmission'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.transmissionFactor = material.transmission\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel,\n      }\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap)\n      extensionDef.transmissionTexture = transmissionMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_volume'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.thicknessFactor = material.thickness\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel,\n      }\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap)\n      extensionDef.thicknessTexture = thicknessMapDef\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance\n    extensionDef.attenuationColor = material.attenuationColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_ior'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.ior = material.ior\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_specular'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (\n      !material.isMeshPhysicalMaterial ||\n      (material.specularIntensity === 1.0 &&\n        material.specularColor.equals(DEFAULT_SPECULAR_COLOR) &&\n        !material.specularIntensityMap &&\n        !material.specularColorTexture)\n    )\n      return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel,\n      }\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap)\n      extensionDef.specularTexture = specularIntensityMapDef\n    }\n\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel,\n      }\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap)\n      extensionDef.specularColorTexture = specularColorMapDef\n    }\n\n    extensionDef.specularFactor = material.specularIntensity\n    extensionDef.specularColorFactor = material.specularColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_sheen'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap)\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef\n    }\n\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel,\n      }\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap)\n      extensionDef.sheenColorTexture = sheenColorMapDef\n    }\n\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness\n    extensionDef.sheenColorFactor = material.sheenColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_anisotropy'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) }\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap)\n      extensionDef.anisotropyTexture = anisotropyMapDef\n    }\n\n    extensionDef.anisotropyStrength = material.anisotropy\n    extensionDef.anisotropyRotation = material.anisotropyRotation\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_emissive_strength'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.emissiveStrength = material.emissiveIntensity\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\nexport { GLTFExporter }\n"]},"metadata":{},"sourceType":"module"}