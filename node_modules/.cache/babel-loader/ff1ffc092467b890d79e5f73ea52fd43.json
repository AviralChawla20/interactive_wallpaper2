{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst _DRACOExporter = class {\n  parse(object, options = {\n    decodeSpeed: 5,\n    encodeSpeed: 5,\n    encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n    quantization: [16, 8, 8, 8, 8],\n    exportUvs: true,\n    exportNormals: true,\n    exportColor: false\n  }) {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n    }\n    if (DracoEncoderModule === void 0) {\n      throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n    }\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");\n    }\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      const faces = geometry.getIndex();\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n        for (let i = 0; i < faces2.length; i++) {\n          faces2[i] = i;\n        }\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n      }\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute(\"normal\");\n        if (normals !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute(\"uv\");\n        if (uvs !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n        if (colors !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n        if (colors !== void 0) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error(\"DRACOExporter: Unsupported object type.\");\n    }\n    const encodedData = new dracoEncoder.DracoInt8Array();\n    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n    if (options.encoderMethod !== void 0) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    }\n    if (options.quantization !== void 0) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== void 0) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n    let length;\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n    dracoEncoder.destroy(dracoObject);\n    if (length === 0) {\n      throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n    }\n    const outputData = new Int8Array(new ArrayBuffer(length));\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n};\nlet DRACOExporter = _DRACOExporter;\n// Encoder methods\n__publicField(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\n__publicField(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\n// Geometry type\n__publicField(DRACOExporter, \"POINT_CLOUD\", 0);\n__publicField(DRACOExporter, \"TRIANGULAR_MESH\", 1);\n// Attribute type\n__publicField(DRACOExporter, \"INVALID\", -1);\n__publicField(DRACOExporter, \"POSITION\", 0);\n__publicField(DRACOExporter, \"NORMAL\", 1);\n__publicField(DRACOExporter, \"COLOR\", 2);\n__publicField(DRACOExporter, \"TEX_COORD\", 3);\n__publicField(DRACOExporter, \"GENERIC\", 4);\nexport { DRACOExporter };","map":{"version":3,"sources":["../../src/exporters/DRACOExporter.ts"],"names":["faces"],"mappings":"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","sourcesContent":["import type { EncoderModule } from 'draco3d'\nimport { BufferGeometry, Mesh, Points } from 'three'\n\n/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\ndeclare const DracoEncoderModule: () => EncoderModule\n\nclass DRACOExporter {\n  // Encoder methods\n\n  public static MESH_EDGEBREAKER_ENCODING = 1\n  public static MESH_SEQUENTIAL_ENCODING = 0\n\n  // Geometry type\n\n  public static POINT_CLOUD = 0\n  public static TRIANGULAR_MESH = 1\n\n  // Attribute type\n  public static INVALID = -1\n  public static POSITION = 0\n  public static NORMAL = 1\n  public static COLOR = 2\n  public static TEX_COORD = 3\n  public static GENERIC = 4\n\n  public parse(\n    object: Mesh | Points,\n    options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false,\n    },\n  ): Int8Array {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.')\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.')\n    }\n\n    const geometry = object.geometry\n\n    const dracoEncoder = DracoEncoderModule()\n    const encoder = new dracoEncoder.Encoder()\n    let builder\n    let dracoObject\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.')\n    }\n\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder()\n      dracoObject = new dracoEncoder.Mesh()\n\n      const vertices = geometry.getAttribute('position')\n      // @ts-ignore\n      builder.AddFloatAttributeToMesh(\n        dracoObject,\n        dracoEncoder.POSITION,\n        vertices.count,\n        vertices.itemSize,\n        vertices.array,\n      )\n\n      const faces = geometry.getIndex()\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array as Uint16Array | Uint32Array)\n      } else {\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count)\n\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces)\n      }\n\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute('normal')\n\n        if (normals !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(\n            dracoObject,\n            dracoEncoder.NORMAL,\n            normals.count,\n            normals.itemSize,\n            normals.array,\n          )\n        }\n      }\n\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute('uv')\n\n        if (uvs !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array)\n        }\n      }\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color')\n\n        if (colors !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array)\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      // @ts-ignore\n      builder = new dracoEncoder.PointCloudBuilder()\n      // @ts-ignore\n      dracoObject = new dracoEncoder.PointCloud()\n\n      const vertices = geometry.getAttribute('position')\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array)\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color')\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array)\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.')\n    }\n\n    //Compress using draco encoder\n\n    const encodedData = new dracoEncoder.DracoInt8Array()\n\n    //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5\n\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed)\n\n    // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod)\n    }\n\n    // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i])\n        }\n      }\n    }\n\n    let length\n\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData)\n    } else {\n      // @ts-ignore\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData)\n    }\n\n    dracoEncoder.destroy(dracoObject)\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.')\n    }\n\n    //Copy encoded data to buffer.\n    const outputData = new Int8Array(new ArrayBuffer(length))\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i)\n    }\n\n    dracoEncoder.destroy(encodedData)\n    dracoEncoder.destroy(encoder)\n    dracoEncoder.destroy(builder)\n\n    return outputData\n  }\n}\n\nexport { DRACOExporter }\n"]},"metadata":{},"sourceType":"module"}