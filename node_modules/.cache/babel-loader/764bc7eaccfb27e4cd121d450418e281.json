{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst _Reflector = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = \"Reflector\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Reflector.ReflectorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Reflector = _Reflector;\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`),\n  fragmentShader: (/* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`)\n});\nexport { Reflector };","map":{"version":3,"sources":["../../src/objects/Reflector.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  HalfFloatType,\n  NoToneMapping,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass Reflector extends Mesh {\n  static ReflectorShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      tDiffuse: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isReflector = true\n\n    this.type = 'Reflector'\n    this.camera = new PerspectiveCamera()\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || Reflector.ReflectorShader\n    const multisample = options.multisample !== undefined ? options.multisample : 4\n\n    //\n\n    const reflectorPlane = new Plane()\n    const normal = new Vector3()\n    const reflectorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n    const clipPlane = new Vector4()\n\n    const view = new Vector3()\n    const target = new Vector3()\n    const q = new Vector4()\n\n    const textureMatrix = new Matrix4()\n    const virtualCamera = this.camera\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType,\n    })\n\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader,\n    })\n\n    material.uniforms['tDiffuse'].value = renderTarget.texture\n    material.uniforms['color'].value = color\n    material.uniforms['textureMatrix'].value = textureMatrix\n\n    this.material = material\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(reflectorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(reflectorWorldPosition)\n\n      virtualCamera.position.copy(view)\n      virtualCamera.up.set(0, 1, 0)\n      virtualCamera.up.applyMatrix4(rotationMatrix)\n      virtualCamera.up.reflect(normal)\n      virtualCamera.lookAt(target)\n\n      virtualCamera.far = camera.far // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld()\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(virtualCamera.projectionMatrix)\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition)\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse)\n\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant)\n\n      const projectionMatrix = virtualCamera.projectionMatrix\n\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n      q.z = -1.0\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q))\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x\n      projectionMatrix.elements[6] = clipPlane.y\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias\n      projectionMatrix.elements[14] = clipPlane.w\n\n      // Render\n      scope.visible = false\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentToneMapping = renderer.toneMapping\n\n      let isSRGB = false\n      if ('outputColorSpace' in renderer) isSRGB = renderer.outputColorSpace === 'srgb'\n      else isSRGB = renderer.outputEncoding === 3001 // sRGBEncoding\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.outputEncoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.toneMapping = currentToneMapping\n\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = isSRGB ? 'srgb' : 'srgb-linear'\n      else renderer.outputEncoding = isSRGB ? 3001 : 3000\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      scope.visible = true\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n\n    this.dispose = function () {\n      renderTarget.dispose()\n      scope.material.dispose()\n    }\n  }\n}\n\nexport { Reflector }\n"]},"metadata":{},"sourceType":"module"}