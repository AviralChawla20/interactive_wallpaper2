{"ast":null,"code":"import { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, BufferGeometry, BufferAttribute } from \"three\";\nconst _q = new Quaternion();\nconst _targetPos = new Vector3();\nconst _targetVec = new Vector3();\nconst _effectorPos = new Vector3();\nconst _effectorVec = new Vector3();\nconst _linkPos = new Vector3();\nconst _invLinkQ = new Quaternion();\nconst _linkScale = new Vector3();\nconst _axis = new Vector3();\nconst _vector = new Vector3();\nconst _matrix = new Matrix4();\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i]);\n    }\n    return this;\n  }\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones;\n    const math = Math;\n    const effector = bones[ik.effector];\n    const target = bones[ik.target];\n    _targetPos.setFromMatrixPosition(target.matrixWorld);\n    const links = ik.links;\n    const iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index];\n        if (links[j].enabled === false) break;\n        const limitation = links[j].limitation;\n        const rotationMin = links[j].rotationMin;\n        const rotationMax = links[j].rotationMax;\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n        _invLinkQ.invert();\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n        _effectorVec.subVectors(_effectorPos, _linkPos);\n        _effectorVec.applyQuaternion(_invLinkQ);\n        _effectorVec.normalize();\n        _targetVec.subVectors(_targetPos, _linkPos);\n        _targetVec.applyQuaternion(_invLinkQ);\n        _targetVec.normalize();\n        let angle = _targetVec.dot(_effectorVec);\n        if (angle > 1) {\n          angle = 1;\n        } else if (angle < -1) {\n          angle = -1;\n        }\n        angle = math.acos(angle);\n        if (angle < 1e-5) continue;\n        if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n          angle = ik.minAngle;\n        }\n        if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n          angle = ik.maxAngle;\n        }\n        _axis.crossVectors(_effectorVec, _targetVec);\n        _axis.normalize();\n        _q.setFromAxisAngle(_axis, angle);\n        link.quaternion.multiply(_q);\n        if (limitation !== void 0) {\n          let c = link.quaternion.w;\n          if (c > 1) c = 1;\n          const c2 = math.sqrt(1 - c * c);\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n        }\n        if (rotationMin !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n        }\n        if (rotationMax !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n        }\n        link.updateMatrixWorld(true);\n        rotated = true;\n      }\n      if (!rotated) break;\n    }\n    return this;\n  }\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks);\n  }\n  // private methods\n  _valid() {\n    const iks = this.iks;\n    const bones = this.mesh.skeleton.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n        if (link0.parent !== link1) {\n          console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n        }\n        link0 = link1;\n      }\n    }\n  }\n}\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._init();\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n      _matrix.copy(mesh.matrixWorld).invert();\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(getPosition(targetBone, _matrix));\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(getPosition(linkBone, _matrix));\n        }\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);\n        }\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose();\n    this.targetSphereMaterial.dispose();\n    this.effectorSphereMaterial.dispose();\n    this.linkSphereMaterial.dispose();\n    this.lineMaterial.dispose();\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.isLine) child.geometry.dispose();\n    }\n  }\n  // private method\n  _init() {\n    const scope = this;\n    const iks = this.iks;\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n      this.add(createLine(ik));\n    }\n  }\n}\nexport { CCDIKHelper, CCDIKSolver };","map":{"version":3,"sources":["../../src/animation/CCDIKSolver.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  Line,\n  LineBasicMaterial,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Quaternion,\n  SphereGeometry,\n  Vector3,\n} from 'three'\n\nconst _q = new Quaternion()\nconst _targetPos = new Vector3()\nconst _targetVec = new Vector3()\nconst _effectorPos = new Vector3()\nconst _effectorVec = new Vector3()\nconst _linkPos = new Vector3()\nconst _invLinkQ = new Quaternion()\nconst _linkScale = new Vector3()\nconst _axis = new Vector3()\nconst _vector = new Vector3()\nconst _matrix = new Matrix4()\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh\n    this.iks = iks\n\n    this._valid()\n  }\n\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones\n\n    // for reference overhead reduction in loop\n    const math = Math\n\n    const effector = bones[ik.effector]\n    const target = bones[ik.target]\n\n    // don't use getWorldPosition() here for the performance\n    // because it calls updateMatrixWorld( true ) inside.\n    _targetPos.setFromMatrixPosition(target.matrixWorld)\n\n    const links = ik.links\n    const iteration = ik.iteration !== undefined ? ik.iteration : 1\n\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index]\n\n        // skip this link and following links.\n        // this skip is used for MMD performance optimization.\n        if (links[j].enabled === false) break\n\n        const limitation = links[j].limitation\n        const rotationMin = links[j].rotationMin\n        const rotationMax = links[j].rotationMax\n\n        // don't use getWorldPosition/Quaternion() here for the performance\n        // because they call updateMatrixWorld( true ) inside.\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale)\n        _invLinkQ.invert()\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld)\n\n        // work in link world\n        _effectorVec.subVectors(_effectorPos, _linkPos)\n        _effectorVec.applyQuaternion(_invLinkQ)\n        _effectorVec.normalize()\n\n        _targetVec.subVectors(_targetPos, _linkPos)\n        _targetVec.applyQuaternion(_invLinkQ)\n        _targetVec.normalize()\n\n        let angle = _targetVec.dot(_effectorVec)\n\n        if (angle > 1.0) {\n          angle = 1.0\n        } else if (angle < -1.0) {\n          angle = -1.0\n        }\n\n        angle = math.acos(angle)\n\n        // skip if changing angle is too small to prevent vibration of bone\n        if (angle < 1e-5) continue\n\n        if (ik.minAngle !== undefined && angle < ik.minAngle) {\n          angle = ik.minAngle\n        }\n\n        if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n          angle = ik.maxAngle\n        }\n\n        _axis.crossVectors(_effectorVec, _targetVec)\n        _axis.normalize()\n\n        _q.setFromAxisAngle(_axis, angle)\n        link.quaternion.multiply(_q)\n\n        // TODO: re-consider the limitation specification\n        if (limitation !== undefined) {\n          let c = link.quaternion.w\n\n          if (c > 1.0) c = 1.0\n\n          const c2 = math.sqrt(1 - c * c)\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c)\n        }\n\n        if (rotationMin !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin))\n        }\n\n        if (rotationMax !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax))\n        }\n\n        link.updateMatrixWorld(true)\n\n        rotated = true\n      }\n\n      if (!rotated) break\n    }\n\n    return this\n  }\n\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks)\n  }\n\n  // private methods\n\n  _valid() {\n    const iks = this.iks\n    const bones = this.mesh.skeleton.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const effector = bones[ik.effector]\n      const links = ik.links\n      let link0, link1\n\n      link0 = effector\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index]\n\n        if (link0.parent !== link1) {\n          console.warn('THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name)\n        }\n\n        link0 = link1\n      }\n    }\n  }\n}\n\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv)\n}\n\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv)\n\n  array[index * 3 + 0] = v.x\n  array[index * 3 + 1] = v.y\n  array[index * 3 + 2] = v.z\n}\n\n/**\n * Visualize IK bones\n *\n * @param {SkinnedMesh} mesh\n * @param {Array<Object>} iks\n */\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super()\n\n    this.root = mesh\n    this.iks = iks\n\n    this.matrix.copy(mesh.matrixWorld)\n    this.matrixAutoUpdate = false\n\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8)\n\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this._init()\n  }\n\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root\n\n    if (this.visible) {\n      let offset = 0\n\n      const iks = this.iks\n      const bones = mesh.skeleton.bones\n\n      _matrix.copy(mesh.matrixWorld).invert()\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i]\n\n        const targetBone = bones[ik.target]\n        const effectorBone = bones[ik.effector]\n\n        const targetMesh = this.children[offset++]\n        const effectorMesh = this.children[offset++]\n\n        targetMesh.position.copy(getPosition(targetBone, _matrix))\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix))\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n\n          const linkMesh = this.children[offset++]\n\n          linkMesh.position.copy(getPosition(linkBone, _matrix))\n        }\n\n        const line = this.children[offset++]\n        const array = line.geometry.attributes.position.array\n\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix)\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix)\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix)\n        }\n\n        line.geometry.attributes.position.needsUpdate = true\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld)\n\n    super.updateMatrixWorld(force)\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose()\n\n    this.targetSphereMaterial.dispose()\n    this.effectorSphereMaterial.dispose()\n    this.linkSphereMaterial.dispose()\n    this.lineMaterial.dispose()\n\n    const children = this.children\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]\n\n      if (child.isLine) child.geometry.dispose()\n    }\n  }\n\n  // private method\n\n  _init() {\n    const scope = this\n    const iks = this.iks\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry()\n      const vertices = new Float32Array((2 + ik.links.length) * 3)\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3))\n\n      return geometry\n    }\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial)\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial)\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial)\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial)\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n\n      this.add(createTargetMesh())\n      this.add(createEffectorMesh())\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh())\n      }\n\n      this.add(createLine(ik))\n    }\n  }\n}\n\nexport { CCDIKSolver, CCDIKHelper }\n"]},"metadata":{},"sourceType":"module"}