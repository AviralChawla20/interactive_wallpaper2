{"ast":null,"code":"import { Color, REVISION, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n    const defaultColor = new Color().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]);\n    const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n    const cache = {};\n    const removeThresholdCount = 60;\n    const originalMaterials = {};\n    const originalOnBeforeRenders = {};\n    const uniformsOutline = {\n      outlineThickness: {\n        value: defaultThickness\n      },\n      outlineColor: {\n        value: defaultColor\n      },\n      outlineAlpha: {\n        value: defaultAlpha\n      }\n    };\n    const vertexShader = [\"#include <common>\", \"#include <uv_pars_vertex>\", \"#include <displacementmap_pars_vertex>\", \"#include <fog_pars_vertex>\", \"#include <morphtarget_pars_vertex>\", \"#include <skinning_pars_vertex>\", \"#include <logdepthbuf_pars_vertex>\", \"#include <clipping_planes_pars_vertex>\", \"uniform float outlineThickness;\", \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\", \"\tfloat thickness = outlineThickness;\", \"\tconst float ratio = 1.0;\",\n    // TODO: support outline thickness ratio for each vertex\n    \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n    // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n    \"\tvec4 norm = normalize( pos - pos2 );\", \"\treturn pos + norm * thickness * pos.w * ratio;\", \"}\", \"void main() {\", \"\t#include <uv_vertex>\", \"\t#include <beginnormal_vertex>\", \"\t#include <morphnormal_vertex>\", \"\t#include <skinbase_vertex>\", \"\t#include <skinnormal_vertex>\", \"\t#include <begin_vertex>\", \"\t#include <morphtarget_vertex>\", \"\t#include <skinning_vertex>\", \"\t#include <displacementmap_vertex>\", \"\t#include <project_vertex>\", \"\tvec3 outlineNormal = - objectNormal;\",\n    // the outline material is always rendered with BackSide\n    \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\", \"\t#include <logdepthbuf_vertex>\", \"\t#include <clipping_planes_vertex>\", \"\t#include <fog_vertex>\", \"}\"].join(\"\\n\");\n    const fragmentShader = [\"#include <common>\", \"#include <fog_pars_fragment>\", \"#include <logdepthbuf_pars_fragment>\", \"#include <clipping_planes_pars_fragment>\", \"uniform vec3 outlineColor;\", \"uniform float outlineAlpha;\", \"void main() {\", \"\t#include <clipping_planes_fragment>\", \"\t#include <logdepthbuf_fragment>\", \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\", \"\t#include <tonemapping_fragment>\", `\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>`, \"\t#include <fog_fragment>\", \"\t#include <premultiplied_alpha_fragment>\", \"}\"].join(\"\\n\");\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: \"OutlineEffect\",\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n        vertexShader,\n        fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === void 0) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n      return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer2, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n      if (originalMaterial === void 0) return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== void 0) {\n        if (outlineParameters.thickness !== void 0) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== void 0) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== void 0) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === \"invisible\") return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== void 0) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== void 0) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version;\n    }\n    function cleanupCache() {\n      let keys;\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = void 0;\n      }\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = void 0;\n      }\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n    this.autoClear = renderer.autoClear;\n    this.domElement = renderer.domElement;\n    this.shadowMap = renderer.shadowMap;\n    this.clear = function (color, depth, stencil) {\n      renderer.clear(color, depth, stencil);\n    };\n    this.getPixelRatio = function () {\n      return renderer.getPixelRatio();\n    };\n    this.setPixelRatio = function (value) {\n      renderer.setPixelRatio(value);\n    };\n    this.getSize = function (target) {\n      return renderer.getSize(target);\n    };\n    this.setSize = function (width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle);\n    };\n    this.setViewport = function (x, y, width, height) {\n      renderer.setViewport(x, y, width, height);\n    };\n    this.setScissor = function (x, y, width, height) {\n      renderer.setScissor(x, y, width, height);\n    };\n    this.setScissorTest = function (boolean) {\n      renderer.setScissorTest(boolean);\n    };\n    this.setRenderTarget = function (renderTarget) {\n      renderer.setRenderTarget(renderTarget);\n    };\n  }\n}\nexport { OutlineEffect };","map":{"version":3,"sources":["../../src/effects/OutlineEffect.js"],"names":["renderer"],"mappings":"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","sourcesContent":["import { BackSide, Color, ShaderMaterial, UniformsLib, UniformsUtils, REVISION } from 'three'\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * const effect = new OutlineEffect( renderer );\n * let renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ],\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true\n\n    const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003\n    const defaultColor = new Color().fromArray(\n      parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0],\n    )\n    const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0\n    const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false\n\n    // object.material.uuid -> outlineMaterial or\n    // object.material[ n ].uuid -> outlineMaterial\n    // save at the outline material creation and release\n    // if it's unused removeThresholdCount frames\n    // unless keepAlive is true.\n    const cache = {}\n\n    const removeThresholdCount = 60\n\n    // outlineMaterial.uuid -> object.material or\n    // outlineMaterial.uuid -> object.material[ n ]\n    // save before render and release after render.\n    const originalMaterials = {}\n\n    // object.uuid -> originalOnBeforeRender\n    // save before render and release after render.\n    const originalOnBeforeRenders = {}\n\n    //this.cache = cache;  // for debug\n\n    const uniformsOutline = {\n      outlineThickness: { value: defaultThickness },\n      outlineColor: { value: defaultColor },\n      outlineAlpha: { value: defaultAlpha },\n    }\n\n    const vertexShader = [\n      '#include <common>',\n      '#include <uv_pars_vertex>',\n      '#include <displacementmap_pars_vertex>',\n      '#include <fog_pars_vertex>',\n      '#include <morphtarget_pars_vertex>',\n      '#include <skinning_pars_vertex>',\n      '#include <logdepthbuf_pars_vertex>',\n      '#include <clipping_planes_pars_vertex>',\n\n      'uniform float outlineThickness;',\n\n      'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n      '\tfloat thickness = outlineThickness;',\n      '\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n      '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n      // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n      '\tvec4 norm = normalize( pos - pos2 );',\n      '\treturn pos + norm * thickness * pos.w * ratio;',\n      '}',\n\n      'void main() {',\n\n      '\t#include <uv_vertex>',\n\n      '\t#include <beginnormal_vertex>',\n      '\t#include <morphnormal_vertex>',\n      '\t#include <skinbase_vertex>',\n      '\t#include <skinnormal_vertex>',\n\n      '\t#include <begin_vertex>',\n      '\t#include <morphtarget_vertex>',\n      '\t#include <skinning_vertex>',\n      '\t#include <displacementmap_vertex>',\n      '\t#include <project_vertex>',\n\n      '\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n      '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n      '\t#include <logdepthbuf_vertex>',\n      '\t#include <clipping_planes_vertex>',\n      '\t#include <fog_vertex>',\n\n      '}',\n    ].join('\\n')\n\n    const fragmentShader = [\n      '#include <common>',\n      '#include <fog_pars_fragment>',\n      '#include <logdepthbuf_pars_fragment>',\n      '#include <clipping_planes_pars_fragment>',\n\n      'uniform vec3 outlineColor;',\n      'uniform float outlineAlpha;',\n\n      'void main() {',\n\n      '\t#include <clipping_planes_fragment>',\n      '\t#include <logdepthbuf_fragment>',\n\n      '\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n      '\t#include <tonemapping_fragment>',\n      `\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>`,\n      '\t#include <fog_fragment>',\n      '\t#include <premultiplied_alpha_fragment>',\n\n      '}',\n    ].join('\\n')\n\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: 'OutlineEffect',\n        uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        side: BackSide,\n      })\n    }\n\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid]\n\n      if (data === undefined) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0,\n        }\n\n        cache[originalMaterial.uuid] = data\n      }\n\n      data.used = true\n\n      return data.material\n    }\n\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial)\n\n      originalMaterials[outlineMaterial.uuid] = originalMaterial\n\n      updateOutlineMaterial(outlineMaterial, originalMaterial)\n\n      return outlineMaterial\n    }\n\n    function isCompatible(object) {\n      const geometry = object.geometry\n      const hasNormals = geometry !== undefined && geometry.attributes.normal !== undefined\n\n      return object.isMesh === true && object.material !== undefined && hasNormals === true\n    }\n\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return\n\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i])\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material)\n      }\n\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender\n      object.onBeforeRender = onBeforeRender\n    }\n\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return\n\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid]\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid]\n      }\n\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid]\n    }\n\n    function onBeforeRender(renderer, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid]\n\n      // just in case\n      if (originalMaterial === undefined) return\n\n      updateUniforms(material, originalMaterial)\n    }\n\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters\n\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity\n\n      if (outlineParameters !== undefined) {\n        if (outlineParameters.thickness !== undefined)\n          material.uniforms.outlineThickness.value = outlineParameters.thickness\n        if (outlineParameters.color !== undefined)\n          material.uniforms.outlineColor.value.fromArray(outlineParameters.color)\n        if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha\n      }\n\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias\n      }\n    }\n\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === 'invisible') return\n\n      const outlineParameters = originalMaterial.userData.outlineParameters\n\n      material.fog = originalMaterial.fog\n      material.toneMapped = originalMaterial.toneMapped\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha\n      material.displacementMap = originalMaterial.displacementMap\n\n      if (outlineParameters !== undefined) {\n        if (originalMaterial.visible === false) {\n          material.visible = false\n        } else {\n          material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true\n        }\n\n        material.transparent =\n          outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent\n\n        if (outlineParameters.keepAlive !== undefined)\n          cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive\n      } else {\n        material.transparent = originalMaterial.transparent\n        material.visible = originalMaterial.visible\n      }\n\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false\n\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true\n\n        material.clippingPlanes = originalMaterial.clippingPlanes\n        material.clipIntersection = originalMaterial.clipIntersection\n        material.clipShadows = originalMaterial.clipShadows\n      }\n\n      material.version = originalMaterial.version // update outline material if necessary\n    }\n\n    function cleanupCache() {\n      let keys\n\n      // clear originialMaterials\n      keys = Object.keys(originalMaterials)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = undefined\n      }\n\n      // clear originalOnBeforeRenders\n      keys = Object.keys(originalOnBeforeRenders)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = undefined\n      }\n\n      // remove unused outlineMaterial from cache\n      keys = Object.keys(cache)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i]\n\n        if (cache[key].used === false) {\n          cache[key].count++\n\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key]\n          }\n        } else {\n          cache[key].used = false\n          cache[key].count = 0\n        }\n      }\n    }\n\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera)\n        return\n      }\n\n      const currentAutoClear = renderer.autoClear\n      renderer.autoClear = this.autoClear\n\n      renderer.render(scene, camera)\n\n      renderer.autoClear = currentAutoClear\n\n      this.renderOutline(scene, camera)\n    }\n\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate\n      const currentSceneBackground = scene.background\n      const currentShadowMapEnabled = renderer.shadowMap.enabled\n\n      scene.matrixWorldAutoUpdate = false\n      scene.background = null\n      renderer.autoClear = false\n      renderer.shadowMap.enabled = false\n\n      scene.traverse(setOutlineMaterial)\n\n      renderer.render(scene, camera)\n\n      scene.traverse(restoreOriginalMaterial)\n\n      cleanupCache()\n\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate\n      scene.background = currentSceneBackground\n      renderer.autoClear = currentAutoClear\n      renderer.shadowMap.enabled = currentShadowMapEnabled\n    }\n\n    /*\n     * See #9918\n     *\n     * The following property copies and wrapper methods enable\n     * OutlineEffect to be called from other *Effect, like\n     *\n     * effect = new StereoEffect( new OutlineEffect( renderer ) );\n     *\n     * function render () {\n     *\n     * \teffect.render( scene, camera );\n     *\n     * }\n     */\n    this.autoClear = renderer.autoClear\n    this.domElement = renderer.domElement\n    this.shadowMap = renderer.shadowMap\n\n    this.clear = function (color, depth, stencil) {\n      renderer.clear(color, depth, stencil)\n    }\n\n    this.getPixelRatio = function () {\n      return renderer.getPixelRatio()\n    }\n\n    this.setPixelRatio = function (value) {\n      renderer.setPixelRatio(value)\n    }\n\n    this.getSize = function (target) {\n      return renderer.getSize(target)\n    }\n\n    this.setSize = function (width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle)\n    }\n\n    this.setViewport = function (x, y, width, height) {\n      renderer.setViewport(x, y, width, height)\n    }\n\n    this.setScissor = function (x, y, width, height) {\n      renderer.setScissor(x, y, width, height)\n    }\n\n    this.setScissorTest = function (boolean) {\n      renderer.setScissorTest(boolean)\n    }\n\n    this.setRenderTarget = function (renderTarget) {\n      renderer.setRenderTarget(renderTarget)\n    }\n  }\n}\n\nexport { OutlineEffect }\n"]},"metadata":{},"sourceType":"module"}