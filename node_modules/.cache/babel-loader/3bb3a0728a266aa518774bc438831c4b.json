{"ast":null,"code":"// src/index.ts\nvar updateQueue = makeQueue();\nvar raf = fn => schedule(fn, updateQueue);\nvar writeQueue = makeQueue();\nraf.write = fn => schedule(fn, writeQueue);\nvar onStartQueue = makeQueue();\nraf.onStart = fn => schedule(fn, onStartQueue);\nvar onFrameQueue = makeQueue();\nraf.onFrame = fn => schedule(fn, onFrameQueue);\nvar onFinishQueue = makeQueue();\nraf.onFinish = fn => schedule(fn, onFinishQueue);\nvar timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  const time = raf.now() + ms;\n  const cancel = () => {\n    const i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    pendingCount -= ~i ? 1 : 0;\n  };\n  const timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  pendingCount += 1;\n  start();\n  return timeout;\n};\nvar findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\nraf.cancel = fn => {\n  onStartQueue.delete(fn);\n  onFrameQueue.delete(fn);\n  onFinishQueue.delete(fn);\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = fn => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nvar nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame :\n// eslint-disable-next-line @typescript-eslint/no-empty-function\n() => {};\nraf.use = impl => nativeRaf = impl;\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\nraf.batchedUpdates = fn => fn();\nraf.catch = console.error;\nraf.frameLoop = \"always\";\nraf.advance = () => {\n  if (raf.frameLoop !== \"demand\") {\n    console.warn(\"Cannot call the manual advancement of rafz whilst frameLoop is not set as demand\");\n  } else {\n    update();\n  }\n};\nvar ts = -1;\nvar pendingCount = 0;\nvar sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    if (raf.frameLoop !== \"demand\") {\n      nativeRaf(loop);\n    }\n  }\n}\nfunction stop() {\n  ts = -1;\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  const prevTs = ts;\n  ts = raf.now();\n  const count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    pendingCount -= count;\n  }\n  if (!pendingCount) {\n    stop();\n    return;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = /* @__PURE__ */new Set();\n  let current = next;\n  return {\n    add(fn) {\n      pendingCount += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      pendingCount -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = /* @__PURE__ */new Set();\n        pendingCount -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        pendingCount += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nvar __raf = {\n  /** The number of pending tasks */\n  count() {\n    return pendingCount;\n  },\n  /** Whether there's a raf update loop running */\n  isRunning() {\n    return ts >= 0;\n  },\n  /** Clear internal state. Never call from update loop! */\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    pendingCount = 0;\n  }\n};\nexport { __raf, raf };","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  FrameFn,\n  FrameUpdateFn,\n  NativeRaf,\n  Rafz,\n  Timeout,\n  Throttled,\n} from './types'\n\nexport type { FrameFn, FrameUpdateFn, Timeout, Throttled, Rafz }\n\nlet updateQueue = makeQueue<FrameUpdateFn>()\n\n/**\n * Schedule an update for next frame.\n * Your function can return `true` to repeat next frame.\n */\nexport const raf: Rafz = fn => schedule(fn, updateQueue)\n\nlet writeQueue = makeQueue<FrameFn>()\nraf.write = fn => schedule(fn, writeQueue)\n\nlet onStartQueue = makeQueue<FrameFn>()\nraf.onStart = fn => schedule(fn, onStartQueue)\n\nlet onFrameQueue = makeQueue<FrameFn>()\nraf.onFrame = fn => schedule(fn, onFrameQueue)\n\nlet onFinishQueue = makeQueue<FrameFn>()\nraf.onFinish = fn => schedule(fn, onFinishQueue)\n\nlet timeouts: Timeout[] = []\nraf.setTimeout = (handler, ms) => {\n  const time = raf.now() + ms\n  const cancel = () => {\n    const i = timeouts.findIndex(t => t.cancel == cancel)\n    if (~i) timeouts.splice(i, 1)\n    pendingCount -= ~i ? 1 : 0\n  }\n\n  const timeout: Timeout = { time, handler, cancel }\n  timeouts.splice(findTimeout(time), 0, timeout)\n  pendingCount += 1\n\n  start()\n  return timeout\n}\n\n/** Find the index where the given time is not greater. */\nconst findTimeout = (time: number) =>\n  ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length)\n\nraf.cancel = fn => {\n  onStartQueue.delete(fn)\n  onFrameQueue.delete(fn)\n  onFinishQueue.delete(fn)\n  updateQueue.delete(fn)\n  writeQueue.delete(fn)\n}\n\nraf.sync = fn => {\n  sync = true\n  raf.batchedUpdates(fn)\n  sync = false\n}\n\nraf.throttle = fn => {\n  let lastArgs: any\n  function queuedFn() {\n    try {\n      fn(...lastArgs)\n    } finally {\n      lastArgs = null\n    }\n  }\n  function throttled(...args: any) {\n    lastArgs = args\n    raf.onStart(queuedFn)\n  }\n  throttled.handler = fn\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn)\n    lastArgs = null\n  }\n  return throttled as any\n}\n\nlet nativeRaf =\n  typeof window != 'undefined'\n    ? (window.requestAnimationFrame as NativeRaf)\n    : // eslint-disable-next-line @typescript-eslint/no-empty-function\n      () => {}\n\nraf.use = impl => (nativeRaf = impl)\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now\nraf.batchedUpdates = fn => fn()\nraf.catch = console.error\n\nraf.frameLoop = 'always'\n\nraf.advance = () => {\n  if (raf.frameLoop !== 'demand') {\n    console.warn(\n      'Cannot call the manual advancement of rafz whilst frameLoop is not set as demand'\n    )\n  } else {\n    update()\n  }\n}\n\n/** The most recent timestamp. */\nlet ts = -1\n\n/** The number of pending tasks  */\nlet pendingCount = 0\n\n/** When true, scheduling is disabled. */\nlet sync = false\n\nfunction schedule<T extends Function>(fn: T, queue: Queue<T>) {\n  if (sync) {\n    queue.delete(fn)\n    fn(0)\n  } else {\n    queue.add(fn)\n    start()\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop)\n    }\n  }\n}\n\nfunction stop() {\n  ts = -1\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop)\n    raf.batchedUpdates(update)\n  }\n}\n\nfunction update() {\n  const prevTs = ts\n  ts = raf.now()\n\n  // Flush timeouts whose time is up.\n  const count = findTimeout(ts)\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler())\n    pendingCount -= count\n  }\n\n  if (!pendingCount) {\n    stop()\n\n    return\n  }\n\n  onStartQueue.flush()\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667)\n  onFrameQueue.flush()\n  writeQueue.flush()\n  onFinishQueue.flush()\n}\n\ninterface Queue<T extends Function = any> {\n  add: (fn: T) => void\n  delete: (fn: T) => boolean\n  flush: (arg?: any) => void\n}\n\nfunction makeQueue<T extends Function>(): Queue<T> {\n  let next = new Set<T>()\n  let current = next\n  return {\n    add(fn) {\n      pendingCount += current == next && !next.has(fn) ? 1 : 0\n      next.add(fn)\n    },\n    delete(fn) {\n      pendingCount -= current == next && next.has(fn) ? 1 : 0\n      return next.delete(fn)\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set()\n        pendingCount -= current.size\n        eachSafely(current, fn => fn(arg) && next.add(fn))\n        pendingCount += next.size\n        current = next\n      }\n    },\n  }\n}\n\ninterface Eachable<T> {\n  forEach(cb: (value: T) => void): void\n}\n\nfunction eachSafely<T>(values: Eachable<T>, each: (value: T) => void) {\n  values.forEach(value => {\n    try {\n      each(value)\n    } catch (e) {\n      raf.catch(e as Error)\n    }\n  })\n}\n\n/** Tree-shakable state for testing purposes */\nexport const __raf = {\n  /** The number of pending tasks */\n  count(): number {\n    return pendingCount\n  },\n  /** Whether there's a raf update loop running */\n  isRunning(): boolean {\n    return ts >= 0\n  },\n  /** Clear internal state. Never call from update loop! */\n  clear() {\n    ts = -1\n    timeouts = []\n    onStartQueue = makeQueue()\n    updateQueue = makeQueue()\n    onFrameQueue = makeQueue()\n    writeQueue = makeQueue()\n    onFinishQueue = makeQueue()\n    pendingCount = 0\n  },\n}\n"]},"metadata":{},"sourceType":"module"}