{"ast":null,"code":"import { Matrix4, Vector3 } from \"three\";\nconst inverseProjectionMatrix = new Matrix4();\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert();\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1));\n      }\n    });\n    return this.vertices;\n  }\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\nexport { CSMFrustum };","map":{"version":3,"sources":["../../src/csm/CSMFrustum.js"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Matrix4 } from 'three'\n\nconst inverseProjectionMatrix = new Matrix4()\n\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {}\n\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n    }\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000)\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0\n\n    inverseProjectionMatrix.copy(projectionMatrix).invert()\n\n    // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1)\n    this.vertices.near[1].set(1, -1, -1)\n    this.vertices.near[2].set(-1, -1, -1)\n    this.vertices.near[3].set(-1, 1, -1)\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n    })\n\n    this.vertices.far[0].set(1, 1, 1)\n    this.vertices.far[1].set(1, -1, 1)\n    this.vertices.far[2].set(-1, -1, 1)\n    this.vertices.far[3].set(-1, 1, 1)\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n\n      const absZ = Math.abs(v.z)\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0)\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0))\n      }\n    })\n\n    return this.vertices\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum())\n    }\n\n    target.length = breaks.length\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i]\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1])\n        }\n      }\n\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i])\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix)\n\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix)\n    }\n  }\n}\n\nexport { CSMFrustum }\n"]},"metadata":{},"sourceType":"module"}