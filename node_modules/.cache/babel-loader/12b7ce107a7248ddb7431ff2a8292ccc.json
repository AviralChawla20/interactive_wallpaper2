{"ast":null,"code":"import { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from \"three\";\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer, loadMipmaps) {\n    const dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    };\n    const DDS_MAGIC = 542327876;\n    const DDSD_MIPMAPCOUNT = 131072;\n    const DDSCAPS2_CUBEMAP = 512;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;\n    const DDPF_FOURCC = 4;\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);\n    }\n    function loadARGBMip(buffer2, dataOffset2, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer2, dataOffset2, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++;\n          byteArray[dst] = g;\n          dst++;\n          byteArray[dst] = b;\n          dst++;\n          byteArray[dst] = a;\n          dst++;\n        }\n      }\n      return byteArray;\n    }\n    const FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n    const FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n    const FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n    const FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n    const headerLengthInt = 31;\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n    const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26;\n    const off_caps2 = 28;\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error(\"THREE.DDSLoader.parse: Invalid magic number in DDS header.\");\n      return dds;\n    }\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error(\"THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.\");\n      return dds;\n    }\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error(\"THREE.DDSLoader.parse: Unsupported FourCC code \", int32ToFourCC(fourCC));\n          return dds;\n        }\n    }\n    dds.mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error(\"THREE.DDSLoader.parse: Incomplete cubemap faces\");\n      return dds;\n    }\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n    let dataOffset = header[off_size] + 4;\n    const faces = dds.isCubemap ? 6 : 1;\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n        const mipmap = {\n          data: byteArray,\n          width,\n          height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n    return dds;\n  }\n}\nexport { DDSLoader };","map":{"version":3,"sources":["../../src/loaders/DDSLoader.js"],"names":["buffer","dataOffset"],"mappings":";AASA,MAAM,SAAA,SAAkB,uBAAA,CAAwB;EAC9C,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;EACd;EAED,KAAA,CAAM,MAAA,EAAQ,WAAA,EAAa;IACzB,MAAM,GAAA,GAAM;MAAE,OAAA,EAAS,EAAA;MAAI,KAAA,EAAO,CAAA;MAAG,MAAA,EAAQ,CAAA;MAAG,MAAA,EAAQ,IAAA;MAAM,WAAA,EAAa;IAAG,CAAA;IAQ9E,MAAM,SAAA,GAAY,SAAA;IAOlB,MAAM,gBAAA,GAAmB,MAAA;IAQzB,MAAM,gBAAA,GAAmB,GAAA;IACzB,MAAM,0BAAA,GAA6B,IAAA;IACnC,MAAM,0BAAA,GAA6B,IAAA;IACnC,MAAM,0BAAA,GAA6B,IAAA;IACnC,MAAM,0BAAA,GAA6B,IAAA;IACnC,MAAM,0BAAA,GAA6B,KAAA;IACnC,MAAM,0BAAA,GAA6B,KAAA;IAKnC,MAAM,WAAA,GAAc,CAAA;IAKpB,SAAS,aAAA,CAAc,KAAA,EAAO;MAC5B,OACE,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA,IAAK,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA,IAAK,CAAA,CAAA,IAAM,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA,IAAK,EAAA,CAAA,IAAO,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA,IAAK,EAAA,CAAA;IAE5G;IAED,SAAS,aAAA,CAAc,KAAA,EAAO;MAC5B,OAAO,MAAA,CAAO,YAAA,CAAa,KAAA,GAAQ,GAAA,EAAO,KAAA,IAAS,CAAA,GAAK,GAAA,EAAO,KAAA,IAAS,EAAA,GAAM,GAAA,EAAO,KAAA,IAAS,EAAA,GAAM,GAAI,CAAA;IACzG;IAED,SAAS,WAAA,CAAYA,OAAAA,EAAQC,WAAAA,EAAY,KAAA,EAAO,MAAA,EAAQ;MACtD,MAAM,UAAA,GAAa,KAAA,GAAQ,MAAA,GAAS,CAAA;MACpC,MAAM,SAAA,GAAY,IAAI,UAAA,CAAWD,OAAAA,EAAQC,WAAAA,EAAY,UAAU,CAAA;MAC/D,MAAM,SAAA,GAAY,IAAI,UAAA,CAAW,UAAU,CAAA;MAC3C,IAAI,GAAA,GAAM,CAAA;MACV,IAAI,GAAA,GAAM,CAAA;MACV,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC/B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,EAAO,CAAA,EAAA,EAAK;UAC9B,MAAM,CAAA,GAAI,SAAA,CAAU,GAAG,CAAA;UACvB,GAAA,EAAA;UACA,MAAM,CAAA,GAAI,SAAA,CAAU,GAAG,CAAA;UACvB,GAAA,EAAA;UACA,MAAM,CAAA,GAAI,SAAA,CAAU,GAAG,CAAA;UACvB,GAAA,EAAA;UACA,MAAM,CAAA,GAAI,SAAA,CAAU,GAAG,CAAA;UACvB,GAAA,EAAA;UACA,SAAA,CAAU,GAAG,CAAA,GAAI,CAAA;UACjB,GAAA,EAAA;UACA,SAAA,CAAU,GAAG,CAAA,GAAI,CAAA;UACjB,GAAA,EAAA;UACA,SAAA,CAAU,GAAG,CAAA,GAAI,CAAA;UACjB,GAAA,EAAA;UACA,SAAA,CAAU,GAAG,CAAA,GAAI,CAAA;UACjB,GAAA,EAAA;QACD;MACF;MAED,OAAO,SAAA;IACR;IAED,MAAM,WAAA,GAAc,aAAA,CAAc,MAAM,CAAA;IACxC,MAAM,WAAA,GAAc,aAAA,CAAc,MAAM,CAAA;IACxC,MAAM,WAAA,GAAc,aAAA,CAAc,MAAM,CAAA;IACxC,MAAM,WAAA,GAAc,aAAA,CAAc,MAAM,CAAA;IAExC,MAAM,eAAA,GAAkB,EAAA;IAIxB,MAAM,SAAA,GAAY,CAAA;IAElB,MAAM,QAAA,GAAW,CAAA;IACjB,MAAM,SAAA,GAAY,CAAA;IAClB,MAAM,UAAA,GAAa,CAAA;IACnB,MAAM,SAAA,GAAY,CAAA;IAElB,MAAM,eAAA,GAAkB,CAAA;IAExB,MAAM,WAAA,GAAc,EAAA;IACpB,MAAM,YAAA,GAAe,EAAA;IACrB,MAAM,eAAA,GAAkB,EAAA;IACxB,MAAM,YAAA,GAAe,EAAA;IACrB,MAAM,YAAA,GAAe,EAAA;IACrB,MAAM,YAAA,GAAe,EAAA;IACrB,MAAM,YAAA,GAAe,EAAA;IAGrB,MAAM,SAAA,GAAY,EAAA;IAMlB,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,MAAA,EAAQ,CAAA,EAAG,eAAe,CAAA;IAExD,IAAI,MAAA,CAAO,SAAS,CAAA,KAAM,SAAA,EAAW;MACnC,OAAA,CAAQ,KAAA,CAAM,4DAA4D,CAAA;MAC1E,OAAO,GAAA;IACR;IAED,IAAI,CAAC,MAAA,CAAO,WAAW,CAAA,GAAI,WAAA,EAAa;MACtC,OAAA,CAAQ,KAAA,CAAM,wEAAwE,CAAA;MACtF,OAAO,GAAA;IACR;IAED,IAAI,UAAA;IAEJ,MAAM,MAAA,GAAS,MAAA,CAAO,YAAY,CAAA;IAElC,IAAI,kBAAA,GAAqB,KAAA;IAEzB,QAAQ,MAAA;MACN,KAAK,WAAA;QACH,UAAA,GAAa,CAAA;QACb,GAAA,CAAI,MAAA,GAAS,oBAAA;QACb;MAEF,KAAK,WAAA;QACH,UAAA,GAAa,EAAA;QACb,GAAA,CAAI,MAAA,GAAS,qBAAA;QACb;MAEF,KAAK,WAAA;QACH,UAAA,GAAa,EAAA;QACb,GAAA,CAAI,MAAA,GAAS,qBAAA;QACb;MAEF,KAAK,WAAA;QACH,UAAA,GAAa,CAAA;QACb,GAAA,CAAI,MAAA,GAAS,eAAA;QACb;MAEF;QACE,IACE,MAAA,CAAO,eAAe,CAAA,KAAM,EAAA,IAC5B,MAAA,CAAO,YAAY,CAAA,GAAI,QAAA,IACvB,MAAA,CAAO,YAAY,CAAA,GAAI,KAAA,IACvB,MAAA,CAAO,YAAY,CAAA,GAAI,GAAA,IACvB,MAAA,CAAO,YAAY,CAAA,GAAI,UAAA,EACvB;UACA,kBAAA,GAAqB,IAAA;UACrB,UAAA,GAAa,EAAA;UACb,GAAA,CAAI,MAAA,GAAS,UAAA;QACvB,CAAA,MAAe;UACL,OAAA,CAAQ,KAAA,CAAM,iDAAA,EAAmD,aAAA,CAAc,MAAM,CAAC,CAAA;UACtF,OAAO,GAAA;QACR;IACJ;IAED,GAAA,CAAI,WAAA,GAAc,CAAA;IAElB,IAAI,MAAA,CAAO,SAAS,CAAA,GAAI,gBAAA,IAAoB,WAAA,KAAgB,KAAA,EAAO;MACjE,GAAA,CAAI,WAAA,GAAc,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,MAAA,CAAO,eAAe,CAAC,CAAA;IACtD;IAED,MAAM,KAAA,GAAQ,MAAA,CAAO,SAAS,CAAA;IAC9B,GAAA,CAAI,SAAA,GAAY,KAAA,GAAQ,gBAAA,GAAmB,IAAA,GAAO,KAAA;IAClD,IACE,GAAA,CAAI,SAAA,KACH,EAAE,KAAA,GAAQ,0BAAA,CAAA,IACT,EAAE,KAAA,GAAQ,0BAAA,CAAA,IACV,EAAE,KAAA,GAAQ,0BAAA,CAAA,IACV,EAAE,KAAA,GAAQ,0BAAA,CAAA,IACV,EAAE,KAAA,GAAQ,0BAAA,CAAA,IACV,EAAE,KAAA,GAAQ,0BAAA,CAAA,CAAA,EACZ;MACA,OAAA,CAAQ,KAAA,CAAM,iDAAiD,CAAA;MAC/D,OAAO,GAAA;IACR;IAED,GAAA,CAAI,KAAA,GAAQ,MAAA,CAAO,SAAS,CAAA;IAC5B,GAAA,CAAI,MAAA,GAAS,MAAA,CAAO,UAAU,CAAA;IAE9B,IAAI,UAAA,GAAa,MAAA,CAAO,QAAQ,CAAA,GAAI,CAAA;IAIpC,MAAM,KAAA,GAAQ,GAAA,CAAI,SAAA,GAAY,CAAA,GAAI,CAAA;IAElC,KAAA,IAAS,IAAA,GAAO,CAAA,EAAG,IAAA,GAAO,KAAA,EAAO,IAAA,EAAA,EAAQ;MACvC,IAAI,KAAA,GAAQ,GAAA,CAAI,KAAA;MAChB,IAAI,MAAA,GAAS,GAAA,CAAI,MAAA;MAEjB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,WAAA,EAAa,CAAA,EAAA,EAAK;QACxC,IAAI,SAAA,EAAW,UAAA;QAEf,IAAI,kBAAA,EAAoB;UACtB,SAAA,GAAY,WAAA,CAAY,MAAA,EAAQ,UAAA,EAAY,KAAA,EAAO,MAAM,CAAA;UACzD,UAAA,GAAa,SAAA,CAAU,MAAA;QACjC,CAAA,MAAe;UACL,UAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,KAAK,CAAA,GAAI,CAAA,GAAK,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,MAAM,CAAA,GAAK,CAAA,GAAK,UAAA;UACtE,SAAA,GAAY,IAAI,UAAA,CAAW,MAAA,EAAQ,UAAA,EAAY,UAAU,CAAA;QAC1D;QAED,MAAM,MAAA,GAAS;UAAE,IAAA,EAAM,SAAA;UAAW,KAAA;UAAc;QAAgB,CAAA;QAChE,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA;QAEvB,UAAA,IAAc,UAAA;QAEd,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,KAAA,IAAS,CAAA,EAAG,CAAC,CAAA;QAC9B,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,MAAA,IAAU,CAAA,EAAG,CAAC,CAAA;MACjC;IACF;IAED,OAAO,GAAA;EACR;AACH","sourcesContent":["import {\n  CompressedTextureLoader,\n  RGBAFormat,\n  RGBA_S3TC_DXT3_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_S3TC_DXT1_Format,\n} from 'three'\n\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer, loadMipmaps) {\n    const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 }\n\n    // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    const DDS_MAGIC = 0x20534444\n\n    // let DDSD_CAPS = 0x1;\n    // let DDSD_HEIGHT = 0x2;\n    // let DDSD_WIDTH = 0x4;\n    // let DDSD_PITCH = 0x8;\n    // let DDSD_PIXELFORMAT = 0x1000;\n    const DDSD_MIPMAPCOUNT = 0x20000\n    // let DDSD_LINEARSIZE = 0x80000;\n    // let DDSD_DEPTH = 0x800000;\n\n    // let DDSCAPS_COMPLEX = 0x8;\n    // let DDSCAPS_MIPMAP = 0x400000;\n    // let DDSCAPS_TEXTURE = 0x1000;\n\n    const DDSCAPS2_CUBEMAP = 0x200\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\n    // let DDSCAPS2_VOLUME = 0x200000;\n\n    // let DDPF_ALPHAPIXELS = 0x1;\n    // let DDPF_ALPHA = 0x2;\n    const DDPF_FOURCC = 0x4\n    // let DDPF_RGB = 0x40;\n    // let DDPF_YUV = 0x200;\n    // let DDPF_LUMINANCE = 0x20000;\n\n    function fourCCToInt32(value) {\n      return (\n        value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24)\n      )\n    }\n\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff)\n    }\n\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 4\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength)\n      const byteArray = new Uint8Array(dataLength)\n      let dst = 0\n      let src = 0\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src]\n          src++\n          const g = srcBuffer[src]\n          src++\n          const r = srcBuffer[src]\n          src++\n          const a = srcBuffer[src]\n          src++\n          byteArray[dst] = r\n          dst++ //r\n          byteArray[dst] = g\n          dst++ //g\n          byteArray[dst] = b\n          dst++ //b\n          byteArray[dst] = a\n          dst++ //a\n        }\n      }\n\n      return byteArray\n    }\n\n    const FOURCC_DXT1 = fourCCToInt32('DXT1')\n    const FOURCC_DXT3 = fourCCToInt32('DXT3')\n    const FOURCC_DXT5 = fourCCToInt32('DXT5')\n    const FOURCC_ETC1 = fourCCToInt32('ETC1')\n\n    const headerLengthInt = 31 // The header length in 32 bit ints\n\n    // Offsets into the header array\n\n    const off_magic = 0\n\n    const off_size = 1\n    const off_flags = 2\n    const off_height = 3\n    const off_width = 4\n\n    const off_mipmapCount = 7\n\n    const off_pfFlags = 20\n    const off_pfFourCC = 21\n    const off_RGBBitCount = 22\n    const off_RBitMask = 23\n    const off_GBitMask = 24\n    const off_BBitMask = 25\n    const off_ABitMask = 26\n\n    // let off_caps = 27;\n    const off_caps2 = 28\n    // let off_caps3 = 29;\n    // let off_caps4 = 30;\n\n    // Parse header\n\n    const header = new Int32Array(buffer, 0, headerLengthInt)\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.')\n      return dds\n    }\n\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.')\n      return dds\n    }\n\n    let blockBytes\n\n    const fourCC = header[off_pfFourCC]\n\n    let isRGBAUncompressed = false\n\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8\n        dds.format = RGB_S3TC_DXT1_Format\n        break\n\n      case FOURCC_DXT3:\n        blockBytes = 16\n        dds.format = RGBA_S3TC_DXT3_Format\n        break\n\n      case FOURCC_DXT5:\n        blockBytes = 16\n        dds.format = RGBA_S3TC_DXT5_Format\n        break\n\n      case FOURCC_ETC1:\n        blockBytes = 8\n        dds.format = RGB_ETC1_Format\n        break\n\n      default:\n        if (\n          header[off_RGBBitCount] === 32 &&\n          header[off_RBitMask] & 0xff0000 &&\n          header[off_GBitMask] & 0xff00 &&\n          header[off_BBitMask] & 0xff &&\n          header[off_ABitMask] & 0xff000000\n        ) {\n          isRGBAUncompressed = true\n          blockBytes = 64\n          dds.format = RGBAFormat\n        } else {\n          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC))\n          return dds\n        }\n    }\n\n    dds.mipmapCount = 1\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount])\n    }\n\n    const caps2 = header[off_caps2]\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false\n    if (\n      dds.isCubemap &&\n      (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))\n    ) {\n      console.error('THREE.DDSLoader.parse: Incomplete cubemap faces')\n      return dds\n    }\n\n    dds.width = header[off_width]\n    dds.height = header[off_height]\n\n    let dataOffset = header[off_size] + 4\n\n    // Extract mipmaps buffers\n\n    const faces = dds.isCubemap ? 6 : 1\n\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width\n      let height = dds.height\n\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength\n\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height)\n          dataLength = byteArray.length\n        } else {\n          dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength)\n        }\n\n        const mipmap = { data: byteArray, width: width, height: height }\n        dds.mipmaps.push(mipmap)\n\n        dataOffset += dataLength\n\n        width = Math.max(width >> 1, 1)\n        height = Math.max(height >> 1, 1)\n      }\n    }\n\n    return dds\n  }\n}\n\nexport { DDSLoader }\n"]},"metadata":{},"sourceType":"module"}