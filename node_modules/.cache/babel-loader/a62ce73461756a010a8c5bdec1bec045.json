{"ast":null,"code":"import * as THREE from \"three\";\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 2e-3;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 3e-3;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener(\"connected\", this._onConnected);\n    this.hand.addEventListener(\"disconnected\", this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    var _a, _b;\n    this.visible = false;\n    this.xrInputSource = null;\n    (_a = this.pointerGeometry) == null ? void 0 : _a.dispose();\n    (_b = this.pointerMesh) == null ? void 0 : _b.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  }\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints[\"index-finger-tip\"];\n    const thumbTip = this.hand.joints[\"thumb-tip\"];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener(\"connected\", this._onConnected);\n    this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n  }\n}\nexport { OculusHandPointerModel };","map":{"version":3,"sources":["../../src/webxr/OculusHandPointerModel.js"],"names":[],"mappings":"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","sourcesContent":["import * as THREE from 'three'\n\nconst PINCH_MAX = 0.05\nconst PINCH_THRESHOLD = 0.02\nconst PINCH_MIN = 0.01\nconst POINTER_ADVANCE_MAX = 0.02\nconst POINTER_OPACITY_MAX = 1\nconst POINTER_OPACITY_MIN = 0.4\nconst POINTER_FRONT_RADIUS = 0.002\nconst POINTER_REAR_RADIUS = 0.01\nconst POINTER_REAR_RADIUS_MIN = 0.003\nconst POINTER_LENGTH = 0.035\nconst POINTER_SEGMENTS = 16\nconst POINTER_RINGS = 12\nconst POINTER_HEMISPHERE_ANGLE = 110\nconst YAXIS = new THREE.Vector3(0, 1, 0)\nconst ZAXIS = new THREE.Vector3(0, 0, 1)\n\nconst CURSOR_RADIUS = 0.02\nconst CURSOR_MAX_DISTANCE = 1.5\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super()\n\n    this.hand = hand\n    this.controller = controller\n\n    // Unused\n    this.motionController = null\n    this.envMap = null\n    this.mesh = null\n\n    this.pointerGeometry = null\n    this.pointerMesh = null\n    this.pointerObject = null\n\n    this.pinched = false\n    this.attached = false\n\n    this.cursorObject = null\n\n    this.raycaster = null\n\n    this._onConnected = this._onConnected.bind(this)\n    this._onDisconnected = this._onDisconnected.bind(this)\n    this.hand.addEventListener('connected', this._onConnected)\n    this.hand.addEventListener('disconnected', this._onDisconnected)\n  }\n\n  _onConnected(event) {\n    const xrInputSource = event.data\n    if (xrInputSource.hand) {\n      this.visible = true\n      this.xrInputSource = xrInputSource\n\n      this.createPointer()\n    }\n  }\n\n  _onDisconnected() {\n    this.visible = false\n    this.xrInputSource = null\n\n    this.pointerGeometry?.dispose()\n    this.pointerMesh?.material.dispose()\n\n    this.clear()\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone()\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, (Math.PI * 2) / POINTER_SEGMENTS)\n      const vid = ringIndex * POINTER_SEGMENTS + i\n      vertices[3 * vid] = segmentVector.x\n      vertices[3 * vid + 1] = segmentVector.y\n      vertices[3 * vid + 2] = segmentVector.z\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array\n    // first ring for front face\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius))\n    this._drawVerticesRing(vertices, frontFaceBase, 0)\n\n    // rings for rear hemisphere\n    const rearBase = new THREE.Vector3(\n      Math.sin((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      Math.cos((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      0,\n    )\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1)\n      rearBase.applyAxisAngle(YAXIS, (Math.PI * POINTER_HEMISPHERE_ANGLE) / 180 / (POINTER_RINGS * -2))\n    }\n\n    // front and rear face center vertices\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius))\n    vertices[frontCenterIndex * 3] = frontCenter.x\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius)\n    vertices[rearCenterIndex * 3] = rearCenter.x\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n    // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0)\n    // const vertices = [];\n    const indices = []\n    this.pointerGeometry = new THREE.BufferGeometry()\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS)\n\n    // construct faces to connect rings\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n    }\n\n    // construct front and rear face\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i)\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1)\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1)\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS)\n\n    const material = new THREE.MeshBasicMaterial()\n    material.transparent = true\n    material.opacity = POINTER_OPACITY_MIN\n\n    this.pointerGeometry.setIndex(indices)\n\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material)\n\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n    this.pointerObject = new THREE.Object3D()\n    this.pointerObject.add(this.pointerMesh)\n\n    this.raycaster = new THREE.Raycaster()\n\n    // create cursor\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10)\n    const cursorMaterial = new THREE.MeshBasicMaterial()\n    cursorMaterial.transparent = true\n    cursorMaterial.opacity = POINTER_OPACITY_MIN\n\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial)\n    this.pointerObject.add(this.cursorObject)\n\n    this.add(this.pointerObject)\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld\n      const tempMatrix = new THREE.Matrix4()\n      tempMatrix.identity().extractRotation(pointerMatrix)\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix)\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible\n    const indexTip = this.hand.joints['index-finger-tip']\n    const thumbTip = this.hand.joints['thumb-tip']\n    const distance = indexTip.position.distanceTo(thumbTip.position)\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5)\n    this.pointerObject.position.copy(position)\n    this.pointerObject.quaternion.copy(this.controller.quaternion)\n\n    this.pinched = distance <= PINCH_THRESHOLD\n\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN)\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN)\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN\n      this._updatePointerVertices(rearRadius)\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX)\n        this.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN)\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius)\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force)\n    if (this.pointerGeometry) {\n      this._updatePointer()\n      this._updateRaycaster()\n    }\n  }\n\n  isPinched() {\n    return this.pinched\n  }\n\n  setAttached(attached) {\n    this.attached = attached\n  }\n\n  isAttached() {\n    return this.attached\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive)\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive)\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive)\n      const direction = new THREE.Vector3(0, 0, -1)\n      if (intersections.length > 0) {\n        const intersection = intersections[0]\n        const distance = intersection.distance\n        this.cursorObject.position.copy(direction.multiplyScalar(distance))\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE))\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1)\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance))\n    }\n  }\n\n  dispose() {\n    this._onDisconnected()\n    this.hand.removeEventListener('connected', this._onConnected)\n    this.hand.removeEventListener('disconnected', this._onDisconnected)\n  }\n}\n\nexport { OculusHandPointerModel }\n"]},"metadata":{},"sourceType":"module"}