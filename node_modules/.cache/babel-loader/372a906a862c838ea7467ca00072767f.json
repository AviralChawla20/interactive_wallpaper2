{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\nclass OBJExporter {\n  constructor() {\n    __publicField(this, \"output\");\n    __publicField(this, \"indexVertex\");\n    __publicField(this, \"indexVertexUvs\");\n    __publicField(this, \"indexNormals\");\n    __publicField(this, \"vertex\");\n    __publicField(this, \"color\");\n    __publicField(this, \"normal\");\n    __publicField(this, \"uv\");\n    __publicField(this, \"face\");\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  parse(object) {\n    object.traverse(child => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child);\n      }\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child);\n      }\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child);\n      }\n    });\n    return this.output;\n  }\n  parseMesh(mesh) {\n    let nbVertex = 0;\n    let nbNormals = 0;\n    let nbVertexUvs = 0;\n    const geometry = mesh.geometry;\n    const normalMatrixWorld = new Matrix3();\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const normals = geometry.getAttribute(\"normal\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const indices = geometry.getIndex();\n    this.output += `o ${mesh.name}\n`;\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\n`;\n    }\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(mesh.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (uvs !== void 0) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i);\n        this.uv.y = uvs.getY(i);\n        this.output += `vt ${this.uv.x} ${this.uv.y}\n`;\n      }\n    }\n    if (normals !== void 0) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i);\n        this.normal.y = normals.getY(i);\n        this.normal.z = normals.getZ(i);\n        this.normal.applyMatrix3(normalMatrixWorld).normalize();\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`;\n      }\n    }\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n    this.indexVertexUvs += nbVertexUvs;\n    this.indexNormals += nbNormals;\n  }\n  parseLine(line) {\n    let nbVertex = 0;\n    const geometry = line.geometry;\n    const type = line.type;\n    if (geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    this.output += `o ${line.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(line.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (type === \"Line\") {\n      this.output += \"l \";\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `;\n      }\n      this.output += \"\\n\";\n    }\n    if (type === \"LineSegments\") {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n  }\n  parsePoints(points) {\n    let nbVertex = 0;\n    const geometry = points.geometry;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const colors = geometry.getAttribute(\"color\");\n    this.output += `o ${points.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i);\n        this.vertex.applyMatrix4(points.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;\n        if (colors !== void 0 && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i);\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;\n        }\n        this.output += \"\\n\";\n      }\n    }\n    this.output += \"p \";\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `;\n    }\n    this.output += \"\\n\";\n    this.indexVertex += nbVertex;\n  }\n}\nexport { OBJExporter };","map":{"version":3,"sources":["../../src/exporters/OBJExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import { BufferAttribute, Color, Line, Matrix3, Mesh, Object3D, Points, Vector2, Vector3 } from 'three'\n\nclass OBJExporter {\n  private output\n\n  private indexVertex\n  private indexVertexUvs\n  private indexNormals\n\n  private vertex\n  private color\n  private normal\n  private uv\n\n  private face: string[]\n\n  constructor() {\n    this.output = ''\n\n    this.indexVertex = 0\n    this.indexVertexUvs = 0\n    this.indexNormals = 0\n\n    this.vertex = new Vector3()\n    this.color = new Color()\n    this.normal = new Vector3()\n    this.uv = new Vector2()\n\n    this.face = []\n  }\n\n  public parse(object: Object3D): string {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child)\n      }\n\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child)\n      }\n\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child)\n      }\n    })\n\n    return this.output\n  }\n\n  private parseMesh(mesh: Mesh): void {\n    let nbVertex = 0\n    let nbNormals = 0\n    let nbVertexUvs = 0\n\n    const geometry = mesh.geometry\n\n    const normalMatrixWorld = new Matrix3()\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n    const normals = geometry.getAttribute('normal')\n    const uvs = geometry.getAttribute('uv')\n    const indices = geometry.getIndex()\n\n    // name of the mesh object\n    this.output += `o ${mesh.name}\\n`\n\n    // name of the mesh material\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\\n`\n    }\n\n    // vertices\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(mesh.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    // uvs\n\n    if (uvs !== undefined) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i)\n        this.uv.y = uvs.getY(i)\n\n        // transform the uv to export format\n        this.output += `vt ${this.uv.x} ${this.uv.y}\\n`\n      }\n    }\n\n    // normals\n\n    if (normals !== undefined) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i)\n        this.normal.y = normals.getY(i)\n        this.normal.z = normals.getZ(i)\n\n        // transform the normal to world space\n        this.normal.applyMatrix3(normalMatrixWorld).normalize()\n\n        // transform the normal to export format\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      }\n    }\n\n    // faces\n\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n    this.indexVertexUvs += nbVertexUvs\n    this.indexNormals += nbNormals\n  }\n\n  private parseLine(line: Line): void {\n    let nbVertex = 0\n\n    const geometry = line.geometry\n    const type = line.type\n\n    if (geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n\n    // name of the line object\n    this.output += `o ${line.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(line.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    if (type === 'Line') {\n      this.output += 'l '\n\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `\n      }\n\n      this.output += '\\n'\n    }\n\n    if (type === 'LineSegments') {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n\n  private parsePoints(points: Points): void {\n    let nbVertex = 0\n\n    const geometry = points.geometry\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    const vertices = geometry.getAttribute('position')\n    const colors = geometry.getAttribute('color')\n\n    this.output += `o ${points.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i)\n        this.vertex.applyMatrix4(points.matrixWorld)\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`\n\n        if (colors !== undefined && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i)\n\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`\n        }\n\n        this.output += '\\n'\n      }\n    }\n\n    this.output += 'p '\n\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `\n    }\n\n    this.output += '\\n'\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n}\n\nexport { OBJExporter }\n"]},"metadata":{},"sourceType":"module"}