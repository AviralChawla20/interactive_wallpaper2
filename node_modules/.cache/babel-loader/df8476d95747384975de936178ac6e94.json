{"ast":null,"code":"import { Box3, Vector3, InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from \"three\";\nconst _box = new Box3();\nconst _vector = new Vector3();\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\", this);\n      }\n    }\n  }\n  toJSON() {}\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\nexport { LineSegmentsGeometry };","map":{"version":3,"sources":["../../src/lines/LineSegmentsGeometry.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = new Box3()\nconst _vector = new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n"]},"metadata":{},"sourceType":"module"}