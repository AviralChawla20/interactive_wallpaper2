{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from \"three\";\nclass AssimpLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n    Virtulous.KeyFrame = class {\n      constructor(time, matrix) {\n        this.time = time;\n        this.matrix = matrix.clone();\n        this.position = new Vector3();\n        this.quaternion = new Quaternion();\n        this.scale = new Vector3(1, 1, 1);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n        this.clone = function () {\n          var n = new Virtulous.KeyFrame(this.time, this.matrix);\n          return n;\n        };\n        this.lerp = function (nextKey, time2) {\n          time2 -= this.time;\n          var dist = nextKey.time - this.time;\n          var l = time2 / dist;\n          var l2 = 1 - l;\n          var keypos = this.position;\n          var keyrot = this.quaternion;\n          var key2pos = nextKey.position;\n          var key2rot = nextKey.quaternion;\n          Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n          Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n          Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n          Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n          Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n          return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n        };\n      }\n    };\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n        this.init();\n      };\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n        this.init();\n      };\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n        t.init();\n        return t;\n      };\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n        return null;\n      }\n      return find(root, target.name);\n    };\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n      this.setTime = function (time) {\n        this.time = time;\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n      };\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n        return n;\n      };\n    };\n    var ASSBIN_CHUNK_AICAMERA = 4660;\n    var ASSBIN_CHUNK_AILIGHT = 4661;\n    var ASSBIN_CHUNK_AITEXTURE = 4662;\n    var ASSBIN_CHUNK_AIMESH = 4663;\n    var ASSBIN_CHUNK_AINODEANIM = 4664;\n    var ASSBIN_CHUNK_AISCENE = 4665;\n    var ASSBIN_CHUNK_AIBONE = 4666;\n    var ASSBIN_CHUNK_AIANIMATION = 4667;\n    var ASSBIN_CHUNK_AINODE = 4668;\n    var ASSBIN_CHUNK_AIMATERIAL = 4669;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;\n    var ASSBIN_MESH_HAS_POSITIONS = 1;\n    var ASSBIN_MESH_HAS_NORMALS = 2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 65536;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    var aiLightSource_DIRECTIONAL = 1;\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    var aiLightSource_SPOT = 3;\n    //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    var aiTextureType_DIFFUSE = 1;\n    var aiTextureType_NORMALS = 6;\n    var aiTextureType_OPACITY = 8;\n    var aiTextureType_LIGHTMAP = 10;\n    var BONESPERVERT = 4;\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n      return rootBone;\n    }\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n      sum = Math.sqrt(sum);\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf(\"bone_\" + name) == 0) return root;\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n      return void 0;\n    }\n    class aiMesh {\n      constructor() {\n        this.mPrimitiveTypes = 0;\n        this.mNumVertices = 0;\n        this.mNumFaces = 0;\n        this.mNumBones = 0;\n        this.mMaterialIndex = 0;\n        this.mVertices = [];\n        this.mNormals = [];\n        this.mTangents = [];\n        this.mBitangents = [];\n        this.mColors = [[]];\n        this.mTextureCoords = [[]];\n        this.mFaces = [];\n        this.mBones = [];\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return;\n          var allBones = [];\n          var offsetMatrix = [];\n          var skeletonRoot = scene.findNode(this.mBones[0].mName);\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent;\n          }\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n          this.threeNode.add(threeSkeletonRootBone);\n          for (let i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            if (bone) {\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName);\n              if (!skeletonRoot) return;\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n              this.threeNode.add(threeSkeletonRootBone);\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            }\n          }\n          var skeleton = new Skeleton(allBones, offsetMatrix);\n          this.threeNode.bind(skeleton, new Matrix4());\n          this.threeNode.material.skinning = true;\n        };\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var geometry = new BufferGeometry();\n          var mat;\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n          geometry.setAttribute(\"position\", new BufferAttribute(this.mVertexBuffer, 3));\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute(\"normal\", new BufferAttribute(this.mNormalBuffer, 3));\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute(\"color\", new BufferAttribute(this.mColorBuffer, 4));\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute(\"uv\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute(\"uv1\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute(\"tangents\", new BufferAttribute(this.mTangentBuffer, 3));\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute(\"bitangents\", new BufferAttribute(this.mBitangentBuffer, 3));\n          }\n          if (this.mBones.length > 0) {\n            var weights = [];\n            var bones = [];\n            for (let i = 0; i < this.mBones.length; i++) {\n              for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j];\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                  weights[weight.mVertexId].push(weight.mWeight);\n                  bones[weight.mVertexId].push(parseInt(i));\n                }\n              }\n            }\n            for (let i in bones) {\n              sortWeights(bones[i], weights[i]);\n            }\n            var _weights = [];\n            var _bones = [];\n            for (let i = 0; i < weights.length; i++) {\n              for (let j = 0; j < 4; j++) {\n                if (weights[i] && bones[i]) {\n                  _weights.push(weights[i][j]);\n                  _bones.push(bones[i][j]);\n                } else {\n                  _weights.push(0);\n                  _bones.push(0);\n                }\n              }\n            }\n            geometry.setAttribute(\"skinWeight\", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n            geometry.setAttribute(\"skinIndex\", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n          }\n          var mesh;\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat);\n            mesh.normalizeSkinWeights();\n          }\n          this.threeNode = mesh;\n          return mesh;\n        };\n      }\n    }\n    class aiFace {\n      constructor() {\n        this.mNumIndices = 0;\n        this.mIndices = [];\n      }\n    }\n    class aiVector3D {\n      constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z);\n        };\n      }\n    }\n    class aiColor3D {\n      constructor() {\n        this.r = 0;\n        this.g = 0;\n        this.b = 0;\n        this.a = 0;\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b);\n        };\n      }\n    }\n    class aiQuaternion {\n      constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n      }\n    }\n    class aiVertexWeight {\n      constructor() {\n        this.mVertexId = 0;\n        this.mWeight = 0;\n      }\n    }\n    class aiString {\n      constructor() {\n        this.data = [];\n        this.toString = function () {\n          var str = \"\";\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i);\n          });\n          return str.replace(/[^\\x20-\\x7E]+/g, \"\");\n        };\n      }\n    }\n    class aiVectorKey {\n      constructor() {\n        this.mTime = 0;\n        this.mValue = null;\n      }\n    }\n    class aiQuatKey {\n      constructor() {\n        this.mTime = 0;\n        this.mValue = null;\n      }\n    }\n    class aiNode {\n      constructor() {\n        this.mName = \"\";\n        this.mTransformation = [];\n        this.mNumChildren = 0;\n        this.mNumMeshes = 0;\n        this.mMeshes = [];\n        this.mChildren = [];\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var o = new Object3D();\n          o.name = this.mName;\n          o.matrix = this.mTransformation.toTHREE();\n          for (let i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene));\n          }\n          for (let i = 0; i < this.mMeshes.length; i++) {\n            o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n          }\n          this.threeNode = o;\n          o.matrix.decompose(o.position, o.quaternion, o.scale);\n          return o;\n        };\n      }\n    }\n    class aiBone {\n      constructor() {\n        this.mName = \"\";\n        this.mNumWeights = 0;\n        this.mOffsetMatrix = 0;\n      }\n    }\n    class aiMaterialProperty {\n      constructor() {\n        this.mKey = \"\";\n        this.mSemantic = 0;\n        this.mIndex = 0;\n        this.mData = [];\n        this.mDataLength = 0;\n        this.mType = 0;\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          var g = reader.getFloat32(4, true);\n          var b = reader.getFloat32(8, true);\n          return new Color(r, g, b);\n        };\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return r;\n        };\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return !!r;\n        };\n        this.dataAsString = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          return s.toString();\n        };\n        this.dataAsMap = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          var path2 = s.toString();\n          path2 = path2.replace(/\\\\/g, \"/\");\n          if (path2.indexOf(\"/\") != -1) {\n            path2 = path2.substr(path2.lastIndexOf(\"/\") + 1);\n          }\n          return textureLoader.load(path2);\n        };\n      }\n    }\n    var namePropMapping = {\n      \"?mat.name\": \"name\",\n      \"$mat.shadingm\": \"shading\",\n      \"$mat.twosided\": \"twoSided\",\n      \"$mat.wireframe\": \"wireframe\",\n      \"$clr.ambient\": \"ambient\",\n      \"$clr.diffuse\": \"color\",\n      \"$clr.specular\": \"specular\",\n      \"$clr.emissive\": \"emissive\",\n      \"$clr.transparent\": \"transparent\",\n      \"$clr.reflective\": \"reflect\",\n      \"$mat.shininess\": \"shininess\",\n      \"$mat.reflectivity\": \"reflectivity\",\n      \"$mat.refracti\": \"refraction\",\n      \"$tex.file\": \"map\"\n    };\n    var nameTypeMapping = {\n      \"?mat.name\": \"string\",\n      \"$mat.shadingm\": \"bool\",\n      \"$mat.twosided\": \"bool\",\n      \"$mat.wireframe\": \"bool\",\n      \"$clr.ambient\": \"color\",\n      \"$clr.diffuse\": \"color\",\n      \"$clr.specular\": \"color\",\n      \"$clr.emissive\": \"color\",\n      \"$clr.transparent\": \"color\",\n      \"$clr.reflective\": \"color\",\n      \"$mat.shininess\": \"float\",\n      \"$mat.reflectivity\": \"float\",\n      \"$mat.refracti\": \"float\",\n      \"$tex.file\": \"map\"\n    };\n    class aiMaterial {\n      constructor() {\n        this.mNumAllocated = 0;\n        this.mNumProperties = 0;\n        this.mProperties = [];\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial();\n          for (let i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"float\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"color\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"bool\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"string\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"map\") {\n              var prop = this.mProperties[i];\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n            }\n          }\n          mat.ambient.r = 0.53;\n          mat.ambient.g = 0.53;\n          mat.ambient.b = 0.53;\n          mat.color.r = 1;\n          mat.color.g = 1;\n          mat.color.b = 1;\n          return mat;\n        };\n      }\n    }\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n    class aiNodeAnim {\n      constructor() {\n        this.mNodeName = \"\";\n        this.mNumPositionKeys = 0;\n        this.mNumRotationKeys = 0;\n        this.mNumScalingKeys = 0;\n        this.mPositionKeys = [];\n        this.mRotationKeys = [];\n        this.mScalingKeys = [];\n        this.mPreState = \"\";\n        this.mPostState = \"\";\n        this.init = function (tps) {\n          if (!tps) tps = 1;\n          function t(t2) {\n            t2.mTime /= tps;\n          }\n          this.mPositionKeys.forEach(t);\n          this.mRotationKeys.forEach(t);\n          this.mScalingKeys.forEach(t);\n        };\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime;\n          }\n          this.mPositionKeys.sort(comp);\n          this.mRotationKeys.sort(comp);\n          this.mScalingKeys.sort(comp);\n        };\n        this.getLength = function () {\n          return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n            return a.mTime;\n          })));\n        };\n        this.toTHREE = function (o) {\n          this.sortKeys();\n          var length = this.getLength();\n          var track = new Virtulous.KeyFrameTrack();\n          for (let i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4();\n            var time = i;\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n            matrix.compose(pos, rotation, scale);\n            var key = new Virtulous.KeyFrame(time, matrix);\n            track.addKey(key);\n          }\n          track.target = o.findNode(this.mNodeName).toTHREE();\n          var tracks = [track];\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n              var t2 = track.clone();\n              t2.target = o.nodeToBoneMap[this.mNodeName][i];\n              tracks.push(t2);\n            }\n          }\n          return tracks;\n        };\n      }\n    }\n    class aiAnimation {\n      constructor() {\n        this.mName = \"\";\n        this.mDuration = 0;\n        this.mTicksPerSecond = 0;\n        this.mNumChannels = 0;\n        this.mChannels = [];\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation();\n          for (let i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond);\n            var tracks = this.mChannels[i].toTHREE(root);\n            for (let j in tracks) {\n              tracks[j].init();\n              animationHandle.addTrack(tracks[j]);\n            }\n          }\n          animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n            return e.length;\n          }));\n          return animationHandle;\n        };\n      }\n    }\n    class aiTexture {\n      constructor() {\n        this.mWidth = 0;\n        this.mHeight = 0;\n        this.texAchFormatHint = [];\n        this.pcData = [];\n      }\n    }\n    class aiLight {\n      constructor() {\n        this.mName = \"\";\n        this.mType = 0;\n        this.mAttenuationConstant = 0;\n        this.mAttenuationLinear = 0;\n        this.mAttenuationQuadratic = 0;\n        this.mAngleInnerCone = 0;\n        this.mAngleOuterCone = 0;\n        this.mColorDiffuse = null;\n        this.mColorSpecular = null;\n        this.mColorAmbient = null;\n      }\n    }\n    class aiCamera {\n      constructor() {\n        this.mName = \"\";\n        this.mPosition = null;\n        this.mLookAt = null;\n        this.mUp = null;\n        this.mHorizontalFOV = 0;\n        this.mClipPlaneNear = 0;\n        this.mClipPlaneFar = 0;\n        this.mAspect = 0;\n      }\n    }\n    class aiScene {\n      constructor() {\n        this.versionMajor = 0;\n        this.versionMinor = 0;\n        this.versionRevision = 0;\n        this.compileFlags = 0;\n        this.mFlags = 0;\n        this.mNumMeshes = 0;\n        this.mNumMaterials = 0;\n        this.mNumAnimations = 0;\n        this.mNumTextures = 0;\n        this.mNumLights = 0;\n        this.mNumCameras = 0;\n        this.mRootNode = null;\n        this.mMeshes = [];\n        this.mMaterials = [];\n        this.mAnimations = [];\n        this.mLights = [];\n        this.mCameras = [];\n        this.nodeToBoneMap = {};\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode;\n          }\n          if (root.mName == name) {\n            return root;\n          }\n          for (let i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i]);\n            if (ret) return ret;\n          }\n          return null;\n        };\n        this.toTHREE = function () {\n          this.nodeCount = 0;\n          markBones(this);\n          var o = this.mRootNode.toTHREE(this);\n          for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this);\n          }\n          return {\n            object: o,\n            animation: a\n          };\n        };\n      }\n    }\n    class aiMatrix4 {\n      constructor() {\n        this.elements = [[], [], [], []];\n        this.toTHREE = function () {\n          var m = new Matrix4();\n          for (let i = 0; i < 4; ++i) {\n            for (let i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i];\n            }\n          }\n          return m;\n        };\n      }\n    }\n    var littleEndian = true;\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n      return m;\n    }\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n    }\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n    }\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n    }\n    function ReadBounds(stream, T, n) {\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n    }\n    function ai_assert(bool) {\n      if (!bool) throw \"asset failed\";\n    }\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n      if (node.mNumChildren) {\n        node.mChildren = [];\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n      return node;\n    }\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream);\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n      return b;\n    }\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = [];\n      var c = Read_unsigned_int(stream);\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n      mesh.mTexCoordsBuffers = [];\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break;\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          mesh.mTextureCoords[n] = [];\n          mesh.mTexCoordsBuffers[n] = [];\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      }\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace();\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      }\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    }\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n        mat.mProperties = [];\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream);\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0);\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      }\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      }\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      }\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      }\n      if (scene.mNumLights) {\n        scene.mLights = [];\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      }\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n    function extendStream(stream) {\n      stream.readOffset = 0;\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n      };\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n    var shortened, compressed;\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR);\n      pScene.versionMajor = Read_unsigned_int(stream);\n      pScene.versionMinor = Read_unsigned_int(stream);\n      pScene.versionRevision = Read_unsigned_int(stream);\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw \"Shortened binaries are not supported!\";\n      stream.Seek(256, aiOrigin_CUR);\n      stream.Seek(128, aiOrigin_CUR);\n      stream.Seek(64, aiOrigin_CUR);\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n      return pScene.toTHREE();\n    }\n    return InternReadFile(buffer);\n  }\n}\nexport { AssimpLoader };","map":{"version":3,"sources":["../../src/loaders/AssimpLoader.js"],"names":["time","path","t"],"mappings":"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","sourcesContent":["import {\n  Bone,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Quaternion,\n  Skeleton,\n  SkinnedMesh,\n  TextureLoader,\n  Vector3,\n} from 'three'\n\nclass AssimpLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    var scope = this\n\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    var loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    var Virtulous = {}\n\n    Virtulous.KeyFrame = class {\n      constructor(time, matrix) {\n        this.time = time\n        this.matrix = matrix.clone()\n        this.position = new Vector3()\n        this.quaternion = new Quaternion()\n        this.scale = new Vector3(1, 1, 1)\n        this.matrix.decompose(this.position, this.quaternion, this.scale)\n        this.clone = function () {\n          var n = new Virtulous.KeyFrame(this.time, this.matrix)\n          return n\n        }\n\n        this.lerp = function (nextKey, time) {\n          time -= this.time\n          var dist = nextKey.time - this.time\n          var l = time / dist\n          var l2 = 1 - l\n          var keypos = this.position\n          var keyrot = this.quaternion\n          //      var keyscl =  key.parentspaceScl || key.scl;\n          var key2pos = nextKey.position\n          var key2rot = nextKey.quaternion\n          //  var key2scl =  key2.parentspaceScl || key2.scl;\n          Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l\n          Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l\n          Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l\n          //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n          //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n          //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n          Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w)\n          Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l)\n          return Virtulous.KeyFrame.tempAniMatrix.compose(\n            Virtulous.KeyFrame.tempAniPos,\n            Virtulous.KeyFrame.tempAniQuat,\n            Virtulous.KeyFrame.tempAniScale,\n          )\n        }\n      }\n    }\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3()\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion()\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1)\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4()\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = []\n      this.target = null\n      this.time = 0\n      this.length = 0\n      this._accelTable = {}\n      this.fps = 20\n      this.addKey = function (key) {\n        this.keys.push(key)\n      }\n\n      this.init = function () {\n        this.sortKeys()\n\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time\n        else this.length = 0\n\n        if (!this.fps) return\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i\n              break\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i\n              break\n            }\n          }\n        }\n      }\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps\n        this.target = data.node\n        var track = data.hierarchy[0].keys\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data))\n        }\n\n        this.init()\n      }\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys\n        var fps = this.fps\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix))\n        }\n\n        this.init()\n      }\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc)\n      }\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time\n      }\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack()\n        t.target = this.target\n        t.time = this.time\n        t.length = this.length\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone())\n        }\n\n        t.init()\n        return t\n      }\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        this.target = compareitor(root, this.target)\n      }\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps\n        time = Math.floor(time)\n        return this._accelTable[time] || 0\n      }\n\n      this.setTime = function (time) {\n        time = Math.abs(time)\n        if (this.length) time = (time % this.length) + 0.05\n        var key0 = null\n        var key1 = null\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i]\n            break\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i + 1]\n            break\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i]\n            key1 = this.keys[0].clone()\n            key1.time += this.length + 0.05\n            break\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.lerp(key1, time))\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.matrix)\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n      }\n    }\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name)\n          if (r) return r\n        }\n\n        return null\n      }\n\n      return find(root, target.name)\n    }\n\n    Virtulous.Animation = function () {\n      this.tracks = []\n      this.length = 0\n\n      this.addTrack = function (track) {\n        this.tracks.push(track)\n        this.length = Math.max(track.length, this.length)\n      }\n\n      this.setTime = function (time) {\n        this.time = time\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time)\n      }\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        var n = new Virtulous.Animation()\n        n.target = target\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone()\n          track.reTarget(target, compareitor)\n          n.addTrack(track)\n        }\n\n        return n\n      }\n    }\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234\n    var ASSBIN_CHUNK_AILIGHT = 0x1235\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236\n    var ASSBIN_CHUNK_AIMESH = 0x1237\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238\n    var ASSBIN_CHUNK_AISCENE = 0x1239\n    var ASSBIN_CHUNK_AIBONE = 0x123a\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b\n    var ASSBIN_CHUNK_AINODE = 0x123c\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1\n    var ASSBIN_MESH_HAS_NORMALS = 0x2\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4\n    //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    var aiLightSource_DIRECTIONAL = 0x1\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    var aiLightSource_SPOT = 0x3\n    //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n    var aiTextureType_DIFFUSE = 0x1\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n    var aiTextureType_NORMALS = 0x6\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n    var aiTextureType_OPACITY = 0x8\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n    var aiTextureType_LIGHTMAP = 0xa\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n    var BONESPERVERT = 4\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i]\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName)\n          if (boneNode) boneNode.isBone = true\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone()\n      rootBone.matrix.copy(root.matrix)\n      rootBone.matrixWorld.copy(root.matrixWorld)\n      rootBone.position.copy(root.position)\n      rootBone.quaternion.copy(root.quaternion)\n      rootBone.scale.copy(root.scale)\n      scene.nodeCount++\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString()\n\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = []\n      scene.nodeToBoneMap[root.name].push(rootBone)\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene)\n        rootBone.add(child)\n      }\n\n      return rootBone\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = []\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i],\n        })\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w\n      })\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0,\n        })\n      }\n\n      if (pairs.length > 4) pairs.length = 4\n      var sum = 0\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w\n      }\n\n      sum = Math.sqrt(sum)\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum\n        indexes[i] = pairs[i].i\n        weights[i] = pairs[i].w\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name)\n\n        if (ret) return ret\n      }\n\n      return undefined\n    }\n\n    class aiMesh {\n      constructor() {\n        this.mPrimitiveTypes = 0\n        this.mNumVertices = 0\n        this.mNumFaces = 0\n        this.mNumBones = 0\n        this.mMaterialIndex = 0\n        this.mVertices = []\n        this.mNormals = []\n        this.mTangents = []\n        this.mBitangents = []\n        this.mColors = [[]]\n        this.mTextureCoords = [[]]\n        this.mFaces = []\n        this.mBones = []\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return\n\n          var allBones = []\n          var offsetMatrix = []\n          var skeletonRoot = scene.findNode(this.mBones[0].mName)\n\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent\n          }\n\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n          this.threeNode.add(threeSkeletonRootBone)\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n\n            if (bone) {\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName)\n              if (!skeletonRoot) return\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n              this.threeNode.add(threeSkeletonRootBone)\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            }\n          }\n\n          var skeleton = new Skeleton(allBones, offsetMatrix)\n\n          this.threeNode.bind(skeleton, new Matrix4())\n          this.threeNode.material.skinning = true\n        }\n\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var geometry = new BufferGeometry()\n          var mat\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene)\n          else mat = new MeshLambertMaterial()\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1))\n          geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3))\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3))\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4))\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2))\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2))\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3))\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3))\n          }\n          if (this.mBones.length > 0) {\n            var weights = []\n            var bones = []\n\n            for (let i = 0; i < this.mBones.length; i++) {\n              for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j]\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = []\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = []\n                  weights[weight.mVertexId].push(weight.mWeight)\n                  bones[weight.mVertexId].push(parseInt(i))\n                }\n              }\n            }\n\n            for (let i in bones) {\n              sortWeights(bones[i], weights[i])\n            }\n\n            var _weights = []\n            var _bones = []\n\n            for (let i = 0; i < weights.length; i++) {\n              for (let j = 0; j < 4; j++) {\n                if (weights[i] && bones[i]) {\n                  _weights.push(weights[i][j])\n                  _bones.push(bones[i][j])\n                } else {\n                  _weights.push(0)\n                  _bones.push(0)\n                }\n              }\n            }\n\n            geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT))\n            geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT))\n          }\n\n          var mesh\n\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat)\n\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat)\n            mesh.normalizeSkinWeights()\n          }\n\n          this.threeNode = mesh\n          //mesh.matrixAutoUpdate = false;\n          return mesh\n        }\n      }\n    }\n\n    class aiFace {\n      constructor() {\n        this.mNumIndices = 0\n        this.mIndices = []\n      }\n    }\n\n    class aiVector3D {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z)\n        }\n      }\n    }\n\n    class aiColor3D {\n      constructor() {\n        this.r = 0\n        this.g = 0\n        this.b = 0\n        this.a = 0\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b)\n        }\n      }\n    }\n\n    class aiQuaternion {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n        this.w = 0\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w)\n        }\n      }\n    }\n\n    class aiVertexWeight {\n      constructor() {\n        this.mVertexId = 0\n        this.mWeight = 0\n      }\n    }\n\n    class aiString {\n      constructor() {\n        this.data = []\n        this.toString = function () {\n          var str = ''\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i)\n          })\n          return str.replace(/[^\\x20-\\x7E]+/g, '')\n        }\n      }\n    }\n\n    class aiVectorKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiQuatKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiNode {\n      constructor() {\n        this.mName = ''\n        this.mTransformation = []\n        this.mNumChildren = 0\n        this.mNumMeshes = 0\n        this.mMeshes = []\n        this.mChildren = []\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var o = new Object3D()\n          o.name = this.mName\n          o.matrix = this.mTransformation.toTHREE()\n\n          for (let i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene))\n          }\n\n          for (let i = 0; i < this.mMeshes.length; i++) {\n            o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene))\n          }\n\n          this.threeNode = o\n          //o.matrixAutoUpdate = false;\n          o.matrix.decompose(o.position, o.quaternion, o.scale)\n          return o\n        }\n      }\n    }\n\n    class aiBone {\n      constructor() {\n        this.mName = ''\n        this.mNumWeights = 0\n        this.mOffsetMatrix = 0\n      }\n    }\n\n    class aiMaterialProperty {\n      constructor() {\n        this.mKey = ''\n        this.mSemantic = 0\n        this.mIndex = 0\n        this.mData = []\n        this.mDataLength = 0\n        this.mType = 0\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          var g = reader.getFloat32(4, true)\n          var b = reader.getFloat32(8, true)\n          //var a = reader.getFloat32(12, true);\n          return new Color(r, g, b)\n        }\n\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return r\n        }\n\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return !!r\n        }\n\n        this.dataAsString = function () {\n          var s = new aiString()\n          s.data = this.mData\n          return s.toString()\n        }\n\n        this.dataAsMap = function () {\n          var s = new aiString()\n          s.data = this.mData\n          var path = s.toString()\n          path = path.replace(/\\\\/g, '/')\n\n          if (path.indexOf('/') != -1) {\n            path = path.substr(path.lastIndexOf('/') + 1)\n          }\n\n          return textureLoader.load(path)\n        }\n      }\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map',\n    }\n\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map',\n    }\n\n    class aiMaterial {\n      constructor() {\n        this.mNumAllocated = 0\n        this.mNumProperties = 0\n        this.mProperties = []\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial()\n\n          for (let i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n              var prop = this.mProperties[i]\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap()\n            }\n          }\n\n          mat.ambient.r = 0.53\n          mat.ambient.g = 0.53\n          mat.ambient.b = 0.53\n          mat.color.r = 1\n          mat.color.g = 1\n          mat.color.b = 1\n          return mat\n        }\n      }\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3()\n      var lm1 = 1 - l\n      v.x = v1.x * l + v2.x * lm1\n      v.y = v1.y * l + v2.y * lm1\n      v.z = v1.z * l + v2.z * lm1\n      return v\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l)\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE()\n\n      var dist = Infinity\n      var key = null\n      var nextKey = null\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time)\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist\n          key = keys[i]\n          nextKey = keys[i + 1]\n        }\n      }\n\n      if (!key) {\n        return null\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      } else {\n        nextKey = keys[0].clone()\n        nextKey.mTime += lne\n\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      }\n    }\n\n    class aiNodeAnim {\n      constructor() {\n        this.mNodeName = ''\n        this.mNumPositionKeys = 0\n        this.mNumRotationKeys = 0\n        this.mNumScalingKeys = 0\n        this.mPositionKeys = []\n        this.mRotationKeys = []\n        this.mScalingKeys = []\n        this.mPreState = ''\n        this.mPostState = ''\n        this.init = function (tps) {\n          if (!tps) tps = 1\n\n          function t(t) {\n            t.mTime /= tps\n          }\n\n          this.mPositionKeys.forEach(t)\n          this.mRotationKeys.forEach(t)\n          this.mScalingKeys.forEach(t)\n        }\n\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime\n          }\n\n          this.mPositionKeys.sort(comp)\n          this.mRotationKeys.sort(comp)\n          this.mScalingKeys.sort(comp)\n        }\n\n        this.getLength = function () {\n          return Math.max(\n            Math.max.apply(\n              null,\n              this.mPositionKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mRotationKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mScalingKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n          )\n        }\n\n        this.toTHREE = function (o) {\n          this.sortKeys()\n          var length = this.getLength()\n          var track = new Virtulous.KeyFrameTrack()\n\n          for (let i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4()\n            var time = i\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp)\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp)\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp)\n            matrix.compose(pos, rotation, scale)\n\n            var key = new Virtulous.KeyFrame(time, matrix)\n            track.addKey(key)\n          }\n\n          track.target = o.findNode(this.mNodeName).toTHREE()\n\n          var tracks = [track]\n\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n              var t2 = track.clone()\n              t2.target = o.nodeToBoneMap[this.mNodeName][i]\n              tracks.push(t2)\n            }\n          }\n\n          return tracks\n        }\n      }\n    }\n\n    class aiAnimation {\n      constructor() {\n        this.mName = ''\n        this.mDuration = 0\n        this.mTicksPerSecond = 0\n        this.mNumChannels = 0\n        this.mChannels = []\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation()\n\n          for (let i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond)\n\n            var tracks = this.mChannels[i].toTHREE(root)\n\n            for (let j in tracks) {\n              tracks[j].init()\n              animationHandle.addTrack(tracks[j])\n            }\n          }\n\n          animationHandle.length = Math.max.apply(\n            null,\n            animationHandle.tracks.map(function (e) {\n              return e.length\n            }),\n          )\n          return animationHandle\n        }\n      }\n    }\n\n    class aiTexture {\n      constructor() {\n        this.mWidth = 0\n        this.mHeight = 0\n        this.texAchFormatHint = []\n        this.pcData = []\n      }\n    }\n\n    class aiLight {\n      constructor() {\n        this.mName = ''\n        this.mType = 0\n        this.mAttenuationConstant = 0\n        this.mAttenuationLinear = 0\n        this.mAttenuationQuadratic = 0\n        this.mAngleInnerCone = 0\n        this.mAngleOuterCone = 0\n        this.mColorDiffuse = null\n        this.mColorSpecular = null\n        this.mColorAmbient = null\n      }\n    }\n\n    class aiCamera {\n      constructor() {\n        this.mName = ''\n        this.mPosition = null\n        this.mLookAt = null\n        this.mUp = null\n        this.mHorizontalFOV = 0\n        this.mClipPlaneNear = 0\n        this.mClipPlaneFar = 0\n        this.mAspect = 0\n      }\n    }\n\n    class aiScene {\n      constructor() {\n        this.versionMajor = 0\n        this.versionMinor = 0\n        this.versionRevision = 0\n        this.compileFlags = 0\n        this.mFlags = 0\n        this.mNumMeshes = 0\n        this.mNumMaterials = 0\n        this.mNumAnimations = 0\n        this.mNumTextures = 0\n        this.mNumLights = 0\n        this.mNumCameras = 0\n        this.mRootNode = null\n        this.mMeshes = []\n        this.mMaterials = []\n        this.mAnimations = []\n        this.mLights = []\n        this.mCameras = []\n        this.nodeToBoneMap = {}\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode\n          }\n\n          if (root.mName == name) {\n            return root\n          }\n\n          for (let i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i])\n            if (ret) return ret\n          }\n\n          return null\n        }\n\n        this.toTHREE = function () {\n          this.nodeCount = 0\n\n          markBones(this)\n\n          var o = this.mRootNode.toTHREE(this)\n\n          for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this)\n\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this)\n          }\n\n          return { object: o, animation: a }\n        }\n      }\n    }\n\n    class aiMatrix4 {\n      constructor() {\n        this.elements = [[], [], [], []]\n        this.toTHREE = function () {\n          var m = new Matrix4()\n\n          for (let i = 0; i < 4; ++i) {\n            for (let i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i]\n            }\n          }\n\n          return m\n        }\n      }\n    }\n\n    var littleEndian = true\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian)\n      dataview.readOffset += 8\n      return val\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset)\n      dataview.readOffset += 1\n      return val\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian)\n      dataview.readOffset += 2\n      return val\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D()\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D()\n      c.r = readFloat(stream)\n      c.g = readFloat(stream)\n      c.b = readFloat(stream)\n      return c\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion()\n      v.w = readFloat(stream)\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString()\n      var stringlengthbytes = Read_unsigned_int(stream)\n      stream.ReadBytes(s.data, 1, stringlengthbytes)\n      return s.toString()\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight()\n      w.mVertexId = Read_unsigned_int(stream)\n      w.mWeight = readFloat(stream)\n      return w\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4()\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream)\n        }\n      }\n\n      return m\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiVector3D(stream)\n      return v\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiQuaternion(stream)\n      return v\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream)\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream)\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream)\n    }\n\n    function ReadBounds(stream, T /*p*/, n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR)\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed'\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      var node = new aiNode()\n      node.mParent = parent\n      node.mDepth = depth\n      node.mName = Read_aiString(stream)\n      node.mTransformation = Read_aiMatrix4x4(stream)\n      node.mNumChildren = Read_unsigned_int(stream)\n      node.mNumMeshes = Read_unsigned_int(stream)\n\n      if (node.mNumMeshes) {\n        node.mMeshes = []\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream)\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = []\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++)\n          node.mChildren[i] = node2\n        }\n      }\n\n      return node\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      b.mName = Read_aiString(stream)\n      b.mNumWeights = Read_unsigned_int(stream)\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream)\n      // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights)\n      } else {\n        // else write as usual\n\n        b.mWeights = []\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights)\n      }\n\n      return b\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream)\n      mesh.mNumVertices = Read_unsigned_int(stream)\n      mesh.mNumFaces = Read_unsigned_int(stream)\n      mesh.mNumBones = Read_unsigned_int(stream)\n      mesh.mMaterialIndex = Read_unsigned_int(stream)\n      mesh.mNumUVComponents = []\n      // first of all, write bits for all existent vertex components\n      var c = Read_unsigned_int(stream)\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mVertices = []\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mNormals = []\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices)\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTangents = []\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n          mesh.mBitangents = []\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mColors[n] = []\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4)\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR)\n        }\n      }\n\n      mesh.mTexCoordsBuffers = []\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break\n\n        // write number of UV components\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream)\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTextureCoords[n] = []\n          //note that assbin always writes 3d texcoords\n          mesh.mTexCoordsBuffers[n] = []\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            readFloat(stream)\n          }\n        }\n      }\n\n      // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n      if (shortened) {\n        Read_unsigned_int(stream)\n      } else {\n        // else write as usual\n\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = []\n        mesh.mIndexArray = []\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = (mesh.mFaces[i] = new aiFace())\n          // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n          f.mNumIndices = Read_uint16_t(stream)\n          f.mIndices = []\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream)\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream)\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[3])\n            mesh.mIndexArray.push(f.mIndices[0])\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\")\n          }\n        }\n      }\n\n      // write bones\n      if (mesh.mNumBones) {\n        mesh.mBones = []\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone()\n          ReadBinaryBone(stream, mesh.mBones[a])\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      prop.mKey = Read_aiString(stream)\n      prop.mSemantic = Read_unsigned_int(stream)\n      prop.mIndex = Read_unsigned_int(stream)\n      prop.mDataLength = Read_unsigned_int(stream)\n      prop.mType = Read_unsigned_int(stream)\n      prop.mData = []\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength)\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream)\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties\n        }\n\n        mat.mProperties = []\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty()\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i])\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      nd.mNodeName = Read_aiString(stream)\n      nd.mNumPositionKeys = Read_unsigned_int(stream)\n      nd.mNumRotationKeys = Read_unsigned_int(stream)\n      nd.mNumScalingKeys = Read_unsigned_int(stream)\n      nd.mPreState = Read_unsigned_int(stream)\n      nd.mPostState = Read_unsigned_int(stream)\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        } else {\n          // else write as usual\n\n          nd.mPositionKeys = []\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        } else {\n          // else write as usual\n\n          nd.mRotationKeys = []\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        } else {\n          // else write as usual\n\n          nd.mScalingKeys = []\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      anim.mName = Read_aiString(stream)\n      anim.mDuration = Read_double(stream)\n      anim.mTicksPerSecond = Read_double(stream)\n      anim.mNumChannels = Read_unsigned_int(stream)\n\n      if (anim.mNumChannels) {\n        anim.mChannels = []\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim()\n          ReadBinaryNodeAnim(stream, anim.mChannels[a])\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      tex.mWidth = Read_unsigned_int(stream)\n      tex.mHeight = Read_unsigned_int(stream)\n      stream.ReadBytes(tex.achFormatHint, 1, 4)\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth)\n        } else {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4)\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      l.mName = Read_aiString(stream)\n      l.mType = Read_unsigned_int(stream)\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream)\n        l.mAttenuationLinear = readFloat(stream)\n        l.mAttenuationQuadratic = readFloat(stream)\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream)\n      l.mColorSpecular = Read_aiColor3D(stream)\n      l.mColorAmbient = Read_aiColor3D(stream)\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream)\n        l.mAngleOuterCone = readFloat(stream)\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      cam.mName = Read_aiString(stream)\n      cam.mPosition = Read_aiVector3D(stream)\n      cam.mLookAt = Read_aiVector3D(stream)\n      cam.mUp = Read_aiVector3D(stream)\n      cam.mHorizontalFOV = readFloat(stream)\n      cam.mClipPlaneNear = readFloat(stream)\n      cam.mClipPlaneFar = readFloat(stream)\n      cam.mAspect = readFloat(stream)\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      scene.mFlags = Read_unsigned_int(stream)\n      scene.mNumMeshes = Read_unsigned_int(stream)\n      scene.mNumMaterials = Read_unsigned_int(stream)\n      scene.mNumAnimations = Read_unsigned_int(stream)\n      scene.mNumTextures = Read_unsigned_int(stream)\n      scene.mNumLights = Read_unsigned_int(stream)\n      scene.mNumCameras = Read_unsigned_int(stream)\n      // Read node graph\n      scene.mRootNode = new aiNode()\n      scene.mRootNode = ReadBinaryNode(stream, null, 0)\n      // Read all meshes\n      if (scene.mNumMeshes) {\n        scene.mMeshes = []\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh()\n          ReadBinaryMesh(stream, scene.mMeshes[i])\n        }\n      }\n\n      // Read materials\n      if (scene.mNumMaterials) {\n        scene.mMaterials = []\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial()\n          ReadBinaryMaterial(stream, scene.mMaterials[i])\n        }\n      }\n\n      // Read all animations\n      if (scene.mNumAnimations) {\n        scene.mAnimations = []\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation()\n          ReadBinaryAnim(stream, scene.mAnimations[i])\n        }\n      }\n\n      // Read all textures\n      if (scene.mNumTextures) {\n        scene.mTextures = []\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture()\n          ReadBinaryTexture(stream, scene.mTextures[i])\n        }\n      }\n\n      // Read lights\n      if (scene.mNumLights) {\n        scene.mLights = []\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight()\n          ReadBinaryLight(stream, scene.mLights[i])\n        }\n      }\n\n      // Read cameras\n      if (scene.mNumCameras) {\n        scene.mCameras = []\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera()\n          ReadBinaryCamera(stream, scene.mCameras[i])\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0\n    var aiOrigin_BEG = 1\n\n    function extendStream(stream) {\n      stream.readOffset = 0\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off\n        }\n      }\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this)\n      }\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Float32Array(newbuff)\n      }\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint16Array(newbuff)\n      }\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint8Array(newbuff)\n      }\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint32Array(newbuff)\n      }\n    }\n\n    var shortened, compressed\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene()\n      var stream = new DataView(pFiledata)\n      extendStream(stream)\n      stream.Seek(44, aiOrigin_CUR) // signature\n      /*unsigned int versionMajor =*/\n      pScene.versionMajor = Read_unsigned_int(stream)\n      /*unsigned int versionMinor =*/\n      pScene.versionMinor = Read_unsigned_int(stream)\n      /*unsigned int versionRevision =*/\n      pScene.versionRevision = Read_unsigned_int(stream)\n      /*unsigned int compileFlags =*/\n      pScene.compileFlags = Read_unsigned_int(stream)\n      shortened = Read_uint16_t(stream) > 0\n      compressed = Read_uint16_t(stream) > 0\n      if (shortened) throw 'Shortened binaries are not supported!'\n      stream.Seek(256, aiOrigin_CUR) // original filename\n      stream.Seek(128, aiOrigin_CUR) // options\n      stream.Seek(64, aiOrigin_CUR) // padding\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream)\n        var compressedSize = stream.FileSize() - stream.Tell()\n        var compressedData = []\n        stream.Read(compressedData, 1, compressedSize)\n        var uncompressedData = []\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize)\n        var buff = new ArrayBuffer(uncompressedData)\n        ReadBinaryScene(buff, pScene)\n      } else {\n        ReadBinaryScene(stream, pScene)\n      }\n\n      return pScene.toTHREE()\n    }\n\n    return InternReadFile(buffer)\n  }\n}\n\nexport { AssimpLoader }\n"]},"metadata":{},"sourceType":"module"}