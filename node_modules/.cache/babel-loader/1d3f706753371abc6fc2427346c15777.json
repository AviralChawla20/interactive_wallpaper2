{"ast":null,"code":"import { Mesh, Vector3, Matrix3 } from \"three\";\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === \"object\") {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = void 0;\n    }\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        if (vertices === void 0) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== void 0) includeNormals = true;\n        if (uvs !== void 0) includeUVs = true;\n        if (colors !== void 0) includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n    includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n    includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n    includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      console.error(\"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\");\n      return null;\n    }\n    const indexByteCount = 4;\n    let header = `ply\nformat ${options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\"} 1.0\nelement vertex ${vertexCount}\nproperty float x\nproperty float y\nproperty float z\n`;\n    if (includeNormals) {\n      header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n    }\n    if (includeUVs) {\n      header += \"property float s\\nproperty float t\\n\";\n    }\n    if (includeColors) {\n      header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n    }\n    if (includeIndices) {\n      header += `${`element face ${faceCount}\n`}property list uchar int vertex_index\n`;\n    }\n    header += \"end_header\\n\";\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary) {\n      const headerBin = new TextEncoder().encode(header);\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      let writtenVertices = 0;\n      let vertexList = \"\";\n      let faceList = \"\";\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          let line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            } else {\n              line += \" 0 0 0\";\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n            } else if (includeUVs) {\n              line += \" 0 0\";\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += \" 255 255 255\";\n            }\n          }\n          vertexList += line + \"\\n\";\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\n` : \"\\n\"}`;\n    }\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone && onDone(typeof result === \"string\" ? result : \"\"));\n    }\n    return result;\n  }\n  // Iterate over the valid meshes in the object\n  traverseMeshes(object, cb) {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        if (geometry.hasAttribute(\"position\")) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n}\nexport { PLYExporter };","map":{"version":3,"sources":["../../src/exporters/PLYExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import { BufferGeometry, Matrix3, Mesh, Object3D, Vector3 } from 'three'\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nexport interface PLYExporterOptions {\n  binary?: boolean\n  excludeAttributes?: string[]\n  littleEndian?: boolean\n}\n\nclass PLYExporter {\n  public parse(\n    object: Object3D,\n    onDone: ((res: string) => void) | undefined,\n    options: PLYExporterOptions,\n  ): string | ArrayBuffer | null {\n    if (onDone && typeof onDone === 'object') {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.',\n      )\n      options = onDone\n      onDone = undefined\n    }\n\n    // Default options\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [], // normal, uv, color, index\n      littleEndian: false,\n    }\n\n    options = Object.assign(defaultOptions, options)\n\n    const excludeAttributes = options.excludeAttributes\n    let includeNormals = false\n    let includeColors = false\n    let includeUVs = false\n\n    // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n    let vertexCount = 0\n    let faceCount = 0\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        if (vertices === undefined) {\n          return\n        }\n\n        vertexCount += vertices.count\n        faceCount += indices ? indices.count / 3 : vertices.count / 3\n\n        if (normals !== undefined) includeNormals = true\n\n        if (uvs !== undefined) includeUVs = true\n\n        if (colors !== undefined) includeColors = true\n      }\n    })\n\n    const includeIndices = excludeAttributes?.indexOf('index') === -1\n    includeNormals = includeNormals && excludeAttributes?.indexOf('normal') === -1\n    includeColors = includeColors && excludeAttributes?.indexOf('color') === -1\n    includeUVs = includeUVs && excludeAttributes?.indexOf('uv') === -1\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error(\n        'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n          'number of indices is not divisible by 3.',\n      )\n\n      return null\n    }\n\n    const indexByteCount = 4\n\n    let header =\n      'ply\\n' +\n      `format ${\n        options.binary ? (options.littleEndian ? 'binary_little_endian' : 'binary_big_endian') : 'ascii'\n      } 1.0\\n` +\n      `element vertex ${vertexCount}\\n` +\n      // position\n      'property float x\\n' +\n      'property float y\\n' +\n      'property float z\\n'\n\n    if (includeNormals) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n'\n    }\n\n    if (includeUVs) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n'\n    }\n\n    if (includeColors) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n'\n    }\n\n    if (includeIndices) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`\n    }\n\n    header += 'end_header\\n'\n\n    // Generate attribute data\n    const vertex = new Vector3()\n    const normalMatrixWorld = new Matrix3()\n    let result: string | ArrayBuffer | null = null\n\n    if (options.binary) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header)\n\n      // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n      const vertexListLength =\n        vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0))\n\n      // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength))\n      new Uint8Array(output.buffer).set(headerBin, 0)\n\n      let vOffset = headerBin.length\n      let fOffset = headerBin.length + vertexListLength\n      let writtenVertices = 0\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          output.setFloat32(vOffset, vertex.x, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.y, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.z, options.littleEndian)\n          vOffset += 4\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              output.setFloat32(vOffset, vertex.x, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.y, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.z, options.littleEndian)\n              vOffset += 4\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian)\n              vOffset += 4\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255))\n              vOffset += 1\n            } else {\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n            }\n          }\n        }\n\n        if (includeIndices) {\n          // Create the face list\n\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          }\n        }\n\n        // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n        writtenVertices += vertices.count\n      })\n\n      result = output.buffer\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      let writtenVertices = 0\n      let vertexList = ''\n      let faceList = ''\n\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        // form each line\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          let line = vertex.x + ' ' + vertex.y + ' ' + vertex.z\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z\n            } else {\n              line += ' 0 0 0'\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i)\n            } else if (includeUVs) {\n              line += ' 0 0'\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              line +=\n                ' ' +\n                Math.floor(colors.getX(i) * 255) +\n                ' ' +\n                Math.floor(colors.getY(i) * 255) +\n                ' ' +\n                Math.floor(colors.getZ(i) * 255)\n            } else {\n              line += ' 255 255 255'\n            }\n          }\n\n          vertexList += line + '\\n'\n        }\n\n        // Create the face list\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3\n        }\n\n        writtenVertices += vertices.count\n      })\n\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone && onDone(typeof result === 'string' ? result : ''))\n    }\n\n    return result\n  }\n\n  // Iterate over the valid meshes in the object\n  private traverseMeshes(object: Object3D, cb: (mesh: Mesh, geometry: BufferGeometry) => void): void {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        if (geometry.hasAttribute('position')) {\n          cb(mesh, geometry)\n        }\n      }\n    })\n  }\n}\n\nexport { PLYExporter }\n"]},"metadata":{},"sourceType":"module"}