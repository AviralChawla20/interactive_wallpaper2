{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0) return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0) continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance) break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };","map":{"version":3,"sources":["../../src/math/ConvexHull.js"],"names":[],"mappings":"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","sourcesContent":["import { Line3, Plane, Triangle, Vector3 } from 'three'\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0\nconst Deleted = 1\n\nconst _v1 = new Vector3()\nconst _line3 = new Line3()\nconst _plane = new Plane()\nconst _closestPoint = new Vector3()\nconst _triangle = new Triangle()\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1\n\n    this.faces = [] // the generated faces of the convex hull\n    this.newFaces = [] // this array holds the faces that are generated within a single iteration\n\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n    this.assigned = new VertexList()\n    this.unassigned = new VertexList()\n\n    this.vertices = [] // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n\n    if (points.length >= 4) {\n      this.makeEmpty()\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]))\n      }\n\n      this.compute()\n    }\n\n    return this\n  }\n\n  setFromObject(object) {\n    const points = []\n\n    object.updateMatrixWorld(true)\n\n    object.traverse(function (node) {\n      const geometry = node.geometry\n\n      if (geometry !== undefined) {\n        const attribute = geometry.attributes.position\n\n        if (attribute !== undefined) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3()\n\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n            points.push(point)\n          }\n        }\n      }\n    })\n\n    return this.setFromPoints(points)\n  }\n\n  containsPoint(point) {\n    const faces = this.faces\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false\n    }\n\n    return true\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n    const faces = this.faces\n\n    let tNear = -Infinity\n    let tFar = Infinity\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin)\n      const vD = face.normal.dot(ray.direction)\n\n      // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null\n\n      // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0\n\n      // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue\n\n      // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        // plane faces away from the ray, so this plane is a back-face\n\n        tFar = Math.min(t, tFar)\n      } else {\n        // front-face\n\n        tNear = Math.max(t, tNear)\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n\n        return null\n      }\n    }\n\n    // evaluate intersection point\n\n    // always try tNear first since its the closer intersection point\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target)\n    } else {\n      ray.at(tFar, target)\n    }\n\n    return target\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null\n  }\n\n  makeEmpty() {\n    this.faces = []\n    this.vertices = []\n\n    return this\n  }\n\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face\n\n    if (face.outside === null) {\n      this.assigned.append(vertex)\n    } else {\n      this.assigned.insertBefore(face.outside, vertex)\n    }\n\n    face.outside = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null\n      }\n    }\n\n    this.assigned.remove(vertex)\n\n    return this\n  }\n\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside\n      let end = face.outside\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next\n      }\n\n      this.assigned.removeSubList(start, end)\n\n      // fix references\n\n      start.prev = end.next = null\n      face.outside = null\n\n      return start\n    }\n  }\n\n  // Removes all the visible vertices that 'face' is able to see\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face)\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices)\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next\n\n          const distance = absorbingFace.distanceToPoint(vertex.point)\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace)\n          } else {\n            this.unassigned.append(vertex)\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex\n        } while (vertex !== null)\n      }\n    }\n\n    return this\n  }\n\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first()\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n\n        const nextVertex = vertex.next\n\n        let maxDistance = this.tolerance\n\n        let maxFace = null\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i]\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = face\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n\n        vertex = nextVertex\n      } while (vertex !== null)\n    }\n\n    return this\n  }\n\n  // Computes the extremes of a simplex which will be the initial hull\n\n  computeExtremes() {\n    const min = new Vector3()\n    const max = new Vector3()\n\n    const minVertices = []\n    const maxVertices = []\n\n    // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0]\n    }\n\n    min.copy(this.vertices[0].point)\n    max.copy(this.vertices[0].point)\n\n    // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i]\n      const point = vertex.point\n\n      // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j))\n          minVertices[j] = vertex\n        }\n      }\n\n      // update the max coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j))\n          maxVertices[j] = vertex\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance =\n      3 *\n      Number.EPSILON *\n      (Math.max(Math.abs(min.x), Math.abs(max.x)) +\n        Math.max(Math.abs(min.y), Math.abs(max.y)) +\n        Math.max(Math.abs(min.z), Math.abs(max.z)))\n\n    return { min: minVertices, max: maxVertices }\n  }\n\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n  computeInitialHull() {\n    const vertices = this.vertices\n    const extremes = this.computeExtremes()\n    const min = extremes.min\n    const max = extremes.max\n\n    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0\n    let index = 0\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i)\n\n      if (distance > maxDistance) {\n        maxDistance = distance\n        index = i\n      }\n    }\n\n    const v0 = min[index]\n    const v1 = max[index]\n    let v2\n    let v3\n\n    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0\n    _line3.set(v0.point, v1.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint)\n\n        const distance = _closestPoint.distanceToSquared(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v2 = vertex\n        }\n      }\n    }\n\n    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n    maxDistance = -1\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point))\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v3 = vertex\n        }\n      }\n    }\n\n    const faces = []\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j))\n\n        // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0))\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3))\n\n        // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1))\n      }\n    }\n\n    // the initial hull is the tetrahedron\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i])\n    }\n\n    // initial assignment of vertices to the faces of the tetrahedron\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance\n        let maxFace = null\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point)\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            maxFace = this.faces[j]\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n      }\n    }\n\n    return this\n  }\n\n  // Removes inactive faces\n\n  reindexFaces() {\n    const activeFaces = []\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      if (face.mark === Visible) {\n        activeFaces.push(face)\n      }\n    }\n\n    this.faces = activeFaces\n\n    return this\n  }\n\n  // Finds the next vertex to create faces with the current hull\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0\n\n      // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face\n      let vertex = eyeFace.outside\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          eyeVertex = vertex\n        }\n\n        vertex = vertex.next\n      } while (vertex !== null && vertex.face === eyeFace)\n\n      return eyeVertex\n    }\n  }\n\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this.deleteFaceVertices(face)\n\n    face.mark = Deleted\n\n    let edge\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0)\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next\n    }\n\n    do {\n      const twinEdge = edge.twin\n      const oppositeFace = twinEdge.face\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon)\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge)\n        }\n      }\n\n      edge = edge.next\n    } while (edge !== crossEdge)\n\n    return this\n  }\n\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head())\n\n    this.faces.push(face)\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin)\n\n    return face.getEdge(0) // the half edge whose vertex is the eyeVertex\n  }\n\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = []\n\n    let firstSideEdge = null\n    let previousSideEdge = null\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]\n\n      // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge)\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge)\n      }\n\n      this.newFaces.push(sideEdge.face)\n      previousSideEdge = sideEdge\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge)\n\n    return this\n  }\n\n  // Adds a vertex to the hull\n\n  addVertexToHull(eyeVertex) {\n    const horizon = []\n\n    this.unassigned.clear()\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face)\n\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon)\n\n    this.addNewFaces(eyeVertex, horizon)\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces)\n\n    return this\n  }\n\n  cleanup() {\n    this.assigned.clear()\n    this.unassigned.clear()\n    this.newFaces = []\n\n    return this\n  }\n\n  compute() {\n    let vertex\n\n    this.computeInitialHull()\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex)\n    }\n\n    this.reindexFaces()\n\n    this.cleanup()\n\n    return this\n  }\n}\n\n//\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3()\n    this.midpoint = new Vector3()\n    this.area = 0\n\n    this.constant = 0 // signed distance from face to the origin\n    this.outside = null // reference to a vertex in a vertex list this face can see\n    this.mark = Visible\n    this.edge = null\n  }\n\n  static create(a, b, c) {\n    const face = new Face()\n\n    const e0 = new HalfEdge(a, face)\n    const e1 = new HalfEdge(b, face)\n    const e2 = new HalfEdge(c, face)\n\n    // join edges\n\n    e0.next = e2.prev = e1\n    e1.next = e0.prev = e2\n    e2.next = e1.prev = e0\n\n    // main half edge reference\n\n    face.edge = e0\n\n    return face.compute()\n  }\n\n  getEdge(i) {\n    let edge = this.edge\n\n    while (i > 0) {\n      edge = edge.next\n      i--\n    }\n\n    while (i < 0) {\n      edge = edge.prev\n      i++\n    }\n\n    return edge\n  }\n\n  compute() {\n    const a = this.edge.tail()\n    const b = this.edge.head()\n    const c = this.edge.next.head()\n\n    _triangle.set(a.point, b.point, c.point)\n\n    _triangle.getNormal(this.normal)\n    _triangle.getMidpoint(this.midpoint)\n    this.area = _triangle.getArea()\n\n    this.constant = this.normal.dot(this.midpoint)\n\n    return this\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant\n  }\n}\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex\n    this.prev = null\n    this.next = null\n    this.twin = null\n    this.face = face\n  }\n\n  head() {\n    return this.vertex\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null\n  }\n\n  length() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point)\n    }\n\n    return -1\n  }\n\n  lengthSquared() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point)\n    }\n\n    return -1\n  }\n\n  setTwin(edge) {\n    this.twin = edge\n    edge.twin = this\n\n    return this\n  }\n}\n\n// A vertex as a double linked list node.\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point\n    this.prev = null\n    this.next = null\n    this.face = null // the face that is able to see this vertex\n  }\n}\n\n// A double linked list that contains vertex nodes.\n\nclass VertexList {\n  constructor() {\n    this.head = null\n    this.tail = null\n  }\n\n  first() {\n    return this.head\n  }\n\n  last() {\n    return this.tail\n  }\n\n  clear() {\n    this.head = this.tail = null\n\n    return this\n  }\n\n  // Inserts a vertex before the target vertex\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev\n    vertex.next = target\n\n    if (vertex.prev === null) {\n      this.head = vertex\n    } else {\n      vertex.prev.next = vertex\n    }\n\n    target.prev = vertex\n\n    return this\n  }\n\n  // Inserts a vertex after the target vertex\n\n  insertAfter(target, vertex) {\n    vertex.prev = target\n    vertex.next = target.next\n\n    if (vertex.next === null) {\n      this.tail = vertex\n    } else {\n      vertex.next.prev = vertex\n    }\n\n    target.next = vertex\n\n    return this\n  }\n\n  // Appends a vertex to the end of the linked list\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n    vertex.next = null // the tail has no subsequent vertex\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Appends a chain of vertices where 'vertex' is the head.\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next\n    }\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the linked list\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next\n    } else {\n      vertex.prev.next = vertex.next\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev\n    } else {\n      vertex.next.prev = vertex.prev\n    }\n\n    return this\n  }\n\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next\n    } else {\n      a.prev.next = b.next\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev\n    } else {\n      b.next.prev = a.prev\n    }\n\n    return this\n  }\n\n  isEmpty() {\n    return this.head === null\n  }\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList }\n"]},"metadata":{},"sourceType":"module"}