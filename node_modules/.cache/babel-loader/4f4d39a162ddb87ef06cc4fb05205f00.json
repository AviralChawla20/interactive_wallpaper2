{"ast":null,"code":"import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from \"three\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: (/* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `),\n      fragmentShader: (/* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `)\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */new Set();\n  const hardEdgeRays = /* @__PURE__ */new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport { LDrawLoader };","map":{"version":3,"sources":["../../src/loaders/LDrawLoader.js"],"names":["info","i","l","fileName","subobject","group"],"mappings":"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","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Matrix4,\n  Mesh,\n  MeshStandardMaterial,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Ray,\n  REVISION,\n} from 'three'\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0\nconst FINISH_TYPE_CHROME = 1\nconst FINISH_TYPE_PEARLESCENT = 2\nconst FINISH_TYPE_RUBBER = 3\nconst FINISH_TYPE_MATTE_METALLIC = 4\nconst FINISH_TYPE_METAL = 5\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0\nconst FILE_LOCATION_TRY_PARTS = 1\nconst FILE_LOCATION_TRY_P = 2\nconst FILE_LOCATION_TRY_MODELS = 3\nconst FILE_LOCATION_TRY_RELATIVE = 4\nconst FILE_LOCATION_TRY_ABSOLUTE = 5\nconst FILE_LOCATION_NOT_FOUND = 6\n\nconst MAIN_COLOUR_CODE = '16'\nconst MAIN_EDGE_COLOUR_CODE = '24'\n\nconst _tempVec0 = new Vector3()\nconst _tempVec1 = new Vector3()\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color(),\n          },\n          opacity: {\n            value: 1.0,\n          },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n\n      fragmentShader: /* glsl */ `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `,\n    })\n\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n      },\n    })\n\n    this.setValues(parameters)\n    this.isLDrawConditionalLineMaterial = true\n  }\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material)\n    this.isConditionalLine = true\n  }\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i]\n    const vertices = face.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    const v2 = vertices[2]\n\n    _tempVec0.subVectors(v1, v0)\n    _tempVec1.subVectors(v2, v1)\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n  }\n}\n\nconst _ray = new Ray()\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n  const hashMultiplier = (1 + 1e-10) * 1e2\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n\n    return `${x},${y},${z}`\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`\n  }\n\n  // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize()\n\n    const scalar = v0.dot(targetRay.direction)\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar)\n\n    return targetRay\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction)\n  }\n\n  const hardEdges = new Set()\n  const hardEdgeRays = new Map()\n  const halfEdgeList = {}\n  const normals = []\n\n  // Save the list of hard edges by hash\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i]\n    const vertices = ls.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    hardEdges.add(hashEdge(v0, v1))\n    hardEdges.add(hashEdge(v1, v0))\n\n    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray())\n      const rh1 = hashRay(ray)\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray)\n        const rh2 = hashRay(ray)\n\n        const info = {\n          ray,\n          distances: [],\n        }\n\n        hardEdgeRays.set(rh1, info)\n        hardEdgeRays.set(rh2, info)\n      }\n\n      // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n      const info = hardEdgeRays.get(rh1)\n      let d0 = info.ray.direction.dot(v0)\n      let d1 = info.ray.direction.dot(v1)\n      if (d0 > d1) {\n        ;[d0, d1] = [d1, d0]\n      }\n\n      info.distances.push(d0, d1)\n    }\n  }\n\n  // track the half edges associated with each triangle\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i]\n    const vertices = tri.vertices\n    const vertCount = vertices.length\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2\n      const next = (i2 + 1) % vertCount\n      const v0 = vertices[index]\n      const v1 = vertices[next]\n      const hash = hashEdge(v0, v1)\n\n      // don't add the triangle if the edge is supposed to be hard\n      if (hardEdges.has(hash)) {\n        continue\n      }\n\n      // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray)\n\n        const rayHash = hashRay(_ray)\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash)\n          const { ray, distances } = info\n          let d0 = ray.direction.dot(v0)\n          let d1 = ray.direction.dot(v1)\n\n          if (d0 > d1) {\n            ;[d0, d1] = [d1, d0]\n          }\n\n          // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n          let found = false\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true\n              break\n            }\n          }\n\n          if (found) {\n            continue\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri,\n      }\n      halfEdgeList[hash] = info\n    }\n  }\n\n  // Iterate until we've tried to connect all faces to share normals\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key]\n      break\n    }\n\n    if (halfEdge === null) {\n      break\n    }\n\n    // Exhaustively find all connected faces\n    const queue = [halfEdge]\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri\n      const vertices = tri.vertices\n      const vertNormals = tri.normals\n      const faceNormal = tri.faceNormal\n\n      // Check if any edge is connected to another triangle edge\n      const vertCount = vertices.length\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2\n        const next = (i2 + 1) % vertCount\n        const v0 = vertices[index]\n        const v1 = vertices[next]\n\n        // delete this triangle from the list so it won't be found again\n        const hash = hashEdge(v0, v1)\n        delete halfEdgeList[hash]\n\n        const reverseHash = hashEdge(v1, v0)\n        const otherInfo = halfEdgeList[reverseHash]\n        if (otherInfo) {\n          const otherTri = otherInfo.tri\n          const otherIndex = otherInfo.index\n          const otherNormals = otherTri.normals\n          const otherVertCount = otherNormals.length\n          const otherFaceNormal = otherTri.faceNormal\n\n          // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue\n          }\n\n          // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo)\n            delete halfEdgeList[reverseHash]\n          }\n\n          // share the first normal\n          const otherNext = (otherIndex + 1) % otherVertCount\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm)\n            vertNormals[index].norm = otherNormals[otherNext].norm\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext]\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = { norm: new Vector3() }\n            normals.push(sharedNormal1.norm)\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1\n            sharedNormal1.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1\n            sharedNormal1.norm.add(otherFaceNormal)\n          }\n\n          // share the second normal\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm)\n            vertNormals[next].norm = otherNormals[otherIndex].norm\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex]\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() }\n            normals.push(sharedNormal2.norm)\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2\n            sharedNormal2.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2\n            sharedNormal2.norm.add(otherFaceNormal)\n          }\n        }\n      }\n    }\n  }\n\n  // The normals of each face have been added up so now we average them by normalizing the vector.\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize()\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part'\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart'\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line\n    this.lineLength = line.length\n    this.currentCharIndex = 0\n    this.currentChar = ' '\n    this.lineNumber = lineNumber\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return\n      }\n\n      this.currentCharIndex++\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++\n\n    // Seek space\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break\n      }\n\n      this.currentCharIndex++\n    }\n\n    const pos1 = this.currentCharIndex\n\n    this.seekNonSpace()\n\n    return this.line.substring(pos0, pos1)\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()))\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength)\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : ''\n  }\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader\n    this._cache = {}\n  }\n\n  cloneResult(original) {\n    const result = {}\n\n    // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null,\n      }\n    })\n\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone()),\n      }\n    })\n\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n      }\n    })\n\n    // none if this is subsequently modified\n    result.type = original.type\n    result.category = original.category\n    result.keywords = original.keywords\n    result.subobjects = original.subobjects\n    result.totalFaces = original.totalFaces\n    result.startingConstructionStep = original.startingConstructionStep\n    result.materials = original.materials\n    result.group = null\n    return result\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false\n    let locationState = FILE_LOCATION_AS_IS\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase()\n            subobjectURL = fileName\n            triedLowerCase = true\n            locationState = FILE_LOCATION_AS_IS\n          }\n\n          break\n      }\n\n      const loader = this.loader\n      const fileLoader = new FileLoader(loader.manager)\n      fileLoader.setPath(loader.partsLibraryPath)\n      fileLoader.setRequestHeader(loader.requestHeader)\n      fileLoader.setWithCredentials(loader.withCredentials)\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL)\n        return text\n      } catch {\n        continue\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.')\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader\n\n    // final results\n    const faces = []\n    const lineSegments = []\n    const conditionalSegments = []\n    const subobjects = []\n    const materials = {}\n\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null\n    }\n\n    let type = 'Model'\n    let category = null\n    let keywords = null\n    let totalFaces = 0\n\n    // split into lines\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    const lines = text.split('\\n')\n    const numLines = lines.length\n\n    let parsingEmbeddedFiles = false\n    let currentEmbeddedFileName = null\n    let currentEmbeddedText = null\n\n    let bfcCertified = false\n    let bfcCCW = true\n    let bfcInverted = false\n    let bfcCull = true\n\n    let startingConstructionStep = false\n\n    // Parse all line commands\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex]\n\n      if (line.length === 0) continue\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText)\n\n          // New embedded text file\n          currentEmbeddedFileName = line.substring(7)\n          currentEmbeddedText = ''\n        } else {\n          currentEmbeddedText += line + '\\n'\n        }\n\n        continue\n      }\n\n      const lp = new LineParser(line, lineIndex + 1)\n      lp.seekNonSpace()\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue\n      }\n\n      // Parse the line type\n      const lineType = lp.getToken()\n\n      let material\n      let colorCode\n      let segment\n      let ccw\n      let doubleSided\n      let v0, v1, v2, v3, c0, c1\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken()\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken()\n                break\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp)\n                if (material) {\n                  materials[material.userData.code] = material\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString())\n                }\n\n                break\n\n              case '!CATEGORY':\n                category = lp.getToken()\n                break\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',')\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = []\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim())\n                  })\n                }\n\n                break\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true\n                  currentEmbeddedFileName = lp.getRemainingString()\n                  currentEmbeddedText = ''\n\n                  bfcCertified = false\n                  bfcCCW = true\n                }\n\n                break\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken()\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY'\n                      bfcCCW = true\n\n                      break\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW'\n\n                      break\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true\n\n                      break\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP'\n\n                      break\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.')\n\n                      break\n                  }\n                }\n\n                break\n\n              case 'STEP':\n                startingConstructionStep = true\n\n                break\n\n              default:\n                // Other meta directives are not implemented\n                break\n            }\n          }\n\n          break\n\n        // Line type 1: Sub-object file\n        case '1':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n\n          const posX = parseFloat(lp.getToken())\n          const posY = parseFloat(lp.getToken())\n          const posZ = parseFloat(lp.getToken())\n          const m0 = parseFloat(lp.getToken())\n          const m1 = parseFloat(lp.getToken())\n          const m2 = parseFloat(lp.getToken())\n          const m3 = parseFloat(lp.getToken())\n          const m4 = parseFloat(lp.getToken())\n          const m5 = parseFloat(lp.getToken())\n          const m6 = parseFloat(lp.getToken())\n          const m7 = parseFloat(lp.getToken())\n          const m8 = parseFloat(lp.getToken())\n\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1)\n\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/')\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName]\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep,\n          })\n\n          bfcInverted = false\n\n          break\n\n        // Line type 2: Line segment\n        case '2':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n          }\n\n          lineSegments.push(segment)\n\n          break\n\n        // Line type 5: Conditional Line segment\n        case '5':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n          c0 = lp.getVector()\n          c1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1],\n          }\n\n          conditionalSegments.push(segment)\n\n          break\n\n        // Line type 3: Triangle\n        case '3':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n          } else {\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null],\n          })\n          totalFaces++\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null],\n            })\n            totalFaces++\n          }\n\n          break\n\n        // Line type 4: Quadrilateral\n        case '4':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n            v3 = lp.getVector()\n          } else {\n            v3 = lp.getVector()\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null],\n          })\n          totalFaces += 2\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null],\n            })\n            totalFaces += 2\n          }\n\n          break\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.')\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText)\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null,\n    }\n  }\n\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase()\n    const result = this._cache[key]\n    if (result === null || result instanceof Promise) {\n      return null\n    }\n\n    if (clone) {\n      return this.cloneResult(result)\n    } else {\n      return result\n    }\n  }\n\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase()\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName)\n        this._cache[key] = info\n        return info\n      })\n    }\n\n    await this._cache[key]\n  }\n\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase()\n    this._cache[key] = this.parse(text, fileName)\n  }\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n  if (isPassthrough) {\n    colorCode = parentColorCode\n  }\n\n  return materialHierarchy[colorCode] || null\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader\n    this.parseCache = new LDrawParsedCache(loader)\n    this._cache = {}\n  }\n\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader\n    const parseCache = this.parseCache\n    const faceMaterials = new Set()\n\n    // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects\n      const promises = []\n\n      // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i]\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false)\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch((error) => {\n              console.warn(error)\n              return null\n            })\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject)\n        })\n\n        promises.push(promise)\n      }\n\n      const group = new Group()\n      group.userData.category = info.category\n      group.userData.keywords = info.keywords\n      info.group = group\n\n      const subobjectInfos = await Promise.all(promises)\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i]\n        const subobjectInfo = subobjectInfos[i]\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue\n        }\n\n        // if the subobject was loaded as a separate group then apply the parent scopes materials\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale)\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep\n          subobjectGroup.name = subobject.fileName\n\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials)\n\n          group.add(subobjectGroup)\n          continue\n        }\n\n        // add the subobject group if it has children in case it has both children and primitives\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group)\n        }\n\n        // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n        const parentLineSegments = info.lineSegments\n        const parentConditionalSegments = info.conditionalSegments\n        const parentFaces = info.faces\n\n        const lineSegments = subobjectInfo.lineSegments\n        const conditionalSegments = subobjectInfo.conditionalSegments\n\n        const faces = subobjectInfo.faces\n        const matrix = subobject.matrix\n        const inverted = subobject.inverted\n        const matrixScaleInverted = matrix.determinant() < 0\n        const colorCode = subobject.colorCode\n\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i]\n          const vertices = ls.vertices\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true)\n\n          parentLineSegments.push(ls)\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i]\n          const vertices = os.vertices\n          const controlPoints = os.controlPoints\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          controlPoints[0].applyMatrix4(matrix)\n          controlPoints[1].applyMatrix4(matrix)\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true)\n\n          parentConditionalSegments.push(os)\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i]\n          const vertices = tri.vertices\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix)\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false)\n          faceMaterials.add(tri.colorCode)\n\n          // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse()\n          }\n\n          parentFaces.push(tri)\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces\n      }\n\n      // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials)\n      }\n\n      return info\n    }\n\n    // Track material use to see if we need to use the normal smooth slow path for hard edges.\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode)\n    }\n\n    await processInfoSubobjects(info)\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1\n      generateFaceNormals(info.faces)\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments)\n    }\n\n    // Add the primitive objects and metadata.\n    const group = info.group\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces))\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2))\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true))\n    }\n\n    return group\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase()\n      const group = await this._cache[key]\n      return group.clone()\n    } else {\n      return null\n    }\n  }\n\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache\n    const key = fileName.toLowerCase()\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName)\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName)\n\n      const info = parseCache.getData(fileName)\n      const promise = this.processIntoMesh(info)\n\n      // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName)\n      }\n\n      // Cache object if it's a part so it can be reused later.\n      if (isPartType(info.type)) {\n        this._cache[key] = promise\n      }\n\n      // return a copy\n      const group = await promise\n      return group.clone()\n    }\n  }\n\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache\n    const info = parseCache.parse(text)\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName)\n    }\n\n    return this.processIntoMesh(info)\n  }\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1\n  }\n\n  return 1\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial)\n\n  if (totalElements === null) {\n    totalElements = elements.length\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3)\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null\n  const materials = []\n\n  const quadArray = new Array(6)\n  const bufferGeometry = new BufferGeometry()\n  let prevMaterial = null\n  let index0 = 0\n  let numGroupVerts = 0\n  let offset = 0\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem]\n    let vertices = elem.vertices\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0]\n      quadArray[1] = vertices[1]\n      quadArray[2] = vertices[2]\n      quadArray[3] = vertices[0]\n      quadArray[4] = vertices[2]\n      quadArray[5] = vertices[3]\n      vertices = quadArray\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j]\n      const index = offset + j * 3\n      positions[index + 0] = v.x\n      positions[index + 1] = v.y\n      positions[index + 2] = v.z\n    }\n\n    // create the normals array if this is a set of faces\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0]\n        const v1 = vertices[1]\n        const v2 = vertices[2]\n        _tempVec0.subVectors(v1, v0)\n        _tempVec1.subVectors(v2, v1)\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n      }\n\n      let elemNormals = elem.normals\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0]\n        quadArray[1] = elemNormals[1]\n        quadArray[2] = elemNormals[2]\n        quadArray[3] = elemNormals[0]\n        quadArray[4] = elemNormals[2]\n        quadArray[5] = elemNormals[3]\n        elemNormals = quadArray\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm\n        }\n\n        const index = offset + j * 3\n        normals[index + 0] = n.x\n        normals[index + 1] = n.y\n        normals[index + 2] = n.z\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1)\n      }\n\n      const material = elem.material\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material)\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial)\n            } else {\n              materials.push(material.userData.edgeMaterial)\n            }\n          } else {\n            materials.push(null)\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode)\n      }\n\n      prevMaterial = elem.colorCode\n      index0 = offset / 3\n      numGroupVerts = vertices.length\n    } else {\n      numGroupVerts += vertices.length\n    }\n\n    offset += 3 * vertices.length\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1)\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3))\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3))\n  }\n\n  let object3d = null\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true\n\n    const controlArray0 = new Float32Array(elements.length * 3 * 2)\n    const controlArray1 = new Float32Array(elements.length * 3 * 2)\n    const directionArray = new Float32Array(elements.length * 3 * 2)\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i]\n      const vertices = os.vertices\n      const controlPoints = os.controlPoints\n      const c0 = controlPoints[0]\n      const c1 = controlPoints[1]\n      const v0 = vertices[0]\n      const v1 = vertices[1]\n      const index = i * 3 * 2\n      controlArray0[index + 0] = c0.x\n      controlArray0[index + 1] = c0.y\n      controlArray0[index + 2] = c0.z\n      controlArray0[index + 3] = c0.x\n      controlArray0[index + 4] = c0.y\n      controlArray0[index + 5] = c0.z\n\n      controlArray1[index + 0] = c1.x\n      controlArray1[index + 1] = c1.y\n      controlArray1[index + 2] = c1.z\n      controlArray1[index + 3] = c1.x\n      controlArray1[index + 4] = c1.y\n      controlArray1[index + 5] = c1.z\n\n      directionArray[index + 0] = v1.x - v0.x\n      directionArray[index + 1] = v1.y - v0.y\n      directionArray[index + 2] = v1.z - v0.z\n      directionArray[index + 3] = v1.x - v0.x\n      directionArray[index + 4] = v1.y - v0.y\n      directionArray[index + 5] = v1.z - v0.z\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false))\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false))\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false))\n  }\n\n  return object3d\n}\n\n//\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Array of THREE.Material\n    this.materials = []\n    this.materialLibrary = {}\n\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n    this.partsCache = new LDrawPartsGeometryCache(this)\n\n    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n    this.fileMap = {}\n\n    // Initializes the materials library with default materials\n    this.setMaterials([])\n\n    // If this flag is set to true the vertex normals will be smoothed.\n    this.smoothNormals = true\n\n    // The path to load parts from the LDraw parts library from.\n    this.partsLibraryPath = ''\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path\n    return this\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n\n    const text = await fileLoader.loadAsync(url)\n    const colorLineRegex = /^0 !COLOUR/\n    const lines = text.split(/[\\n\\r]/g)\n    const materials = []\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '')\n        const material = this.parseColorMetaDirective(new LineParser(directive))\n        materials.push(material)\n      }\n    }\n\n    this.setMaterials(materials)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache\n          .parseModel(text, this.materialLibrary)\n          .then((group) => {\n            this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true)\n            this.computeConstructionSteps(group)\n            onLoad(group)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group)\n      onLoad(group)\n    })\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {}\n    this.materials = []\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i])\n    }\n\n    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')))\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')))\n\n    return this\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap\n\n    return this\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n    const matLib = this.materialLibrary\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material)\n      matLib[material.userData.code] = material\n    }\n\n    return this\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3)\n\n      return this.parseColorMetaDirective(\n        new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''),\n      )\n    }\n\n    return this.materialLibrary[colorCode] || null\n  }\n\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i])\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material)\n        }\n      }\n    })\n\n    // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine\n      const isPassthrough =\n        (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n      if (isPassthrough) {\n        colorCode = parentColorCode\n      }\n\n      let material = null\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode]\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode)\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`)\n        }\n      } else {\n        return colorCode\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial\n        }\n      }\n\n      return material\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE)\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE)\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n\n    let code = null\n\n    // Triangle and line colors\n    let color = 0xff00ff\n    let edgeColor = 0xff00ff\n\n    // Transparency\n    let alpha = 1\n    let isTransparent = false\n    // Self-illumination:\n    let luminance = 0\n\n    let finishType = FINISH_TYPE_DEFAULT\n\n    let edgeMaterial = null\n\n    const name = lineParser.getToken()\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.',\n      )\n    }\n\n    // Parse tag tokens and their parameters\n    let token = null\n    while (true) {\n      token = lineParser.getToken()\n\n      if (!token) {\n        break\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken()\n          break\n\n        case 'VALUE':\n          color = lineParser.getToken()\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2)\n          } else if (!color.startsWith('#')) {\n            throw new Error(\n              'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          break\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken()\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2)\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor)\n            if (!edgeMaterial) {\n              throw new Error(\n                'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.',\n              )\n            }\n\n            // Get the edge material for this triangle material\n            edgeMaterial = edgeMaterial.userData.edgeMaterial\n          }\n\n          break\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken())\n\n          if (isNaN(alpha)) {\n            throw new Error(\n              'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255))\n\n          if (alpha < 1) {\n            isTransparent = true\n          }\n\n          break\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken())\n\n          if (isNaN(luminance)) {\n            throw new Error(\n              'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.',\n            )\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255))\n\n          break\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME\n          break\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT\n          break\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER\n          break\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC\n          break\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL\n          break\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd()\n          break\n\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' +\n              token +\n              '\" while parsing material' +\n              lineParser.getLineNumberString() +\n              '.',\n          )\n      }\n    }\n\n    let material = null\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0 })\n        break\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.25 })\n        break\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({ color: color, roughness: 0, metalness: 1 })\n        break\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0 })\n        break\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.4 })\n        break\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.85 })\n        break\n\n      default:\n        // Should not happen\n        break\n    }\n\n    material.transparent = isTransparent\n    material.premultipliedAlpha = true\n    material.opacity = alpha\n    material.depthWrite = !isTransparent\n\n    material.polygonOffset = true\n    material.polygonOffsetFactor = 1\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance)\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent,\n      })\n      edgeMaterial.userData.code = code\n      edgeMaterial.name = name + ' - Edge'\n\n      // This is the material used for conditional edges\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha,\n      })\n    }\n\n    material.userData.code = code\n    material.name = name\n\n    material.userData.edgeMaterial = edgeMaterial\n\n    this.addMaterial(material)\n\n    return material\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n    let stepNumber = 0\n\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++\n        }\n\n        c.userData.constructionStep = stepNumber\n      }\n    })\n\n    model.userData.numConstructionSteps = stepNumber + 1\n  }\n}\n\nexport { LDrawLoader }\n"]},"metadata":{},"sourceType":"module"}