{"ast":null,"code":"import { Vector3, Matrix3, LineSegments, BufferGeometry, Float32BufferAttribute, LineBasicMaterial } from \"three\";\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _normalMatrix = new Matrix3();\nclass VertexNormalsHelper extends LineSegments {\n  constructor(object, size = 1, color = 16711680) {\n    const geometry = new BufferGeometry();\n    const nNormals = object.geometry.attributes.normal.count;\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n    geometry.setAttribute(\"position\", positions);\n    super(geometry, new LineBasicMaterial({\n      color,\n      toneMapped: false\n    }));\n    this.object = object;\n    this.size = size;\n    this.type = \"VertexNormalsHelper\";\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n  update() {\n    this.object.updateMatrixWorld(true);\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n    const matrixWorld = this.object.matrixWorld;\n    const position = this.geometry.attributes.position;\n    const objGeometry = this.object.geometry;\n    if (objGeometry) {\n      const objPos = objGeometry.attributes.position;\n      const objNorm = objGeometry.attributes.normal;\n      let idx = 0;\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\n        _v1.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld);\n        _v2.fromBufferAttribute(objNorm, j);\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n        idx = idx + 1;\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n        idx = idx + 1;\n      }\n    }\n    position.needsUpdate = true;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nexport { VertexNormalsHelper };","map":{"version":3,"sources":["../../src/helpers/VertexNormalsHelper.js"],"names":[],"mappings":";AAEA,MAAM,GAAA,GAAM,IAAI,OAAA,CAAS,CAAA;AACzB,MAAM,GAAA,GAAM,IAAI,OAAA,CAAS,CAAA;AACzB,MAAM,aAAA,GAAgB,IAAI,OAAA,CAAS,CAAA;AAEnC,MAAM,mBAAA,SAA4B,YAAA,CAAa;EAC7C,WAAA,CAAY,MAAA,EAAQ,IAAA,GAAO,CAAA,EAAG,KAAA,GAAQ,QAAA,EAAU;IAC9C,MAAM,QAAA,GAAW,IAAI,cAAA,CAAgB,CAAA;IAErC,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA,CAAS,UAAA,CAAW,MAAA,CAAO,KAAA;IACnD,MAAM,SAAA,GAAY,IAAI,sBAAA,CAAuB,QAAA,GAAW,CAAA,GAAI,CAAA,EAAG,CAAC,CAAA;IAEhE,QAAA,CAAS,YAAA,CAAa,UAAA,EAAY,SAAS,CAAA;IAE3C,KAAA,CAAM,QAAA,EAAU,IAAI,iBAAA,CAAkB;MAAE,KAAA;MAAO,UAAA,EAAY;IAAK,CAAE,CAAC,CAAA;IAEnE,IAAA,CAAK,MAAA,GAAS,MAAA;IACd,IAAA,CAAK,IAAA,GAAO,IAAA;IACZ,IAAA,CAAK,IAAA,GAAO,qBAAA;IAIZ,IAAA,CAAK,gBAAA,GAAmB,KAAA;IAExB,IAAA,CAAK,MAAA,CAAQ,CAAA;EACd;EAED,MAAA,CAAA,EAAS;IACP,IAAA,CAAK,MAAA,CAAO,iBAAA,CAAkB,IAAI,CAAA;IAElC,aAAA,CAAc,eAAA,CAAgB,IAAA,CAAK,MAAA,CAAO,WAAW,CAAA;IAErD,MAAM,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,WAAA;IAEhC,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA,CAAS,UAAA,CAAW,QAAA;IAI1C,MAAM,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,QAAA;IAEhC,IAAI,WAAA,EAAa;MACf,MAAM,MAAA,GAAS,WAAA,CAAY,UAAA,CAAW,QAAA;MAEtC,MAAM,OAAA,GAAU,WAAA,CAAY,UAAA,CAAW,MAAA;MAEvC,IAAI,GAAA,GAAM,CAAA;MAIV,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,KAAA,EAAO,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC9C,GAAA,CAAI,mBAAA,CAAoB,MAAA,EAAQ,CAAC,CAAA,CAAE,YAAA,CAAa,WAAW,CAAA;QAE3D,GAAA,CAAI,mBAAA,CAAoB,OAAA,EAAS,CAAC,CAAA;QAElC,GAAA,CAAI,YAAA,CAAa,aAAa,CAAA,CAAE,SAAA,CAAW,CAAA,CAAC,cAAA,CAAe,IAAA,CAAK,IAAI,CAAA,CAAE,GAAA,CAAI,GAAG,CAAA;QAE7E,QAAA,CAAS,MAAA,CAAO,GAAA,EAAK,GAAA,CAAI,CAAA,EAAG,GAAA,CAAI,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA;QAExC,GAAA,GAAM,GAAA,GAAM,CAAA;QAEZ,QAAA,CAAS,MAAA,CAAO,GAAA,EAAK,GAAA,CAAI,CAAA,EAAG,GAAA,CAAI,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA;QAExC,GAAA,GAAM,GAAA,GAAM,CAAA;MACb;IACF;IAED,QAAA,CAAS,WAAA,GAAc,IAAA;EACxB;EAED,OAAA,CAAA,EAAU;IACR,IAAA,CAAK,QAAA,CAAS,OAAA,CAAS,CAAA;IACvB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAS,CAAA;EACxB;AACH","sourcesContent":["import { BufferGeometry, Float32BufferAttribute, LineSegments, LineBasicMaterial, Matrix3, Vector3 } from 'three'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _normalMatrix = new Matrix3()\n\nclass VertexNormalsHelper extends LineSegments {\n  constructor(object, size = 1, color = 0xff0000) {\n    const geometry = new BufferGeometry()\n\n    const nNormals = object.geometry.attributes.normal.count\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3)\n\n    geometry.setAttribute('position', positions)\n\n    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))\n\n    this.object = object\n    this.size = size\n    this.type = 'VertexNormalsHelper'\n\n    //\n\n    this.matrixAutoUpdate = false\n\n    this.update()\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true)\n\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld)\n\n    const matrixWorld = this.object.matrixWorld\n\n    const position = this.geometry.attributes.position\n\n    //\n\n    const objGeometry = this.object.geometry\n\n    if (objGeometry) {\n      const objPos = objGeometry.attributes.position\n\n      const objNorm = objGeometry.attributes.normal\n\n      let idx = 0\n\n      // for simplicity, ignore index and drawcalls, and render every normal\n\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\n        _v1.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld)\n\n        _v2.fromBufferAttribute(objNorm, j)\n\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1)\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z)\n\n        idx = idx + 1\n\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z)\n\n        idx = idx + 1\n      }\n    }\n\n    position.needsUpdate = true\n  }\n\n  dispose() {\n    this.geometry.dispose()\n    this.material.dispose()\n  }\n}\n\nexport { VertexNormalsHelper }\n"]},"metadata":{},"sourceType":"module"}