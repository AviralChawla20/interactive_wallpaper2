{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n    __publicField(this, \"renderScene\");\n    __publicField(this, \"renderCamera\");\n    __publicField(this, \"selectedObjects\");\n    __publicField(this, \"visibleEdgeColor\");\n    __publicField(this, \"hiddenEdgeColor\");\n    __publicField(this, \"edgeGlow\");\n    __publicField(this, \"usePatternTexture\");\n    __publicField(this, \"edgeThickness\");\n    __publicField(this, \"edgeStrength\");\n    __publicField(this, \"downSampleRatio\");\n    __publicField(this, \"pulsePeriod\");\n    __publicField(this, \"resolution\");\n    __publicField(this, \"renderTargetMaskBuffer\");\n    __publicField(this, \"depthMaterial\");\n    __publicField(this, \"prepareMaskMaterial\");\n    __publicField(this, \"renderTargetDepthBuffer\");\n    __publicField(this, \"renderTargetMaskDownSampleBuffer\");\n    __publicField(this, \"renderTargetBlurBuffer1\");\n    __publicField(this, \"renderTargetBlurBuffer2\");\n    __publicField(this, \"edgeDetectionMaterial\");\n    __publicField(this, \"renderTargetEdgeBuffer1\");\n    __publicField(this, \"renderTargetEdgeBuffer2\");\n    __publicField(this, \"separableBlurMaterial1\");\n    __publicField(this, \"separableBlurMaterial2\");\n    __publicField(this, \"overlayMaterial\");\n    __publicField(this, \"materialCopy\");\n    __publicField(this, \"oldClearAlpha\");\n    __publicField(this, \"fsQuad\");\n    __publicField(this, \"tempPulseColor1\");\n    __publicField(this, \"tempPulseColor2\");\n    __publicField(this, \"textureMatrix\");\n    __publicField(this, \"patternTexture\");\n    __publicField(this, \"_visibilityCache\");\n    __publicField(this, \"_oldClearColor\");\n    __publicField(this, \"copyUniforms\");\n    __publicField(this, \"BlurDirectionX\", new Vector2(1, 0));\n    __publicField(this, \"BlurDirectionY\", new Vector2(0, 1));\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1;\n    this.edgeStrength = 3;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = /* @__PURE__ */new Map();\n    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    this.overlayMaterial = this.getOverlayMaterial();\n    if (CopyShader === void 0) console.error(\"THREE.OutlinePass relies on CopyShader\");\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms[\"opacity\"].value = 1;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera2) {\n      const type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n  }\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n  }\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        let bFound = false;\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n        if (bFound === false) {\n          const visibility = object.visible;\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(16777215, 1);\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null;\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.updateTextureMatrix();\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.renderScene.background = currentBackground;\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      }\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n      this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n      this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n      this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1, 1, 1)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1, 1, 1)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1\n        },\n        edgeGlow: {\n          value: 1\n        },\n        usePatternTexture: {\n          value: 0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n}\nexport { OutlinePass };","map":{"version":3,"sources":["../../src/postprocessing/OutlinePass.ts"],"names":["camera"],"mappings":"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","sourcesContent":["import { Pass, FullScreenQuad } from './Pass'\nimport {\n  AdditiveBlending,\n  Camera,\n  Color,\n  DoubleSide,\n  Line,\n  Matrix4,\n  Mesh,\n  MeshDepthMaterial,\n  NoBlending,\n  Object3D,\n  PerspectiveCamera,\n  Points,\n  RGBADepthPacking,\n  Scene,\n  ShaderMaterial,\n  Sprite,\n  Texture,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n  WebGLRenderTarget,\n} from 'three'\nimport { CopyShader } from '../shaders/CopyShader'\n\nclass OutlinePass extends Pass {\n  public renderScene: Scene\n  public renderCamera: Camera\n  public selectedObjects: Object3D[]\n  public visibleEdgeColor: Color\n  public hiddenEdgeColor: Color\n  public edgeGlow: number\n  public usePatternTexture: boolean\n  public edgeThickness: number\n  public edgeStrength: number\n  public downSampleRatio: number\n  public pulsePeriod: number\n  public resolution: Vector2\n  public renderTargetMaskBuffer: WebGLRenderTarget\n  public depthMaterial: MeshDepthMaterial\n  public prepareMaskMaterial: ShaderMaterial\n  public renderTargetDepthBuffer: WebGLRenderTarget\n  public renderTargetMaskDownSampleBuffer: WebGLRenderTarget\n  public renderTargetBlurBuffer1: WebGLRenderTarget\n  public renderTargetBlurBuffer2: WebGLRenderTarget\n  public edgeDetectionMaterial: ShaderMaterial\n  public renderTargetEdgeBuffer1: WebGLRenderTarget\n  public renderTargetEdgeBuffer2: WebGLRenderTarget\n  public separableBlurMaterial1: ShaderMaterial\n  public separableBlurMaterial2: ShaderMaterial\n  public overlayMaterial: ShaderMaterial\n  public materialCopy: ShaderMaterial\n  public oldClearAlpha: number\n  public fsQuad: FullScreenQuad\n  public tempPulseColor1: Color\n  public tempPulseColor2: Color\n  public textureMatrix: Matrix4\n  public patternTexture?: Texture\n\n  private _visibilityCache: Map<Object3D, boolean>\n  private _oldClearColor: Color\n\n  public copyUniforms\n\n  public BlurDirectionX = new Vector2(1.0, 0.0)\n  public BlurDirectionY = new Vector2(0.0, 1.0)\n\n  constructor(resolution: Vector2, scene: Scene, camera: Camera, selectedObjects?: Object3D[]) {\n    super()\n\n    this.renderScene = scene\n    this.renderCamera = camera\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : []\n    this.visibleEdgeColor = new Color(1, 1, 1)\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02)\n    this.edgeGlow = 0.0\n    this.usePatternTexture = false\n    this.edgeThickness = 1.0\n    this.edgeStrength = 3.0\n    this.downSampleRatio = 2\n    this.pulsePeriod = 0\n\n    this._visibilityCache = new Map()\n\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)\n\n    const resx = Math.round(this.resolution.x / this.downSampleRatio)\n    const resy = Math.round(this.resolution.y / this.downSampleRatio)\n\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y)\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask'\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false\n\n    this.depthMaterial = new MeshDepthMaterial()\n    this.depthMaterial.side = DoubleSide\n    this.depthMaterial.depthPacking = RGBADepthPacking\n    this.depthMaterial.blending = NoBlending\n\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial()\n    this.prepareMaskMaterial.side = DoubleSide\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(\n      this.prepareMaskMaterial.fragmentShader,\n      this.renderCamera as PerspectiveCamera,\n    )\n\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y)\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth'\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false\n\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy)\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample'\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false\n\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy)\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1'\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2))\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2'\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false\n\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial()\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy)\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1'\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2))\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2'\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false\n\n    const MAX_EDGE_THICKNESS = 4\n    const MAX_EDGE_GLOW = 4\n\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS)\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW)\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2))\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW\n\n    // Overlay material\n    this.overlayMaterial = this.getOverlayMaterial()\n\n    // copy material\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader')\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n    this.copyUniforms['opacity'].value = 1.0\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.enabled = true\n    this.needsSwap = false\n\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.fsQuad = new FullScreenQuad(this.materialCopy)\n\n    this.tempPulseColor1 = new Color()\n    this.tempPulseColor2 = new Color()\n    this.textureMatrix = new Matrix4()\n\n    function replaceDepthToViewZ(string: string, camera: PerspectiveCamera): string {\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic'\n\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ')\n    }\n  }\n\n  public dispose(): void {\n    this.renderTargetMaskBuffer.dispose()\n    this.renderTargetDepthBuffer.dispose()\n    this.renderTargetMaskDownSampleBuffer.dispose()\n    this.renderTargetBlurBuffer1.dispose()\n    this.renderTargetBlurBuffer2.dispose()\n    this.renderTargetEdgeBuffer1.dispose()\n    this.renderTargetEdgeBuffer2.dispose()\n  }\n\n  public setSize(width: number, height: number): void {\n    this.renderTargetMaskBuffer.setSize(width, height)\n    this.renderTargetDepthBuffer.setSize(width, height)\n\n    let resx = Math.round(width / this.downSampleRatio)\n    let resy = Math.round(height / this.downSampleRatio)\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy)\n    this.renderTargetBlurBuffer1.setSize(resx, resy)\n    this.renderTargetEdgeBuffer1.setSize(resx, resy)\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)\n\n    resx = Math.round(resx / 2)\n    resy = Math.round(resy / 2)\n\n    this.renderTargetBlurBuffer2.setSize(resx, resy)\n    this.renderTargetEdgeBuffer2.setSize(resx, resy)\n\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy)\n  }\n\n  public changeVisibilityOfSelectedObjects(bVisible: boolean): void {\n    const cache = this._visibilityCache\n\n    function gatherSelectedMeshesCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object) as boolean\n        } else {\n          cache.set(object, object.visible)\n          object.visible = bVisible\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i]\n      selectedObject.traverse(gatherSelectedMeshesCallBack)\n    }\n  }\n\n  public changeVisibilityOfNonSelectedObjects(bVisible: boolean): void {\n    const cache = this._visibilityCache\n    const selectedMeshes: Object3D[] = []\n\n    function gatherSelectedMeshesCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh) selectedMeshes.push(object)\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i]\n      selectedObject.traverse(gatherSelectedMeshesCallBack)\n    }\n\n    function VisibilityChangeCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh || (object as Sprite).isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n\n        let bFound = false\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id\n\n          if (selectedObjectId === object.id) {\n            bFound = true\n            break\n          }\n        }\n\n        if (bFound === false) {\n          const visibility = object.visible\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible\n          }\n\n          cache.set(object, visibility)\n        }\n      } else if ((object as Points).isPoints || (object as Line).isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n\n        if (bVisible === true) {\n          object.visible = cache.get(object) as boolean // restore\n        } else {\n          cache.set(object, object.visible)\n          object.visible = bVisible\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack)\n  }\n\n  public updateTextureMatrix(): void {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix)\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)\n  }\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget,\n    deltaTime: number,\n    maskActive: boolean,\n  ): void {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor)\n      this.oldClearAlpha = renderer.getClearAlpha()\n      const oldAutoClear = renderer.autoClear\n\n      renderer.autoClear = false\n\n      if (maskActive) renderer.state.buffers.stencil.setTest(false)\n\n      renderer.setClearColor(0xffffff, 1)\n\n      // Make selected objects invisible\n      this.changeVisibilityOfSelectedObjects(false)\n\n      const currentBackground = this.renderScene.background\n      this.renderScene.background = null\n\n      // 1. Draw Non Selected objects in the depth buffer\n      this.renderScene.overrideMaterial = this.depthMaterial\n      renderer.setRenderTarget(this.renderTargetDepthBuffer)\n      renderer.clear()\n      renderer.render(this.renderScene, this.renderCamera)\n\n      // Make selected objects visible\n      this.changeVisibilityOfSelectedObjects(true)\n      this._visibilityCache.clear()\n\n      // Update Texture Matrix for Depth compare\n      this.updateTextureMatrix()\n\n      // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n      this.changeVisibilityOfNonSelectedObjects(false)\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(\n        (this.renderCamera as PerspectiveCamera).near,\n        (this.renderCamera as PerspectiveCamera).far,\n      )\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix\n      renderer.setRenderTarget(this.renderTargetMaskBuffer)\n      renderer.clear()\n      renderer.render(this.renderScene, this.renderCamera)\n      this.renderScene.overrideMaterial = null\n      this.changeVisibilityOfNonSelectedObjects(true)\n      this._visibilityCache.clear()\n\n      this.renderScene.background = currentBackground\n\n      // 2. Downsample to Half resolution\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      this.tempPulseColor1.copy(this.visibleEdgeColor)\n      this.tempPulseColor2.copy(this.hiddenEdgeColor)\n\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + (Math.cos((performance.now() * 0.01) / this.pulsePeriod) * (1.0 - 0.25)) / 2\n        this.tempPulseColor1.multiplyScalar(scalar)\n        this.tempPulseColor2.multiplyScalar(scalar)\n      }\n\n      // 3. Apply Edge Detection Pass\n      this.fsQuad.material = this.edgeDetectionMaterial\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(\n        this.renderTargetMaskDownSampleBuffer.width,\n        this.renderTargetMaskDownSampleBuffer.height,\n      )\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // 4. Apply Blur on Half res\n      this.fsQuad.material = this.separableBlurMaterial1\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // Apply Blur on quarter res\n      this.fsQuad.material = this.separableBlurMaterial2\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // Blend it additively over the input texture\n      this.fsQuad.material = this.overlayMaterial\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture\n\n      if (maskActive) renderer.state.buffers.stencil.setTest(true)\n\n      renderer.setRenderTarget(readBuffer)\n      this.fsQuad.render(renderer)\n\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n      renderer.autoClear = oldAutoClear\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    }\n  }\n\n  public getPrepareMaskMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: { value: null },\n        cameraNearFar: { value: new Vector2(0.5, 0.5) },\n        textureMatrix: { value: null },\n      },\n\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`,\n    })\n  }\n\n  public getEdgeDetectionMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        visibleEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },\n        hiddenEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`,\n    })\n  }\n\n  public getSeperableBlurMaterial(maxRadius: number): ShaderMaterial {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius,\n      },\n\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n        kernelRadius: { value: 1.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`,\n    })\n  }\n\n  public getOverlayMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        edgeTexture1: { value: null },\n        edgeTexture2: { value: null },\n        patternTexture: { value: null },\n        edgeStrength: { value: 1.0 },\n        edgeGlow: { value: 1.0 },\n        usePatternTexture: { value: 0.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n  }\n}\n\nexport { OutlinePass }\n"]},"metadata":{},"sourceType":"module"}