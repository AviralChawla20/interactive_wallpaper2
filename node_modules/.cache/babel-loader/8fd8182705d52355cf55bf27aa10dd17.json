{"ast":null,"code":"import { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, REVISION, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from \"three\";\nclass ParallaxBarrierEffect {\n  constructor(renderer) {\n    const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const _scene = new Scene();\n    const _stereo = new StereoCamera();\n    const _params = {\n      minFilter: LinearFilter,\n      magFilter: NearestFilter,\n      format: RGBAFormat\n    };\n    const _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n    const _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n    const _material = new ShaderMaterial({\n      uniforms: {\n        mapLeft: {\n          value: _renderTargetL.texture\n        },\n        mapRight: {\n          value: _renderTargetR.texture\n        }\n      },\n      vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = vec2( uv.x, uv.y );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n      fragmentShader: [\"uniform sampler2D mapLeft;\", \"uniform sampler2D mapRight;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 uv = vUv;\", \"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\", \"\t\tgl_FragColor = texture2D( mapLeft, uv );\", \"\t} else {\", \"\t\tgl_FragColor = texture2D( mapRight, uv );\", \"\t}\", \"\t#include <tonemapping_fragment>\", `\t#include <${parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>`, \"}\"].join(\"\\n\")\n    });\n    const mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n    _scene.add(mesh);\n    this.setSize = function (width, height) {\n      renderer.setSize(width, height);\n      const pixelRatio = renderer.getPixelRatio();\n      _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n      _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n    };\n    this.render = function (scene, camera) {\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n      _stereo.update(camera);\n      renderer.setRenderTarget(_renderTargetL);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraL);\n      renderer.setRenderTarget(_renderTargetR);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraR);\n      renderer.setRenderTarget(null);\n      renderer.render(_scene, _camera);\n    };\n  }\n}\nexport { ParallaxBarrierEffect };","map":{"version":3,"sources":["../../src/effects/ParallaxBarrierEffect.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  LinearFilter,\n  Mesh,\n  NearestFilter,\n  OrthographicCamera,\n  PlaneGeometry,\n  RGBAFormat,\n  Scene,\n  ShaderMaterial,\n  StereoCamera,\n  WebGLRenderTarget,\n  REVISION,\n} from 'three'\n\nclass ParallaxBarrierEffect {\n  constructor(renderer) {\n    const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n\n    const _scene = new Scene()\n\n    const _stereo = new StereoCamera()\n\n    const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat }\n\n    const _renderTargetL = new WebGLRenderTarget(512, 512, _params)\n    const _renderTargetR = new WebGLRenderTarget(512, 512, _params)\n\n    const _material = new ShaderMaterial({\n      uniforms: {\n        mapLeft: { value: _renderTargetL.texture },\n        mapRight: { value: _renderTargetR.texture },\n      },\n\n      vertexShader: [\n        'varying vec2 vUv;',\n\n        'void main() {',\n\n        '\tvUv = vec2( uv.x, uv.y );',\n        '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n        '}',\n      ].join('\\n'),\n\n      fragmentShader: [\n        'uniform sampler2D mapLeft;',\n        'uniform sampler2D mapRight;',\n        'varying vec2 vUv;',\n\n        'void main() {',\n\n        '\tvec2 uv = vUv;',\n\n        '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',\n\n        '\t\tgl_FragColor = texture2D( mapLeft, uv );',\n\n        '\t} else {',\n\n        '\t\tgl_FragColor = texture2D( mapRight, uv );',\n\n        '\t}',\n\n        '\t#include <tonemapping_fragment>',\n        `\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>`,\n\n        '}',\n      ].join('\\n'),\n    })\n\n    const mesh = new Mesh(new PlaneGeometry(2, 2), _material)\n    _scene.add(mesh)\n\n    this.setSize = function (width, height) {\n      renderer.setSize(width, height)\n\n      const pixelRatio = renderer.getPixelRatio()\n\n      _renderTargetL.setSize(width * pixelRatio, height * pixelRatio)\n      _renderTargetR.setSize(width * pixelRatio, height * pixelRatio)\n    }\n\n    this.render = function (scene, camera) {\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      _stereo.update(camera)\n\n      renderer.setRenderTarget(_renderTargetL)\n      renderer.clear()\n      renderer.render(scene, _stereo.cameraL)\n\n      renderer.setRenderTarget(_renderTargetR)\n      renderer.clear()\n      renderer.render(scene, _stereo.cameraR)\n\n      renderer.setRenderTarget(null)\n      renderer.render(_scene, _camera)\n    }\n  }\n}\n\nexport { ParallaxBarrierEffect }\n"]},"metadata":{},"sourceType":"module"}