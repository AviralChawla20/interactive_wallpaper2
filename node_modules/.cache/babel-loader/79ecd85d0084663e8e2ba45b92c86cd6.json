{"ast":null,"code":"import { Loader, FileLoader, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip } from \"three\";\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.animateBonePositions = true;\n    this.animateBoneRotations = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text) {\n    function readBvh(lines2) {\n      if (nextLine(lines2) !== \"HIERARCHY\") {\n        console.error(\"THREE.BVHLoader: HIERARCHY expected.\");\n      }\n      const list = [];\n      const root = readNode(lines2, nextLine(lines2), list);\n      if (nextLine(lines2) !== \"MOTION\") {\n        console.error(\"THREE.BVHLoader: MOTION expected.\");\n      }\n      let tokens = nextLine(lines2).split(/[\\s]+/);\n      const numFrames = parseInt(tokens[1]);\n      if (isNaN(numFrames)) {\n        console.error(\"THREE.BVHLoader: Failed to read number of frames.\");\n      }\n      tokens = nextLine(lines2).split(/[\\s]+/);\n      const frameTime = parseFloat(tokens[2]);\n      if (isNaN(frameTime)) {\n        console.error(\"THREE.BVHLoader: Failed to read frame time.\");\n      }\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n      return list;\n    }\n    function readFrameData(data, frameTime, bone) {\n      if (bone.type === \"ENDSITE\") return;\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      const quat = new Quaternion();\n      const vx = new Vector3(1, 0, 0);\n      const vy = new Vector3(0, 1, 0);\n      const vz = new Vector3(0, 0, 1);\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case \"Xposition\":\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n          case \"Yposition\":\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n          case \"Zposition\":\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n          case \"Xrotation\":\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case \"Yrotation\":\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case \"Zrotation\":\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          default:\n            console.warn(\"THREE.BVHLoader: Invalid channel type.\");\n        }\n      }\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i]);\n      }\n    }\n    function readNode(lines2, firstline, list) {\n      const node = {\n        name: \"\",\n        type: \"\",\n        frames: []\n      };\n      list.push(node);\n      let tokens = firstline.split(/[\\s]+/);\n      if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n        node.type = \"ENDSITE\";\n        node.name = \"ENDSITE\";\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n      if (nextLine(lines2) !== \"{\") {\n        console.error(\"THREE.BVHLoader: Expected opening { after type & name\");\n      }\n      tokens = nextLine(lines2).split(/[\\s]+/);\n      if (tokens[0] !== \"OFFSET\") {\n        console.error(\"THREE.BVHLoader: Expected OFFSET but got: \" + tokens[0]);\n      }\n      if (tokens.length !== 4) {\n        console.error(\"THREE.BVHLoader: Invalid number of values for OFFSET.\");\n      }\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error(\"THREE.BVHLoader: Invalid values of OFFSET.\");\n      }\n      node.offset = offset;\n      if (node.type !== \"ENDSITE\") {\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        if (tokens[0] !== \"CHANNELS\") {\n          console.error(\"THREE.BVHLoader: Expected CHANNELS definition.\");\n        }\n        const numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      }\n      while (true) {\n        const line = nextLine(lines2);\n        if (line === \"}\") {\n          return node;\n        } else {\n          node.children.push(readNode(lines2, line, list));\n        }\n      }\n    }\n    function toTHREEBone(source, list) {\n      const bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n      if (source.type !== \"ENDSITE\") {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n      return bone;\n    }\n    function toTHREEAnimation(bones2) {\n      const tracks = [];\n      for (let i = 0; i < bones2.length; i++) {\n        const bone = bones2[i];\n        if (bone.type === \"ENDSITE\") continue;\n        const times = [];\n        const positions = [];\n        const rotations = [];\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j];\n          times.push(frame.time);\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack(\".bones[\" + bone.name + \"].position\", times, positions));\n        }\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack(\".bones[\" + bone.name + \"].quaternion\", times, rotations));\n        }\n      }\n      return new AnimationClip(\"animation\", -1, tracks);\n    }\n    function nextLine(lines2) {\n      let line;\n      while ((line = lines2.shift().trim()).length === 0) {}\n      return line;\n    }\n    const scope = this;\n    const lines = text.split(/[\\r\\n]+/g);\n    const bones = readBvh(lines);\n    const threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    const threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n}\nexport { BVHLoader };","map":{"version":3,"sources":["../../src/loaders/BVHLoader.js"],"names":["lines","bones"],"mappings":"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","sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  FileLoader,\n  Loader,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  Skeleton,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.animateBonePositions = true\n    this.animateBoneRotations = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    /*\n\t\t\treads a string array (lines) from a BVH file\n\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\treturns thee root node:\n\t\t\t{ name: '', channels: [], children: [] }\n\t\t*/\n    function readBvh(lines) {\n      // read model structure\n\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.')\n      }\n\n      const list = [] // collects flat array of all bones\n      const root = readNode(lines, nextLine(lines), list)\n\n      // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.')\n      }\n\n      // number of frames\n\n      let tokens = nextLine(lines).split(/[\\s]+/)\n      const numFrames = parseInt(tokens[1])\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.')\n      }\n\n      // frame time\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n      const frameTime = parseFloat(tokens[2])\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.')\n      }\n\n      // read frame data line by line\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/)\n        readFrameData(tokens, i * frameTime, root)\n      }\n\n      return list\n    }\n\n    /*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n\n      if (bone.type === 'ENDSITE') return\n\n      // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n      }\n\n      bone.frames.push(keyframe)\n\n      const quat = new Quaternion()\n\n      const vx = new Vector3(1, 0, 0)\n      const vy = new Vector3(0, 1, 0)\n      const vz = new Vector3(0, 0, 1)\n\n      // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim())\n            break\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim())\n            break\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim())\n            break\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.')\n        }\n      }\n\n      // parse child nodes\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i])\n      }\n    }\n\n    /*\n\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n    function readNode(lines, firstline, list) {\n      const node = { name: '', type: '', frames: [] }\n      list.push(node)\n\n      // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/)\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE'\n        node.name = 'ENDSITE' // bvh end sites have no name\n      } else {\n        node.name = tokens[1]\n        node.type = tokens[0].toUpperCase()\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name')\n      }\n\n      // parse OFFSET\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0])\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.')\n      }\n\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]))\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.')\n      }\n\n      node.offset = offset\n\n      // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/)\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.')\n        }\n\n        const numChannels = parseInt(tokens[1])\n        node.channels = tokens.splice(2, numChannels)\n        node.children = []\n      }\n\n      // read children\n\n      while (true) {\n        const line = nextLine(lines)\n\n        if (line === '}') {\n          return node\n        } else {\n          node.children.push(readNode(lines, line, list))\n        }\n      }\n    }\n\n    /*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n    function toTHREEBone(source, list) {\n      const bone = new Bone()\n      list.push(bone)\n\n      bone.position.add(source.offset)\n      bone.name = source.name\n\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list))\n        }\n      }\n\n      return bone\n    }\n\n    /*\n\t\t\tbuilds a AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: a AnimationClip containing position and quaternion tracks\n\t\t*/\n    function toTHREEAnimation(bones) {\n      const tracks = []\n\n      // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i]\n\n        if (bone.type === 'ENDSITE') continue\n\n        // track data\n\n        const times = []\n        const positions = []\n        const rotations = []\n\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j]\n\n          times.push(frame.time)\n\n          // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x)\n          positions.push(frame.position.y + bone.offset.y)\n          positions.push(frame.position.z + bone.offset.z)\n\n          rotations.push(frame.rotation.x)\n          rotations.push(frame.rotation.y)\n          rotations.push(frame.rotation.z)\n          rotations.push(frame.rotation.w)\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions))\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations))\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks)\n    }\n\n    /*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n    function nextLine(lines) {\n      let line\n      // skip empty lines\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line\n    }\n\n    const scope = this\n\n    const lines = text.split(/[\\r\\n]+/g)\n\n    const bones = readBvh(lines)\n\n    const threeBones = []\n    toTHREEBone(bones[0], threeBones)\n\n    const threeClip = toTHREEAnimation(bones)\n\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip,\n    }\n  }\n}\n\nexport { BVHLoader }\n"]},"metadata":{},"sourceType":"module"}