{"ast":null,"code":"import { ShaderMaterial, UniformsUtils, ShaderLib, RGBADepthPacking, BufferGeometry, BufferAttribute, InstancedBufferGeometry, InstancedBufferAttribute, Vector3, Math as Math$1, Vector4 } from 'three';\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor(parameters, uniforms) {\n    super();\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.');\n      Object.keys(parameters.uniformValues).forEach(key => {\n        parameters[key] = parameters.uniformValues[key];\n      });\n      delete parameters.uniformValues;\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach(key => {\n      this[key] = parameters[key];\n    });\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n  setUniformValues(values) {\n    if (!values) return;\n    const keys = Object.keys(values);\n    keys.forEach(key => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n  stringifyChunk(name) {\n    let value;\n    if (!this[name]) {\n      value = '';\n    } else if (typeof this[name] === 'string') {\n      value = this[name];\n    } else {\n      value = this[name].join('\\n');\n    }\n    return value;\n  }\n}\nclass BasicAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshBasicMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_basic/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['basic'].uniforms);\n    this.lights = false;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.basic.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <beginnormal_vertex>', `\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk('vertexNormal')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.basic.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `);\n  }\n}\nclass LambertAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshLambertMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_lambert/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['lambert'].uniforms);\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.lambert.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <beginnormal_vertex>', `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.lambert.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `).replace('#include <emissivemap_fragment>', `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `);\n  }\n}\nclass PhongAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshPhongMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_phong/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['phong'].uniforms);\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.phong.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <beginnormal_vertex>', `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.phong.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `).replace('#include <emissivemap_fragment>', `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `).replace('#include <lights_phong_fragment>', `\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk('fragmentSpecular')}\n        `);\n  }\n}\nclass StandardAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshStandardMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_standard/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['physical'].uniforms);\n    this.lights = true;\n    this.extensions = this.extensions || {};\n    this.extensions.derivatives = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.standard.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <beginnormal_vertex>', `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.standard.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `).replace('#include <emissivemap_fragment>', `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `).replace('#include <roughnessmap_fragment>', `\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk('fragmentRoughness')}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `).replace('#include <metalnessmap_fragment>', `\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk('fragmentMetalness')}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `);\n  }\n}\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.toon.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <beginnormal_vertex>', `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.toon.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `).replace('#include <emissivemap_fragment>', `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `);\n  }\n}\nclass PointsAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.PointsMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor(parameters) {\n    super(parameters, ShaderLib['points'].uniforms);\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n  concatVertexShader() {\n    return ShaderLib.points.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `);\n  }\n  concatFragmentShader() {\n    return ShaderLib.points.fragmentShader.replace('void main() {', `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `).replace('#include <map_fragment>', `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${this.stringifyChunk('fragmentMap') || '#include <map_fragment>'}\n\n        `).replace('#include <premultiplied_alpha_fragment>', `\n        ${this.stringifyChunk('fragmentShape')}\n\n        #include <premultiplied_alpha_fragment>\n        `);\n  }\n}\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor(parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n  concatVertexShader() {\n    return ShaderLib.depth.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n}\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor(parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n  concatVertexShader() {\n    return ShaderLib.distanceRGBA.vertexShader.replace('void main() {', `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `).replace('#include <begin_vertex>', `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `).replace('#include <morphtarget_vertex>', `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `).replace('#include <skinning_vertex>', `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `);\n  }\n}\nclass PrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n   *\n   * @param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor(prefab, count) {\n    super();\n\n    /**\n     * A reference to the prefab geometry used to create this instance.\n     * @type {Geometry|BufferGeometry}\n     */\n    this.prefabGeometry = prefab;\n    this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = count;\n\n    /**\n     * Number of vertices of the prefab.\n     * @type {Number}\n     */\n    if (this.isPrefabBufferGeometry) {\n      this.prefabVertexCount = prefab.attributes.position.count;\n    } else {\n      this.prefabVertexCount = prefab.vertices.length;\n    }\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n  bufferIndices() {\n    let prefabIndices = [];\n    let prefabIndexCount;\n    if (this.isPrefabBufferGeometry) {\n      if (this.prefabGeometry.index) {\n        prefabIndexCount = this.prefabGeometry.index.count;\n        prefabIndices = this.prefabGeometry.index.array;\n      } else {\n        prefabIndexCount = this.prefabVertexCount;\n        for (let i = 0; i < prefabIndexCount; i++) {\n          prefabIndices.push(i);\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      prefabIndexCount = prefabFaceCount * 3;\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        prefabIndices.push(face.a, face.b, face.c);\n      }\n    }\n    const indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n    for (let i = 0; i < this.prefabCount; i++) {\n      for (let k = 0; k < prefabIndexCount; k++) {\n        indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * this.prefabVertexCount;\n      }\n    }\n  }\n  bufferPositions() {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    if (this.isPrefabBufferGeometry) {\n      const positions = this.prefabGeometry.attributes.position.array;\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          positionBuffer[offset] = positions[j * 3];\n          positionBuffer[offset + 1] = positions[j * 3 + 1];\n          positionBuffer[offset + 2] = positions[j * 3 + 2];\n        }\n      }\n    } else {\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          const prefabVertex = this.prefabGeometry.vertices[j];\n          positionBuffer[offset] = prefabVertex.x;\n          positionBuffer[offset + 1] = prefabVertex.y;\n          positionBuffer[offset + 2] = prefabVertex.z;\n        }\n      }\n    }\n  }\n  bufferUvs() {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    if (this.isPrefabBufferGeometry) {\n      const uvs = this.prefabGeometry.attributes.uv.array;\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          uvBuffer[offset] = uvs[j * 2];\n          uvBuffer[offset + 1] = uvs[j * 2 + 1];\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      const uvs = [];\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        const uv = this.prefabGeometry.faceVertexUvs[0][i];\n        uvs[face.a] = uv[0];\n        uvs[face.b] = uv[1];\n        uvs[face.c] = uv[2];\n      }\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          const uv = uvs[j];\n          uvBuffer[offset] = uv.x;\n          uvBuffer[offset + 1] = uv.y;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute(name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n    this.setAttribute(name, attribute);\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData(attribute, prefabIndex, data) {\n    attribute = typeof attribute === 'string' ? this.attributes[attribute] : attribute;\n    let offset = prefabIndex * this.prefabVertexCount * attribute.itemSize;\n    for (let i = 0; i < this.prefabVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\nclass MultiPrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry array is repeated a number of times.\n   *\n   * @param {Array} prefabs An array with Geometry instances to repeat.\n   * @param {Number} repeatCount The number of times to repeat the array of Geometries.\n   * @constructor\n   */\n  constructor(prefabs, repeatCount) {\n    super();\n    if (Array.isArray(prefabs)) {\n      this.prefabGeometries = prefabs;\n    } else {\n      this.prefabGeometries = [prefabs];\n    }\n    this.prefabGeometriesCount = this.prefabGeometries.length;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = repeatCount * this.prefabGeometriesCount;\n    /**\n     * How often the prefab array is repeated.\n     * @type {Number}\n     */\n    this.repeatCount = repeatCount;\n\n    /**\n     * Array of vertex counts per prefab.\n     * @type {Array}\n     */\n    this.prefabVertexCounts = this.prefabGeometries.map(p => p.isBufferGeometry ? p.attributes.position.count : p.vertices.length);\n    /**\n     * Total number of vertices for one repetition of the prefabs\n     * @type {number}\n     */\n    this.repeatVertexCount = this.prefabVertexCounts.reduce((r, v) => r + v, 0);\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n  bufferIndices() {\n    let repeatIndexCount = 0;\n    this.prefabIndices = this.prefabGeometries.map(geometry => {\n      let indices = [];\n      if (geometry.isBufferGeometry) {\n        if (geometry.index) {\n          indices = geometry.index.array;\n        } else {\n          for (let i = 0; i < geometry.attributes.position.count; i++) {\n            indices.push(i);\n          }\n        }\n      } else {\n        for (let i = 0; i < geometry.faces.length; i++) {\n          const face = geometry.faces[i];\n          indices.push(face.a, face.b, face.c);\n        }\n      }\n      repeatIndexCount += indices.length;\n      return indices;\n    });\n    const indexBuffer = new Uint32Array(repeatIndexCount * this.repeatCount);\n    let indexOffset = 0;\n    let prefabOffset = 0;\n    for (let i = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometriesCount;\n      const indices = this.prefabIndices[index];\n      const vertexCount = this.prefabVertexCounts[index];\n      for (let j = 0; j < indices.length; j++) {\n        indexBuffer[indexOffset++] = indices[j] + prefabOffset;\n      }\n      prefabOffset += vertexCount;\n    }\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n  }\n  bufferPositions() {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    const prefabPositions = this.prefabGeometries.map((geometry, i) => {\n      let positions;\n      if (geometry.isBufferGeometry) {\n        positions = geometry.attributes.position.array;\n      } else {\n        const vertexCount = this.prefabVertexCounts[i];\n        positions = [];\n        for (let j = 0, offset = 0; j < vertexCount; j++) {\n          const prefabVertex = geometry.vertices[j];\n          positions[offset++] = prefabVertex.x;\n          positions[offset++] = prefabVertex.y;\n          positions[offset++] = prefabVertex.z;\n        }\n      }\n      return positions;\n    });\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const positions = prefabPositions[index];\n      for (let j = 0; j < vertexCount; j++) {\n        positionBuffer[offset++] = positions[j * 3];\n        positionBuffer[offset++] = positions[j * 3 + 1];\n        positionBuffer[offset++] = positions[j * 3 + 2];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute with UV coordinates.\n   */\n  bufferUvs() {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    const prefabUvs = this.prefabGeometries.map((geometry, i) => {\n      let uvs;\n      if (geometry.isBufferGeometry) {\n        if (!geometry.attributes.uv) {\n          console.error('No UV found in prefab geometry', geometry);\n        }\n        uvs = geometry.attributes.uv.array;\n      } else {\n        const prefabFaceCount = this.prefabIndices[i].length / 3;\n        const uvObjects = [];\n        for (let j = 0; j < prefabFaceCount; j++) {\n          const face = geometry.faces[j];\n          const uv = geometry.faceVertexUvs[0][j];\n          uvObjects[face.a] = uv[0];\n          uvObjects[face.b] = uv[1];\n          uvObjects[face.c] = uv[2];\n        }\n        uvs = [];\n        for (let k = 0; k < uvObjects.length; k++) {\n          uvs[k * 2] = uvObjects[k].x;\n          uvs[k * 2 + 1] = uvObjects[k].y;\n        }\n      }\n      return uvs;\n    });\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const uvs = prefabUvs[index];\n      for (let j = 0; j < vertexCount; j++) {\n        uvBuffer[offset++] = uvs[j * 2];\n        uvBuffer[offset++] = uvs[j * 2 + 1];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute(name, itemSize, factory) {\n    const buffer = new Float32Array(this.repeatCount * this.repeatVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n    this.setAttribute(name, attribute);\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n    return attribute;\n  }\n\n  /**\n  * Sets data for all vertices of a prefab at a given index.\n  * Usually called in a loop.\n  *\n  * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n  * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n  * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n  */\n  setPrefabData(attribute, prefabIndex, data) {\n    attribute = typeof attribute === 'string' ? this.attributes[attribute] : attribute;\n    const prefabGeometryIndex = prefabIndex % this.prefabGeometriesCount;\n    const prefabGeometryVertexCount = this.prefabVertexCounts[prefabGeometryIndex];\n    const whole = (prefabIndex / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount;\n    const wholeOffset = whole * this.repeatVertexCount;\n    const part = prefabIndex - whole;\n    let partOffset = 0;\n    let i = 0;\n    while (i < part) {\n      partOffset += this.prefabVertexCounts[i++];\n    }\n    let offset = (wholeOffset + partOffset) * attribute.itemSize;\n    for (let i = 0; i < prefabGeometryVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\nclass InstancedPrefabBufferGeometry extends InstancedBufferGeometry {\n  /**\n   * A wrapper around THREE.InstancedBufferGeometry, which is more memory efficient than PrefabBufferGeometry, but requires the ANGLE_instanced_arrays extension.\n   *\n   * @param {BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor(prefab, count) {\n    super();\n    this.prefabGeometry = prefab;\n    this.copy(prefab);\n    this.instanceCount = count;\n    this.prefabCount = count;\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute(name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * itemSize);\n    const attribute = new InstancedBufferAttribute(buffer, itemSize);\n    this.setAttribute(name, attribute);\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n    return attribute;\n  }\n  /**\n   * Sets data for a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData(attribute, prefabIndex, data) {\n    attribute = typeof attribute === 'string' ? this.attributes[attribute] : attribute;\n    let offset = prefabIndex * attribute.itemSize;\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n    geometry.vertices = vertices;\n  },\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function (geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n    v = v || new Vector3();\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n    return v;\n  },\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function (box, v) {\n    v = v || new Vector3();\n    v.x = Math$1.randFloat(box.min.x, box.max.x);\n    v.y = Math$1.randFloat(box.min.y, box.max.y);\n    v.z = Math$1.randFloat(box.min.z, box.max.z);\n    return v;\n  },\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function (v) {\n    v = v || new Vector3();\n    v.x = Math$1.randFloatSpread(2.0);\n    v.y = Math$1.randFloatSpread(2.0);\n    v.z = Math$1.randFloatSpread(2.0);\n    v.normalize();\n    return v;\n  },\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function (sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function (sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor(model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids() {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n  bufferIndices() {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n      indexBuffer[offset] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n  bufferPositions(localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n        positionBuffer[face.a * 3] = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n        positionBuffer[face.b * 3] = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n        positionBuffer[face.c * 3] = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    } else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n        positionBuffer[offset] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs() {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    for (let i = 0; i < this.faceCount; i++) {\n      const face = this.modelGeometry.faces[i];\n      let uv;\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2] = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2] = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2] = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning() {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n      skinIndexBuffer[i * 4] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n      skinWeightBuffer[i * 4] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute(name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n    this.setAttribute(name, attribute);\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData(attribute, faceIndex, data) {\n    attribute = typeof attribute === 'string' ? this.attributes[attribute] : attribute;\n    let offset = faceIndex * 3 * attribute.itemSize;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\nclass PointBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry consists of points.\n   * @param {Number} count The number of points.\n   * @constructor\n   */\n  constructor(count) {\n    super();\n\n    /**\n     * Number of points.\n     * @type {Number}\n     */\n    this.pointCount = count;\n    this.bufferPositions();\n  }\n  bufferPositions() {\n    this.createAttribute('position', 3);\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each point upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPointData.\n   *\n   * @returns {THREE.BufferAttribute}\n   */\n  createAttribute(name, itemSize, factory) {\n    const buffer = new Float32Array(this.pointCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n    this.setAttribute(name, attribute);\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.pointCount; i++) {\n        factory(data, i, this.pointCount);\n        this.setPointData(attribute, i, data);\n      }\n    }\n    return attribute;\n  }\n  setPointData(attribute, pointIndex, data) {\n    attribute = typeof attribute === 'string' ? this.attributes[attribute] : attribute;\n    let offset = pointIndex * attribute.itemSize;\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\nvar catmull_rom_spline = \"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\\n    vec4 v0 = (p2 - p0) * c.x;\\n    vec4 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\\n    vec3 v0 = (p2 - p0) * c.x;\\n    vec3 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\\n    vec2 v0 = (p2 - p0) * c.x;\\n    vec2 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\\n    float v0 = (p2 - p0) * c.x;\\n    float v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nivec4 getCatmullRomSplineIndices(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(max(0.0, index - 1.0));\\n    int i1 = int(index);\\n    int i2 = int(min(index + 1.0, l));\\n    int i3 = int(min(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(index == 0.0 ? l : index - 1.0);\\n    int i1 = int(index);\\n    int i2 = int(mod(index + 1.0, l));\\n    int i3 = int(mod(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\n\";\nvar cubic_bezier = \"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\n\";\nvar ease_back_in = \"float easeBackIn(float p, float amplitude) {\\n    return p * p * ((amplitude + 1.0) * p - amplitude);\\n}\\nfloat easeBackIn(float p) {\\n    return easeBackIn(p, 1.70158);\\n}\\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackIn(t / d, amplitude) * c;\\n}\\nfloat easeBackIn(float t, float b, float c, float d) {\\n    return b + easeBackIn(t / d) * c;\\n}\\n\";\nvar ease_back_in_out = \"float easeBackInOut(float p, float amplitude) {\\n    amplitude *= 1.525;\\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\\n}\\nfloat easeBackInOut(float p) {\\n    return easeBackInOut(p, 1.70158);\\n}\\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackInOut(t / d, amplitude) * c;\\n}\\nfloat easeBackInOut(float t, float b, float c, float d) {\\n    return b + easeBackInOut(t / d) * c;\\n}\\n\";\nvar ease_back_out = \"float easeBackOut(float p, float amplitude) {\\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\\n}\\nfloat easeBackOut(float p) {\\n    return easeBackOut(p, 1.70158);\\n}\\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackOut(t / d, amplitude) * c;\\n}\\nfloat easeBackOut(float t, float b, float c, float d) {\\n    return b + easeBackOut(t / d) * c;\\n}\\n\";\nvar ease_bezier = \"float easeBezier(float p, vec4 curve) {\\n    float ip = 1.0 - p;\\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\\n}\\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\\n    return b + easeBezier(t / d, curve) * c;\\n}\\n\";\nvar ease_bounce_in = \"float easeBounceIn(float p) {\\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\\n        return 1.0 - (7.5625 * p * p);\\n    } else if (p < 2.0 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\\n    } else if (p < 2.5 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\\n    }\\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\\n}\\nfloat easeBounceIn(float t, float b, float c, float d) {\\n    return b + easeBounceIn(t / d) * c;\\n}\\n\";\nvar ease_bounce_in_out = \"float easeBounceInOut(float p) {\\n    bool invert = (p < 0.5);\\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\\n    if (p < 1.0 / 2.75) {\\n        p = 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    } else {\\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n    }\\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\\n}\\nfloat easeBounceInOut(float t, float b, float c, float d) {\\n    return b + easeBounceInOut(t / d) * c;\\n}\\n\";\nvar ease_bounce_out = \"float easeBounceOut(float p) {\\n    if (p < 1.0 / 2.75) {\\n        return 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    }\\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n}\\nfloat easeBounceOut(float t, float b, float c, float d) {\\n    return b + easeBounceOut(t / d) * c;\\n}\\n\";\nvar ease_circ_in = \"float easeCircIn(float p) {\\n    return -(sqrt(1.0 - p * p) - 1.0);\\n}\\nfloat easeCircIn(float t, float b, float c, float d) {\\n    return b + easeCircIn(t / d) * c;\\n}\\n\";\nvar ease_circ_in_out = \"float easeCircInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\\n}\\nfloat easeCircInOut(float t, float b, float c, float d) {\\n    return b + easeCircInOut(t / d) * c;\\n}\\n\";\nvar ease_circ_out = \"float easeCircOut(float p) {\\n  return sqrt(1.0 - (p = p - 1.0) * p);\\n}\\nfloat easeCircOut(float t, float b, float c, float d) {\\n  return b + easeCircOut(t / d) * c;\\n}\\n\";\nvar ease_cubic_in = \"float easeCubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat easeCubicIn(float t, float b, float c, float d) {\\n  return b + easeCubicIn(t / d) * c;\\n}\\n\";\nvar ease_cubic_in_out = \"float easeCubicInOut(float t) {\\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\\n}\\nfloat easeCubicInOut(float t, float b, float c, float d) {\\n  return b + easeCubicInOut(t / d) * c;\\n}\\n\";\nvar ease_cubic_out = \"float easeCubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\nfloat easeCubicOut(float t, float b, float c, float d) {\\n  return b + easeCubicOut(t / d) * c;\\n}\\n\";\nvar ease_elastic_in = \"float easeElasticIn(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\\n}\\nfloat easeElasticIn(float p) {\\n    return easeElasticIn(p, 1.0, 0.3);\\n}\\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticIn(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticIn(float t, float b, float c, float d) {\\n    return b + easeElasticIn(t / d) * c;\\n}\\n\";\nvar ease_elastic_in_out = \"float easeElasticInOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\\n}\\nfloat easeElasticInOut(float p) {\\n    return easeElasticInOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d) {\\n    return b + easeElasticInOut(t / d) * c;\\n}\\n\";\nvar ease_elastic_out = \"float easeElasticOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\\n}\\nfloat easeElasticOut(float p) {\\n    return easeElasticOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticOut(float t, float b, float c, float d) {\\n    return b + easeElasticOut(t / d) * c;\\n}\\n\";\nvar ease_expo_in = \"float easeExpoIn(float p) {\\n    return pow(2.0, 10.0 * (p - 1.0));\\n}\\nfloat easeExpoIn(float t, float b, float c, float d) {\\n    return b + easeExpoIn(t / d) * c;\\n}\\n\";\nvar ease_expo_in_out = \"float easeExpoInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\\n}\\nfloat easeExpoInOut(float t, float b, float c, float d) {\\n    return b + easeExpoInOut(t / d) * c;\\n}\\n\";\nvar ease_expo_out = \"float easeExpoOut(float p) {\\n  return 1.0 - pow(2.0, -10.0 * p);\\n}\\nfloat easeExpoOut(float t, float b, float c, float d) {\\n  return b + easeExpoOut(t / d) * c;\\n}\\n\";\nvar ease_quad_in = \"float easeQuadIn(float t) {\\n    return t * t;\\n}\\nfloat easeQuadIn(float t, float b, float c, float d) {\\n  return b + easeQuadIn(t / d) * c;\\n}\\n\";\nvar ease_quad_in_out = \"float easeQuadInOut(float t) {\\n    float p = 2.0 * t * t;\\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\nfloat easeQuadInOut(float t, float b, float c, float d) {\\n    return b + easeQuadInOut(t / d) * c;\\n}\\n\";\nvar ease_quad_out = \"float easeQuadOut(float t) {\\n  return -t * (t - 2.0);\\n}\\nfloat easeQuadOut(float t, float b, float c, float d) {\\n  return b + easeQuadOut(t / d) * c;\\n}\\n\";\nvar ease_quart_in = \"float easeQuartIn(float t) {\\n  return t * t * t * t;\\n}\\nfloat easeQuartIn(float t, float b, float c, float d) {\\n  return b + easeQuartIn(t / d) * c;\\n}\\n\";\nvar ease_quart_in_out = \"float easeQuartInOut(float t) {\\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\nfloat easeQuartInOut(float t, float b, float c, float d) {\\n    return b + easeQuartInOut(t / d) * c;\\n}\\n\";\nvar ease_quart_out = \"float easeQuartOut(float t) {\\n  return 1.0 - pow(1.0 - t, 4.0);\\n}\\nfloat easeQuartOut(float t, float b, float c, float d) {\\n  return b + easeQuartOut(t / d) * c;\\n}\\n\";\nvar ease_quint_in = \"float easeQuintIn(float t) {\\n    return pow(t, 5.0);\\n}\\nfloat easeQuintIn(float t, float b, float c, float d) {\\n    return b + easeQuintIn(t / d) * c;\\n}\\n\";\nvar ease_quint_in_out = \"float easeQuintInOut(float t) {\\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\\n}\\nfloat easeQuintInOut(float t, float b, float c, float d) {\\n    return b + easeQuintInOut(t / d) * c;\\n}\\n\";\nvar ease_quint_out = \"float easeQuintOut(float t) {\\n    return (t -= 1.0) * t * t * t * t + 1.0;\\n}\\nfloat easeQuintOut(float t, float b, float c, float d) {\\n    return b + easeQuintOut(t / d) * c;\\n}\\n\";\nvar ease_sine_in = \"float easeSineIn(float p) {\\n  return -cos(p * 1.57079632679) + 1.0;\\n}\\nfloat easeSineIn(float t, float b, float c, float d) {\\n  return b + easeSineIn(t / d) * c;\\n}\\n\";\nvar ease_sine_in_out = \"float easeSineInOut(float p) {\\n  return -0.5 * (cos(PI * p) - 1.0);\\n}\\nfloat easeSineInOut(float t, float b, float c, float d) {\\n  return b + easeSineInOut(t / d) * c;\\n}\\n\";\nvar ease_sine_out = \"float easeSineOut(float p) {\\n  return sin(p * 1.57079632679);\\n}\\nfloat easeSineOut(float t, float b, float c, float d) {\\n  return b + easeSineOut(t / d) * c;\\n}\\n\";\nvar quadratic_bezier = \"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\";\nvar quaternion_rotation = \"vec3 rotateVector(vec4 q, vec3 v) {\\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\\n    float halfAngle = angle * 0.5;\\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\\n}\\n\";\nvar quaternion_slerp = \"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\\n    float s = 1.0 - t;\\n    float c = dot(q0, q1);\\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\\n    if (sqrSn > 2.220446049250313e-16) {\\n        float sn = sqrt(sqrSn);\\n        float len = atan(sn, c * dir);\\n        s = sin(s * len) / sn;\\n        t = sin(t * len) / sn;\\n    }\\n    float tDir = t * dir;\\n    return normalize(q0 * s + q1 * tDir);\\n}\\n\";\n\n// generated by scripts/build_shader_chunks.js\n\nconst ShaderChunk = {\n  catmull_rom_spline: catmull_rom_spline,\n  cubic_bezier: cubic_bezier,\n  ease_back_in: ease_back_in,\n  ease_back_in_out: ease_back_in_out,\n  ease_back_out: ease_back_out,\n  ease_bezier: ease_bezier,\n  ease_bounce_in: ease_bounce_in,\n  ease_bounce_in_out: ease_bounce_in_out,\n  ease_bounce_out: ease_bounce_out,\n  ease_circ_in: ease_circ_in,\n  ease_circ_in_out: ease_circ_in_out,\n  ease_circ_out: ease_circ_out,\n  ease_cubic_in: ease_cubic_in,\n  ease_cubic_in_out: ease_cubic_in_out,\n  ease_cubic_out: ease_cubic_out,\n  ease_elastic_in: ease_elastic_in,\n  ease_elastic_in_out: ease_elastic_in_out,\n  ease_elastic_out: ease_elastic_out,\n  ease_expo_in: ease_expo_in,\n  ease_expo_in_out: ease_expo_in_out,\n  ease_expo_out: ease_expo_out,\n  ease_quad_in: ease_quad_in,\n  ease_quad_in_out: ease_quad_in_out,\n  ease_quad_out: ease_quad_out,\n  ease_quart_in: ease_quart_in,\n  ease_quart_in_out: ease_quart_in_out,\n  ease_quart_out: ease_quart_out,\n  ease_quint_in: ease_quint_in,\n  ease_quint_in_out: ease_quint_in_out,\n  ease_quint_out: ease_quint_out,\n  ease_sine_in: ease_sine_in,\n  ease_sine_in_out: ease_sine_in_out,\n  ease_sine_out: ease_sine_out,\n  quadratic_bezier: quadratic_bezier,\n  quaternion_rotation: quaternion_rotation,\n  quaternion_slerp: quaternion_slerp\n};\n\n/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n  this.trail = 0;\n}\nTimelineSegment.prototype.compile = function () {\n  return this.compiler(this);\n};\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function () {\n    return this.start + this.duration;\n  }\n});\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function (key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function (duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  let start = this.duration;\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    } else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n    this.duration = Math.max(this.duration, start + duration);\n  } else {\n    this.duration += duration;\n  }\n  let keys = Object.keys(transitions),\n    key;\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\nTimeline.prototype.processTransition = function (key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    } else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function () {\n  const c = [];\n  const keys = Object.keys(this.segments);\n  let segments;\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n    this.fillGaps(segments);\n    segments.forEach(function (s) {\n      c.push(s.compile());\n    });\n  }\n  return c;\n};\nTimeline.prototype.fillGaps = function (segments) {\n  if (segments.length === 0) return;\n  let s0, s1;\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function (key) {\n  let t = this.timeKey;\n  return this.segments[key] ? this.segments[key].map(function (s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\nconst TimelineChunks = {\n  vec3: function (n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    return `vec3 ${n} = vec3(${x}, ${y}, ${z});`;\n  },\n  vec4: function (n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    const w = (v.w || 0).toPrecision(p);\n    return `vec4 ${n} = vec4(${x}, ${y}, ${z}, ${w});`;\n  },\n  delayDuration: function (segment) {\n    return `\n    float cDelay${segment.key} = ${segment.start.toPrecision(4)};\n    float cDuration${segment.key} = ${segment.duration.toPrecision(4)};\n    `;\n  },\n  progress: function (segment) {\n    // zero duration segments should always render complete\n    if (segment.duration === 0) {\n      return `float progress = 1.0;`;\n    } else {\n      return `\n      float progress = clamp(time - cDelay${segment.key}, 0.0, cDuration${segment.key}) / cDuration${segment.key};\n      ${segment.transition.ease ? `progress = ${segment.transition.ease}(progress${segment.transition.easeParams ? `, ${segment.transition.easeParams.map(v => v.toPrecision(4)).join(`, `)}` : ``});` : ``}\n      `;\n    }\n  },\n  renderCheck: function (segment) {\n    const startTime = segment.start.toPrecision(4);\n    const endTime = (segment.end + segment.trail).toPrecision(4);\n    return `if (time < ${startTime} || time > ${endTime}) return;`;\n  }\n};\nconst TranslationSegment = {\n  compiler: function (segment) {\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cTranslateFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cTranslateTo${segment.key}`, segment.transition.to, 2)}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      v += mix(cTranslateFrom${segment.key}, cTranslateTo${segment.key}, progress);\n    }\n    `;\n  },\n  defaultFrom: new Vector3(0, 0, 0)\n};\nTimeline.register('translate', TranslationSegment);\nconst ScaleSegment = {\n  compiler: function (segment) {\n    const origin = segment.transition.origin;\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cScaleFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cScaleTo${segment.key}`, segment.transition.to, 2)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      v *= mix(cScaleFrom${segment.key}, cScaleTo${segment.key}, progress);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: new Vector3(1, 1, 1)\n};\nTimeline.register('scale', ScaleSegment);\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(segment.transition.from.axis.x, segment.transition.from.axis.y, segment.transition.from.axis.z, segment.transition.from.angle);\n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(toAxis.x, toAxis.y, toAxis.z, segment.transition.to.angle);\n    const origin = segment.transition.origin;\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {\n    axis: new Vector3(),\n    angle: 0\n  }\n};\nTimeline.register('rotate', RotationSegment);\nexport { BaseAnimationMaterial, BasicAnimationMaterial, DepthAnimationMaterial, DistanceAnimationMaterial, InstancedPrefabBufferGeometry, LambertAnimationMaterial, ModelBufferGeometry, MultiPrefabBufferGeometry, PhongAnimationMaterial, PointBufferGeometry, PointsAnimationMaterial, PrefabBufferGeometry, RotationSegment, ScaleSegment, ShaderChunk, StandardAnimationMaterial, Timeline, TimelineChunks, TimelineSegment, ToonAnimationMaterial, TranslationSegment, Utils };","map":{"version":3,"names":["ShaderMaterial","UniformsUtils","ShaderLib","RGBADepthPacking","BufferGeometry","BufferAttribute","InstancedBufferGeometry","InstancedBufferAttribute","Vector3","Math","Math$1","Vector4","BaseAnimationMaterial","constructor","parameters","uniforms","uniformValues","console","warn","Object","keys","forEach","key","setValues","merge","setUniformValues","values","value","stringifyChunk","name","join","BasicAnimationMaterial","lights","vertexShader","concatVertexShader","fragmentShader","concatFragmentShader","basic","replace","LambertAnimationMaterial","lambert","PhongAnimationMaterial","phong","StandardAnimationMaterial","extensions","derivatives","standard","ToonAnimationMaterial","toon","PointsAnimationMaterial","points","DepthAnimationMaterial","depthPacking","clipping","depth","DistanceAnimationMaterial","distanceRGBA","PrefabBufferGeometry","prefab","count","prefabGeometry","isPrefabBufferGeometry","isBufferGeometry","prefabCount","prefabVertexCount","attributes","position","vertices","length","bufferIndices","bufferPositions","prefabIndices","prefabIndexCount","index","array","i","push","prefabFaceCount","faces","face","a","b","c","indexBuffer","Uint32Array","setIndex","k","positionBuffer","createAttribute","positions","offset","j","prefabVertex","x","y","z","bufferUvs","uvBuffer","uvs","uv","faceVertexUvs","itemSize","factory","buffer","Float32Array","attribute","setAttribute","data","setPrefabData","prefabIndex","MultiPrefabBufferGeometry","prefabs","repeatCount","Array","isArray","prefabGeometries","prefabGeometriesCount","prefabVertexCounts","map","p","repeatVertexCount","reduce","r","v","repeatIndexCount","geometry","indices","indexOffset","prefabOffset","vertexCount","prefabPositions","prefabUvs","error","uvObjects","prefabGeometryIndex","prefabGeometryVertexCount","whole","wholeOffset","part","partOffset","InstancedPrefabBufferGeometry","copy","instanceCount","Utils","separateFaces","il","n","va","vb","vc","clone","computeCentroid","randomInBox","box","randFloat","min","max","randomAxis","randFloatSpread","normalize","createDepthAnimationMaterial","sourceMaterial","defines","vertexFunctions","vertexParameters","vertexInit","vertexPosition","createDistanceAnimationMaterial","ModelBufferGeometry","model","options","modelGeometry","faceCount","computeCentroids","localizeFaces","centroids","centroid","vertex","bufferSkinning","skinIndexBuffer","skinWeightBuffer","skinIndex","skinIndices","skinWeight","skinWeights","w","setFaceData","faceIndex","PointBufferGeometry","pointCount","setPointData","pointIndex","catmull_rom_spline","cubic_bezier","ease_back_in","ease_back_in_out","ease_back_out","ease_bezier","ease_bounce_in","ease_bounce_in_out","ease_bounce_out","ease_circ_in","ease_circ_in_out","ease_circ_out","ease_cubic_in","ease_cubic_in_out","ease_cubic_out","ease_elastic_in","ease_elastic_in_out","ease_elastic_out","ease_expo_in","ease_expo_in_out","ease_expo_out","ease_quad_in","ease_quad_in_out","ease_quad_out","ease_quart_in","ease_quart_in_out","ease_quart_out","ease_quint_in","ease_quint_in_out","ease_quint_out","ease_sine_in","ease_sine_in_out","ease_sine_out","quadratic_bezier","quaternion_rotation","quaternion_slerp","ShaderChunk","TimelineSegment","start","duration","transition","compiler","trail","prototype","compile","defineProperty","get","Timeline","timeKey","segments","__key","segmentDefinitions","register","definition","add","transitions","positionOffset","_eval","eval","undefined","processTransition","from","defaultFrom","to","toString","fillGaps","s","s0","s1","end","getTransformCalls","t","TimelineChunks","vec3","toPrecision","vec4","delayDuration","segment","progress","ease","easeParams","renderCheck","startTime","endTime","TranslationSegment","ScaleSegment","origin","RotationSegment","fromAxisAngle","axis","angle","toAxis","toAxisAngle"],"sources":["C:/Users/Aviral Chawla/Downloads/Attractors-buffer/Attractors-buffer/node_modules/three-bas/dist/bas.module.js"],"sourcesContent":["import { ShaderMaterial, UniformsUtils, ShaderLib, RGBADepthPacking, BufferGeometry, BufferAttribute, InstancedBufferGeometry, InstancedBufferAttribute, Vector3, Math as Math$1, Vector4 } from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.');\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key];\n      });\n\n      delete parameters.uniformValues;\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key];\n    });\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nclass BasicAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshBasicMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_basic/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['basic'].uniforms);\n\n    this.lights = false;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.basic.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.basic.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n  }\n}\n\nclass LambertAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshLambertMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_lambert/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['lambert'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.lambert.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.lambert.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PhongAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshPhongMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_phong/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['phong'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.phong.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.phong.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <lights_phong_fragment>',\n        `\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk('fragmentSpecular')}\n        `\n      )\n  }\n}\n\nclass StandardAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshStandardMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_standard/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['physical'].uniforms);\n\n    this.lights = true;\n    this.extensions = (this.extensions || {});\n    this.extensions.derivatives = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.standard.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.standard.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <roughnessmap_fragment>',\n        `\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk('fragmentRoughness')}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `\n      )\n      .replace(\n        '#include <metalnessmap_fragment>',\n        `\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk('fragmentMetalness')}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `\n      )\n  }\n}\n\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.toon.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PointsAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.PointsMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['points'].uniforms);\n\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.points.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.points.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <premultiplied_alpha_fragment>',\n        `\n        ${this.stringifyChunk('fragmentShape')}\n\n        #include <premultiplied_alpha_fragment>\n        `\n      )\n  }\n}\n\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass PrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n   *\n   * @param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    /**\n     * A reference to the prefab geometry used to create this instance.\n     * @type {Geometry|BufferGeometry}\n     */\n    this.prefabGeometry = prefab;\n    this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = count;\n\n    /**\n     * Number of vertices of the prefab.\n     * @type {Number}\n     */\n    if (this.isPrefabBufferGeometry) {\n      this.prefabVertexCount = prefab.attributes.position.count;\n    }\n    else {\n      this.prefabVertexCount = prefab.vertices.length;\n    }\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let prefabIndices = [];\n    let prefabIndexCount;\n\n    if (this.isPrefabBufferGeometry) {\n      if (this.prefabGeometry.index) {\n        prefabIndexCount = this.prefabGeometry.index.count;\n        prefabIndices = this.prefabGeometry.index.array;\n      }\n      else {\n        prefabIndexCount = this.prefabVertexCount;\n\n        for (let i = 0; i < prefabIndexCount; i++) {\n          prefabIndices.push(i);\n        }\n      }\n    }\n    else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      prefabIndexCount = prefabFaceCount * 3;\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        prefabIndices.push(face.a, face.b, face.c);\n      }\n    }\n\n    const indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      for (let k = 0; k < prefabIndexCount; k++) {\n        indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * this.prefabVertexCount;\n      }\n    }\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const positions = this.prefabGeometry.attributes.position.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          positionBuffer[offset    ] = positions[j * 3];\n          positionBuffer[offset + 1] = positions[j * 3 + 1];\n          positionBuffer[offset + 2] = positions[j * 3 + 2];\n        }\n      }\n    }\n    else {\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          const prefabVertex = this.prefabGeometry.vertices[j];\n\n          positionBuffer[offset    ] = prefabVertex.x;\n          positionBuffer[offset + 1] = prefabVertex.y;\n          positionBuffer[offset + 2] = prefabVertex.z;\n        }\n      }\n    }\n  }\n\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const uvs = this.prefabGeometry.attributes.uv.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          uvBuffer[offset    ] = uvs[j * 2];\n          uvBuffer[offset + 1] = uvs[j * 2 + 1];\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      const uvs = [];\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        const uv = this.prefabGeometry.faceVertexUvs[0][i];\n\n        uvs[face.a] = uv[0];\n        uvs[face.b] = uv[1];\n        uvs[face.c] = uv[2];\n      }\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          const uv = uvs[j];\n\n          uvBuffer[offset] = uv.x;\n          uvBuffer[offset + 1] = uv.y;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * this.prefabVertexCount * attribute.itemSize;\n\n    for (let i = 0; i < this.prefabVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass MultiPrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry array is repeated a number of times.\n   *\n   * @param {Array} prefabs An array with Geometry instances to repeat.\n   * @param {Number} repeatCount The number of times to repeat the array of Geometries.\n   * @constructor\n   */\n  constructor (prefabs, repeatCount) {\n    super();\n\n    if (Array.isArray(prefabs)) {\n      this.prefabGeometries = prefabs;\n    } else {\n      this.prefabGeometries = [prefabs];\n    }\n\n    this.prefabGeometriesCount = this.prefabGeometries.length;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = repeatCount * this.prefabGeometriesCount;\n    /**\n     * How often the prefab array is repeated.\n     * @type {Number}\n     */\n    this.repeatCount = repeatCount;\n\n    /**\n     * Array of vertex counts per prefab.\n     * @type {Array}\n     */\n    this.prefabVertexCounts = this.prefabGeometries.map(p => p.isBufferGeometry ? p.attributes.position.count : p.vertices.length);\n    /**\n     * Total number of vertices for one repetition of the prefabs\n     * @type {number}\n     */\n    this.repeatVertexCount = this.prefabVertexCounts.reduce((r, v) => r + v, 0);\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let repeatIndexCount = 0;\n\n    this.prefabIndices = this.prefabGeometries.map(geometry => {\n      let indices = [];\n\n      if (geometry.isBufferGeometry) {\n        if (geometry.index) {\n          indices = geometry.index.array;\n        } else {\n          for (let i = 0; i < geometry.attributes.position.count; i++) {\n            indices.push(i);\n          }\n        }\n      } else {\n        for (let i = 0; i < geometry.faces.length; i++) {\n          const face = geometry.faces[i];\n          indices.push(face.a, face.b, face.c);\n        }\n      }\n\n      repeatIndexCount += indices.length;\n\n      return indices;\n    });\n\n    const indexBuffer = new Uint32Array(repeatIndexCount * this.repeatCount);\n    let indexOffset = 0;\n    let prefabOffset = 0;\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometriesCount;\n      const indices = this.prefabIndices[index];\n      const vertexCount = this.prefabVertexCounts[index];\n\n      for (let j = 0; j < indices.length; j++) {\n        indexBuffer[indexOffset++] = indices[j] + prefabOffset;\n      }\n\n      prefabOffset += vertexCount;\n    }\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    const prefabPositions = this.prefabGeometries.map((geometry, i) => {\n      let positions;\n\n      if (geometry.isBufferGeometry) {\n        positions = geometry.attributes.position.array;\n      } else {\n\n        const vertexCount = this.prefabVertexCounts[i];\n\n        positions = [];\n\n        for (let j = 0, offset = 0; j < vertexCount; j++) {\n          const prefabVertex = geometry.vertices[j];\n\n          positions[offset++] = prefabVertex.x;\n          positions[offset++] = prefabVertex.y;\n          positions[offset++] = prefabVertex.z;\n        }\n      }\n\n      return positions;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const positions = prefabPositions[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        positionBuffer[offset++] = positions[j * 3];\n        positionBuffer[offset++] = positions[j * 3 + 1];\n        positionBuffer[offset++] = positions[j * 3 + 2];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    const prefabUvs = this.prefabGeometries.map((geometry, i) => {\n      let uvs;\n\n      if (geometry.isBufferGeometry) {\n        if (!geometry.attributes.uv) {\n          console.error('No UV found in prefab geometry', geometry);\n        }\n\n        uvs = geometry.attributes.uv.array;\n      } else {\n        const prefabFaceCount = this.prefabIndices[i].length / 3;\n        const uvObjects = [];\n\n        for (let j = 0; j < prefabFaceCount; j++) {\n          const face = geometry.faces[j];\n          const uv = geometry.faceVertexUvs[0][j];\n\n          uvObjects[face.a] = uv[0];\n          uvObjects[face.b] = uv[1];\n          uvObjects[face.c] = uv[2];\n        }\n\n        uvs = [];\n\n        for (let k = 0; k < uvObjects.length; k++) {\n          uvs[k * 2] = uvObjects[k].x;\n          uvs[k * 2 + 1] = uvObjects[k].y;\n        }\n      }\n\n      return uvs;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const uvs = prefabUvs[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        uvBuffer[offset++] = uvs[j * 2];\n        uvBuffer[offset++] = uvs[j * 2 + 1];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n   createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.repeatCount * this.repeatVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n   }\n\n   /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    const prefabGeometryIndex = prefabIndex % this.prefabGeometriesCount;\n    const prefabGeometryVertexCount = this.prefabVertexCounts[prefabGeometryIndex];\n    const whole = (prefabIndex / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount;\n    const wholeOffset = whole * this.repeatVertexCount;\n    const part = prefabIndex - whole;\n    let partOffset = 0;\n    let i = 0;\n\n    while(i < part) {\n      partOffset += this.prefabVertexCounts[i++];\n    }\n\n    let offset = (wholeOffset + partOffset) * attribute.itemSize;\n\n    for (let i = 0; i < prefabGeometryVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass InstancedPrefabBufferGeometry extends InstancedBufferGeometry {\n  /**\n   * A wrapper around THREE.InstancedBufferGeometry, which is more memory efficient than PrefabBufferGeometry, but requires the ANGLE_instanced_arrays extension.\n   *\n   * @param {BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    this.prefabGeometry = prefab;\n    this.copy(prefab);\n\n    this.instanceCount = count;\n    this.prefabCount = count;\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * itemSize);\n    const attribute = new InstancedBufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  };\n\n  /**\n   * Sets data for a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  };\n}\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloat(box.min.x, box.max.x);\n    v.y = Math$1.randFloat(box.min.y, box.max.y);\n    v.z = Math$1.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloatSpread(2.0);\n    v.y = Math$1.randFloatSpread(2.0);\n    v.z = Math$1.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass PointBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry consists of points.\n   * @param {Number} count The number of points.\n   * @constructor\n   */\n  constructor (count) {\n    super();\n\n    /**\n     * Number of points.\n     * @type {Number}\n     */\n    this.pointCount = count;\n\n    this.bufferPositions();\n  }\n\n  bufferPositions () {\n    this.createAttribute('position', 3);\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each point upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPointData.\n   *\n   * @returns {THREE.BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.pointCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.pointCount; i++) {\n        factory(data, i, this.pointCount);\n        this.setPointData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  setPointData (attribute, pointIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = pointIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\n\nvar catmull_rom_spline = \"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\\n    vec4 v0 = (p2 - p0) * c.x;\\n    vec4 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\\n    vec3 v0 = (p2 - p0) * c.x;\\n    vec3 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\\n    vec2 v0 = (p2 - p0) * c.x;\\n    vec2 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\\n    float v0 = (p2 - p0) * c.x;\\n    float v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nivec4 getCatmullRomSplineIndices(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(max(0.0, index - 1.0));\\n    int i1 = int(index);\\n    int i2 = int(min(index + 1.0, l));\\n    int i3 = int(min(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(index == 0.0 ? l : index - 1.0);\\n    int i1 = int(index);\\n    int i2 = int(mod(index + 1.0, l));\\n    int i3 = int(mod(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\n\";\n\nvar cubic_bezier = \"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\n\";\n\nvar ease_back_in = \"float easeBackIn(float p, float amplitude) {\\n    return p * p * ((amplitude + 1.0) * p - amplitude);\\n}\\nfloat easeBackIn(float p) {\\n    return easeBackIn(p, 1.70158);\\n}\\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackIn(t / d, amplitude) * c;\\n}\\nfloat easeBackIn(float t, float b, float c, float d) {\\n    return b + easeBackIn(t / d) * c;\\n}\\n\";\n\nvar ease_back_in_out = \"float easeBackInOut(float p, float amplitude) {\\n    amplitude *= 1.525;\\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\\n}\\nfloat easeBackInOut(float p) {\\n    return easeBackInOut(p, 1.70158);\\n}\\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackInOut(t / d, amplitude) * c;\\n}\\nfloat easeBackInOut(float t, float b, float c, float d) {\\n    return b + easeBackInOut(t / d) * c;\\n}\\n\";\n\nvar ease_back_out = \"float easeBackOut(float p, float amplitude) {\\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\\n}\\nfloat easeBackOut(float p) {\\n    return easeBackOut(p, 1.70158);\\n}\\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackOut(t / d, amplitude) * c;\\n}\\nfloat easeBackOut(float t, float b, float c, float d) {\\n    return b + easeBackOut(t / d) * c;\\n}\\n\";\n\nvar ease_bezier = \"float easeBezier(float p, vec4 curve) {\\n    float ip = 1.0 - p;\\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\\n}\\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\\n    return b + easeBezier(t / d, curve) * c;\\n}\\n\";\n\nvar ease_bounce_in = \"float easeBounceIn(float p) {\\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\\n        return 1.0 - (7.5625 * p * p);\\n    } else if (p < 2.0 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\\n    } else if (p < 2.5 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\\n    }\\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\\n}\\nfloat easeBounceIn(float t, float b, float c, float d) {\\n    return b + easeBounceIn(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_in_out = \"float easeBounceInOut(float p) {\\n    bool invert = (p < 0.5);\\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\\n    if (p < 1.0 / 2.75) {\\n        p = 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    } else {\\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n    }\\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\\n}\\nfloat easeBounceInOut(float t, float b, float c, float d) {\\n    return b + easeBounceInOut(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_out = \"float easeBounceOut(float p) {\\n    if (p < 1.0 / 2.75) {\\n        return 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    }\\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n}\\nfloat easeBounceOut(float t, float b, float c, float d) {\\n    return b + easeBounceOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in = \"float easeCircIn(float p) {\\n    return -(sqrt(1.0 - p * p) - 1.0);\\n}\\nfloat easeCircIn(float t, float b, float c, float d) {\\n    return b + easeCircIn(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in_out = \"float easeCircInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\\n}\\nfloat easeCircInOut(float t, float b, float c, float d) {\\n    return b + easeCircInOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_out = \"float easeCircOut(float p) {\\n  return sqrt(1.0 - (p = p - 1.0) * p);\\n}\\nfloat easeCircOut(float t, float b, float c, float d) {\\n  return b + easeCircOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in = \"float easeCubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat easeCubicIn(float t, float b, float c, float d) {\\n  return b + easeCubicIn(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in_out = \"float easeCubicInOut(float t) {\\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\\n}\\nfloat easeCubicInOut(float t, float b, float c, float d) {\\n  return b + easeCubicInOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_out = \"float easeCubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\nfloat easeCubicOut(float t, float b, float c, float d) {\\n  return b + easeCubicOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in = \"float easeElasticIn(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\\n}\\nfloat easeElasticIn(float p) {\\n    return easeElasticIn(p, 1.0, 0.3);\\n}\\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticIn(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticIn(float t, float b, float c, float d) {\\n    return b + easeElasticIn(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in_out = \"float easeElasticInOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\\n}\\nfloat easeElasticInOut(float p) {\\n    return easeElasticInOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d) {\\n    return b + easeElasticInOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_out = \"float easeElasticOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\\n}\\nfloat easeElasticOut(float p) {\\n    return easeElasticOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticOut(float t, float b, float c, float d) {\\n    return b + easeElasticOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in = \"float easeExpoIn(float p) {\\n    return pow(2.0, 10.0 * (p - 1.0));\\n}\\nfloat easeExpoIn(float t, float b, float c, float d) {\\n    return b + easeExpoIn(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in_out = \"float easeExpoInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\\n}\\nfloat easeExpoInOut(float t, float b, float c, float d) {\\n    return b + easeExpoInOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_out = \"float easeExpoOut(float p) {\\n  return 1.0 - pow(2.0, -10.0 * p);\\n}\\nfloat easeExpoOut(float t, float b, float c, float d) {\\n  return b + easeExpoOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in = \"float easeQuadIn(float t) {\\n    return t * t;\\n}\\nfloat easeQuadIn(float t, float b, float c, float d) {\\n  return b + easeQuadIn(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in_out = \"float easeQuadInOut(float t) {\\n    float p = 2.0 * t * t;\\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\nfloat easeQuadInOut(float t, float b, float c, float d) {\\n    return b + easeQuadInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_out = \"float easeQuadOut(float t) {\\n  return -t * (t - 2.0);\\n}\\nfloat easeQuadOut(float t, float b, float c, float d) {\\n  return b + easeQuadOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in = \"float easeQuartIn(float t) {\\n  return t * t * t * t;\\n}\\nfloat easeQuartIn(float t, float b, float c, float d) {\\n  return b + easeQuartIn(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in_out = \"float easeQuartInOut(float t) {\\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\nfloat easeQuartInOut(float t, float b, float c, float d) {\\n    return b + easeQuartInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_out = \"float easeQuartOut(float t) {\\n  return 1.0 - pow(1.0 - t, 4.0);\\n}\\nfloat easeQuartOut(float t, float b, float c, float d) {\\n  return b + easeQuartOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in = \"float easeQuintIn(float t) {\\n    return pow(t, 5.0);\\n}\\nfloat easeQuintIn(float t, float b, float c, float d) {\\n    return b + easeQuintIn(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in_out = \"float easeQuintInOut(float t) {\\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\\n}\\nfloat easeQuintInOut(float t, float b, float c, float d) {\\n    return b + easeQuintInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_out = \"float easeQuintOut(float t) {\\n    return (t -= 1.0) * t * t * t * t + 1.0;\\n}\\nfloat easeQuintOut(float t, float b, float c, float d) {\\n    return b + easeQuintOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in = \"float easeSineIn(float p) {\\n  return -cos(p * 1.57079632679) + 1.0;\\n}\\nfloat easeSineIn(float t, float b, float c, float d) {\\n  return b + easeSineIn(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in_out = \"float easeSineInOut(float p) {\\n  return -0.5 * (cos(PI * p) - 1.0);\\n}\\nfloat easeSineInOut(float t, float b, float c, float d) {\\n  return b + easeSineInOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_out = \"float easeSineOut(float p) {\\n  return sin(p * 1.57079632679);\\n}\\nfloat easeSineOut(float t, float b, float c, float d) {\\n  return b + easeSineOut(t / d) * c;\\n}\\n\";\n\nvar quadratic_bezier = \"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\";\n\nvar quaternion_rotation = \"vec3 rotateVector(vec4 q, vec3 v) {\\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\\n    float halfAngle = angle * 0.5;\\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\\n}\\n\";\n\nvar quaternion_slerp = \"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\\n    float s = 1.0 - t;\\n    float c = dot(q0, q1);\\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\\n    if (sqrSn > 2.220446049250313e-16) {\\n        float sn = sqrt(sqrSn);\\n        float len = atan(sn, c * dir);\\n        s = sin(s * len) / sn;\\n        t = sin(t * len) / sn;\\n    }\\n    float tDir = t * dir;\\n    return normalize(q0 * s + q1 * tDir);\\n}\\n\";\n\n// generated by scripts/build_shader_chunks.js\n\n\nconst ShaderChunk = {\n  catmull_rom_spline: catmull_rom_spline,\n  cubic_bezier: cubic_bezier,\n  ease_back_in: ease_back_in,\n  ease_back_in_out: ease_back_in_out,\n  ease_back_out: ease_back_out,\n  ease_bezier: ease_bezier,\n  ease_bounce_in: ease_bounce_in,\n  ease_bounce_in_out: ease_bounce_in_out,\n  ease_bounce_out: ease_bounce_out,\n  ease_circ_in: ease_circ_in,\n  ease_circ_in_out: ease_circ_in_out,\n  ease_circ_out: ease_circ_out,\n  ease_cubic_in: ease_cubic_in,\n  ease_cubic_in_out: ease_cubic_in_out,\n  ease_cubic_out: ease_cubic_out,\n  ease_elastic_in: ease_elastic_in,\n  ease_elastic_in_out: ease_elastic_in_out,\n  ease_elastic_out: ease_elastic_out,\n  ease_expo_in: ease_expo_in,\n  ease_expo_in_out: ease_expo_in_out,\n  ease_expo_out: ease_expo_out,\n  ease_quad_in: ease_quad_in,\n  ease_quad_in_out: ease_quad_in_out,\n  ease_quad_out: ease_quad_out,\n  ease_quart_in: ease_quart_in,\n  ease_quart_in_out: ease_quart_in_out,\n  ease_quart_out: ease_quart_out,\n  ease_quint_in: ease_quint_in,\n  ease_quint_in_out: ease_quint_in_out,\n  ease_quint_out: ease_quint_out,\n  ease_sine_in: ease_sine_in,\n  ease_sine_in_out: ease_sine_in_out,\n  ease_sine_out: ease_sine_out,\n  quadratic_bezier: quadratic_bezier,\n  quaternion_rotation: quaternion_rotation,\n  quaternion_slerp: quaternion_slerp,\n\n};\n\n/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n\n  this.trail = 0;\n}\n\nTimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};\n\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function() {\n    return this.start + this.duration;\n  }\n});\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function(key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  \n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function(duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  \n  let start = this.duration;\n\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    }\n    else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n\n    this.duration = Math.max(this.duration, start + duration);\n  }\n  else {\n    this.duration += duration;\n  }\n\n  let keys = Object.keys(transitions), key;\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\n\nTimeline.prototype.processTransition = function(key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    }\n    else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};\nTimeline.prototype.fillGaps = function(segments) {\n  if (segments.length === 0) return;\n\n  let s0, s1;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\n\nconst TimelineChunks = {\n  vec3: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n\n    return `vec3 ${n} = vec3(${x}, ${y}, ${z});`;\n  },\n  vec4: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    const w = (v.w || 0).toPrecision(p);\n  \n    return `vec4 ${n} = vec4(${x}, ${y}, ${z}, ${w});`;\n  },\n  delayDuration: function(segment) {\n    return `\n    float cDelay${segment.key} = ${segment.start.toPrecision(4)};\n    float cDuration${segment.key} = ${segment.duration.toPrecision(4)};\n    `;\n  },\n  progress: function(segment) {\n    // zero duration segments should always render complete\n    if (segment.duration === 0) {\n      return `float progress = 1.0;`\n    }\n    else {\n      return `\n      float progress = clamp(time - cDelay${segment.key}, 0.0, cDuration${segment.key}) / cDuration${segment.key};\n      ${segment.transition.ease ? `progress = ${segment.transition.ease}(progress${(segment.transition.easeParams ? `, ${segment.transition.easeParams.map((v) => v.toPrecision(4)).join(`, `)}` : ``)});` : ``}\n      `;\n    }\n  },\n  renderCheck: function(segment) {\n    const startTime = segment.start.toPrecision(4);\n    const endTime = (segment.end + segment.trail).toPrecision(4);\n\n    return `if (time < ${startTime} || time > ${endTime}) return;`;\n  }\n};\n\nconst TranslationSegment = {\n  compiler: function(segment) {\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cTranslateFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cTranslateTo${segment.key}`, segment.transition.to, 2)}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      v += mix(cTranslateFrom${segment.key}, cTranslateTo${segment.key}, progress);\n    }\n    `;\n  },\n  defaultFrom: new Vector3(0, 0, 0)\n};\n\nTimeline.register('translate', TranslationSegment);\n\nconst ScaleSegment = {\n  compiler: function(segment) {\n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cScaleFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cScaleTo${segment.key}`, segment.transition.to, 2)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      v *= mix(cScaleFrom${segment.key}, cScaleTo${segment.key}, progress);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: new Vector3(1, 1, 1)\n};\n\nTimeline.register('scale', ScaleSegment);\n\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(\n      segment.transition.from.axis.x,\n      segment.transition.from.axis.y,\n      segment.transition.from.axis.z,\n      segment.transition.from.angle\n    );\n  \n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(\n      toAxis.x,\n      toAxis.y,\n      toAxis.z,\n      segment.transition.to.angle\n    );\n  \n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {axis: new Vector3(), angle: 0}\n};\n\nTimeline.register('rotate', RotationSegment);\n\nexport { BaseAnimationMaterial, BasicAnimationMaterial, DepthAnimationMaterial, DistanceAnimationMaterial, InstancedPrefabBufferGeometry, LambertAnimationMaterial, ModelBufferGeometry, MultiPrefabBufferGeometry, PhongAnimationMaterial, PointBufferGeometry, PointsAnimationMaterial, PrefabBufferGeometry, RotationSegment, ScaleSegment, ShaderChunk, StandardAnimationMaterial, Timeline, TimelineChunks, TimelineSegment, ToonAnimationMaterial, TranslationSegment, Utils };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}