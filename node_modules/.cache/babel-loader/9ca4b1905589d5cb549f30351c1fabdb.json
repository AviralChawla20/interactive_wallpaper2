{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, MeshBasicMaterial, LinearMipmapLinearFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super();\n    this.resolution = resolution !== void 0 ? resolution : 256;\n    this.needsInit = true;\n    this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    this.luminanceRT = null;\n    this.previousLuminanceRT = null;\n    this.currentLuminanceRT = null;\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: {\n          value: null\n        },\n        currentLum: {\n          value: null\n        },\n        minLuminance: {\n          value: 0.01\n        },\n        delta: {\n          value: 0.016\n        },\n        tau: {\n          value: 1\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`\n    };\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }\n  reset() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n    this.previousLuminanceRT.texture.generateMipmaps = false;\n    const pars = {\n      minFilter: LinearMipmapLinearFilter,\n      generateMipmaps: true\n    };\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n    if (this.adaptive) {\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    }\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 7829367\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  }\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  }\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  }\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  }\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  }\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n}\nexport { AdaptiveToneMappingPass };","map":{"version":3,"sources":["../../src/postprocessing/AdaptiveToneMappingPass.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  LinearMipmapLinearFilter,\n  MeshBasicMaterial,\n  NoBlending,\n  ShaderMaterial,\n  UniformsUtils,\n  WebGLRenderTarget,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { LuminosityShader } from '../shaders/LuminosityShader'\nimport { ToneMapShader } from '../shaders/ToneMapShader'\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super()\n\n    this.resolution = resolution !== undefined ? resolution : 256\n    this.needsInit = true\n    this.adaptive = adaptive !== undefined ? !!adaptive : true\n\n    this.luminanceRT = null\n    this.previousLuminanceRT = null\n    this.currentLuminanceRT = null\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n    })\n\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1),\n      },\n      uniforms: {\n        lastLum: { value: null },\n        currentLum: { value: null },\n        minLuminance: { value: 0.01 },\n        delta: { value: 0.016 },\n        tau: { value: 1.0 },\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`,\n    }\n\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending,\n    })\n\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime /*, maskActive*/) {\n    if (this.needsInit) {\n      this.reset(renderer)\n\n      this.luminanceRT.texture.type = readBuffer.texture.type\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type\n      this.needsInit = false\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture\n      renderer.setRenderTarget(this.currentLuminanceRT)\n      this.fsQuad.render(renderer)\n\n      //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n      this.fsQuad.material = this.materialAdaptiveLum\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture\n      renderer.setRenderTarget(this.luminanceRT)\n      this.fsQuad.render(renderer)\n\n      //Copy the new adapted luminance value so that it can be used by the next frame.\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture\n      renderer.setRenderTarget(this.previousLuminanceRT)\n      this.fsQuad.render(renderer)\n    }\n\n    this.fsQuad.material = this.materialToneMap\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    } else {\n      renderer.setRenderTarget(writeBuffer)\n\n      if (this.clear) renderer.clear()\n\n      this.fsQuad.render(renderer)\n    }\n  }\n\n  reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose()\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose()\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose()\n    }\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution)\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l'\n    this.luminanceRT.texture.generateMipmaps = false\n\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution)\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl'\n    this.previousLuminanceRT.texture.generateMipmaps = false\n\n    // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    const pars = { minFilter: LinearMipmapLinearFilter, generateMipmaps: true }\n\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars)\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl'\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = ''\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture\n    }\n\n    //Put something in the adaptive luminance texture so that the scene can render initially\n    this.fsQuad.material = new MeshBasicMaterial({ color: 0x777777 })\n    this.materialLuminance.needsUpdate = true\n    this.materialAdaptiveLum.needsUpdate = true\n    this.materialToneMap.needsUpdate = true\n    // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  }\n\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = ''\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture\n    } else {\n      this.adaptive = false\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE']\n      this.materialToneMap.uniforms.luminanceMap.value = null\n    }\n\n    this.materialToneMap.needsUpdate = true\n  }\n\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate)\n    }\n  }\n\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum\n    }\n  }\n\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum\n    }\n  }\n\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum\n    }\n  }\n\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey\n    }\n  }\n\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose()\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose()\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose()\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose()\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose()\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose()\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose()\n    }\n  }\n}\n\nexport { AdaptiveToneMappingPass }\n"]},"metadata":{},"sourceType":"module"}