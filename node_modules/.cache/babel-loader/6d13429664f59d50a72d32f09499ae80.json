{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from \"three\";\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.debug = false;\n    this.group = null;\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group();\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n    this.readFile(arraybuffer, path);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i]);\n    }\n    return this.group;\n  }\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer);\n    const chunk = this.readChunk(data);\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data);\n          this.debugMessage(\"3DS file version: \" + version);\n        } else if (next === MDATA) {\n          this.resetPosition(data);\n          this.readMeshData(data, path);\n        } else {\n          this.debugMessage(\"Unknown main chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n    }\n    this.debugMessage(\"Parsed \" + this.meshes.length + \" meshes\");\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data);\n        this.debugMessage(\"Mesh Version: \" + version);\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data);\n        this.debugMessage(\"Master scale: \" + scale);\n        this.group.scale.set(scale, scale, scale);\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage(\"Named Object\");\n        this.resetPosition(data);\n        this.readNamedObject(data);\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage(\"Material\");\n        this.resetPosition(data);\n        this.readMaterialEntry(data, path);\n      } else {\n        this.debugMessage(\"Unknown MDATA chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n  }\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n  readNamedObject(data) {\n    const chunk = this.readChunk(data);\n    const name = this.readString(data, 64);\n    chunk.cur = this.position;\n    let next = this.nextChunk(data, chunk);\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data);\n        const mesh = this.readMesh(data);\n        mesh.name = name;\n        this.meshes.push(mesh);\n      } else {\n        this.debugMessage(\"Unknown named object chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n  }\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const material = new MeshPhongMaterial();\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64);\n        this.debugMessage(\"   Name: \" + material.name);\n      } else if (next === MAT_WIRE) {\n        this.debugMessage(\"   Wireframe\");\n        material.wireframe = true;\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data);\n        material.wireframeLinewidth = value;\n        this.debugMessage(\"   Wireframe Thickness: \" + value);\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide;\n        this.debugMessage(\"   DoubleSided\");\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage(\"   Additive Blending\");\n        material.blending = AdditiveBlending;\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage(\"   Diffuse Color\");\n        material.color = this.readColor(data);\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage(\"   Specular Color\");\n        material.specular = this.readColor(data);\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage(\"   Ambient color\");\n        material.color = this.readColor(data);\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data);\n        material.shininess = shininess * 100;\n        this.debugMessage(\"   Shininess : \" + shininess);\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data);\n        material.opacity = 1 - transparency;\n        this.debugMessage(\"  Transparency : \" + transparency);\n        material.transparent = material.opacity < 1 ? true : false;\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage(\"   ColorMap\");\n        this.resetPosition(data);\n        material.map = this.readMap(data, path);\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage(\"   BumpMap\");\n        this.resetPosition(data);\n        material.bumpMap = this.readMap(data, path);\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage(\"   OpacityMap\");\n        this.resetPosition(data);\n        material.alphaMap = this.readMap(data, path);\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage(\"   SpecularMap\");\n        this.resetPosition(data);\n        material.specularMap = this.readMap(data, path);\n      } else {\n        this.debugMessage(\"   Unknown material chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    this.materials[material.name] = material;\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n  readMesh(data) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const geometry = new BufferGeometry();\n    const material = new MeshPhongMaterial();\n    const mesh = new Mesh(geometry, material);\n    mesh.name = \"mesh\";\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data);\n        this.debugMessage(\"   Vertex: \" + points);\n        const vertices = [];\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n        }\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data);\n        this.readFaceArray(data, mesh);\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data);\n        this.debugMessage(\"   UV: \" + texels);\n        const uvs = [];\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data));\n          uvs.push(this.readFloat(data));\n        }\n        geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage(\"   Tranformation Matrix (TODO)\");\n        const values = [];\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data);\n        }\n        const matrix = new Matrix4();\n        matrix.elements[0] = values[0];\n        matrix.elements[1] = values[6];\n        matrix.elements[2] = values[3];\n        matrix.elements[3] = values[9];\n        matrix.elements[4] = values[2];\n        matrix.elements[5] = values[8];\n        matrix.elements[6] = values[5];\n        matrix.elements[7] = values[11];\n        matrix.elements[8] = values[1];\n        matrix.elements[9] = values[7];\n        matrix.elements[10] = values[4];\n        matrix.elements[11] = values[10];\n        matrix.elements[12] = 0;\n        matrix.elements[13] = 0;\n        matrix.elements[14] = 0;\n        matrix.elements[15] = 1;\n        matrix.transpose();\n        const inverse = new Matrix4();\n        inverse.copy(matrix).invert();\n        geometry.applyMatrix4(inverse);\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      } else {\n        this.debugMessage(\"   Unknown mesh chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    geometry.computeVertexNormals();\n    return mesh;\n  }\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data);\n    const faces = this.readWord(data);\n    this.debugMessage(\"   Faces: \" + faces);\n    const index = [];\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n      this.readWord(data);\n    }\n    mesh.geometry.setIndex(index);\n    let materialIndex = 0;\n    let start = 0;\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data);\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage(\"      Material Group\");\n        this.resetPosition(data);\n        const group = this.readMaterialGroup(data);\n        const count = group.index.length * 3;\n        mesh.geometry.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex++;\n        const material = this.materials[group.name];\n        if (Array.isArray(mesh.material) === false) mesh.material = [];\n        if (material !== void 0) {\n          mesh.material.push(material);\n        }\n      } else {\n        this.debugMessage(\"      Unknown face array chunk: \" + subchunk.toString(16));\n      }\n      this.endChunk(subchunk);\n    }\n    if (mesh.material.length === 1) mesh.material = mesh.material[0];\n    this.endChunk(chunk);\n  }\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    let texture = {};\n    const loader = new TextureLoader(this.manager);\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128);\n        texture = loader.load(name);\n        this.debugMessage(\"      File: \" + path + name);\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data);\n        this.debugMessage(\"      OffsetX: \" + texture.offset.x);\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data);\n        this.debugMessage(\"      OffsetY: \" + texture.offset.y);\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data);\n        this.debugMessage(\"      RepeatX: \" + texture.repeat.x);\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data);\n        this.debugMessage(\"      RepeatY: \" + texture.repeat.y);\n      } else {\n        this.debugMessage(\"      Unknown map chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    return texture;\n  }\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(data) {\n    this.readChunk(data);\n    const name = this.readString(data, 64);\n    const numFaces = this.readWord(data);\n    this.debugMessage(\"         Name: \" + name);\n    this.debugMessage(\"         Faces: \" + numFaces);\n    const index = [];\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data));\n    }\n    return {\n      name,\n      index\n    };\n  }\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n  readColor(data) {\n    const chunk = this.readChunk(data);\n    const color = new Color();\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data);\n      const g = this.readByte(data);\n      const b = this.readByte(data);\n      color.setRGB(r / 255, g / 255, b / 255);\n      this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data);\n      const g = this.readFloat(data);\n      const b = this.readFloat(data);\n      color.setRGB(r, g, b);\n      this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n    } else {\n      this.debugMessage(\"      Unknown color chunk: \" + chunk.toString(16));\n    }\n    this.endChunk(chunk);\n    return color;\n  }\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n  readChunk(data) {\n    const chunk = {};\n    chunk.cur = this.position;\n    chunk.id = this.readWord(data);\n    chunk.size = this.readDWord(data);\n    chunk.end = chunk.cur + chunk.size;\n    chunk.cur += 6;\n    return chunk;\n  }\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n  endChunk(chunk) {\n    this.position = chunk.end;\n  }\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0;\n    }\n    this.position = chunk.cur;\n    try {\n      const next = this.readChunk(data);\n      chunk.cur += next.size;\n      return next.id;\n    } catch (e) {\n      this.debugMessage(\"Unable to read chunk at \" + this.position);\n      return 0;\n    }\n  }\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n  resetPosition() {\n    this.position -= 6;\n  }\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readByte(data) {\n    const v = data.getUint8(this.position, true);\n    this.position += 1;\n    return v;\n  }\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true);\n      this.position += 4;\n      return v;\n    } catch (e) {\n      this.debugMessage(e + \" \" + this.position + \" \" + data.byteLength);\n    }\n  }\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readInt(data) {\n    const v = data.getInt32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readShort(data) {\n    const v = data.getInt16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readDWord(data) {\n    const v = data.getUint32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readWord(data) {\n    const v = data.getUint16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n  readString(data, maxLength) {\n    let s = \"\";\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data);\n      if (!c) {\n        break;\n      }\n      s += String.fromCharCode(c);\n    }\n    return s;\n  }\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readPercentage(data) {\n    const chunk = this.readChunk(data);\n    let value;\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100;\n        break;\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data);\n        break;\n      default:\n        this.debugMessage(\"      Unknown percentage chunk: \" + chunk.toString(16));\n    }\n    this.endChunk(chunk);\n    return value;\n  }\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message);\n    }\n  }\n}\nconst M3DMAGIC = 19789;\nconst MLIBMAGIC = 15786;\nconst CMAGIC = 49725;\nconst M3D_VERSION = 2;\nconst COLOR_F = 16;\nconst COLOR_24 = 17;\nconst LIN_COLOR_24 = 18;\nconst LIN_COLOR_F = 19;\nconst INT_PERCENTAGE = 48;\nconst FLOAT_PERCENTAGE = 49;\nconst MDATA = 15677;\nconst MESH_VERSION = 15678;\nconst MASTER_SCALE = 256;\nconst MAT_ENTRY = 45055;\nconst MAT_NAME = 40960;\nconst MAT_AMBIENT = 40976;\nconst MAT_DIFFUSE = 40992;\nconst MAT_SPECULAR = 41008;\nconst MAT_SHININESS = 41024;\nconst MAT_TRANSPARENCY = 41040;\nconst MAT_TWO_SIDE = 41089;\nconst MAT_ADDITIVE = 41091;\nconst MAT_WIRE = 41093;\nconst MAT_WIRE_SIZE = 41095;\nconst MAT_TEXMAP = 41472;\nconst MAT_OPACMAP = 41488;\nconst MAT_BUMPMAP = 41520;\nconst MAT_SPECMAP = 41476;\nconst MAT_MAPNAME = 41728;\nconst MAT_MAP_USCALE = 41812;\nconst MAT_MAP_VSCALE = 41814;\nconst MAT_MAP_UOFFSET = 41816;\nconst MAT_MAP_VOFFSET = 41818;\nconst NAMED_OBJECT = 16384;\nconst N_TRI_OBJECT = 16640;\nconst POINT_ARRAY = 16656;\nconst FACE_ARRAY = 16672;\nconst MSH_MAT_GROUP = 16688;\nconst TEX_VERTS = 16704;\nconst MESH_MATRIX = 16736;\nexport { TDSLoader };","map":{"version":3,"sources":["../../src/loaders/TDSLoader.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  AdditiveBlending,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  TextureLoader,\n} from 'three'\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.debug = false\n\n    this.group = null\n    this.position = 0\n\n    this.materials = []\n    this.meshes = []\n  }\n\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group()\n    this.position = 0\n    this.materials = []\n    this.meshes = []\n\n    this.readFile(arraybuffer, path)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i])\n    }\n\n    return this.group\n  }\n\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer)\n    const chunk = this.readChunk(data)\n\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk)\n\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data)\n          this.debugMessage('3DS file version: ' + version)\n        } else if (next === MDATA) {\n          this.resetPosition(data)\n          this.readMeshData(data, path)\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.toString(16))\n        }\n\n        next = this.nextChunk(data, chunk)\n      }\n    }\n\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes')\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data)\n        this.debugMessage('Mesh Version: ' + version)\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data)\n        this.debugMessage('Master scale: ' + scale)\n        this.group.scale.set(scale, scale, scale)\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage('Named Object')\n        this.resetPosition(data)\n        this.readNamedObject(data)\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage('Material')\n        this.resetPosition(data)\n        this.readMaterialEntry(data, path)\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n  }\n\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n  readNamedObject(data) {\n    const chunk = this.readChunk(data)\n    const name = this.readString(data, 64)\n    chunk.cur = this.position\n\n    let next = this.nextChunk(data, chunk)\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data)\n        const mesh = this.readMesh(data)\n        mesh.name = name\n        this.meshes.push(mesh)\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    const material = new MeshPhongMaterial()\n\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64)\n        this.debugMessage('   Name: ' + material.name)\n      } else if (next === MAT_WIRE) {\n        this.debugMessage('   Wireframe')\n        material.wireframe = true\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data)\n        material.wireframeLinewidth = value\n        this.debugMessage('   Wireframe Thickness: ' + value)\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide\n        this.debugMessage('   DoubleSided')\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending')\n        material.blending = AdditiveBlending\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color')\n        material.specular = this.readColor(data)\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data)\n        material.shininess = shininess * 100\n        this.debugMessage('   Shininess : ' + shininess)\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data)\n        material.opacity = 1 - transparency\n        this.debugMessage('  Transparency : ' + transparency)\n        material.transparent = material.opacity < 1 ? true : false\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap')\n        this.resetPosition(data)\n        material.map = this.readMap(data, path)\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap')\n        this.resetPosition(data)\n        material.bumpMap = this.readMap(data, path)\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap')\n        this.resetPosition(data)\n        material.alphaMap = this.readMap(data, path)\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap')\n        this.resetPosition(data)\n        material.specularMap = this.readMap(data, path)\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    this.materials[material.name] = material\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n  readMesh(data) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    const geometry = new BufferGeometry()\n\n    const material = new MeshPhongMaterial()\n    const mesh = new Mesh(geometry, material)\n    mesh.name = 'mesh'\n\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data)\n\n        this.debugMessage('   Vertex: ' + points)\n\n        //BufferGeometry\n\n        const vertices = []\n\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data)\n        this.readFaceArray(data, mesh)\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data)\n\n        this.debugMessage('   UV: ' + texels)\n\n        //BufferGeometry\n\n        const uvs = []\n\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data))\n          uvs.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage('   Tranformation Matrix (TODO)')\n\n        const values = []\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data)\n        }\n\n        const matrix = new Matrix4()\n\n        //X Line\n        matrix.elements[0] = values[0]\n        matrix.elements[1] = values[6]\n        matrix.elements[2] = values[3]\n        matrix.elements[3] = values[9]\n\n        //Y Line\n        matrix.elements[4] = values[2]\n        matrix.elements[5] = values[8]\n        matrix.elements[6] = values[5]\n        matrix.elements[7] = values[11]\n\n        //Z Line\n        matrix.elements[8] = values[1]\n        matrix.elements[9] = values[7]\n        matrix.elements[10] = values[4]\n        matrix.elements[11] = values[10]\n\n        //W Line\n        matrix.elements[12] = 0\n        matrix.elements[13] = 0\n        matrix.elements[14] = 0\n        matrix.elements[15] = 1\n\n        matrix.transpose()\n\n        const inverse = new Matrix4()\n        inverse.copy(matrix).invert()\n        geometry.applyMatrix4(inverse)\n\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale)\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    geometry.computeVertexNormals()\n\n    return mesh\n  }\n\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data)\n    const faces = this.readWord(data)\n\n    this.debugMessage('   Faces: ' + faces)\n\n    const index = []\n\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data))\n\n      this.readWord(data) // visibility\n    }\n\n    mesh.geometry.setIndex(index)\n\n    //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0\n    let start = 0\n\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data)\n\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group')\n\n        this.resetPosition(data)\n\n        const group = this.readMaterialGroup(data)\n        const count = group.index.length * 3 // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex)\n\n        start += count\n        materialIndex++\n\n        const material = this.materials[group.name]\n\n        if (Array.isArray(mesh.material) === false) mesh.material = []\n\n        if (material !== undefined) {\n          mesh.material.push(material)\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.toString(16))\n      }\n\n      this.endChunk(subchunk)\n    }\n\n    if (mesh.material.length === 1) mesh.material = mesh.material[0] // for backwards compatibility\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    let texture = {}\n\n    const loader = new TextureLoader(this.manager)\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128)\n        texture = loader.load(name)\n\n        this.debugMessage('      File: ' + path + name)\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data)\n        this.debugMessage('      OffsetX: ' + texture.offset.x)\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data)\n        this.debugMessage('      OffsetY: ' + texture.offset.y)\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data)\n        this.debugMessage('      RepeatX: ' + texture.repeat.x)\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data)\n        this.debugMessage('      RepeatY: ' + texture.repeat.y)\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    return texture\n  }\n\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(data) {\n    this.readChunk(data)\n    const name = this.readString(data, 64)\n    const numFaces = this.readWord(data)\n\n    this.debugMessage('         Name: ' + name)\n    this.debugMessage('         Faces: ' + numFaces)\n\n    const index = []\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data))\n    }\n\n    return { name: name, index: index }\n  }\n\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n  readColor(data) {\n    const chunk = this.readChunk(data)\n    const color = new Color()\n\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data)\n      const g = this.readByte(data)\n      const b = this.readByte(data)\n\n      color.setRGB(r / 255, g / 255, b / 255)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data)\n      const g = this.readFloat(data)\n      const b = this.readFloat(data)\n\n      color.setRGB(r, g, b)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n    return color\n  }\n\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n  readChunk(data) {\n    const chunk = {}\n\n    chunk.cur = this.position\n    chunk.id = this.readWord(data)\n    chunk.size = this.readDWord(data)\n    chunk.end = chunk.cur + chunk.size\n    chunk.cur += 6\n\n    return chunk\n  }\n\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n  endChunk(chunk) {\n    this.position = chunk.end\n  }\n\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0\n    }\n\n    this.position = chunk.cur\n\n    try {\n      const next = this.readChunk(data)\n      chunk.cur += next.size\n      return next.id\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position)\n      return 0\n    }\n  }\n\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n  resetPosition() {\n    this.position -= 6\n  }\n\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readByte(data) {\n    const v = data.getUint8(this.position, true)\n    this.position += 1\n    return v\n  }\n\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true)\n      this.position += 4\n      return v\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength)\n    }\n  }\n\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readInt(data) {\n    const v = data.getInt32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readShort(data) {\n    const v = data.getInt16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readDWord(data) {\n    const v = data.getUint32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readWord(data) {\n    const v = data.getUint16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n  readString(data, maxLength) {\n    let s = ''\n\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data)\n      if (!c) {\n        break\n      }\n\n      s += String.fromCharCode(c)\n    }\n\n    return s\n  }\n\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readPercentage(data) {\n    const chunk = this.readChunk(data)\n    let value\n\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100\n        break\n\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data)\n        break\n\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n\n    return value\n  }\n\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message)\n    }\n  }\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4d4d\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3daa\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xc23d\nconst M3D_VERSION = 0x0002\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010\nconst COLOR_24 = 0x0011\nconst LIN_COLOR_24 = 0x0012\nconst LIN_COLOR_F = 0x0013\nconst INT_PERCENTAGE = 0x0030\nconst FLOAT_PERCENTAGE = 0x0031\nconst MDATA = 0x3d3d\nconst MESH_VERSION = 0x3d3e\nconst MASTER_SCALE = 0x0100\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xafff\nconst MAT_NAME = 0xa000\nconst MAT_AMBIENT = 0xa010\nconst MAT_DIFFUSE = 0xa020\nconst MAT_SPECULAR = 0xa030\nconst MAT_SHININESS = 0xa040\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xa050\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xa081\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xa083\nconst MAT_WIRE = 0xa085\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xa087\nconst MAT_TEXMAP = 0xa200\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xa210\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xa230\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xa204\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xa300\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xa354\nconst MAT_MAP_VSCALE = 0xa356\nconst MAT_MAP_UOFFSET = 0xa358\nconst MAT_MAP_VOFFSET = 0xa35a\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100\nconst POINT_ARRAY = 0x4110\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120\nconst MSH_MAT_GROUP = 0x4130\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140\nconst MESH_MATRIX = 0x4160\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader }\n"]},"metadata":{},"sourceType":"module"}