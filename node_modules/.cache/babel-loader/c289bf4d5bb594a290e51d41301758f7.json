{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector2, Color, WebGLRenderTarget, HalfFloatType, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\nconst _UnrealBloomPass = class extends Pass {\n  constructor(resolution, strength, radius, threshold) {\n    super();\n    this.strength = strength !== void 0 ? strength : 1;\n    this.radius = radius;\n    this.threshold = threshold;\n    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    this.clearColor = new Color(0, 0, 0);\n    this.renderTargetsHorizontal = [];\n    this.renderTargetsVertical = [];\n    this.nMips = 5;\n    let resx = Math.round(this.resolution.x / 2);\n    let resy = Math.round(this.resolution.y / 2);\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n    this.renderTargetBright.texture.generateMipmaps = false;\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n      this.renderTargetsHorizontal.push(renderTargetHorizonal);\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n    const highPassShader = LuminosityHighPassShader;\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n    this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {}\n    });\n    this.separableBlurMaterials = [];\n    const kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(this.resolution.x / 2);\n    resy = Math.round(this.resolution.y / 2);\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n      this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n    this.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n    this.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n    this.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n    this.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n    this.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n    this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n    this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n    this.compositeMaterial.needsUpdate = true;\n    const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];\n    this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms[\"opacity\"].value = 1;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.basic = new MeshBasicMaterial();\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n    this.renderTargetBright.dispose();\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose();\n    }\n    this.compositeMaterial.dispose();\n    this.materialCopy.dispose();\n    this.basic.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    let resx = Math.round(width / 2);\n    let resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n    this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n    let inputRenderTarget = this.renderTargetBright;\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    }\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n    this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n    this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    }\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  }\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n    });\n  }\n};\nlet UnrealBloomPass = _UnrealBloomPass;\n__publicField(UnrealBloomPass, \"BlurDirectionX\", new Vector2(1, 0));\n__publicField(UnrealBloomPass, \"BlurDirectionY\", new Vector2(0, 1));\nexport { UnrealBloomPass };","map":{"version":3,"sources":["../../src/postprocessing/UnrealBloomPass.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  AdditiveBlending,\n  Color,\n  HalfFloatType,\n  MeshBasicMaterial,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader'\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n  static BlurDirectionX = new Vector2(1.0, 0.0)\n  static BlurDirectionY = new Vector2(0.0, 1.0)\n\n  constructor(resolution, strength, radius, threshold) {\n    super()\n\n    this.strength = strength !== undefined ? strength : 1\n    this.radius = radius\n    this.threshold = threshold\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)\n\n    // create color only once here, reuse it later inside the render function\n    this.clearColor = new Color(0, 0, 0)\n\n    // render targets\n    this.renderTargetsHorizontal = []\n    this.renderTargetsVertical = []\n    this.nMips = 5\n    let resx = Math.round(this.resolution.x / 2)\n    let resy = Math.round(this.resolution.y / 2)\n\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright'\n    this.renderTargetBright.texture.generateMipmaps = false\n\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i\n      renderTargetHorizonal.texture.generateMipmaps = false\n\n      this.renderTargetsHorizontal.push(renderTargetHorizonal)\n\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i\n      renderTargetVertical.texture.generateMipmaps = false\n\n      this.renderTargetsVertical.push(renderTargetVertical)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms)\n\n    this.highPassUniforms['luminosityThreshold'].value = threshold\n    this.highPassUniforms['smoothWidth'].value = 0.01\n\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {},\n    })\n\n    // Gaussian Blur Materials\n    this.separableBlurMaterials = []\n    const kernelSizeArray = [3, 5, 7, 9, 11]\n    resx = Math.round(this.resolution.x / 2)\n    resy = Math.round(this.resolution.y / 2)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]))\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // Composite material\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips)\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1\n    this.compositeMaterial.needsUpdate = true\n\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2]\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors\n    this.bloomTintColors = [\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n    ]\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    // copy material\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n    this.copyUniforms['opacity'].value = 1.0\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.enabled = true\n    this.needsSwap = false\n\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.basic = new MeshBasicMaterial()\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose()\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose()\n    }\n\n    this.renderTargetBright.dispose()\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose()\n    }\n\n    this.compositeMaterial.dispose()\n    this.materialCopy.dispose()\n    this.basic.dispose()\n\n    //\n\n    this.fsQuad.dispose()\n  }\n\n  setSize(width, height) {\n    let resx = Math.round(width / 2)\n    let resy = Math.round(height / 2)\n\n    this.renderTargetBright.setSize(resx, resy)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy)\n      this.renderTargetsVertical[i].setSize(resx, resy)\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n      resy = Math.round(resy / 2)\n    }\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor)\n    this.oldClearAlpha = renderer.getClearAlpha()\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.setClearColor(this.clearColor, 0)\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(false)\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic\n      this.basic.map = readBuffer.texture\n\n      renderer.setRenderTarget(null)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold\n    this.fsQuad.material = this.materialHighPassFilter\n\n    renderer.setRenderTarget(this.renderTargetBright)\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i]\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetsVertical[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      inputRenderTarget = this.renderTargetsVertical[i]\n    }\n\n    // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0])\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(true)\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    } else {\n      renderer.setRenderTarget(readBuffer)\n      this.fsQuad.render(renderer)\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n    renderer.autoClear = oldAutoClear\n  }\n\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius,\n      },\n\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`,\n    })\n  }\n\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips,\n      },\n\n      uniforms: {\n        blurTexture1: { value: null },\n        blurTexture2: { value: null },\n        blurTexture3: { value: null },\n        blurTexture4: { value: null },\n        blurTexture5: { value: null },\n        bloomStrength: { value: 1.0 },\n        bloomFactors: { value: null },\n        bloomTintColors: { value: null },\n        bloomRadius: { value: 0.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`,\n    })\n  }\n}\n\nexport { UnrealBloomPass }\n"]},"metadata":{},"sourceType":"module"}