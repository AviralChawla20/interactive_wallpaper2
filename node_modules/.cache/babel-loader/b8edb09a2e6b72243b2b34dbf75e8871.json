{"ast":null,"code":"import { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from \"three\";\nconst a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\nconst b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\nclass OBB {\n  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n  }\n  set(center, halfSize, rotation) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n    return this;\n  }\n  copy(obb2) {\n    this.center.copy(obb2.center);\n    this.halfSize.copy(obb2.halfSize);\n    this.rotation.copy(obb2.rotation);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  getSize(result) {\n    return result.copy(this.halfSize).multiplyScalar(2);\n  }\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint(point, result) {\n    const halfSize = this.halfSize;\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    result.copy(this.center);\n    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n    result.add(xAxis.multiplyScalar(x));\n    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n    result.add(yAxis.multiplyScalar(y));\n    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n    result.add(zAxis.multiplyScalar(z));\n    return result;\n  }\n  containsPoint(point) {\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n  }\n  intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3));\n  }\n  intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, closestPoint);\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB(obb2, epsilon = Number.EPSILON) {\n    a.c = this.center;\n    a.e[0] = this.halfSize.x;\n    a.e[1] = this.halfSize.y;\n    a.e[2] = this.halfSize.z;\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n    b.c = obb2.center;\n    b.e[0] = obb2.halfSize.x;\n    b.e[1] = obb2.halfSize.y;\n    b.e[2] = obb2.halfSize.z;\n    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j]);\n      }\n    }\n    v1.subVectors(b.c, a.c);\n    t[0] = v1.dot(a.u[0]);\n    t[1] = v1.dot(a.u[1]);\n    t[2] = v1.dot(a.u[2]);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;\n      }\n    }\n    let ra, rb;\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i];\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];\n      if (Math.abs(t[i]) > ra + rb) return false;\n    }\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];\n      rb = b.e[i];\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;\n    }\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false;\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false;\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false;\n    return true;\n  }\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane(plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));\n    const d = plane.normal.dot(this.center) - plane.constant;\n    return Math.abs(d) <= r;\n  }\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay(ray, result) {\n    this.getSize(size);\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);\n    matrix.setFromMatrix3(this.rotation);\n    matrix.setPosition(this.center);\n    inverse.copy(matrix).invert();\n    localRay.copy(ray).applyMatrix4(inverse);\n    if (localRay.intersectBox(aabb, result)) {\n      return result.applyMatrix4(matrix);\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null;\n  }\n  fromBox3(box3) {\n    box3.getCenter(this.center);\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\n    this.rotation.identity();\n    return this;\n  }\n  equals(obb2) {\n    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);\n  }\n  applyMatrix4(matrix2) {\n    const e = matrix2.elements;\n    let sx = v1.set(e[0], e[1], e[2]).length();\n    const sy = v1.set(e[4], e[5], e[6]).length();\n    const sz = v1.set(e[8], e[9], e[10]).length();\n    const det = matrix2.determinant();\n    if (det < 0) sx = -sx;\n    rotationMatrix.setFromMatrix4(matrix2);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    rotationMatrix.elements[0] *= invSX;\n    rotationMatrix.elements[1] *= invSX;\n    rotationMatrix.elements[2] *= invSX;\n    rotationMatrix.elements[3] *= invSY;\n    rotationMatrix.elements[4] *= invSY;\n    rotationMatrix.elements[5] *= invSY;\n    rotationMatrix.elements[6] *= invSZ;\n    rotationMatrix.elements[7] *= invSZ;\n    rotationMatrix.elements[8] *= invSZ;\n    this.rotation.multiply(rotationMatrix);\n    this.halfSize.x *= sx;\n    this.halfSize.y *= sy;\n    this.halfSize.z *= sz;\n    v1.setFromMatrixPosition(matrix2);\n    this.center.add(v1);\n    return this;\n  }\n}\nconst obb = new OBB();\nexport { OBB };","map":{"version":3,"sources":["../../src/math/OBB.js"],"names":["obb","matrix"],"mappings":"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","sourcesContent":["import { Box3, MathUtils, Matrix4, Matrix3, Ray, Vector3 } from 'three'\n\n// module scope helper variables\n\nconst a = {\n  c: null, // center\n  u: [new Vector3(), new Vector3(), new Vector3()], // basis vectors\n  e: [], // half width\n}\n\nconst b = {\n  c: null, // center\n  u: [new Vector3(), new Vector3(), new Vector3()], // basis vectors\n  e: [], // half width\n}\n\nconst R = [[], [], []]\nconst AbsR = [[], [], []]\nconst t = []\n\nconst xAxis = new Vector3()\nconst yAxis = new Vector3()\nconst zAxis = new Vector3()\nconst v1 = new Vector3()\nconst size = new Vector3()\nconst closestPoint = new Vector3()\nconst rotationMatrix = new Matrix3()\nconst aabb = new Box3()\nconst matrix = new Matrix4()\nconst inverse = new Matrix4()\nconst localRay = new Ray()\n\n// OBB\n\nclass OBB {\n  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n    this.center = center\n    this.halfSize = halfSize\n    this.rotation = rotation\n  }\n\n  set(center, halfSize, rotation) {\n    this.center = center\n    this.halfSize = halfSize\n    this.rotation = rotation\n\n    return this\n  }\n\n  copy(obb) {\n    this.center.copy(obb.center)\n    this.halfSize.copy(obb.halfSize)\n    this.rotation.copy(obb.rotation)\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  getSize(result) {\n    return result.copy(this.halfSize).multiplyScalar(2)\n  }\n\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint(point, result) {\n    const halfSize = this.halfSize\n\n    v1.subVectors(point, this.center)\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // start at the center position of the OBB\n\n    result.copy(this.center)\n\n    // project the target onto the OBB axes and walk towards that point\n\n    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x)\n    result.add(xAxis.multiplyScalar(x))\n\n    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y)\n    result.add(yAxis.multiplyScalar(y))\n\n    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z)\n    result.add(zAxis.multiplyScalar(z))\n\n    return result\n  }\n\n  containsPoint(point) {\n    v1.subVectors(point, this.center)\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // project v1 onto each axis and check if these points lie inside the OBB\n\n    return (\n      Math.abs(v1.dot(xAxis)) <= this.halfSize.x &&\n      Math.abs(v1.dot(yAxis)) <= this.halfSize.y &&\n      Math.abs(v1.dot(zAxis)) <= this.halfSize.z\n    )\n  }\n\n  intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3))\n  }\n\n  intersectsSphere(sphere) {\n    // find the point on the OBB closest to the sphere center\n\n    this.clampPoint(sphere.center, closestPoint)\n\n    // if that point is inside the sphere, the OBB and sphere intersect\n\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius\n  }\n\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB(obb, epsilon = Number.EPSILON) {\n    // prepare data structures (the code uses the same nomenclature like the reference)\n\n    a.c = this.center\n    a.e[0] = this.halfSize.x\n    a.e[1] = this.halfSize.y\n    a.e[2] = this.halfSize.z\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2])\n\n    b.c = obb.center\n    b.e[0] = obb.halfSize.x\n    b.e[1] = obb.halfSize.y\n    b.e[2] = obb.halfSize.z\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2])\n\n    // compute rotation matrix expressing b in a's coordinate frame\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j])\n      }\n    }\n\n    // compute translation vector\n\n    v1.subVectors(b.c, a.c)\n\n    // bring translation into a's coordinate frame\n\n    t[0] = v1.dot(a.u[0])\n    t[1] = v1.dot(a.u[1])\n    t[2] = v1.dot(a.u[2])\n\n    // compute common subexpressions. Add in an epsilon term to\n    // counteract arithmetic errors when two edges are parallel and\n    // their cross product is (near) null\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon\n      }\n    }\n\n    let ra, rb\n\n    // test axes L = A0, L = A1, L = A2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i]\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2]\n      if (Math.abs(t[i]) > ra + rb) return false\n    }\n\n    // test axes L = B0, L = B1, L = B2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i]\n      rb = b.e[i]\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false\n    }\n\n    // test axis L = A0 x B0\n\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0]\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1]\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false\n\n    // test axis L = A0 x B1\n\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1]\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0]\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false\n\n    // test axis L = A0 x B2\n\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2]\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0]\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false\n\n    // test axis L = A1 x B0\n\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0]\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1]\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false\n\n    // test axis L = A1 x B1\n\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1]\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0]\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false\n\n    // test axis L = A1 x B2\n\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2]\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0]\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false\n\n    // test axis L = A2 x B0\n\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0]\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1]\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false\n\n    // test axis L = A2 x B1\n\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1]\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0]\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false\n\n    // test axis L = A2 x B2\n\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2]\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0]\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false\n\n    // since no separating axis is found, the OBBs must be intersecting\n\n    return true\n  }\n\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane(plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n    const r =\n      this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) +\n      this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) +\n      this.halfSize.z * Math.abs(plane.normal.dot(zAxis))\n\n    // compute distance of the OBB's center from the plane\n\n    const d = plane.normal.dot(this.center) - plane.constant\n\n    // Intersection occurs when distance d falls within [-r,+r] interval\n\n    return Math.abs(d) <= r\n  }\n\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay(ray, result) {\n    // the idea is to perform the intersection test in the local space\n    // of the OBB.\n\n    this.getSize(size)\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size)\n\n    // create a 4x4 transformation matrix\n\n    matrix.setFromMatrix3(this.rotation)\n    matrix.setPosition(this.center)\n\n    // transform ray to the local space of the OBB\n\n    inverse.copy(matrix).invert()\n    localRay.copy(ray).applyMatrix4(inverse)\n\n    // perform ray <-> AABB intersection test\n\n    if (localRay.intersectBox(aabb, result)) {\n      // transform the intersection point back to world space\n\n      return result.applyMatrix4(matrix)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null\n  }\n\n  fromBox3(box3) {\n    box3.getCenter(this.center)\n\n    box3.getSize(this.halfSize).multiplyScalar(0.5)\n\n    this.rotation.identity()\n\n    return this\n  }\n\n  equals(obb) {\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation)\n  }\n\n  applyMatrix4(matrix) {\n    const e = matrix.elements\n\n    let sx = v1.set(e[0], e[1], e[2]).length()\n    const sy = v1.set(e[4], e[5], e[6]).length()\n    const sz = v1.set(e[8], e[9], e[10]).length()\n\n    const det = matrix.determinant()\n    if (det < 0) sx = -sx\n\n    rotationMatrix.setFromMatrix4(matrix)\n\n    const invSX = 1 / sx\n    const invSY = 1 / sy\n    const invSZ = 1 / sz\n\n    rotationMatrix.elements[0] *= invSX\n    rotationMatrix.elements[1] *= invSX\n    rotationMatrix.elements[2] *= invSX\n\n    rotationMatrix.elements[3] *= invSY\n    rotationMatrix.elements[4] *= invSY\n    rotationMatrix.elements[5] *= invSY\n\n    rotationMatrix.elements[6] *= invSZ\n    rotationMatrix.elements[7] *= invSZ\n    rotationMatrix.elements[8] *= invSZ\n\n    this.rotation.multiply(rotationMatrix)\n\n    this.halfSize.x *= sx\n    this.halfSize.y *= sy\n    this.halfSize.z *= sz\n\n    v1.setFromMatrixPosition(matrix)\n    this.center.add(v1)\n\n    return this\n  }\n}\n\nconst obb = new OBB()\n\nexport { OBB }\n"]},"metadata":{},"sourceType":"module"}