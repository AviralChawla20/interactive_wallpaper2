{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data2) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      let headerText = \"\";\n      let headerLength = 0;\n      const result = patternHeader.exec(data2);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength,\n        objInfo: \"\"\n      };\n      const lines = headerText.split(\"\\n\");\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = {\n          type: propertValues[0]\n        };\n        if (property.type === \"list\") {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\") continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(\" \");\n        switch (lineType) {\n          case \"format\":\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case \"comment\":\n            header.comments.push(line);\n            break;\n          case \"element\":\n            if (currentElement !== void 0) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case \"property\":\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case \"obj_info\":\n            header.objInfo = line;\n            break;\n          default:\n            console.log(\"unhandled\", lineType, lineValues);\n        }\n      }\n      if (currentElement !== void 0) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case \"char\":\n        case \"uchar\":\n        case \"short\":\n        case \"ushort\":\n        case \"int\":\n        case \"uint\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n          return parseInt(n);\n        case \"float\":\n        case \"double\":\n        case \"float32\":\n        case \"float64\":\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function parseASCII(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = \"\";\n      if ((result = patternBody.exec(data2)) !== null) {\n        body = result[1];\n      }\n      const lines = body.split(\"\\n\");\n      let currentElement = 0;\n      let currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\") {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry2 = new BufferGeometry();\n      if (buffer.indices.length > 0) {\n        geometry2.setIndex(buffer.indices);\n      }\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n      if (buffer.normals.length > 0) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry2 = geometry2.toNonIndexed();\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n      geometry2.computeBoundingSphere();\n      return geometry2;\n    }\n    function handleElement(buffer, elementName, element) {\n      if (elementName === \"vertex\") {\n        buffer.vertices.push(element.x, element.y, element.z);\n        if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n        if (\"s\" in element && \"t\" in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n        if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n          buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n        }\n      } else if (elementName === \"face\") {\n        const vertex_indices = element.vertex_indices || element.vertex_index;\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        case \"int8\":\n        case \"char\":\n          return [dataview.getInt8(at), 1];\n        case \"uint8\":\n        case \"uchar\":\n          return [dataview.getUint8(at), 1];\n        case \"int16\":\n        case \"short\":\n          return [dataview.getInt16(at, little_endian), 2];\n        case \"uint16\":\n        case \"ushort\":\n          return [dataview.getUint16(at, little_endian), 2];\n        case \"int32\":\n        case \"int\":\n          return [dataview.getInt32(at, little_endian), 4];\n        case \"uint32\":\n        case \"uint\":\n          return [dataview.getUint32(at, little_endian), 4];\n        case \"float32\":\n        case \"float\":\n          return [dataview.getFloat32(at, little_endian), 4];\n        case \"float64\":\n        case \"double\":\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result,\n        read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      const little_endian = header.format === \"binary_little_endian\";\n      const body = new DataView(data2, header.headerLength);\n      let result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    }\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const text = decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nexport { PLYLoader };","map":{"version":3,"sources":["../../src/loaders/PLYLoader.js"],"names":["data","geometry"],"mappings":";;AA6BA,MAAM,SAAA,SAAkB,MAAA,CAAO;EAC7B,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;IAEb,IAAA,CAAK,mBAAA,GAAsB,CAAE,CAAA;EAC9B;EAED,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,KAAA,GAAQ,IAAA;IAEd,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;IAC1C,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA;IACxB,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;IACpC,MAAA,CAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA;IAC1C,MAAA,CAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe,CAAA;IAC9C,MAAA,CAAO,IAAA,CACL,GAAA,EACA,UAAU,IAAA,EAAM;MACd,IAAI;QACF,MAAA,CAAO,KAAA,CAAM,KAAA,CAAM,IAAI,CAAC,CAAA;MACzB,CAAA,CAAA,OAAQ,CAAA,EAAP;QACA,IAAI,OAAA,EAAS;UACX,OAAA,CAAQ,CAAC,CAAA;QACrB,CAAA,MAAiB;UACL,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAChB;QAED,KAAA,CAAM,OAAA,CAAQ,SAAA,CAAU,GAAG,CAAA;MAC5B;IACF,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAED,sBAAA,CAAuB,OAAA,EAAS;IAC9B,IAAA,CAAK,mBAAA,GAAsB,OAAA;EAC5B;EAED,KAAA,CAAM,IAAA,EAAM;IACV,SAAS,WAAA,CAAYA,KAAAA,EAAM;MACzB,MAAM,aAAA,GAAgB,6BAAA;MACtB,IAAI,UAAA,GAAa,EAAA;MACjB,IAAI,YAAA,GAAe,CAAA;MACnB,MAAM,MAAA,GAAS,aAAA,CAAc,IAAA,CAAKA,KAAI,CAAA;MAEtC,IAAI,MAAA,KAAW,IAAA,EAAM;QACnB,UAAA,GAAa,MAAA,CAAO,CAAC,CAAA;QACrB,YAAA,GAAe,IAAI,IAAA,CAAK,CAAC,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,CAAE,IAAA;MACtC;MAED,MAAM,MAAA,GAAS;QACb,QAAA,EAAU,EAAE;QACZ,QAAA,EAAU,EAAE;QACZ,YAAA;QACA,OAAA,EAAS;MACV,CAAA;MAED,MAAM,KAAA,GAAQ,UAAA,CAAW,KAAA,CAAM,IAAI,CAAA;MACnC,IAAI,cAAA;MAEJ,SAAS,yBAAA,CAA0B,aAAA,EAAe,mBAAA,EAAqB;QACrE,MAAM,QAAA,GAAW;UAAE,IAAA,EAAM,aAAA,CAAc,CAAC;QAAG,CAAA;QAE3C,IAAI,QAAA,CAAS,IAAA,KAAS,MAAA,EAAQ;UAC5B,QAAA,CAAS,IAAA,GAAO,aAAA,CAAc,CAAC,CAAA;UAC/B,QAAA,CAAS,SAAA,GAAY,aAAA,CAAc,CAAC,CAAA;UACpC,QAAA,CAAS,QAAA,GAAW,aAAA,CAAc,CAAC,CAAA;QAC7C,CAAA,MAAe;UACL,QAAA,CAAS,IAAA,GAAO,aAAA,CAAc,CAAC,CAAA;QAChC;QAED,IAAI,QAAA,CAAS,IAAA,IAAQ,mBAAA,EAAqB;UACxC,QAAA,CAAS,IAAA,GAAO,mBAAA,CAAoB,QAAA,CAAS,IAAI,CAAA;QAClD;QAED,OAAO,QAAA;MACR;MAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;QACrC,IAAI,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;QAClB,IAAA,GAAO,IAAA,CAAK,IAAA,CAAM,CAAA;QAElB,IAAI,IAAA,KAAS,EAAA,EAAI;QAEjB,MAAM,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;QACnC,MAAM,QAAA,GAAW,UAAA,CAAW,KAAA,CAAO,CAAA;QACnC,IAAA,GAAO,UAAA,CAAW,IAAA,CAAK,GAAG,CAAA;QAE1B,QAAQ,QAAA;UACN,KAAK,QAAA;YACH,MAAA,CAAO,MAAA,GAAS,UAAA,CAAW,CAAC,CAAA;YAC5B,MAAA,CAAO,OAAA,GAAU,UAAA,CAAW,CAAC,CAAA;YAE7B;UAEF,KAAK,SAAA;YACH,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,IAAI,CAAA;YAEzB;UAEF,KAAK,SAAA;YACH,IAAI,cAAA,KAAmB,KAAA,CAAA,EAAW;cAChC,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,cAAc,CAAA;YACpC;YAED,cAAA,GAAiB,CAAE,CAAA;YACnB,cAAA,CAAe,IAAA,GAAO,UAAA,CAAW,CAAC,CAAA;YAClC,cAAA,CAAe,KAAA,GAAQ,QAAA,CAAS,UAAA,CAAW,CAAC,CAAC,CAAA;YAC7C,cAAA,CAAe,UAAA,GAAa,EAAE;YAE9B;UAEF,KAAK,UAAA;YACH,cAAA,CAAe,UAAA,CAAW,IAAA,CAAK,yBAAA,CAA0B,UAAA,EAAY,KAAA,CAAM,mBAAmB,CAAC,CAAA;YAE/F;UAEF,KAAK,UAAA;YACH,MAAA,CAAO,OAAA,GAAU,IAAA;YAEjB;UAEF;YACE,OAAA,CAAQ,GAAA,CAAI,WAAA,EAAa,QAAA,EAAU,UAAU,CAAA;QAChD;MACF;MAED,IAAI,cAAA,KAAmB,KAAA,CAAA,EAAW;QAChC,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,cAAc,CAAA;MACpC;MAED,OAAO,MAAA;IACR;IAED,SAAS,gBAAA,CAAiB,CAAA,EAAG,IAAA,EAAM;MACjC,QAAQ,IAAA;QACN,KAAK,MAAA;QACL,KAAK,OAAA;QACL,KAAK,OAAA;QACL,KAAK,QAAA;QACL,KAAK,KAAA;QACL,KAAK,MAAA;QACL,KAAK,MAAA;QACL,KAAK,OAAA;QACL,KAAK,OAAA;QACL,KAAK,QAAA;QACL,KAAK,OAAA;QACL,KAAK,QAAA;UACH,OAAO,QAAA,CAAS,CAAC,CAAA;QAEnB,KAAK,OAAA;QACL,KAAK,QAAA;QACL,KAAK,SAAA;QACL,KAAK,SAAA;UACH,OAAO,UAAA,CAAW,CAAC,CAAA;MACtB;IACF;IAED,SAAS,iBAAA,CAAkB,UAAA,EAAY,IAAA,EAAM;MAC3C,MAAM,MAAA,GAAS,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;MAE/B,MAAM,OAAA,GAAU,CAAE,CAAA;MAElB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC1C,IAAI,UAAA,CAAW,CAAC,CAAA,CAAE,IAAA,KAAS,MAAA,EAAQ;UACjC,MAAM,IAAA,GAAO,EAAE;UACf,MAAM,CAAA,GAAI,gBAAA,CAAiB,MAAA,CAAO,KAAA,CAAO,CAAA,EAAE,UAAA,CAAW,CAAC,CAAA,CAAE,SAAS,CAAA;UAElE,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;YAC1B,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAiB,MAAA,CAAO,KAAA,CAAO,CAAA,EAAE,UAAA,CAAW,CAAC,CAAA,CAAE,QAAQ,CAAC,CAAA;UACnE;UAED,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,IAAA;QACxC,CAAA,MAAe;UACL,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,gBAAA,CAAiB,MAAA,CAAO,KAAA,CAAK,CAAA,EAAI,UAAA,CAAW,CAAC,CAAA,CAAE,IAAI,CAAA;QAClF;MACF;MAED,OAAO,OAAA;IACR;IAED,SAAS,UAAA,CAAWA,KAAAA,EAAM,MAAA,EAAQ;MAGhC,MAAM,MAAA,GAAS;QACb,OAAA,EAAS,EAAE;QACX,QAAA,EAAU,EAAE;QACZ,OAAA,EAAS,EAAE;QACX,GAAA,EAAK,EAAE;QACP,aAAA,EAAe,EAAE;QACjB,MAAA,EAAQ;MACT,CAAA;MAED,IAAI,MAAA;MAEJ,MAAM,WAAA,GAAc,wBAAA;MACpB,IAAI,IAAA,GAAO,EAAA;MACX,IAAA,CAAK,MAAA,GAAS,WAAA,CAAY,IAAA,CAAKA,KAAI,CAAA,MAAO,IAAA,EAAM;QAC9C,IAAA,GAAO,MAAA,CAAO,CAAC,CAAA;MAChB;MAED,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;MAC7B,IAAI,cAAA,GAAiB,CAAA;MACrB,IAAI,mBAAA,GAAsB,CAAA;MAE1B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;QACrC,IAAI,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;QAClB,IAAA,GAAO,IAAA,CAAK,IAAA,CAAM,CAAA;QAClB,IAAI,IAAA,KAAS,EAAA,EAAI;UACf;QACD;QAED,IAAI,mBAAA,IAAuB,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,KAAA,EAAO;UAChE,cAAA,EAAA;UACA,mBAAA,GAAsB,CAAA;QACvB;QAED,MAAM,OAAA,GAAU,iBAAA,CAAkB,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,UAAA,EAAY,IAAI,CAAA;QAElF,aAAA,CAAc,MAAA,EAAQ,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,IAAA,EAAM,OAAO,CAAA;QAEnE,mBAAA,EAAA;MACD;MAED,OAAO,WAAA,CAAY,MAAM,CAAA;IAC1B;IAED,SAAS,WAAA,CAAY,MAAA,EAAQ;MAC3B,IAAIC,SAAAA,GAAW,IAAI,cAAA,CAAgB,CAAA;MAInC,IAAI,MAAA,CAAO,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;QAC7B,SAAA,CAAS,QAAA,CAAS,MAAA,CAAO,OAAO,CAAA;MACjC;MAED,SAAA,CAAS,YAAA,CAAa,UAAA,EAAY,IAAI,sBAAA,CAAuB,MAAA,CAAO,QAAA,EAAU,CAAC,CAAC,CAAA;MAIhF,IAAI,MAAA,CAAO,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;QAC7B,SAAA,CAAS,YAAA,CAAa,QAAA,EAAU,IAAI,sBAAA,CAAuB,MAAA,CAAO,OAAA,EAAS,CAAC,CAAC,CAAA;MAC9E;MAED,IAAI,MAAA,CAAO,GAAA,CAAI,MAAA,GAAS,CAAA,EAAG;QACzB,SAAA,CAAS,YAAA,CAAa,IAAA,EAAM,IAAI,sBAAA,CAAuB,MAAA,CAAO,GAAA,EAAK,CAAC,CAAC,CAAA;MACtE;MAED,IAAI,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;QAC5B,SAAA,CAAS,YAAA,CAAa,OAAA,EAAS,IAAI,sBAAA,CAAuB,MAAA,CAAO,MAAA,EAAQ,CAAC,CAAC,CAAA;MAC5E;MAED,IAAI,MAAA,CAAO,aAAA,CAAc,MAAA,GAAS,CAAA,EAAG;QACnC,SAAA,GAAWA,SAAAA,CAAS,YAAA,CAAc,CAAA;QAClC,SAAA,CAAS,YAAA,CAAa,IAAA,EAAM,IAAI,sBAAA,CAAuB,MAAA,CAAO,aAAA,EAAe,CAAC,CAAC,CAAA;MAChF;MAED,SAAA,CAAS,qBAAA,CAAuB,CAAA;MAEhC,OAAO,SAAA;IACR;IAED,SAAS,aAAA,CAAc,MAAA,EAAQ,WAAA,EAAa,OAAA,EAAS;MACnD,IAAI,WAAA,KAAgB,QAAA,EAAU;QAC5B,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAC,CAAA;QAEpD,IAAI,IAAA,IAAQ,OAAA,IAAW,IAAA,IAAQ,OAAA,IAAW,IAAA,IAAQ,OAAA,EAAS;UACzD,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,OAAA,CAAQ,EAAA,EAAI,OAAA,CAAQ,EAAA,EAAI,OAAA,CAAQ,EAAE,CAAA;QACvD;QAED,IAAI,GAAA,IAAO,OAAA,IAAW,GAAA,IAAO,OAAA,EAAS;UACpC,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,OAAA,CAAQ,CAAA,EAAG,OAAA,CAAQ,CAAC,CAAA;QACrC;QAED,IAAI,KAAA,IAAS,OAAA,IAAW,OAAA,IAAW,OAAA,IAAW,MAAA,IAAU,OAAA,EAAS;UAC/D,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,OAAA,CAAQ,GAAA,GAAM,GAAA,EAAO,OAAA,CAAQ,KAAA,GAAQ,GAAA,EAAO,OAAA,CAAQ,IAAA,GAAO,GAAK,CAAA;QACpF;MACT,CAAA,MAAA,IAAiB,WAAA,KAAgB,MAAA,EAAQ;QACjC,MAAM,cAAA,GAAiB,OAAA,CAAQ,cAAA,IAAkB,OAAA,CAAQ,YAAA;QACzD,MAAM,QAAA,GAAW,OAAA,CAAQ,QAAA;QAEzB,IAAI,cAAA,CAAe,MAAA,KAAW,CAAA,EAAG;UAC/B,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAC,CAAA;UAE3E,IAAI,QAAA,IAAY,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;YACrC,MAAA,CAAO,aAAA,CAAc,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,CAAC,CAAC,CAAA;YAClD,MAAA,CAAO,aAAA,CAAc,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,CAAC,CAAC,CAAA;YAClD,MAAA,CAAO,aAAA,CAAc,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,CAAC,CAAC,CAAA;UACnD;QACX,CAAA,MAAA,IAAmB,cAAA,CAAe,MAAA,KAAW,CAAA,EAAG;UACtC,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAC,CAAA;UAC3E,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,EAAG,cAAA,CAAe,CAAC,CAAC,CAAA;QAC5E;MACF;IACF;IAED,SAAS,UAAA,CAAW,QAAA,EAAU,EAAA,EAAI,IAAA,EAAM,aAAA,EAAe;MACrD,QAAQ,IAAA;QAEN,KAAK,MAAA;QACL,KAAK,MAAA;UACH,OAAO,CAAC,QAAA,CAAS,OAAA,CAAQ,EAAE,CAAA,EAAG,CAAC,CAAA;QACjC,KAAK,OAAA;QACL,KAAK,OAAA;UACH,OAAO,CAAC,QAAA,CAAS,QAAA,CAAS,EAAE,CAAA,EAAG,CAAC,CAAA;QAClC,KAAK,OAAA;QACL,KAAK,OAAA;UACH,OAAO,CAAC,QAAA,CAAS,QAAA,CAAS,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;QACjD,KAAK,QAAA;QACL,KAAK,QAAA;UACH,OAAO,CAAC,QAAA,CAAS,SAAA,CAAU,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;QAClD,KAAK,OAAA;QACL,KAAK,KAAA;UACH,OAAO,CAAC,QAAA,CAAS,QAAA,CAAS,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;QACjD,KAAK,QAAA;QACL,KAAK,MAAA;UACH,OAAO,CAAC,QAAA,CAAS,SAAA,CAAU,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;QAClD,KAAK,SAAA;QACL,KAAK,OAAA;UACH,OAAO,CAAC,QAAA,CAAS,UAAA,CAAW,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;QACnD,KAAK,SAAA;QACL,KAAK,QAAA;UACH,OAAO,CAAC,QAAA,CAAS,UAAA,CAAW,EAAA,EAAI,aAAa,CAAA,EAAG,CAAC,CAAA;MACpD;IACF;IAED,SAAS,iBAAA,CAAkB,QAAA,EAAU,EAAA,EAAI,UAAA,EAAY,aAAA,EAAe;MAClE,MAAM,OAAA,GAAU,CAAE,CAAA;MAClB,IAAI,MAAA;QACF,IAAA,GAAO,CAAA;MAET,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC1C,IAAI,UAAA,CAAW,CAAC,CAAA,CAAE,IAAA,KAAS,MAAA,EAAQ;UACjC,MAAM,IAAA,GAAO,EAAE;UAEf,MAAA,GAAS,UAAA,CAAW,QAAA,EAAU,EAAA,GAAK,IAAA,EAAM,UAAA,CAAW,CAAC,CAAA,CAAE,SAAA,EAAW,aAAa,CAAA;UAC/E,MAAM,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA;UAClB,IAAA,IAAQ,MAAA,CAAO,CAAC,CAAA;UAEhB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;YAC1B,MAAA,GAAS,UAAA,CAAW,QAAA,EAAU,EAAA,GAAK,IAAA,EAAM,UAAA,CAAW,CAAC,CAAA,CAAE,QAAA,EAAU,aAAa,CAAA;YAC9E,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,CAAC,CAAC,CAAA;YACnB,IAAA,IAAQ,MAAA,CAAO,CAAC,CAAA;UACjB;UAED,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,IAAA;QACxC,CAAA,MAAe;UACL,MAAA,GAAS,UAAA,CAAW,QAAA,EAAU,EAAA,GAAK,IAAA,EAAM,UAAA,CAAW,CAAC,CAAA,CAAE,IAAA,EAAM,aAAa,CAAA;UAC1E,OAAA,CAAQ,UAAA,CAAW,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA;UACtC,IAAA,IAAQ,MAAA,CAAO,CAAC,CAAA;QACjB;MACF;MAED,OAAO,CAAC,OAAA,EAAS,IAAI,CAAA;IACtB;IAED,SAAS,WAAA,CAAYD,KAAAA,EAAM,MAAA,EAAQ;MACjC,MAAM,MAAA,GAAS;QACb,OAAA,EAAS,EAAE;QACX,QAAA,EAAU,EAAE;QACZ,OAAA,EAAS,EAAE;QACX,GAAA,EAAK,EAAE;QACP,aAAA,EAAe,EAAE;QACjB,MAAA,EAAQ;MACT,CAAA;MAED,MAAM,aAAA,GAAgB,MAAA,CAAO,MAAA,KAAW,sBAAA;MACxC,MAAM,IAAA,GAAO,IAAI,QAAA,CAASA,KAAAA,EAAM,MAAA,CAAO,YAAY,CAAA;MACnD,IAAI,MAAA;QACF,GAAA,GAAM,CAAA;MAER,KAAA,IAAS,cAAA,GAAiB,CAAA,EAAG,cAAA,GAAiB,MAAA,CAAO,QAAA,CAAS,MAAA,EAAQ,cAAA,EAAA,EAAkB;QACtF,KAAA,IACM,mBAAA,GAAsB,CAAA,EAC1B,mBAAA,GAAsB,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,KAAA,EACtD,mBAAA,EAAA,EACA;UACA,MAAA,GAAS,iBAAA,CAAkB,IAAA,EAAM,GAAA,EAAK,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,UAAA,EAAY,aAAa,CAAA;UAC/F,GAAA,IAAO,MAAA,CAAO,CAAC,CAAA;UACf,MAAM,OAAA,GAAU,MAAA,CAAO,CAAC,CAAA;UAExB,aAAA,CAAc,MAAA,EAAQ,MAAA,CAAO,QAAA,CAAS,cAAc,CAAA,CAAE,IAAA,EAAM,OAAO,CAAA;QACpE;MACF;MAED,OAAO,WAAA,CAAY,MAAM,CAAA;IAC1B;IAID,IAAI,QAAA;IACJ,MAAM,KAAA,GAAQ,IAAA;IAEd,IAAI,IAAA,YAAgB,WAAA,EAAa;MAC/B,MAAM,IAAA,GAAO,UAAA,CAAW,IAAI,UAAA,CAAW,IAAI,CAAC,CAAA;MAC5C,MAAM,MAAA,GAAS,WAAA,CAAY,IAAI,CAAA;MAE/B,QAAA,GAAW,MAAA,CAAO,MAAA,KAAW,OAAA,GAAU,UAAA,CAAW,IAAA,EAAM,MAAM,CAAA,GAAI,WAAA,CAAY,IAAA,EAAM,MAAM,CAAA;IAChG,CAAA,MAAW;MACL,QAAA,GAAW,UAAA,CAAW,IAAA,EAAM,WAAA,CAAY,IAAI,CAAC,CAAA;IAC9C;IAED,OAAO,QAAA;EACR;AACH","sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.propertyNameMapping = {}\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping\n  }\n\n  parse(data) {\n    function parseHeader(data) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/\n      let headerText = ''\n      let headerLength = 0\n      const result = patternHeader.exec(data)\n\n      if (result !== null) {\n        headerText = result[1]\n        headerLength = new Blob([result[0]]).size\n      }\n\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: '',\n      }\n\n      const lines = headerText.split('\\n')\n      let currentElement\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = { type: propertValues[0] }\n\n        if (property.type === 'list') {\n          property.name = propertValues[3]\n          property.countType = propertValues[1]\n          property.itemType = propertValues[2]\n        } else {\n          property.name = propertValues[1]\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name]\n        }\n\n        return property\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n\n        if (line === '') continue\n\n        const lineValues = line.split(/\\s+/)\n        const lineType = lineValues.shift()\n        line = lineValues.join(' ')\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0]\n            header.version = lineValues[1]\n\n            break\n\n          case 'comment':\n            header.comments.push(line)\n\n            break\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement)\n            }\n\n            currentElement = {}\n            currentElement.name = lineValues[0]\n            currentElement.count = parseInt(lineValues[1])\n            currentElement.properties = []\n\n            break\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping))\n\n            break\n\n          case 'obj_info':\n            header.objInfo = line\n\n            break\n\n          default:\n            console.log('unhandled', lineType, lineValues)\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement)\n      }\n\n      return header\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n)\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n)\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/)\n\n      const element = {}\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n          const n = parseASCIINumber(values.shift(), properties[i].countType)\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType))\n          }\n\n          element[properties[i].name] = list\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type)\n        }\n      }\n\n      return element\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      let result\n\n      const patternBody = /end_header\\s([\\s\\S]*)$/\n      let body = ''\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1]\n      }\n\n      const lines = body.split('\\n')\n      let currentElement = 0\n      let currentElementCount = 0\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n        if (line === '') {\n          continue\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++\n          currentElementCount = 0\n        }\n\n        const element = parseASCIIElement(header.elements[currentElement].properties, line)\n\n        handleElement(buffer, header.elements[currentElement].name, element)\n\n        currentElementCount++\n      }\n\n      return postProcess(buffer)\n    }\n\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry()\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices)\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3))\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3))\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2))\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3))\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed()\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2))\n      }\n\n      geometry.computeBoundingSphere()\n\n      return geometry\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z)\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz)\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t)\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0)\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index // issue #9338\n        const texcoord = element.texcoord\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2])\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1])\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3])\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5])\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3])\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3])\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1]\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1]\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2]\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2]\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4]\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4]\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4]\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8]\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {}\n      let result,\n        read = 0\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian)\n          const n = result[0]\n          read += result[1]\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian)\n            list.push(result[0])\n            read += result[1]\n          }\n\n          element[properties[i].name] = list\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian)\n          element[properties[i].name] = result[0]\n          read += result[1]\n        }\n      }\n\n      return [element, read]\n    }\n\n    function parseBinary(data, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      const little_endian = header.format === 'binary_little_endian'\n      const body = new DataView(data, header.headerLength)\n      let result,\n        loc = 0\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (\n          let currentElementCount = 0;\n          currentElementCount < header.elements[currentElement].count;\n          currentElementCount++\n        ) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian)\n          loc += result[1]\n          const element = result[0]\n\n          handleElement(buffer, header.elements[currentElement].name, element)\n        }\n      }\n\n      return postProcess(buffer)\n    }\n\n    //\n\n    let geometry\n    const scope = this\n\n    if (data instanceof ArrayBuffer) {\n      const text = decodeText(new Uint8Array(data))\n      const header = parseHeader(text)\n\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header)\n    } else {\n      geometry = parseASCII(data, parseHeader(data))\n    }\n\n    return geometry\n  }\n}\n\nexport { PLYLoader }\n"]},"metadata":{},"sourceType":"module"}