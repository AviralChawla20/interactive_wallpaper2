{"ast":null,"code":"import { Loader, FileLoader, Vector3, Matrix4 } from \"three\";\nimport { gunzipSync } from \"fflate\";\nimport { Volume } from \"../misc/Volume.js\";\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    let _data = data;\n    let _dataPointer = 0;\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n    const _littleEndian = true;\n    const headerObject = {};\n    function scan(type, chunks) {\n      if (chunks === void 0 || chunks === null) {\n        chunks = 1;\n      }\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n      switch (type) {\n        case \"uchar\":\n          break;\n        case \"schar\":\n          _array_type = Int8Array;\n          break;\n        case \"ushort\":\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n        case \"sshort\":\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n        case \"uint\":\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n        case \"sint\":\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n        case \"float\":\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n        case \"complex\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n        case \"double\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      }\n      let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n      if (_nativeLittleEndian != _littleEndian) {\n        _bytes2 = flipEndianness(_bytes2, _chunkSize);\n      }\n      if (chunks == 1) {\n        return _bytes2[0];\n      }\n      return _bytes2;\n    }\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n      for (let i2 = 0; i2 < array.byteLength; i2 += chunkSize) {\n        for (let j = i2 + chunkSize - 1, k = i2; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n      return array;\n    }\n    function parseHeader(header) {\n      let data2, field, fn, i2, l, m, _i, _len;\n      const lines = header.split(/\\r?\\n/);\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (l.match(/^#/)) ;else if (m = l.match(/(.*):(.*)/)) {\n          field = m[1].trim();\n          data2 = m[2].trim();\n          fn = _fieldFunctions[field];\n          if (fn) {\n            fn.call(headerObject, data2);\n          } else {\n            headerObject[field] = data2;\n          }\n        }\n      }\n      if (!headerObject.isNrrd) {\n        throw new Error(\"Not an NRRD file\");\n      }\n      if (headerObject.encoding === \"bz2\" || headerObject.encoding === \"bzip2\") {\n        throw new Error(\"Bzip is not supported\");\n      }\n      if (!headerObject.vectors) {\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n        if (headerObject.spacings) {\n          for (i2 = 0; i2 <= 2; i2++) {\n            if (!isNaN(headerObject.spacings[i2])) {\n              headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);\n            }\n          }\n        }\n      }\n    }\n    function parseDataAsText(data2, start, end) {\n      let number = \"\";\n      start = start || 0;\n      end = end || data2.length;\n      let value;\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n      if (headerObject.encoding === \"hex\") {\n        base = 16;\n      }\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n      for (let i2 = start; i2 < end; i2++) {\n        value = data2[i2];\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== \"\") {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n          number = \"\";\n        }\n      }\n      if (number !== \"\") {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n      return result;\n    }\n    const _bytes = scan(\"uchar\", data.byteLength);\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        _header = this.parseChars(_bytes, 0, i - 2);\n        _data_start = i + 1;\n        break;\n      }\n    }\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start);\n    if (headerObject.encoding.substring(0, 2) === \"gz\") {\n      _data = gunzipSync(new Uint8Array(_data));\n    } else if (headerObject.encoding === \"ascii\" || headerObject.encoding === \"text\" || headerObject.encoding === \"txt\" || headerObject.encoding === \"hex\") {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === \"raw\") {\n      const _copy = new Uint8Array(_data.length);\n      for (let i2 = 0; i2 < _data.length; i2++) {\n        _copy[i2] = _data[i2];\n      }\n      _data = _copy;\n    }\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject;\n    volume.data = new headerObject.__array(_data);\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1];\n    volume.windowLow = min;\n    volume.windowHigh = max;\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2];\n    const spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n    const spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n    const spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n    volume.spacing = [spacingX, spacingY, spacingZ];\n    volume.matrix = new Matrix4();\n    let _spaceX = 1;\n    let _spaceY = 1;\n    const _spaceZ = 1;\n    if (headerObject.space == \"left-posterior-superior\") {\n      _spaceX = -1;\n      _spaceY = -1;\n    } else if (headerObject.space === \"left-anterior-superior\") {\n      _spaceX = -1;\n    }\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n    }\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n    return volume;\n  }\n  parseChars(array, start, end) {\n    if (start === void 0) {\n      start = 0;\n    }\n    if (end === void 0) {\n      end = array.length;\n    }\n    let output = \"\";\n    let i = 0;\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n    return output;\n  }\n}\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case \"uchar\":\n      case \"unsigned char\":\n      case \"uint8\":\n      case \"uint8_t\":\n        this.__array = Uint8Array;\n        break;\n      case \"signed char\":\n      case \"int8\":\n      case \"int8_t\":\n        this.__array = Int8Array;\n        break;\n      case \"short\":\n      case \"short int\":\n      case \"signed short\":\n      case \"signed short int\":\n      case \"int16\":\n      case \"int16_t\":\n        this.__array = Int16Array;\n        break;\n      case \"ushort\":\n      case \"unsigned short\":\n      case \"unsigned short int\":\n      case \"uint16\":\n      case \"uint16_t\":\n        this.__array = Uint16Array;\n        break;\n      case \"int\":\n      case \"signed int\":\n      case \"int32\":\n      case \"int32_t\":\n        this.__array = Int32Array;\n        break;\n      case \"uint\":\n      case \"unsigned int\":\n      case \"uint32\":\n      case \"uint32_t\":\n        this.__array = Uint32Array;\n        break;\n      case \"float\":\n        this.__array = Float32Array;\n        break;\n      case \"double\":\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error(\"Unsupported NRRD data type: \" + data);\n    }\n    return this.type = data;\n  },\n  endian: function (data) {\n    return this.endian = data;\n  },\n  encoding: function (data) {\n    return this.encoding = data;\n  },\n  dimension: function (data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function (data) {\n    let i;\n    return this.sizes = function () {\n      const _ref = data.split(/\\s+/);\n      const _results = [];\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function (data) {\n    return this.space = data;\n  },\n  \"space origin\": function (data) {\n    return this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n  },\n  \"space directions\": function (data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(function () {\n          const _ref = v.slice(1, -1).split(/,/);\n          const _results2 = [];\n          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n            _results2.push(parseFloat(f));\n          }\n          return _results2;\n        }());\n      }\n      return _results;\n    }();\n  },\n  spacings: function (data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":{"version":3,"sources":["../../src/loaders/NRRDLoader.js"],"names":["_bytes","i","data"],"mappings":";;;AAIA,MAAM,UAAA,SAAmB,MAAA,CAAO;EAC9B,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;EACd;EAED,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,KAAA,GAAQ,IAAA;IAEd,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,KAAA,CAAM,OAAO,CAAA;IAC3C,MAAA,CAAO,OAAA,CAAQ,KAAA,CAAM,IAAI,CAAA;IACzB,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;IACpC,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM,aAAa,CAAA;IAC3C,MAAA,CAAO,kBAAA,CAAmB,KAAA,CAAM,eAAe,CAAA;IAC/C,MAAA,CAAO,IAAA,CACL,GAAA,EACA,UAAU,IAAA,EAAM;MACd,IAAI;QACF,MAAA,CAAO,KAAA,CAAM,KAAA,CAAM,IAAI,CAAC,CAAA;MACzB,CAAA,CAAA,OAAQ,CAAA,EAAP;QACA,IAAI,OAAA,EAAS;UACX,OAAA,CAAQ,CAAC,CAAA;QACrB,CAAA,MAAiB;UACL,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;QAChB;QAED,KAAA,CAAM,OAAA,CAAQ,SAAA,CAAU,GAAG,CAAA;MAC5B;IACF,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAED,KAAA,CAAM,IAAA,EAAM;IAGV,IAAI,KAAA,GAAQ,IAAA;IAEZ,IAAI,YAAA,GAAe,CAAA;IAEnB,MAAM,mBAAA,GAAsB,IAAI,SAAA,CAAU,IAAI,UAAA,CAAW,CAAC,CAAC,CAAC,CAAA,CAAE,MAAM,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA;IAE3E,MAAM,aAAA,GAAgB,IAAA;IAEtB,MAAM,YAAA,GAAe,CAAE,CAAA;IAEvB,SAAS,IAAA,CAAK,IAAA,EAAM,MAAA,EAAQ;MAC1B,IAAI,MAAA,KAAW,KAAA,CAAA,IAAa,MAAA,KAAW,IAAA,EAAM;QAC3C,MAAA,GAAS,CAAA;MACV;MAED,IAAI,UAAA,GAAa,CAAA;MACjB,IAAI,WAAA,GAAc,UAAA;MAElB,QAAQ,IAAA;QAEN,KAAK,OAAA;UACH;QACF,KAAK,OAAA;UACH,WAAA,GAAc,SAAA;UACd;QAEF,KAAK,QAAA;UACH,WAAA,GAAc,WAAA;UACd,UAAA,GAAa,CAAA;UACb;QACF,KAAK,QAAA;UACH,WAAA,GAAc,UAAA;UACd,UAAA,GAAa,CAAA;UACb;QAEF,KAAK,MAAA;UACH,WAAA,GAAc,WAAA;UACd,UAAA,GAAa,CAAA;UACb;QACF,KAAK,MAAA;UACH,WAAA,GAAc,UAAA;UACd,UAAA,GAAa,CAAA;UACb;QACF,KAAK,OAAA;UACH,WAAA,GAAc,YAAA;UACd,UAAA,GAAa,CAAA;UACb;QACF,KAAK,SAAA;UACH,WAAA,GAAc,YAAA;UACd,UAAA,GAAa,CAAA;UACb;QACF,KAAK,QAAA;UACH,WAAA,GAAc,YAAA;UACd,UAAA,GAAa,CAAA;UACb;MACH;MAGD,IAAIA,OAAAA,GAAS,IAAI,WAAA,CAAY,KAAA,CAAM,KAAA,CAAM,YAAA,EAAe,YAAA,IAAgB,MAAA,GAAS,UAAA,CAAY,CAAA;MAG7F,IAAI,mBAAA,IAAuB,aAAA,EAAe;QAExC,OAAA,GAAS,cAAA,CAAeA,OAAAA,EAAQ,UAAU,CAAA;MAC3C;MAED,IAAI,MAAA,IAAU,CAAA,EAAG;QAEf,OAAOA,OAAAA,CAAO,CAAC,CAAA;MAChB;MAGD,OAAO,OAAA;IACR;IAID,SAAS,cAAA,CAAe,KAAA,EAAO,SAAA,EAAW;MACxC,MAAM,EAAA,GAAK,IAAI,UAAA,CAAW,KAAA,CAAM,MAAA,EAAQ,KAAA,CAAM,UAAA,EAAY,KAAA,CAAM,UAAU,CAAA;MAC1E,KAAA,IAASC,EAAAA,GAAI,CAAA,EAAGA,EAAAA,GAAI,KAAA,CAAM,UAAA,EAAYA,EAAAA,IAAK,SAAA,EAAW;QACpD,KAAA,IAAS,CAAA,GAAIA,EAAAA,GAAI,SAAA,GAAY,CAAA,EAAG,CAAA,GAAIA,EAAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,CAAA,EAAA,EAAK;UACtD,MAAM,GAAA,GAAM,EAAA,CAAG,CAAC,CAAA;UAChB,EAAA,CAAG,CAAC,CAAA,GAAI,EAAA,CAAG,CAAC,CAAA;UACZ,EAAA,CAAG,CAAC,CAAA,GAAI,GAAA;QACT;MACF;MAED,OAAO,KAAA;IACR;IAGD,SAAS,WAAA,CAAY,MAAA,EAAQ;MAC3B,IAAIC,KAAAA,EAAM,KAAA,EAAO,EAAA,EAAID,EAAAA,EAAG,CAAA,EAAG,CAAA,EAAG,EAAA,EAAI,IAAA;MAClC,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,OAAO,CAAA;MAClC,KAAK,EAAA,GAAK,CAAA,EAAG,IAAA,GAAO,KAAA,CAAM,MAAA,EAAQ,EAAA,GAAK,IAAA,EAAM,EAAA,EAAA,EAAM;QACjD,CAAA,GAAI,KAAA,CAAM,EAAE,CAAA;QACZ,IAAI,CAAA,CAAE,KAAA,CAAM,SAAS,CAAA,EAAG;UACtB,YAAA,CAAa,MAAA,GAAS,IAAA;QACvB,CAAA,MAAA,IAAU,CAAA,CAAE,KAAA,CAAM,IAAI,CAAA,EAAG,CAAA,KAAA,IACd,CAAA,GAAI,CAAA,CAAE,KAAA,CAAM,WAAW,CAAA,EAAI;UACrC,KAAA,GAAQ,CAAA,CAAE,CAAC,CAAA,CAAE,IAAA,CAAM,CAAA;UACnB,KAAA,GAAO,CAAA,CAAE,CAAC,CAAA,CAAE,IAAA,CAAM,CAAA;UAClB,EAAA,GAAK,eAAA,CAAgB,KAAK,CAAA;UAC1B,IAAI,EAAA,EAAI;YACN,EAAA,CAAG,IAAA,CAAK,YAAA,EAAcC,KAAI,CAAA;UACtC,CAAA,MAAiB;YACL,YAAA,CAAa,KAAK,CAAA,GAAI,KAAA;UACvB;QACF;MACF;MAED,IAAI,CAAC,YAAA,CAAa,MAAA,EAAQ;QACxB,MAAM,IAAI,KAAA,CAAM,kBAAkB,CAAA;MACnC;MAED,IAAI,YAAA,CAAa,QAAA,KAAa,KAAA,IAAS,YAAA,CAAa,QAAA,KAAa,OAAA,EAAS;QACxE,MAAM,IAAI,KAAA,CAAM,uBAAuB,CAAA;MACxC;MAED,IAAI,CAAC,YAAA,CAAa,OAAA,EAAS;QAEzB,YAAA,CAAa,OAAA,GAAU,CAAC,IAAI,OAAA,CAAQ,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA,EAAG,IAAI,OAAA,CAAQ,CAAA,EAAG,CAAA,EAAG,CAAC,CAAC,CAAA;QAExF,IAAI,YAAA,CAAa,QAAA,EAAU;UACzB,KAAKD,EAAAA,GAAI,CAAA,EAAGA,EAAAA,IAAK,CAAA,EAAGA,EAAAA,EAAAA,EAAK;YACvB,IAAI,CAAC,KAAA,CAAM,YAAA,CAAa,QAAA,CAASA,EAAC,CAAC,CAAA,EAAG;cACpC,YAAA,CAAa,OAAA,CAAQA,EAAC,CAAA,CAAE,cAAA,CAAe,YAAA,CAAa,QAAA,CAASA,EAAC,CAAC,CAAA;YAChE;UACF;QACF;MACF;IACF;IAGD,SAAS,eAAA,CAAgBC,KAAAA,EAAM,KAAA,EAAO,GAAA,EAAK;MACzC,IAAI,MAAA,GAAS,EAAA;MACb,KAAA,GAAQ,KAAA,IAAS,CAAA;MACjB,GAAA,GAAM,GAAA,IAAOA,KAAAA,CAAK,MAAA;MAClB,IAAI,KAAA;MAEJ,MAAM,iBAAA,GAAoB,YAAA,CAAa,KAAA,CAAM,MAAA,CAAO,UAAU,QAAA,EAAU,OAAA,EAAS;QAC/E,OAAO,QAAA,GAAW,OAAA;MACnB,CAAA,EAAE,CAAC,CAAA;MAEJ,IAAI,IAAA,GAAO,EAAA;MACX,IAAI,YAAA,CAAa,QAAA,KAAa,KAAA,EAAO;QACnC,IAAA,GAAO,EAAA;MACR;MAED,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,OAAA,CAAQ,iBAAiB,CAAA;MACzD,IAAI,WAAA,GAAc,CAAA;MAClB,IAAI,eAAA,GAAkB,QAAA;MACtB,IAAI,YAAA,CAAa,OAAA,KAAY,YAAA,IAAgB,YAAA,CAAa,OAAA,KAAY,YAAA,EAAc;QAClF,eAAA,GAAkB,UAAA;MACnB;MAED,KAAA,IAASD,EAAAA,GAAI,KAAA,EAAOA,EAAAA,GAAI,GAAA,EAAKA,EAAAA,EAAAA,EAAK;QAChC,KAAA,GAAQC,KAAAA,CAAKD,EAAC,CAAA;QAEd,IAAA,CAAK,KAAA,GAAQ,CAAA,IAAK,KAAA,GAAQ,EAAA,KAAO,KAAA,KAAU,EAAA,EAAI;UAC7C,MAAA,IAAU,MAAA,CAAO,YAAA,CAAa,KAAK,CAAA;QAC7C,CAAA,MAAe;UACL,IAAI,MAAA,KAAW,EAAA,EAAI;YACjB,MAAA,CAAO,WAAW,CAAA,GAAI,eAAA,CAAgB,MAAA,EAAQ,IAAI,CAAA;YAClD,WAAA,EAAA;UACD;UAED,MAAA,GAAS,EAAA;QACV;MACF;MAED,IAAI,MAAA,KAAW,EAAA,EAAI;QACjB,MAAA,CAAO,WAAW,CAAA,GAAI,eAAA,CAAgB,MAAA,EAAQ,IAAI,CAAA;QAClD,WAAA,EAAA;MACD;MAED,OAAO,MAAA;IACR;IAED,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,EAAS,IAAA,CAAK,UAAU,CAAA;IAC5C,MAAM,OAAA,GAAU,MAAA,CAAO,MAAA;IACvB,IAAI,OAAA,GAAU,IAAA;IACd,IAAI,WAAA,GAAc,CAAA;IAClB,IAAI,CAAA;IACJ,KAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,EAAS,CAAA,EAAA,EAAK;MAC5B,IAAI,MAAA,CAAO,CAAA,GAAI,CAAC,CAAA,IAAK,EAAA,IAAM,MAAA,CAAO,CAAC,CAAA,IAAK,EAAA,EAAI;QAG1C,OAAA,GAAU,IAAA,CAAK,UAAA,CAAW,MAAA,EAAQ,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA;QAE1C,WAAA,GAAc,CAAA,GAAI,CAAA;QAClB;MACD;IACF;IAGD,WAAA,CAAY,OAAO,CAAA;IAEnB,KAAA,GAAQ,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA;IACnC,IAAI,YAAA,CAAa,QAAA,CAAS,SAAA,CAAU,CAAA,EAAG,CAAC,CAAA,KAAM,IAAA,EAAM;MAGlD,KAAA,GAAQ,UAAA,CAAW,IAAI,UAAA,CAAW,KAAK,CAAC,CAAA;IAC9C,CAAA,MAAA,IACM,YAAA,CAAa,QAAA,KAAa,OAAA,IAC1B,YAAA,CAAa,QAAA,KAAa,MAAA,IAC1B,YAAA,CAAa,QAAA,KAAa,KAAA,IAC1B,YAAA,CAAa,QAAA,KAAa,KAAA,EAC1B;MACA,KAAA,GAAQ,eAAA,CAAgB,KAAK,CAAA;IACnC,CAAA,MAAA,IAAe,YAAA,CAAa,QAAA,KAAa,KAAA,EAAO;MAE1C,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,KAAA,CAAM,MAAM,CAAA;MAEzC,KAAA,IAASA,EAAAA,GAAI,CAAA,EAAGA,EAAAA,GAAI,KAAA,CAAM,MAAA,EAAQA,EAAAA,EAAAA,EAAK;QACrC,KAAA,CAAMA,EAAC,CAAA,GAAI,KAAA,CAAMA,EAAC,CAAA;MACnB;MAED,KAAA,GAAQ,KAAA;IACT;IAGD,KAAA,GAAQ,KAAA,CAAM,MAAA;IAEd,MAAM,MAAA,GAAS,IAAI,MAAA,CAAQ,CAAA;IAC3B,MAAA,CAAO,MAAA,GAAS,YAAA;IAIhB,MAAA,CAAO,IAAA,GAAO,IAAI,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAA;IAE5C,MAAM,OAAA,GAAU,MAAA,CAAO,aAAA,CAAe,CAAA;IACtC,MAAM,GAAA,GAAM,OAAA,CAAQ,CAAC,CAAA;IACrB,MAAM,GAAA,GAAM,OAAA,CAAQ,CAAC,CAAA;IAErB,MAAA,CAAO,SAAA,GAAY,GAAA;IACnB,MAAA,CAAO,UAAA,GAAa,GAAA;IAGpB,MAAA,CAAO,UAAA,GAAa,CAAC,YAAA,CAAa,KAAA,CAAM,CAAC,CAAA,EAAG,YAAA,CAAa,KAAA,CAAM,CAAC,CAAA,EAAG,YAAA,CAAa,KAAA,CAAM,CAAC,CAAC,CAAA;IACxF,MAAA,CAAO,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA;IACpC,MAAA,CAAO,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA;IACpC,MAAA,CAAO,OAAA,GAAU,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA;IAEpC,MAAM,QAAA,GAAW,IAAI,OAAA,CACnB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAC1B,CAAA,CAAC,MAAA,CAAQ,CAAA;IACV,MAAM,QAAA,GAAW,IAAI,OAAA,CACnB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAC1B,CAAA,CAAC,MAAA,CAAQ,CAAA;IACV,MAAM,QAAA,GAAW,IAAI,OAAA,CACnB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAAA,EACzB,YAAA,CAAa,OAAA,CAAQ,CAAC,CAAA,CAAE,CAAC,CAC1B,CAAA,CAAC,MAAA,CAAQ,CAAA;IACV,MAAA,CAAO,OAAA,GAAU,CAAC,QAAA,EAAU,QAAA,EAAU,QAAQ,CAAA;IAG9C,MAAA,CAAO,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;IAE7B,IAAI,OAAA,GAAU,CAAA;IACd,IAAI,OAAA,GAAU,CAAA;IACd,MAAM,OAAA,GAAU,CAAA;IAEhB,IAAI,YAAA,CAAa,KAAA,IAAS,yBAAA,EAA2B;MACnD,OAAA,GAAU,CAAA,CAAA;MACV,OAAA,GAAU,CAAA,CAAA;IAChB,CAAA,MAAA,IAAe,YAAA,CAAa,KAAA,KAAU,wBAAA,EAA0B;MAC1D,OAAA,GAAU,CAAA,CAAA;IACX;IAED,IAAI,CAAC,YAAA,CAAa,OAAA,EAAS;MACzB,MAAA,CAAO,MAAA,CAAO,GAAA,CAAI,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;IACxF,CAAA,MAAW;MACL,MAAM,CAAA,GAAI,YAAA,CAAa,OAAA;MAEvB,MAAA,CAAO,MAAA,CAAO,GAAA,CACZ,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,CAAA,EACA,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,CAAA,EACA,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,OAAA,GAAU,CAAA,CAAE,CAAC,CAAA,CAAE,CAAC,CAAA,EAChB,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CACD,CAAA;IACF;IAED,MAAA,CAAO,aAAA,GAAgB,IAAI,OAAA,CAAS,CAAA;IACpC,MAAA,CAAO,aAAA,CAAc,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA,CAAE,MAAA,CAAQ,CAAA;IACjD,MAAA,CAAO,aAAA,GAAgB,IAAI,OAAA,CAAQ,MAAA,CAAO,OAAA,EAAS,MAAA,CAAO,OAAA,EAAS,MAAA,CAAO,OAAO,CAAA,CAC9E,YAAA,CAAa,MAAA,CAAO,MAAM,CAAA,CAC1B,KAAA,CAAO,CAAA,CACP,OAAA,CAAS,CAAA,CACT,GAAA,CAAI,IAAA,CAAK,GAAG,CAAA;IAIf,IAAI,MAAA,CAAO,cAAA,KAAmB,CAAA,QAAA,EAAW;MACvC,MAAA,CAAO,cAAA,GAAiB,GAAA;IACzB;IAED,IAAI,MAAA,CAAO,cAAA,KAAmB,QAAA,EAAU;MACtC,MAAA,CAAO,cAAA,GAAiB,GAAA;IACzB;IAED,OAAO,MAAA;EACR;EAED,UAAA,CAAW,KAAA,EAAO,KAAA,EAAO,GAAA,EAAK;IAE5B,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;MACvB,KAAA,GAAQ,CAAA;IACT;IAED,IAAI,GAAA,KAAQ,KAAA,CAAA,EAAW;MACrB,GAAA,GAAM,KAAA,CAAM,MAAA;IACb;IAED,IAAI,MAAA,GAAS,EAAA;IAEb,IAAI,CAAA,GAAI,CAAA;IACR,KAAK,CAAA,GAAI,KAAA,EAAO,CAAA,GAAI,GAAA,EAAK,EAAE,CAAA,EAAG;MAC5B,MAAA,IAAU,MAAA,CAAO,YAAA,CAAa,KAAA,CAAM,CAAC,CAAC,CAAA;IACvC;IAED,OAAO,MAAA;EACR;AACH;AAEA,MAAM,eAAA,GAAkB;EACtB,IAAA,EAAM,SAAA,CAAU,IAAA,EAAM;IACpB,QAAQ,IAAA;MACN,KAAK,OAAA;MACL,KAAK,eAAA;MACL,KAAK,OAAA;MACL,KAAK,SAAA;QACH,IAAA,CAAK,OAAA,GAAU,UAAA;QACf;MACF,KAAK,aAAA;MACL,KAAK,MAAA;MACL,KAAK,QAAA;QACH,IAAA,CAAK,OAAA,GAAU,SAAA;QACf;MACF,KAAK,OAAA;MACL,KAAK,WAAA;MACL,KAAK,cAAA;MACL,KAAK,kBAAA;MACL,KAAK,OAAA;MACL,KAAK,SAAA;QACH,IAAA,CAAK,OAAA,GAAU,UAAA;QACf;MACF,KAAK,QAAA;MACL,KAAK,gBAAA;MACL,KAAK,oBAAA;MACL,KAAK,QAAA;MACL,KAAK,UAAA;QACH,IAAA,CAAK,OAAA,GAAU,WAAA;QACf;MACF,KAAK,KAAA;MACL,KAAK,YAAA;MACL,KAAK,OAAA;MACL,KAAK,SAAA;QACH,IAAA,CAAK,OAAA,GAAU,UAAA;QACf;MACF,KAAK,MAAA;MACL,KAAK,cAAA;MACL,KAAK,QAAA;MACL,KAAK,UAAA;QACH,IAAA,CAAK,OAAA,GAAU,WAAA;QACf;MACF,KAAK,OAAA;QACH,IAAA,CAAK,OAAA,GAAU,YAAA;QACf;MACF,KAAK,QAAA;QACH,IAAA,CAAK,OAAA,GAAU,YAAA;QACf;MACF;QACE,MAAM,IAAI,KAAA,CAAM,8BAAA,GAAiC,IAAI,CAAA;IACxD;IAED,OAAQ,IAAA,CAAK,IAAA,GAAO,IAAA;EACrB,CAAA;EAED,MAAA,EAAQ,SAAA,CAAU,IAAA,EAAM;IACtB,OAAQ,IAAA,CAAK,MAAA,GAAS,IAAA;EACvB,CAAA;EAED,QAAA,EAAU,SAAA,CAAU,IAAA,EAAM;IACxB,OAAQ,IAAA,CAAK,QAAA,GAAW,IAAA;EACzB,CAAA;EAED,SAAA,EAAW,SAAA,CAAU,IAAA,EAAM;IACzB,OAAQ,IAAA,CAAK,GAAA,GAAM,QAAA,CAAS,IAAA,EAAM,EAAE,CAAA;EACrC,CAAA;EAED,KAAA,EAAO,SAAA,CAAU,IAAA,EAAM;IACrB,IAAI,CAAA;IACJ,OAAQ,IAAA,CAAK,KAAA,GAAS,YAAY;MAChC,MAAM,IAAA,GAAO,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;MAC7B,MAAM,QAAA,GAAW,EAAE;MAEnB,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,IAAA,GAAO,IAAA,CAAK,MAAA,EAAQ,EAAA,GAAK,IAAA,EAAM,EAAA,EAAA,EAAM;QACpD,CAAA,GAAI,IAAA,CAAK,EAAE,CAAA;QACX,QAAA,CAAS,IAAA,CAAK,QAAA,CAAS,CAAA,EAAG,EAAE,CAAC,CAAA;MAC9B;MAED,OAAO,QAAA;IACb,CAAA,CAAA,CAAA;EACG,CAAA;EAED,KAAA,EAAO,SAAA,CAAU,IAAA,EAAM;IACrB,OAAQ,IAAA,CAAK,KAAA,GAAQ,IAAA;EACtB,CAAA;EAED,cAAA,EAAgB,SAAA,CAAU,IAAA,EAAM;IAC9B,OAAQ,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA;EACvE,CAAA;EAED,kBAAA,EAAoB,SAAA,CAAU,IAAA,EAAM;IAClC,IAAI,CAAA,EAAG,CAAA;IACP,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,UAAU,CAAA;IACnC,OAAQ,IAAA,CAAK,OAAA,GAAW,YAAY;MAClC,MAAM,QAAA,GAAW,EAAE;MAEnB,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,IAAA,GAAO,KAAA,CAAM,MAAA,EAAQ,EAAA,GAAK,IAAA,EAAM,EAAA,EAAA,EAAM;QACrD,CAAA,GAAI,KAAA,CAAM,EAAE,CAAA;QACZ,QAAA,CAAS,IAAA,CACN,YAAY;UACX,MAAM,IAAA,GAAO,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,CAAA,CAAE,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA;UACrC,MAAM,SAAA,GAAY,EAAE;UAEpB,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,KAAA,GAAQ,IAAA,CAAK,MAAA,EAAQ,EAAA,GAAK,KAAA,EAAO,EAAA,EAAA,EAAM;YACtD,CAAA,GAAI,IAAA,CAAK,EAAE,CAAA;YACX,SAAA,CAAU,IAAA,CAAK,UAAA,CAAW,CAAC,CAAC,CAAA;UAC7B;UAED,OAAO,SAAA;QACnB,CAAA,CAAc,CACL,CAAA;MACF;MAED,OAAO,QAAA;IACb,CAAA,CAAA,CAAA;EACG,CAAA;EAED,QAAA,EAAU,SAAA,CAAU,IAAA,EAAM;IACxB,IAAI,CAAA;IACJ,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;IAC9B,OAAQ,IAAA,CAAK,QAAA,GAAY,YAAY;MACnC,MAAM,QAAA,GAAW,EAAE;MAEnB,KAAA,IAAS,EAAA,GAAK,CAAA,EAAG,IAAA,GAAO,KAAA,CAAM,MAAA,EAAQ,EAAA,GAAK,IAAA,EAAM,EAAA,EAAA,EAAM;QACrD,CAAA,GAAI,KAAA,CAAM,EAAE,CAAA;QACZ,QAAA,CAAS,IAAA,CAAK,UAAA,CAAW,CAAC,CAAC,CAAA;MAC5B;MAED,OAAO,QAAA;IACb,CAAA,CAAA,CAAA;EACG;AACH,CAAA","sourcesContent":["import { FileLoader, Loader, Matrix4, Vector3 } from 'three'\nimport { gunzipSync } from 'fflate'\nimport { Volume } from '../misc/Volume'\n\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n    let _data = data\n\n    let _dataPointer = 0\n\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0\n\n    const _littleEndian = true\n\n    const headerObject = {}\n\n    function scan(type, chunks) {\n      if (chunks === undefined || chunks === null) {\n        chunks = 1\n      }\n\n      let _chunkSize = 1\n      let _array_type = Uint8Array\n\n      switch (type) {\n        // 1 byte data types\n        case 'uchar':\n          break\n        case 'schar':\n          _array_type = Int8Array\n          break\n        // 2 byte data types\n        case 'ushort':\n          _array_type = Uint16Array\n          _chunkSize = 2\n          break\n        case 'sshort':\n          _array_type = Int16Array\n          _chunkSize = 2\n          break\n        // 4 byte data types\n        case 'uint':\n          _array_type = Uint32Array\n          _chunkSize = 4\n          break\n        case 'sint':\n          _array_type = Int32Array\n          _chunkSize = 4\n          break\n        case 'float':\n          _array_type = Float32Array\n          _chunkSize = 4\n          break\n        case 'complex':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n        case 'double':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n      }\n\n      // increase the data pointer in-place\n      let _bytes = new _array_type(_data.slice(_dataPointer, (_dataPointer += chunks * _chunkSize)))\n\n      // if required, flip the endianness of the bytes\n      if (_nativeLittleEndian != _littleEndian) {\n        // we need to flip here since the format doesn't match the native endianness\n        _bytes = flipEndianness(_bytes, _chunkSize)\n      }\n\n      if (chunks == 1) {\n        // if only one chunk was requested, just return one value\n        return _bytes[0]\n      }\n\n      // return the byte array\n      return _bytes\n    }\n\n    //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength)\n      for (let i = 0; i < array.byteLength; i += chunkSize) {\n        for (let j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n          const tmp = u8[k]\n          u8[k] = u8[j]\n          u8[j] = tmp\n        }\n      }\n\n      return array\n    }\n\n    //parse the header\n    function parseHeader(header) {\n      let data, field, fn, i, l, m, _i, _len\n      const lines = header.split(/\\r?\\n/)\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i]\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true\n        } else if (l.match(/^#/)) {\n        } else if ((m = l.match(/(.*):(.*)/))) {\n          field = m[1].trim()\n          data = m[2].trim()\n          fn = _fieldFunctions[field]\n          if (fn) {\n            fn.call(headerObject, data)\n          } else {\n            headerObject[field] = data\n          }\n        }\n      }\n\n      if (!headerObject.isNrrd) {\n        throw new Error('Not an NRRD file')\n      }\n\n      if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n        throw new Error('Bzip is not supported')\n      }\n\n      if (!headerObject.vectors) {\n        //if no space direction is set, let's use the identity\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]\n        //apply spacing if defined\n        if (headerObject.spacings) {\n          for (i = 0; i <= 2; i++) {\n            if (!isNaN(headerObject.spacings[i])) {\n              headerObject.vectors[i].multiplyScalar(headerObject.spacings[i])\n            }\n          }\n        }\n      }\n    }\n\n    //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n    function parseDataAsText(data, start, end) {\n      let number = ''\n      start = start || 0\n      end = end || data.length\n      let value\n      //length of the result is the product of the sizes\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current\n      }, 1)\n\n      let base = 10\n      if (headerObject.encoding === 'hex') {\n        base = 16\n      }\n\n      const result = new headerObject.__array(lengthOfTheResult)\n      let resultIndex = 0\n      let parsingFunction = parseInt\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat\n      }\n\n      for (let i = start; i < end; i++) {\n        value = data[i]\n        //if value is not a space\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value)\n        } else {\n          if (number !== '') {\n            result[resultIndex] = parsingFunction(number, base)\n            resultIndex++\n          }\n\n          number = ''\n        }\n      }\n\n      if (number !== '') {\n        result[resultIndex] = parsingFunction(number, base)\n        resultIndex++\n      }\n\n      return result\n    }\n\n    const _bytes = scan('uchar', data.byteLength)\n    const _length = _bytes.length\n    let _header = null\n    let _data_start = 0\n    let i\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        // we found two line breaks in a row\n        // now we know what the header is\n        _header = this.parseChars(_bytes, 0, i - 2)\n        // this is were the data starts\n        _data_start = i + 1\n        break\n      }\n    }\n\n    // parse the header\n    parseHeader(_header)\n\n    _data = _bytes.subarray(_data_start) // the data without header\n    if (headerObject.encoding.substring(0, 2) === 'gz') {\n      // we need to decompress the datastream\n      // here we start the unzipping and get a typed Uint8Array back\n      _data = gunzipSync(new Uint8Array(_data))\n    } else if (\n      headerObject.encoding === 'ascii' ||\n      headerObject.encoding === 'text' ||\n      headerObject.encoding === 'txt' ||\n      headerObject.encoding === 'hex'\n    ) {\n      _data = parseDataAsText(_data)\n    } else if (headerObject.encoding === 'raw') {\n      //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n      const _copy = new Uint8Array(_data.length)\n\n      for (let i = 0; i < _data.length; i++) {\n        _copy[i] = _data[i]\n      }\n\n      _data = _copy\n    }\n\n    // .. let's use the underlying array buffer\n    _data = _data.buffer\n\n    const volume = new Volume()\n    volume.header = headerObject\n    //\n    // parse the (unzipped) data to a datastream of the correct type\n    //\n    volume.data = new headerObject.__array(_data)\n    // get the min and max intensities\n    const min_max = volume.computeMinMax()\n    const min = min_max[0]\n    const max = min_max[1]\n    // attach the scalar range to the volume\n    volume.windowLow = min\n    volume.windowHigh = max\n\n    // get the image dimensions\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]]\n    volume.xLength = volume.dimensions[0]\n    volume.yLength = volume.dimensions[1]\n    volume.zLength = volume.dimensions[2]\n    // spacing\n    const spacingX = new Vector3(\n      headerObject.vectors[0][0],\n      headerObject.vectors[0][1],\n      headerObject.vectors[0][2],\n    ).length()\n    const spacingY = new Vector3(\n      headerObject.vectors[1][0],\n      headerObject.vectors[1][1],\n      headerObject.vectors[1][2],\n    ).length()\n    const spacingZ = new Vector3(\n      headerObject.vectors[2][0],\n      headerObject.vectors[2][1],\n      headerObject.vectors[2][2],\n    ).length()\n    volume.spacing = [spacingX, spacingY, spacingZ]\n\n    // Create IJKtoRAS matrix\n    volume.matrix = new Matrix4()\n\n    let _spaceX = 1\n    let _spaceY = 1\n    const _spaceZ = 1\n\n    if (headerObject.space == 'left-posterior-superior') {\n      _spaceX = -1\n      _spaceY = -1\n    } else if (headerObject.space === 'left-anterior-superior') {\n      _spaceX = -1\n    }\n\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1)\n    } else {\n      const v = headerObject.vectors\n\n      volume.matrix.set(\n        _spaceX * v[0][0],\n        _spaceX * v[1][0],\n        _spaceX * v[2][0],\n        0,\n        _spaceY * v[0][1],\n        _spaceY * v[1][1],\n        _spaceY * v[2][1],\n        0,\n        _spaceZ * v[0][2],\n        _spaceZ * v[1][2],\n        _spaceZ * v[2][2],\n        0,\n        0,\n        0,\n        0,\n        1,\n      )\n    }\n\n    volume.inverseMatrix = new Matrix4()\n    volume.inverseMatrix.copy(volume.matrix).invert()\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength)\n      .applyMatrix4(volume.matrix)\n      .round()\n      .toArray()\n      .map(Math.abs)\n\n    // .. and set the default threshold\n    // only if the threshold was not already set\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min\n    }\n\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max\n    }\n\n    return volume\n  }\n\n  parseChars(array, start, end) {\n    // without borders, use the whole array\n    if (start === undefined) {\n      start = 0\n    }\n\n    if (end === undefined) {\n      end = array.length\n    }\n\n    let output = ''\n    // create and append the chars\n    let i = 0\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i])\n    }\n\n    return output\n  }\n}\n\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array\n        break\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array\n        break\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array\n        break\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array\n        break\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array\n        break\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array\n        break\n      case 'float':\n        this.__array = Float32Array\n        break\n      case 'double':\n        this.__array = Float64Array\n        break\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data)\n    }\n\n    return (this.type = data)\n  },\n\n  endian: function (data) {\n    return (this.endian = data)\n  },\n\n  encoding: function (data) {\n    return (this.encoding = data)\n  },\n\n  dimension: function (data) {\n    return (this.dim = parseInt(data, 10))\n  },\n\n  sizes: function (data) {\n    let i\n    return (this.sizes = (function () {\n      const _ref = data.split(/\\s+/)\n      const _results = []\n\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i]\n        _results.push(parseInt(i, 10))\n      }\n\n      return _results\n    })())\n  },\n\n  space: function (data) {\n    return (this.space = data)\n  },\n\n  'space origin': function (data) {\n    return (this.space_origin = data.split('(')[1].split(')')[0].split(','))\n  },\n\n  'space directions': function (data) {\n    let f, v\n    const parts = data.match(/\\(.*?\\)/g)\n    return (this.vectors = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i]\n        _results.push(\n          (function () {\n            const _ref = v.slice(1, -1).split(/,/)\n            const _results2 = []\n\n            for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              f = _ref[_j]\n              _results2.push(parseFloat(f))\n            }\n\n            return _results2\n          })(),\n        )\n      }\n\n      return _results\n    })())\n  },\n\n  spacings: function (data) {\n    let f\n    const parts = data.split(/\\s+/)\n    return (this.spacings = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i]\n        _results.push(parseFloat(f))\n      }\n\n      return _results\n    })())\n  },\n}\n\nexport { NRRDLoader }\n"]},"metadata":{},"sourceType":"module"}