{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this) this.colorSpace = \"srgb\";else this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\nconst canvases = /* @__PURE__ */new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n        minY = -Infinity;\n      let maxX = Infinity,\n        maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\") return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\") return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\") accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map(property => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({\n            x,\n            y,\n            width,\n            height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping) clipper.add({\n      x,\n      y,\n      width,\n      height\n    });\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext(\"2d\"\n  /*, { alpha: false }*/);\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map(property => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", {\n            bubbles: true\n          }));\n        }\n      }\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"sources":["../../src/interactive/HTMLMesh.js"],"names":["context","element","width","rect"],"mappings":"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","sourcesContent":["import { CanvasTexture, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Color } from 'three'\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom)\n\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001)\n    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true })\n\n    super(geometry, material)\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event)\n    }\n\n    this.addEventListener('mousedown', onEvent)\n    this.addEventListener('mousemove', onEvent)\n    this.addEventListener('mouseup', onEvent)\n    this.addEventListener('click', onEvent)\n\n    this.dispose = function () {\n      geometry.dispose()\n      material.dispose()\n\n      material.map.dispose()\n\n      canvases.delete(dom)\n\n      this.removeEventListener('mousedown', onEvent)\n      this.removeEventListener('mousemove', onEvent)\n      this.removeEventListener('mouseup', onEvent)\n      this.removeEventListener('click', onEvent)\n    }\n  }\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom))\n\n    this.dom = dom\n\n    this.anisotropy = 16\n    if ('colorSpace' in this) this.colorSpace = 'srgb'\n    else this.encoding = 3001 // sRGBEncoding\n    this.minFilter = LinearFilter\n    this.magFilter = LinearFilter\n\n    // Create an observer on the DOM, and run html2canvas update in the next loop\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16)\n      }\n    })\n\n    const config = { attributes: true, childList: true, subtree: true, characterData: true }\n    observer.observe(dom, config)\n\n    this.observer = observer\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y)\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom)\n    this.needsUpdate = true\n\n    this.scheduleUpdate = null\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect()\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate)\n\n    super.dispose()\n  }\n}\n\n//\n\nconst canvases = new WeakMap()\n\nfunction html2canvas(element) {\n  const range = document.createRange()\n  const color = new Color()\n\n  function Clipper(context) {\n    const clips = []\n    let isClipping = false\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false\n        context.restore()\n      }\n\n      if (clips.length === 0) return\n\n      let minX = -Infinity,\n        minY = -Infinity\n      let maxX = Infinity,\n        maxY = Infinity\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i]\n\n        minX = Math.max(minX, clip.x)\n        minY = Math.max(minY, clip.y)\n        maxX = Math.min(maxX, clip.x + clip.width)\n        maxY = Math.min(maxY, clip.y + clip.height)\n      }\n\n      context.save()\n      context.beginPath()\n      context.rect(minX, minY, maxX - minX, maxY - minY)\n      context.clip()\n\n      isClipping = true\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip)\n        doClip()\n      },\n\n      remove: function () {\n        clips.pop()\n        doClip()\n      },\n    }\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase()\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily\n      context.textBaseline = 'top'\n      context.fillStyle = style.color\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1)\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2\n    if (h < 2 * r) r = h / 2\n\n    context.beginPath()\n    context.moveTo(x + r, y)\n    context.arcTo(x + w, y, x + w, y + h, r)\n    context.arcTo(x + w, y + h, x, y + h, r)\n    context.arcTo(x, y + h, x, y, r)\n    context.arcTo(x, y, x + w, y, r)\n    context.closePath()\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width']\n    const borderStyle = style[which + 'Style']\n    const borderColor = style[which + 'Color']\n\n    if (\n      borderWidth !== '0px' &&\n      borderStyle !== 'none' &&\n      borderColor !== 'transparent' &&\n      borderColor !== 'rgba(0, 0, 0, 0)'\n    ) {\n      context.strokeStyle = borderColor\n      context.lineWidth = parseFloat(borderWidth)\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(x + width, y + height)\n      context.stroke()\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n\n      range.selectNode(element)\n\n      const rect = range.getBoundingClientRect()\n\n      x = rect.left - offset.left - 0.5\n      y = rect.top - offset.top - 0.5\n      width = rect.width\n      height = rect.height\n\n      drawText(style, x, y, element.nodeValue.trim())\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return\n\n      context.save()\n      const dpr = window.devicePixelRatio\n      context.scale(1 / dpr, 1 / dpr)\n      context.drawImage(element, 0, 0)\n      context.restore()\n    } else {\n      if (element.style.display === 'none') return\n\n      const rect = element.getBoundingClientRect()\n\n      x = rect.left - offset.left - 0.5\n      y = rect.top - offset.top - 0.5\n      width = rect.width\n      height = rect.height\n\n      style = window.getComputedStyle(element)\n\n      // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius))\n\n      const backgroundColor = style.backgroundColor\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor\n        context.fill()\n      }\n\n      // If all the borders match then stroke the round rectangle\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight']\n\n      let match = true\n      let prevBorder = null\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match =\n            style[border + 'Width'] === style[prevBorder + 'Width'] &&\n            style[border + 'Color'] === style[prevBorder + 'Color'] &&\n            style[border + 'Style'] === style[prevBorder + 'Style']\n        }\n\n        if (match === false) break\n\n        prevBorder = border\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n\n        const width = parseFloat(style.borderTopWidth)\n\n        if (\n          style.borderTopWidth !== '0px' &&\n          style.borderTopStyle !== 'none' &&\n          style.borderTopColor !== 'transparent' &&\n          style.borderTopColor !== 'rgba(0, 0, 0, 0)'\n        ) {\n          context.strokeStyle = style.borderTopColor\n          context.lineWidth = width\n          context.stroke()\n        }\n      } else {\n        // Otherwise draw individual borders\n\n        drawBorder(style, 'borderTop', x, y, width, 0)\n        drawBorder(style, 'borderLeft', x, y, 0, height)\n        drawBorder(style, 'borderBottom', x, y + height, width, 0)\n        drawBorder(style, 'borderRight', x + width, y, 0, height)\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor\n\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color\n\n        color.set(accentColor)\n\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2)\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111'\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height)\n\n          context.fillStyle = 'white'\n          context.strokeStyle = accentColor\n          context.lineWidth = 1\n          context.fill()\n          context.stroke()\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height)\n\n            context.fillStyle = accentColor\n            context.strokeStyle = accentTextColor\n            context.lineWidth = 2\n            context.fill()\n            context.stroke()\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2)\n\n          context.fillStyle = element.checked ? accentColor : 'white'\n          context.strokeStyle = element.checked ? accentTextColor : accentColor\n          context.lineWidth = 1\n          context.stroke()\n          context.fill()\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign\n\n            context.textAlign = 'center'\n\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold',\n            }\n\n            drawText(properties, x + width / 2, y, '✔')\n\n            context.textAlign = currentTextAlign\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map((property) => parseFloat(element[property]))\n          const position = ((value - min) / (max - min)) * (width - height)\n\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4)\n          context.fillStyle = accentTextColor\n          context.strokeStyle = accentColor\n          context.lineWidth = 1\n          context.fill()\n          context.stroke()\n\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4)\n          context.fillStyle = accentColor\n          context.fill()\n\n          buildRectPath(x + position, y, height, height, height / 2)\n          context.fillStyle = accentColor\n          context.fill()\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({ x: x, y: y, width: width, height: height })\n\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value)\n\n          clipper.remove()\n        }\n      }\n    }\n\n    /*\n\t\t// debug\n\t\tcontext.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n\t\tcontext.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n\t\t*/\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden'\n\n    if (isClipping) clipper.add({ x: x, y: y, width: width, height: height })\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style)\n    }\n\n    if (isClipping) clipper.remove()\n  }\n\n  const offset = element.getBoundingClientRect()\n\n  let canvas = canvases.get(element)\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas')\n    canvas.width = offset.width\n    canvas.height = offset.height\n    canvases.set(element, canvas)\n  }\n\n  const context = canvas.getContext('2d' /*, { alpha: false }*/)\n\n  const clipper = new Clipper(context)\n\n  // console.time( 'drawElement' );\n\n  drawElement(element)\n\n  // console.timeEnd( 'drawElement' );\n\n  return canvas\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView,\n  }\n\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit))\n\n  const rect = element.getBoundingClientRect()\n\n  x = x * rect.width + rect.left\n  y = y * rect.height + rect.top\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect()\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit))\n\n        if (\n          element instanceof HTMLInputElement &&\n          element.type === 'range' &&\n          (event === 'mousedown' || event === 'click')\n        ) {\n          const [min, max] = ['min', 'max'].map((property) => parseFloat(element[property]))\n\n          const width = rect.width\n          const offsetX = x - rect.x\n          const proportion = offsetX / width\n          element.value = min + (max - min) * proportion\n          element.dispatchEvent(new InputEvent('input', { bubbles: true }))\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i])\n      }\n    }\n  }\n\n  traverse(element)\n}\n\nexport { HTMLMesh }\n"]},"metadata":{},"sourceType":"module"}