{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst _LightningStrike = class extends BufferGeometry {\n  constructor(rayParameters = {}) {\n    super();\n    this.isLightningStrike = true;\n    this.type = \"LightningStrike\";\n    this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n    this.createMesh();\n  }\n  static createRandomGenerator() {\n    const numSeeds = 2053;\n    const seeds = [];\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random());\n    }\n    const generator = {\n      currentSeed: 0,\n      random: function () {\n        const value = seeds[generator.currentSeed];\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n        return value;\n      },\n      getSeed: function () {\n        return generator.currentSeed / numSeeds;\n      },\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n      }\n    };\n    return generator;\n  }\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v;\n      } else {\n        return v.clone();\n      }\n    };\n    dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n    dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2,\n    // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n    dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n    dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n    dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n    dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n    dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n    dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n    dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n    return dest;\n  }\n  update(time) {\n    if (this.isStatic) return;\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = _LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = _LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = _LightningStrike.RAY_STEADY;\n      }\n      this.visible = true;\n    } else {\n      this.visible = false;\n      if (time < this.rayParameters.birthTime) {\n        this.state = _LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = _LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n  init(rayParameters) {\n    this.rayParameters = rayParameters;\n    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs;\n    if (rayParameters.randomGenerator !== void 0) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n      if (rayParameters.noiseSeed !== void 0) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = _LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    }\n    if (rayParameters.onDecideSubrayCreation !== void 0) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n      if (rayParameters.onSubrayCreation !== void 0) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    }\n    this.state = _LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n    this.raySegments = [];\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator);\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    }\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute(\"position\", this.positionAttribute);\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute(\"uv\", this.uvsAttribute);\n    }\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    }\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n      if (time < subray.birthTime) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          scope.createPrism(segment);\n        }\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n  addNewSubray() {\n    return this.subrays[this.numSubrays++];\n  }\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0;\n    this.initSubray(this.addNewSubray(), this.rayParameters);\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n  fractalRayRecursive(segment) {\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    }\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n    if (lForwards < 1e-6) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos;\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos);\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n  createPrism(segment) {\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n  createPrismFaces(vertex) {\n    const indices = this.indices;\n    vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n      if (isActive) {\n        probability = lightningStrike.subrayProbability;\n      }\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n    this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n    this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n  copy(source) {\n    super.copy(source);\n    this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n  clone() {\n    return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n  }\n};\nlet LightningStrike = _LightningStrike;\n// Ray states\n__publicField(LightningStrike, \"RAY_INITIALIZED\", 0);\n__publicField(LightningStrike, \"RAY_UNBORN\", 1);\n__publicField(LightningStrike, \"RAY_PROPAGATING\", 2);\n__publicField(LightningStrike, \"RAY_STEADY\", 3);\n__publicField(LightningStrike, \"RAY_VANISHING\", 4);\n__publicField(LightningStrike, \"RAY_EXTINGUISHED\", 5);\n__publicField(LightningStrike, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n__publicField(LightningStrike, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\nexport { LightningStrike };","map":{"version":3,"sources":["../../src/geometries/LightningStrike.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  BufferGeometry,\n  DynamicDrawUsage,\n  Float32BufferAttribute,\n  MathUtils,\n  Uint32BufferAttribute,\n  Vector3,\n} from 'three'\nimport { SimplexNoise } from '../math/SimplexNoise'\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  // Ray states\n  static RAY_INITIALIZED = 0\n  static RAY_UNBORN = 1\n  static RAY_PROPAGATING = 2\n  static RAY_STEADY = 3\n  static RAY_VANISHING = 4\n  static RAY_EXTINGUISHED = 5\n\n  static COS30DEG = Math.cos((30 * Math.PI) / 180)\n  static SIN30DEG = Math.sin((30 * Math.PI) / 180)\n\n  constructor(rayParameters = {}) {\n    super()\n\n    this.isLightningStrike = true\n\n    this.type = 'LightningStrike'\n\n    // Set parameters, and set undefined parameters to default values\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters))\n\n    // Creates and populates the mesh\n    this.createMesh()\n  }\n\n  static createRandomGenerator() {\n    const numSeeds = 2053\n    const seeds = []\n\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random())\n    }\n\n    const generator = {\n      currentSeed: 0,\n\n      random: function () {\n        const value = seeds[generator.currentSeed]\n\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds\n\n        return value\n      },\n\n      getSeed: function () {\n        return generator.currentSeed / numSeeds\n      },\n\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds\n      },\n    }\n\n    return generator\n  }\n\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v\n      } else {\n        return v.clone()\n      }\n    }\n\n    ;(dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0)),\n      (dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0)),\n      (dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1),\n      (dest.roughness = source.roughness !== undefined ? source.roughness : 0.9),\n      (dest.straightness = source.straightness !== undefined ? source.straightness : 0.7),\n      (dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1))\n    ;(dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1)),\n      (dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1),\n      (dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1),\n      (dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5),\n      (dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2),\n      (dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2),\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\n      (dest.isEternal =\n        source.isEternal !== undefined\n          ? source.isEternal\n          : source.birthTime === undefined || source.deathTime === undefined),\n      (dest.birthTime = source.birthTime),\n      (dest.deathTime = source.deathTime),\n      (dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1),\n      (dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9),\n      (dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4),\n      (dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6)\n\n    // These parameters cannot change after lightning creation:\n\n    dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9\n    dest.isStatic = source.isStatic !== undefined ? source.isStatic : false\n    dest.ramification = source.ramification !== undefined ? source.ramification : 5\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3\n    dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6\n    dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false\n    ;(dest.randomGenerator = source.randomGenerator),\n      (dest.noiseSeed = source.noiseSeed),\n      (dest.onDecideSubrayCreation = source.onDecideSubrayCreation),\n      (dest.onSubrayCreation = source.onSubrayCreation)\n\n    return dest\n  }\n\n  update(time) {\n    if (this.isStatic) return\n\n    if (\n      this.rayParameters.isEternal ||\n      (this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime)\n    ) {\n      this.updateMesh(time)\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING\n      } else {\n        this.state = LightningStrike.RAY_STEADY\n      }\n\n      this.visible = true\n    } else {\n      this.visible = false\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n\n    this.rayParameters = rayParameters\n\n    // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9\n    rayParameters.maxIterations = this.maxIterations\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false\n    rayParameters.isStatic = this.isStatic\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5\n    rayParameters.ramification = this.ramification\n    this.maxSubrayRecursion =\n      rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion\n    this.recursionProbability =\n      rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6\n    rayParameters.recursionProbability = this.recursionProbability\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false\n    rayParameters.generateUVs = this.generateUVs\n\n    // Random generator\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator\n      this.seedGenerator = rayParameters.randomGenerator\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed)\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator()\n      this.seedGenerator = Math\n    }\n\n    // Ray creation callbacks\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation\n    } else {\n      this.createDefaultSubrayCreationCallbacks()\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation\n      }\n    }\n\n    // Internal state\n\n    this.state = LightningStrike.RAY_INITIALIZED\n\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)))\n    rayParameters.maxSubrays = this.maxSubrays\n\n    this.maxRaySegments = 2 * (1 << this.maxIterations)\n\n    this.subrays = []\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray())\n    }\n\n    this.raySegments = []\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment())\n    }\n\n    this.time = 0\n    this.timeFraction = 0\n    this.currentSegmentCallback = null\n    this.currentCreateTriangleVertices = this.generateUVs\n      ? this.createTriangleVerticesWithUVs\n      : this.createTriangleVerticesWithoutUVs\n    this.numSubrays = 0\n    this.currentSubray = null\n    this.currentSegmentIndex = 0\n    this.isInitialSegment = false\n    this.subrayProbability = 0\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n    this.vertices = null\n    this.uvs = null\n    this.indices = null\n    this.positionAttribute = null\n    this.uvsAttribute = null\n\n    this.simplexX = new SimplexNoise(this.seedGenerator)\n    this.simplexY = new SimplexNoise(this.seedGenerator)\n    this.simplexZ = new SimplexNoise(this.seedGenerator)\n\n    // Temp vectors\n    this.forwards = new Vector3()\n    this.forwardsFill = new Vector3()\n    this.side = new Vector3()\n    this.down = new Vector3()\n    this.middlePos = new Vector3()\n    this.middleLinPos = new Vector3()\n    this.newPos = new Vector3()\n    this.vPos = new Vector3()\n    this.cross1 = new Vector3()\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations\n\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays\n\n    this.vertices = new Float32Array(maxVerts * 3)\n    this.indices = new Uint32Array(maxIndices)\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2)\n    }\n\n    // Populate the mesh\n    this.fillMesh(0)\n\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1))\n\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3)\n    this.setAttribute('position', this.positionAttribute)\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2)\n      this.setAttribute('uv', this.uvsAttribute)\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage\n      this.positionAttribute.usage = DynamicDrawUsage\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage\n      }\n    }\n\n    // Store buffers for later modification\n    this.vertices = this.positionAttribute.array\n    this.indices = this.index.array\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time)\n\n    this.drawRange.count = this.currentIndex\n\n    this.index.needsUpdate = true\n\n    this.positionAttribute.needsUpdate = true\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n\n        return\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n\n          scope.createPrism(segment)\n\n          scope.onDecideSubrayCreation(segment, scope)\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n\n          scope.createPrism(segment)\n        }\n\n        scope.onDecideSubrayCreation(segment, scope)\n      }\n    })\n  }\n\n  addNewSubray(/*rayParameters*/) {\n    return this.subrays[this.numSubrays++]\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset)\n    subray.pos1.copy(rayParameters.destOffset)\n    subray.up0.copy(rayParameters.up0)\n    subray.up1.copy(rayParameters.up1)\n    subray.radius0 = rayParameters.radius0\n    subray.radius1 = rayParameters.radius1\n    subray.birthTime = rayParameters.birthTime\n    subray.deathTime = rayParameters.deathTime\n    subray.timeScale = rayParameters.timeScale\n    subray.roughness = rayParameters.roughness\n    subray.straightness = rayParameters.straightness\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor\n\n    subray.maxIterations = this.maxIterations\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0\n    subray.recursion = 0\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time\n    this.currentSegmentCallback = segmentCallback\n    this.numSubrays = 0\n\n    // Add the top level subray\n    this.initSubray(this.addNewSubray(), this.rayParameters)\n\n    // Process all subrays that are being generated until consuming all of them\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex]\n      this.currentSubray = subray\n\n      this.randomGenerator.setSeed(subray.seed)\n\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor)\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor)\n\n      const random1 = this.randomGenerator.random\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime)\n\n      this.currentSegmentIndex = 0\n      this.isInitialSegment = true\n\n      const segment = this.getNewSegment()\n      segment.iteration = 0\n      segment.pos0.copy(subray.pos0)\n      segment.pos1.copy(subray.pos1)\n      segment.linPos0.copy(subray.linPos0)\n      segment.linPos1.copy(subray.linPos1)\n      segment.up0.copy(subray.up0)\n      segment.up1.copy(subray.up1)\n      segment.radius0 = subray.radius0\n      segment.radius1 = subray.radius1\n      segment.fraction0 = 0\n      segment.fraction1 = 1\n      segment.positionVariationFactor = 1 - subray.straightness\n\n      this.subrayProbability =\n        (this.ramification * Math.pow(this.recursionProbability, subray.recursion)) / (1 << subray.maxIterations)\n\n      this.fractalRayRecursive(segment)\n    }\n\n    this.currentSegmentCallback = null\n    this.currentSubray = null\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment)\n\n      return\n    }\n\n    // Interpolation\n    this.forwards.subVectors(segment.pos1, segment.pos0)\n    let lForwards = this.forwards.length()\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01)\n      lForwards = this.forwards.length()\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5\n\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration)\n\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5)\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5)\n    const p = this.middleLinPos\n\n    // Noise\n    this.newPos.set(\n      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension),\n    )\n\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards)\n    this.newPos.add(this.middlePos)\n\n    // Recursion\n\n    const newSegment1 = this.getNewSegment()\n    newSegment1.pos0.copy(segment.pos0)\n    newSegment1.pos1.copy(this.newPos)\n    newSegment1.linPos0.copy(segment.linPos0)\n    newSegment1.linPos1.copy(this.middleLinPos)\n    newSegment1.up0.copy(segment.up0)\n    newSegment1.up1.copy(segment.up1)\n    newSegment1.radius0 = segment.radius0\n    newSegment1.radius1 = middleRadius\n    newSegment1.fraction0 = segment.fraction0\n    newSegment1.fraction1 = middleFraction\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment1.iteration = segment.iteration + 1\n\n    const newSegment2 = this.getNewSegment()\n    newSegment2.pos0.copy(this.newPos)\n    newSegment2.pos1.copy(segment.pos1)\n    newSegment2.linPos0.copy(this.middleLinPos)\n    newSegment2.linPos1.copy(segment.linPos1)\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize())\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize()\n    newSegment2.up1.copy(segment.up1)\n    newSegment2.radius0 = middleRadius\n    newSegment2.radius1 = segment.radius1\n    newSegment2.fraction0 = middleFraction\n    newSegment2.fraction1 = segment.fraction1\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment2.iteration = segment.iteration + 1\n\n    this.fractalRayRecursive(newSegment1)\n\n    this.fractalRayRecursive(newSegment2)\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize()\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0)\n\n      this.isInitialSegment = false\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1)\n\n    this.createPrismFaces()\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    this.currentVertex += 3\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n    const uv = this.uvs\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0.5\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 1\n\n    this.currentVertex += 3\n  }\n\n  createPrismFaces(vertex /*, index*/) {\n    const indices = this.indices\n    vertex = this.currentVertex - 6\n\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 5\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random\n\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      // Decide subrays creation at parent (sub)ray segment\n\n      const subray = lightningStrike.currentSubray\n\n      const period = lightningStrike.rayParameters.subrayPeriod\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle\n\n      const phase0 =\n        lightningStrike.rayParameters.isEternal && subray.recursion == 0\n          ? -random1() * period\n          : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period\n\n      const phase = lightningStrike.time - phase0\n      const currentCycle = Math.floor(phase / period)\n\n      const childSubraySeed = random1() * (currentCycle + 1)\n\n      const isActive = phase % period <= dutyCycle * period\n\n      let probability = 0\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability\n        // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (\n        subray.recursion < lightningStrike.maxSubrayRecursion &&\n        lightningStrike.numSubrays < lightningStrike.maxSubrays &&\n        random1() < probability\n      ) {\n        const childSubray = lightningStrike.addNewSubray()\n\n        const parentSeed = lightningStrike.randomGenerator.getSeed()\n        childSubray.seed = childSubraySeed\n        lightningStrike.randomGenerator.setSeed(childSubraySeed)\n\n        childSubray.recursion = subray.recursion + 1\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1)\n\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.up0.copy(subray.up0)\n        childSubray.up1.copy(subray.up1)\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor\n        childSubray.radius1 = Math.min(\n          lightningStrike.rayParameters.minRadius,\n          segment.radius1 * lightningStrike.rayParameters.radius1Factor,\n        )\n\n        childSubray.birthTime = phase0 + currentCycle * period\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime)\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime)\n        }\n\n        childSubray.timeScale = subray.timeScale * 2\n        childSubray.roughness = subray.roughness\n        childSubray.straightness = subray.straightness\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor\n\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike)\n\n        lightningStrike.randomGenerator.setSeed(parentSeed)\n      }\n    }\n\n    const vec1Pos = new Vector3()\n    const vec2Forward = new Vector3()\n    const vec3Side = new Vector3()\n    const vec4Up = new Vector3()\n\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2)\n    }\n\n    this.subrayConePosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cone\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n\n    this.subrayCylinderPosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cylinder\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0,\n    }\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0,\n    }\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++]\n  }\n\n  copy(source) {\n    super.copy(source)\n\n    this.init(LightningStrike.copyParameters({}, source.rayParameters))\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters))\n  }\n}\n\nexport { LightningStrike }\n"]},"metadata":{},"sourceType":"module"}