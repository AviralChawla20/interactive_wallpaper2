{"ast":null,"code":"import { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nconst _v1 = new Vector3();\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 1e-4) {\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    const n = 30 * 30;\n    for (let i = 0; i < n; i++) this.segments[i] = false;\n  }\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    const userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  }\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = [];\n    const tempPlane1 = this.tempPlane1;\n    const tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    const scope = this;\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n      let angle = Math.PI;\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      }\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      const obj1 = scope.tempResultObjects.object1;\n      const obj2 = scope.tempResultObjects.object2;\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  }\n  cutByPlane(object, plane, output) {\n    const geometry = object.geometry;\n    const coords = geometry.attributes.position.array;\n    const normals = geometry.attributes.normal.array;\n    const numPoints = coords.length / 3;\n    let numFaces = numPoints / 3;\n    let indices = geometry.getIndex();\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n    function getVertexIndex(faceIdx, vert) {\n      const idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n    const points1 = [];\n    const points2 = [];\n    const delta = this.smallDelta;\n    const numPointPairs = numPoints * numPoints;\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\n    const p0 = this.tempVector3_P0;\n    const p1 = this.tempVector3_P1;\n    const n0 = this.tempVector3_N0;\n    const n1 = this.tempVector3_N1;\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0);\n      const b1 = getVertexIndex(i, 1);\n      const c1 = getVertexIndex(i, 2);\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0);\n        const b2 = getVertexIndex(j, 1);\n        const c2 = getVertexIndex(j, 2);\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        const coplanar = 1 - n0.dot(n1) < delta;\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    }\n    const localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0);\n      const vb = getVertexIndex(i, 1);\n      const vc = getVertexIndex(i, 2);\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        const segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue;\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n        let mark0 = 0;\n        let d = localPlane.distanceToPoint(p0);\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        }\n        let mark1 = 0;\n        d = localPlane.distanceToPoint(p1);\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          let intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n          if (intersection === null) {\n            console.error(\"Internal error: segment does not intersect plane.\");\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    }\n    const newMass = object.userData.mass * 0.5;\n    this.tempCM1.set(0, 0, 0);\n    let radius1 = 0;\n    const numPoints1 = points1.length;\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\n      this.tempCM1.divideScalar(numPoints1);\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n      this.tempCM1.add(object.position);\n    }\n    this.tempCM2.set(0, 0, 0);\n    let radius2 = 0;\n    const numPoints2 = points2.length;\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\n      this.tempCM2.divideScalar(numPoints2);\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n      this.tempCM2.add(object.position);\n    }\n    let object1 = null;\n    let object2 = null;\n    let numObjects = 0;\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n  static transformFreeVector(v, m) {\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[4] * y + e[8] * z;\n    v.y = e[1] * x + e[5] * y + e[9] * z;\n    v.z = e[2] * x + e[6] * y + e[10] * z;\n    return v;\n  }\n  static transformFreeVectorInverse(v, m) {\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z;\n    v.y = e[4] * x + e[5] * y + e[6] * z;\n    v.z = e[8] * x + e[9] * y + e[10] * z;\n    return v;\n  }\n  static transformTiedVectorInverse(v, m) {\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n    return v;\n  }\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  }\n}\nexport { ConvexObjectBreaker };","map":{"version":3,"sources":["../../src/misc/ConvexObjectBreaker.js"],"names":[],"mappings":"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","sourcesContent":["import { Line3, Mesh, Plane, Vector3 } from 'three'\nimport { ConvexGeometry } from '../geometries/ConvexGeometry'\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a buffer geometry and a material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nconst _v1 = new Vector3()\n\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 0.0001) {\n    this.minSizeForBreak = minSizeForBreak\n    this.smallDelta = smallDelta\n\n    this.tempLine1 = new Line3()\n    this.tempPlane1 = new Plane()\n    this.tempPlane2 = new Plane()\n    this.tempPlane_Cut = new Plane()\n    this.tempCM1 = new Vector3()\n    this.tempCM2 = new Vector3()\n    this.tempVector3 = new Vector3()\n    this.tempVector3_2 = new Vector3()\n    this.tempVector3_3 = new Vector3()\n    this.tempVector3_P0 = new Vector3()\n    this.tempVector3_P1 = new Vector3()\n    this.tempVector3_P2 = new Vector3()\n    this.tempVector3_N0 = new Vector3()\n    this.tempVector3_N1 = new Vector3()\n    this.tempVector3_AB = new Vector3()\n    this.tempVector3_CB = new Vector3()\n    this.tempResultObjects = { object1: null, object2: null }\n\n    this.segments = []\n    const n = 30 * 30\n    for (let i = 0; i < n; i++) this.segments[i] = false\n  }\n\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n\n    const userData = object.userData\n    userData.mass = mass\n    userData.velocity = velocity.clone()\n    userData.angularVelocity = angularVelocity.clone()\n    userData.breakable = breakable\n  }\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = []\n\n    const tempPlane1 = this.tempPlane1\n    const tempPlane2 = this.tempPlane2\n\n    this.tempVector3.addVectors(pointOfImpact, normal)\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3)\n\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations\n\n    const scope = this\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject)\n\n        return\n      }\n\n      let angle = Math.PI\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal)\n        tempPlane2.constant = tempPlane1.constant\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle\n\n          // Rotate tempPlane2 at impact point around normal axis and the angle\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact)\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2)\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI\n\n          // Rotate tempPlane2 at object position around normal axis and the angle\n          scope.tempVector3_2\n            .copy(pointOfImpact)\n            .sub(subObject.position)\n            .applyAxisAngle(normal, angle)\n            .add(subObject.position)\n          scope.tempVector3_3.copy(normal).add(subObject.position)\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2)\n        }\n      }\n\n      // Perform the cut\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects)\n\n      const obj1 = scope.tempResultObjects.object1\n      const obj2 = scope.tempResultObjects.object2\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1)\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1)\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0)\n\n    return debris\n  }\n\n  cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n\n    const geometry = object.geometry\n    const coords = geometry.attributes.position.array\n    const normals = geometry.attributes.normal.array\n\n    const numPoints = coords.length / 3\n    let numFaces = numPoints / 3\n\n    let indices = geometry.getIndex()\n\n    if (indices) {\n      indices = indices.array\n      numFaces = indices.length / 3\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n\n      const idx = faceIdx * 3 + vert\n\n      return indices ? indices[idx] : idx\n    }\n\n    const points1 = []\n    const points2 = []\n\n    const delta = this.smallDelta\n\n    // Reset segments mark\n    const numPointPairs = numPoints * numPoints\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false\n\n    const p0 = this.tempVector3_P0\n    const p1 = this.tempVector3_P1\n    const n0 = this.tempVector3_N0\n    const n1 = this.tempVector3_N1\n\n    // Iterate through the faces to mark edges shared by coplanar faces\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0)\n      const b1 = getVertexIndex(i, 1)\n      const c1 = getVertexIndex(i, 2)\n\n      // Assuming all 3 vertices have the same normal\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2)\n\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0)\n        const b2 = getVertexIndex(j, 1)\n        const c2 = getVertexIndex(j, 2)\n\n        // Assuming all 3 vertices have the same normal\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2)\n\n        const coplanar = 1 - n0.dot(n1) < delta\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true\n              this.segments[b1 * numPoints + a1] = true\n            } else {\n              this.segments[c1 * numPoints + a1] = true\n              this.segments[a1 * numPoints + c1] = true\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true\n            this.segments[b1 * numPoints + c1] = true\n          }\n        }\n      }\n    }\n\n    // Transform the plane to object local space\n    const localPlane = this.tempPlane_Cut\n    object.updateMatrix()\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane)\n\n    // Iterate through the faces adding points to both pieces\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0)\n      const vb = getVertexIndex(i, 1)\n      const vc = getVertexIndex(i, 2)\n\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va\n\n        const segmentState = this.segments[i0 * numPoints + i1]\n\n        if (segmentState) continue // The segment already has been processed in another face\n\n        // Mark segment as processed (also inverted segment)\n        this.segments[i0 * numPoints + i1] = true\n        this.segments[i1 * numPoints + i0] = true\n\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2])\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2])\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark0 = 0\n\n        let d = localPlane.distanceToPoint(p0)\n\n        if (d > delta) {\n          mark0 = 2\n          points2.push(p0.clone())\n        } else if (d < -delta) {\n          mark0 = 1\n          points1.push(p0.clone())\n        } else {\n          mark0 = 3\n          points1.push(p0.clone())\n          points2.push(p0.clone())\n        }\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark1 = 0\n\n        d = localPlane.distanceToPoint(p1)\n\n        if (d > delta) {\n          mark1 = 2\n          points2.push(p1.clone())\n        } else if (d < -delta) {\n          mark1 = 1\n          points1.push(p1.clone())\n        } else {\n          mark1 = 3\n          points1.push(p1.clone())\n          points2.push(p1.clone())\n        }\n\n        if ((mark0 === 1 && mark1 === 2) || (mark0 === 2 && mark1 === 1)) {\n          // Intersection of segment with the plane\n\n          this.tempLine1.start.copy(p0)\n          this.tempLine1.end.copy(p1)\n\n          let intersection = new Vector3()\n          intersection = localPlane.intersectLine(this.tempLine1, intersection)\n\n          if (intersection === null) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.')\n            output.segmentedObject1 = null\n            output.segmentedObject2 = null\n            return 0\n          }\n\n          points1.push(intersection)\n          points2.push(intersection.clone())\n        }\n      }\n    }\n\n    // Calculate debris mass (very fast and imprecise):\n    const newMass = object.userData.mass * 0.5\n\n    // Calculate debris Center of Mass (again fast and imprecise)\n    this.tempCM1.set(0, 0, 0)\n    let radius1 = 0\n    const numPoints1 = points1.length\n\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i])\n\n      this.tempCM1.divideScalar(numPoints1)\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i]\n        p.sub(this.tempCM1)\n        radius1 = Math.max(radius1, p.x, p.y, p.z)\n      }\n\n      this.tempCM1.add(object.position)\n    }\n\n    this.tempCM2.set(0, 0, 0)\n    let radius2 = 0\n    const numPoints2 = points2.length\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i])\n\n      this.tempCM2.divideScalar(numPoints2)\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i]\n        p.sub(this.tempCM2)\n        radius2 = Math.max(radius2, p.x, p.y, p.z)\n      }\n\n      this.tempCM2.add(object.position)\n    }\n\n    let object1 = null\n    let object2 = null\n\n    let numObjects = 0\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material)\n      object1.position.copy(this.tempCM1)\n      object1.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object1,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius1 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material)\n      object2.position.copy(this.tempCM2)\n      object2.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object2,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius2 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    output.object1 = object1\n    output.object2 = object2\n\n    return numObjects\n  }\n\n  static transformFreeVector(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[4] * y + e[8] * z\n    v.y = e[1] * x + e[5] * y + e[9] * z\n    v.z = e[2] * x + e[6] * y + e[10] * z\n\n    return v\n  }\n\n  static transformFreeVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z\n    v.y = e[4] * x + e[5] * y + e[6] * z\n    v.z = e[8] * x + e[9] * y + e[10] * z\n\n    return v\n  }\n\n  static transformTiedVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a tied (ordinary) vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12]\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13]\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14]\n\n    return v\n  }\n\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal)\n    resultPlane.constant = plane.constant\n\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m)\n\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m)\n\n    // recalculate constant (like in setFromNormalAndCoplanarPoint)\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal)\n  }\n}\n\nexport { ConvexObjectBreaker }\n"]},"metadata":{},"sourceType":"module"}