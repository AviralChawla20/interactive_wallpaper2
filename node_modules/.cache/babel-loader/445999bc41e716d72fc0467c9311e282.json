{"ast":null,"code":"import { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from \"three\";\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.splitLayer = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    let state = {\n      x: 0,\n      y: 0,\n      z: 0,\n      e: 0,\n      f: 0,\n      extruding: false,\n      relative: false\n    };\n    let layers = [];\n    let currentLayer = void 0;\n    const pathMaterial = new LineBasicMaterial({\n      color: 16711680\n    });\n    pathMaterial.name = \"path\";\n    const extrudingMaterial = new LineBasicMaterial({\n      color: 65280\n    });\n    extrudingMaterial.name = \"extruded\";\n    function newLayer(line) {\n      currentLayer = {\n        vertex: [],\n        pathVertex: [],\n        z: line.z\n      };\n      layers.push(currentLayer);\n    }\n    function addSegment(p1, p2) {\n      if (currentLayer === void 0) {\n        newLayer(p1);\n      }\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n    let lines = data.replace(/;.+/g, \"\").split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(\" \");\n      let cmd = tokens[0].toUpperCase();\n      let args = {};\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== void 0) {\n          let key = token[0].toLowerCase();\n          let value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      });\n      if (cmd === \"G0\" || cmd === \"G1\") {\n        let line = {\n          x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,\n          y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,\n          z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,\n          e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,\n          f: args.f !== void 0 ? absolute(state.f, args.f) : state.f\n        };\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0;\n          if (currentLayer == void 0 || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === \"G2\" || cmd === \"G3\") ;else if (cmd === \"G90\") {\n        state.relative = false;\n      } else if (cmd === \"G91\") {\n        state.relative = true;\n      } else if (cmd === \"G92\") {\n        let line = state;\n        line.x = args.x !== void 0 ? args.x : line.x;\n        line.y = args.y !== void 0 ? args.y : line.y;\n        line.z = args.z !== void 0 ? args.z : line.z;\n        line.e = args.e !== void 0 ? args.e : line.e;\n        state = line;\n      } else ;\n    }\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertex, 3));\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = \"layer\" + i;\n      object.add(segments);\n    }\n    const object = new Group();\n    object.name = \"gcode\";\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [],\n        pathVertex = [];\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        let layerVertex = layer.vertex;\n        let layerPathVertex = layer.pathVertex;\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    return object;\n  }\n}\nexport { GCodeLoader };","map":{"version":3,"sources":["../../src/loaders/GCodeLoader.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  BufferGeometry,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n} from 'three'\n\n/**\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class GCodeLoader\n * @param {Manager} manager Loading manager.\n */\n\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.splitLayer = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false }\n    let layers = []\n\n    let currentLayer = undefined\n\n    const pathMaterial = new LineBasicMaterial({ color: 0xff0000 })\n    pathMaterial.name = 'path'\n\n    const extrudingMaterial = new LineBasicMaterial({ color: 0x00ff00 })\n    extrudingMaterial.name = 'extruded'\n\n    function newLayer(line) {\n      currentLayer = { vertex: [], pathVertex: [], z: line.z }\n      layers.push(currentLayer)\n    }\n\n    //Create lie segment between p1 and p2\n    function addSegment(p1, p2) {\n      if (currentLayer === undefined) {\n        newLayer(p1)\n      }\n\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z)\n        currentLayer.vertex.push(p2.x, p2.y, p2.z)\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z)\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z)\n      }\n    }\n\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1\n    }\n\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2\n    }\n\n    let lines = data.replace(/;.+/g, '').split('\\n')\n\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(' ')\n      let cmd = tokens[0].toUpperCase()\n\n      //Argumments\n      let args = {}\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== undefined) {\n          let key = token[0].toLowerCase()\n          let value = parseFloat(token.substring(1))\n          args[key] = value\n        }\n      })\n\n      //Process commands\n      //G0/G1 – Linear Movement\n      if (cmd === 'G0' || cmd === 'G1') {\n        let line = {\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f,\n        }\n\n        //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0\n\n          if (currentLayer == undefined || line.z != currentLayer.z) {\n            newLayer(line)\n          }\n        }\n\n        addSegment(state, line)\n        state = line\n      } else if (cmd === 'G2' || cmd === 'G3') {\n        //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n        //console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n      } else if (cmd === 'G90') {\n        //G90: Set to Absolute Positioning\n        state.relative = false\n      } else if (cmd === 'G91') {\n        //G91: Set to state.relative Positioning\n        state.relative = true\n      } else if (cmd === 'G92') {\n        //G92: Set Position\n        let line = state\n        line.x = args.x !== undefined ? args.x : line.x\n        line.y = args.y !== undefined ? args.y : line.y\n        line.z = args.z !== undefined ? args.z : line.z\n        line.e = args.e !== undefined ? args.e : line.e\n        state = line\n      } else {\n        //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n      }\n    }\n\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3))\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial)\n      segments.name = 'layer' + i\n      object.add(segments)\n    }\n\n    const object = new Group()\n    object.name = 'gcode'\n\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        addObject(layer.vertex, true, i)\n        addObject(layer.pathVertex, false, i)\n      }\n    } else {\n      const vertex = [],\n        pathVertex = []\n\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        let layerVertex = layer.vertex\n        let layerPathVertex = layer.pathVertex\n\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j])\n        }\n\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j])\n        }\n      }\n\n      addObject(vertex, true, layers.length)\n      addObject(pathVertex, false, layers.length)\n    }\n\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n\n    return object\n  }\n}\n\nexport { GCodeLoader }\n"]},"metadata":{},"sourceType":"module"}