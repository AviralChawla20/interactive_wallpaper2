{"ast":null,"code":"import { Triangle, Vector3 } from \"three\";\nconst _face = new Triangle();\nconst _color = new Vector3();\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry;\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n  build() {\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const faceWeights = new Float32Array(positionAttribute.count / 3);\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1;\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n      }\n      _face.a.fromBufferAttribute(positionAttribute, i);\n      _face.b.fromBufferAttribute(positionAttribute, i + 1);\n      _face.c.fromBufferAttribute(positionAttribute, i + 2);\n      faceWeight *= _face.getArea();\n      faceWeights[i / 3] = faceWeight;\n    }\n    this.distribution = new Float32Array(positionAttribute.count / 3);\n    let cumulativeTotal = 0;\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i];\n      this.distribution[i] = cumulativeTotal;\n    }\n    return this;\n  }\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex();\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n  }\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n  binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return index;\n  }\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n    if (targetNormal !== void 0) {\n      _face.getNormal(targetNormal);\n    }\n    if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n    return this;\n  }\n}\nexport { MeshSurfaceSampler };","map":{"version":3,"sources":["../../src/math/MeshSurfaceSampler.js"],"names":[],"mappings":"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","sourcesContent":["import { Triangle, Vector3 } from 'three'\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle()\nconst _color = new Vector3()\n\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.')\n\n      geometry = geometry.toNonIndexed()\n    }\n\n    this.geometry = geometry\n    this.randomFunction = Math.random\n\n    this.positionAttribute = this.geometry.getAttribute('position')\n    this.colorAttribute = this.geometry.getAttribute('color')\n    this.weightAttribute = null\n\n    this.distribution = null\n  }\n\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null\n\n    return this\n  }\n\n  build() {\n    const positionAttribute = this.positionAttribute\n    const weightAttribute = this.weightAttribute\n\n    const faceWeights = new Float32Array(positionAttribute.count / 3)\n\n    // Accumulate weights for each mesh face.\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1\n\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2)\n      }\n\n      _face.a.fromBufferAttribute(positionAttribute, i)\n      _face.b.fromBufferAttribute(positionAttribute, i + 1)\n      _face.c.fromBufferAttribute(positionAttribute, i + 2)\n      faceWeight *= _face.getArea()\n\n      faceWeights[i / 3] = faceWeight\n    }\n\n    // Store cumulative total face weights in an array, where weight index\n    // corresponds to face index.\n\n    this.distribution = new Float32Array(positionAttribute.count / 3)\n\n    let cumulativeTotal = 0\n\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i]\n\n      this.distribution[i] = cumulativeTotal\n    }\n\n    return this\n  }\n\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction\n    return this\n  }\n\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex()\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor)\n  }\n\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1]\n    return this.binarySearch(this.randomFunction() * cumulativeTotal)\n  }\n\n  binarySearch(x) {\n    const dist = this.distribution\n    let start = 0\n    let end = dist.length - 1\n\n    let index = -1\n\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2)\n\n      if (mid === 0 || (dist[mid - 1] <= x && dist[mid] > x)) {\n        index = mid\n\n        break\n      } else if (x < dist[mid]) {\n        end = mid - 1\n      } else {\n        start = mid + 1\n      }\n    }\n\n    return index\n  }\n\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction()\n    let v = this.randomFunction()\n\n    if (u + v > 1) {\n      u = 1 - u\n      v = 1 - v\n    }\n\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3)\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1)\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2)\n\n    targetPosition\n      .set(0, 0, 0)\n      .addScaledVector(_face.a, u)\n      .addScaledVector(_face.b, v)\n      .addScaledVector(_face.c, 1 - (u + v))\n\n    if (targetNormal !== undefined) {\n      _face.getNormal(targetNormal)\n    }\n\n    if (targetColor !== undefined && this.colorAttribute !== undefined) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3)\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1)\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2)\n\n      _color\n        .set(0, 0, 0)\n        .addScaledVector(_face.a, u)\n        .addScaledVector(_face.b, v)\n        .addScaledVector(_face.c, 1 - (u + v))\n\n      targetColor.r = _color.x\n      targetColor.g = _color.y\n      targetColor.b = _color.z\n    }\n\n    return this\n  }\n}\n\nexport { MeshSurfaceSampler }\n"]},"metadata":{},"sourceType":"module"}