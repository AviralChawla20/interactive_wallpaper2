{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nconst ID_ATTR_NAME = \"_batch_id_\";\nconst _identityMatrix = new Matrix4();\nconst _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\nconst batchingParsVertex = /* glsl */\n`\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`;\nconst batchingbaseVertex = /* glsl */\n`\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`;\nconst batchingnormalVertex = /* glsl */\n`\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`;\nconst batchingVertex = /* glsl */\n`\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`;\nfunction copyAttributeData(src, target, targetOffset = 0) {\n  const itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    const vertexCount = src.count;\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_reservedRanges\");\n    __publicField(this, \"_visible\");\n    __publicField(this, \"_active\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._reservedRanges = [];\n    this._visible = [];\n    this._active = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._matrices = [];\n    this._matricesTexture = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: {\n        value: null\n      }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    };\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    };\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesTexture = matricesTexture;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n  }\n  _initShader() {\n    const material = this.material;\n    const currentOnBeforeCompile = material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <uv_vertex>\", \"#include <uv_vertex>\\n\" + batchingbaseVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    material.defines = material.defines || {};\n    material.defines.BATCHING = false;\n  }\n  _initializeGeometry(reference) {\n    const geometry = this.geometry;\n    const maxVertexCount = this._maxVertexCount;\n    const maxGeometryCount = this._maxGeometryCount;\n    const maxIndexCount = this._maxIndexCount;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n        geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n  }\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry) {\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`);\n    }\n    const batchGeometry = this.geometry;\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".');\n    }\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(`BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`);\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error(\"BatchedMesh: All attributes must have a consistent itemSize and normalized value.\");\n      }\n    }\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    const reservedRanges = this._reservedRanges;\n    if (reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.vertexStart + finalRange.vertexCount;\n    }\n  }\n  getIndexCount() {\n    const reservedRanges = this._reservedRanges;\n    const geometry = this.geometry;\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.indexStart + finalRange.indexCount;\n    }\n  }\n  addGeometry(geometry, vertexCount = -1, indexCount = -1) {\n    this._initializeGeometry(geometry);\n    this._validateGeometry(geometry);\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1\n    };\n    let lastRange = null;\n    const reservedRanges = this._reservedRanges;\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1];\n    }\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute(\"position\").count;\n    } else {\n      range.vertexCount = vertexCount;\n    }\n    if (lastRange === null) {\n      range.vertexStart = 0;\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n    }\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex().count;\n      } else {\n        range.indexCount = indexCount;\n      }\n      if (lastRange === null) {\n        range.indexStart = 0;\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount;\n      }\n    }\n    if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space request exceeds the maximum buffer size.\");\n    }\n    const indexCounts = this._indexCounts;\n    const indexStarts = this._indexStarts;\n    const vertexCounts = this._vertexCounts;\n    const vertexStarts = this._vertexStarts;\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = this._matricesTexture.image.data;\n    visible.push(true);\n    active.push(true);\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    matrices.push(new Matrix4());\n    _identityMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    reservedRanges.push(range);\n    vertexStarts.push(range.vertexStart);\n    vertexCounts.push(range.vertexCount);\n    if (geometry.getIndex() !== null) {\n      indexStarts.push(range.indexCount);\n      indexCounts.push(range.indexCount);\n    }\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this.setGeometryAt(geometryId, geometry);\n    return geometryId;\n  }\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry) {\n    return this.addGeometry(geometry);\n  }\n  setGeometryAt(id, geometry) {\n    if (id >= this._geometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    this._validateGeometry(geometry);\n    const range = this._reservedRanges[id];\n    if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space not large enough for provided geometry.\");\n    }\n    const batchGeometry = this.geometry;\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    const hasIndex = batchGeometry.getIndex() !== null;\n    const dstIndex = batchGeometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const vertexStart = range.vertexStart;\n    const vertexCount = range.vertexCount;\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n      const itemSize = srcAttribute.itemSize;\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i;\n        for (let c = 0; c < itemSize; c++) {\n          dstAttribute.setComponent(index, c, 0);\n        }\n      }\n      dstAttribute.needsUpdate = true;\n    }\n    this._vertexCounts[id] = srcPositionAttribute.count;\n    if (hasIndex) {\n      const indexStart = range.indexStart;\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));\n      }\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart);\n      }\n      dstIndex.needsUpdate = true;\n      this._indexCounts[id] = srcIndex.count;\n    }\n    return id;\n  }\n  deleteGeometry(geometryId) {\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this;\n    }\n    active[geometryId] = false;\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    throw new Error(\"BatchedMesh: Optimize function not implemented.\");\n  }\n  setMatrixAt(geometryId, matrix) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this;\n    }\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n    }\n    matrices[geometryId].copy(matrix);\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    const matrices = this._matrices;\n    const active = this._active;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, value) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this;\n    }\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16);\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    }\n    matricesTexture.needsUpdate = true;\n    visible[geometryId] = value;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    const visible = this._visible;\n    const active = this._active;\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false;\n    }\n    return visible[geometryId];\n  }\n  raycast() {\n    console.warn(\"BatchedMesh: Raycast function not implemented.\");\n  }\n  copy() {\n    throw new Error(\"BatchedMesh: Copy function not implemented.\");\n  }\n  toJSON() {\n    throw new Error(\"BatchedMesh: toJSON function not implemented.\");\n  }\n  dispose() {\n    this.geometry.dispose();\n    this._matricesTexture.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n}\nexport { BatchedMesh };","map":{"version":3,"sources":["../../src/objects/BatchedMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Matrix4,\n  BufferAttribute,\n  InterleavedBufferAttribute,\n  Mesh,\n  BufferGeometry,\n  Material,\n  DataTexture,\n  IUniform,\n  MathUtils,\n  RGBAFormat,\n  FloatType,\n} from 'three'\n\nconst ID_ATTR_NAME = '_batch_id_'\nconst _identityMatrix = new Matrix4()\nconst _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1)\n\n// Custom shaders\nconst batchingParsVertex = /* glsl */ `\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`\n\nconst batchingbaseVertex = /* glsl */ `\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`\n\nconst batchingnormalVertex = /* glsl */ `\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`\n\nconst batchingVertex = /* glsl */ `\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`\n\n// @TODO: SkinnedMesh support?\n// @TODO: Future work if needed. Move into the core. Can be optimized more with WEBGL_multi_draw.\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData(\n  src: BufferAttribute | InterleavedBufferAttribute,\n  target: BufferAttribute | InterleavedBufferAttribute,\n  targetOffset = 0,\n): void {\n  const itemSize = target.itemSize\n  if (\n    (src as InterleavedBufferAttribute).isInterleavedBufferAttribute ||\n    src.array.constructor !== target.array.constructor\n  ) {\n    // use the component getters and setters if the array data cannot\n    // be copied directly\n    const vertexCount = src.count\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        // @ts-ignore\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c))\n      }\n    }\n  } else {\n    // faster copy approach using typed array set function\n    // @ts-ignore\n    target.array.set(src.array, targetOffset * itemSize)\n  }\n\n  target.needsUpdate = true\n}\n\nclass BatchedMesh extends Mesh<BufferGeometry, Material> {\n  _vertexStarts: number[]\n  _vertexCounts: number[]\n  _indexStarts: number[]\n  _indexCounts: number[]\n  _reservedRanges: { vertexStart: number; vertexCount: number; indexStart: number; indexCount: number }[]\n  _visible: boolean[]\n  _active: boolean[]\n  _maxGeometryCount: number\n  _maxVertexCount: number\n  _maxIndexCount: number\n  _geometryInitialized: boolean\n  _geometryCount: number\n  _matrices: Matrix4[]\n  _matricesTexture: DataTexture | null\n  _customUniforms: Record<string, IUniform>\n\n  constructor(\n    maxGeometryCount: number,\n    maxVertexCount: number,\n    maxIndexCount = maxVertexCount * 2,\n    material?: Material,\n  ) {\n    super(new BufferGeometry(), material)\n\n    this._vertexStarts = []\n    this._vertexCounts = []\n    this._indexStarts = []\n    this._indexCounts = []\n    this._reservedRanges = []\n\n    this._visible = []\n    this._active = []\n\n    this._maxGeometryCount = maxGeometryCount\n    this._maxVertexCount = maxVertexCount\n    this._maxIndexCount = maxIndexCount\n\n    this._geometryInitialized = false\n    this._geometryCount = 0\n\n    // Local matrix per geometry by using data texture\n    // @TODO: Support uniform parameter per geometry\n\n    this._matrices = []\n    this._matricesTexture = null!\n\n    // @TODO: Calculate the entire binding box and make frustumCulled true\n    this.frustumCulled = false\n\n    this._customUniforms = {\n      batchingTexture: { value: null },\n    }\n\n    this._initMatricesTexture()\n    this._initShader()\n\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true\n      }\n\n      // @TODO: Implement frustum culling for each geometry\n    }\n\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false\n      }\n    }\n  }\n\n  _initMatricesTexture(): void {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this._maxGeometryCount * 4) // 4 pixels needed for 1 matrix\n    size = MathUtils.ceilPowerOfTwo(size)\n    size = Math.max(size, 4)\n\n    const matricesArray = new Float32Array(size * size * 4) // 4 floats per RGBA pixel\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType)\n\n    this._matricesTexture = matricesTexture\n    this._customUniforms.batchingTexture.value = this._matricesTexture\n  }\n\n  _initShader(): void {\n    const material = this.material\n    const currentOnBeforeCompile = material.onBeforeCompile\n    const customUniforms = this._customUniforms\n\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      // Is this replacement stable across any materials?\n      parameters.vertexShader = parameters.vertexShader\n        .replace('#include <skinning_pars_vertex>', '#include <skinning_pars_vertex>\\n' + batchingParsVertex)\n        .replace('#include <uv_vertex>', '#include <uv_vertex>\\n' + batchingbaseVertex)\n        .replace('#include <skinnormal_vertex>', '#include <skinnormal_vertex>\\n' + batchingnormalVertex)\n        .replace('#include <skinning_vertex>', '#include <skinning_vertex>\\n' + batchingVertex)\n\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName]\n      }\n\n      currentOnBeforeCompile.call(this, parameters, renderer)\n    }\n\n    material.defines = material.defines || {}\n    material.defines.BATCHING = false\n  }\n\n  _initializeGeometry(reference: BufferGeometry): void {\n    // @TODO: geometry.groups support?\n    // @TODO: geometry.drawRange support?\n    // @TODO: geometry.morphAttributes support?\n\n    const geometry = this.geometry\n    const maxVertexCount = this._maxVertexCount\n    const maxGeometryCount = this._maxGeometryCount\n    const maxIndexCount = this._maxIndexCount\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName)\n        const { array, itemSize, normalized } = srcAttribute\n\n        const dstArray = new (array.constructor as Float32ArrayConstructor)(maxVertexCount * itemSize)\n        const dstAttribute = new (srcAttribute.constructor as any)(dstArray, itemSize, normalized)\n\n        // TODO: add usage in @types/three\n        // @ts-ignore\n        dstAttribute.setUsage(srcAttribute.usage)\n\n        geometry.setAttribute(attributeName, dstAttribute)\n      }\n\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount)\n\n        geometry.setIndex(new BufferAttribute(indexArray, 1))\n      }\n\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount)\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1))\n\n      this._geometryInitialized = true\n    }\n  }\n\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry: BufferGeometry): void {\n    // check that the geometry doesn't have a version of our reserved id attribute\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`)\n    }\n\n    // check to ensure the geometries are using consistent attributes and indices\n    const batchGeometry = this.geometry\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".')\n    }\n\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(\n          `BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`,\n        )\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.')\n      }\n    }\n  }\n\n  getGeometryCount(): number {\n    return this._geometryCount\n  }\n\n  getVertexCount(): number {\n    const reservedRanges = this._reservedRanges\n    if (reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.vertexStart + finalRange.vertexCount\n    }\n  }\n\n  getIndexCount(): number {\n    const reservedRanges = this._reservedRanges\n    const geometry = this.geometry\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.indexStart + finalRange.indexCount\n    }\n  }\n\n  addGeometry(geometry: BufferGeometry, vertexCount = -1, indexCount = -1): number {\n    this._initializeGeometry(geometry)\n\n    this._validateGeometry(geometry)\n\n    // ensure we're not over geometry\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    // get the necessary range fo the geometry\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1,\n    }\n\n    let lastRange = null\n    const reservedRanges = this._reservedRanges\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1]\n    }\n\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute('position').count\n    } else {\n      range.vertexCount = vertexCount\n    }\n\n    if (lastRange === null) {\n      range.vertexStart = 0\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount\n    }\n\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex()!.count\n      } else {\n        range.indexCount = indexCount\n      }\n\n      if (lastRange === null) {\n        range.indexStart = 0\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount\n      }\n    }\n\n    if (\n      (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount) ||\n      range.vertexStart + range.vertexCount > this._maxVertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.')\n    }\n\n    const indexCounts = this._indexCounts\n    const indexStarts = this._indexStarts\n    const vertexCounts = this._vertexCounts\n    const vertexStarts = this._vertexStarts\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture\n    const matrices = this._matrices\n    const matricesArray = this._matricesTexture!.image.data\n\n    // push new visibility states\n    visible.push(true)\n    active.push(true)\n\n    // update id\n    const geometryId = this._geometryCount\n    this._geometryCount++\n\n    // initialize matrix information\n    matrices.push(new Matrix4())\n    _identityMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    // add the reserved range\n    reservedRanges.push(range)\n\n    // push new geometry data range\n    vertexStarts.push(range.vertexStart)\n    vertexCounts.push(range.vertexCount)\n\n    if (geometry.getIndex() !== null) {\n      // push new index range\n      indexStarts.push(range.indexCount)\n      indexCounts.push(range.indexCount)\n    }\n\n    // set the id for the geometry\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME)\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId)\n    }\n\n    idAttribute.needsUpdate = true\n\n    // update the geometry\n    this.setGeometryAt(geometryId, geometry)\n\n    return geometryId\n  }\n\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry: BufferGeometry): number {\n    return this.addGeometry(geometry)\n  }\n\n  setGeometryAt(id: number, geometry: BufferGeometry): number {\n    if (id >= this._geometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    this._validateGeometry(geometry)\n\n    const range = this._reservedRanges[id]\n    if (\n      (geometry.getIndex() !== null && geometry.getIndex()!.count > range.indexCount) ||\n      geometry.attributes.position.count > range.vertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.')\n    }\n\n    // copy geometry over\n    const batchGeometry = this.geometry\n    const srcPositionAttribute = geometry.getAttribute('position')\n    const hasIndex = batchGeometry.getIndex() !== null\n    const dstIndex = batchGeometry.getIndex()!\n    const srcIndex = geometry.getIndex()!\n\n    // copy attribute data over\n    const vertexStart = range.vertexStart\n    const vertexCount = range.vertexCount\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart)\n\n      // fill the rest in with zeroes\n      const itemSize = srcAttribute.itemSize\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i\n        for (let c = 0; c < itemSize; c++) {\n          // @ts-ignore\n          dstAttribute.setComponent(index, c, 0)\n        }\n      }\n\n      dstAttribute.needsUpdate = true\n    }\n\n    this._vertexCounts[id] = srcPositionAttribute.count\n\n    if (hasIndex) {\n      // fill the rest in with zeroes\n      const indexStart = range.indexStart\n\n      // copy index data over\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i))\n      }\n\n      // fill the rest in with zeroes\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart)\n      }\n\n      dstIndex.needsUpdate = true\n      this._indexCounts[id] = srcIndex.count\n    }\n\n    return id\n  }\n\n  deleteGeometry(geometryId: number): this {\n    // Note: User needs to call optimize() afterward to pack the data.\n\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this\n    }\n\n    active[geometryId] = false\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    return this\n  }\n\n  optimize(): never {\n    throw new Error('BatchedMesh: Optimize function not implemented.')\n  }\n\n  setMatrixAt(geometryId: number, matrix: Matrix4): this {\n    // @TODO: Map geometryId to index of the arrays because\n    //        optimize() can make geometryId mismatch the index\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this\n    }\n\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16)\n      matricesTexture.needsUpdate = true\n    }\n\n    matrices[geometryId].copy(matrix)\n\n    return this\n  }\n\n  getMatrixAt(geometryId: number, matrix: Matrix4): Matrix4 {\n    const matrices = this._matrices\n    const active = this._active\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix\n    }\n\n    return matrix.copy(matrices[geometryId])\n  }\n\n  setVisibleAt(geometryId: number, value: boolean): this {\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n\n    // if the geometry is out of range, not active, or visibility state\n    // does not change then return early\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this\n    }\n\n    // scale the matrix to zero if it's hidden\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16)\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    }\n\n    matricesTexture.needsUpdate = true\n    visible[geometryId] = value\n\n    return this\n  }\n\n  getVisibleAt(geometryId: number): boolean {\n    const visible = this._visible\n    const active = this._active\n\n    // return early if the geometry is out of range or not active\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false\n    }\n\n    return visible[geometryId]\n  }\n\n  raycast(): void {\n    console.warn('BatchedMesh: Raycast function not implemented.')\n  }\n\n  copy(): never {\n    // super.copy( source );\n\n    throw new Error('BatchedMesh: Copy function not implemented.')\n  }\n\n  toJSON(): never {\n    throw new Error('BatchedMesh: toJSON function not implemented.')\n  }\n\n  dispose(): this {\n    // Assuming the geometry is not shared with other meshes\n    this.geometry.dispose()\n\n    this._matricesTexture!.dispose()\n    this._matricesTexture = null!\n\n    return this\n  }\n}\n\nexport { BatchedMesh }\n"]},"metadata":{},"sourceType":"module"}