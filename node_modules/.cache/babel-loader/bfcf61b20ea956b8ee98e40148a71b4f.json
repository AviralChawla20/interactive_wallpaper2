{"ast":null,"code":"import { Loader, FileLoader } from \"three\";\nimport { parse as parseBuffer } from \"../libs/opentype.js\";\nclass TTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.reversed = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(parseBuffer(buffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(arraybuffer) {\n    function convert(font, reversed) {\n      const round = Math.round;\n      const glyphs = {};\n      const scale = 1e5 / ((font.unitsPerEm || 2048) * 72);\n      const glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n      const unicodes = Object.keys(glyphIndexMap);\n      for (let i = 0; i < unicodes.length; i++) {\n        const unicode = unicodes[i];\n        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];\n        if (unicode !== void 0) {\n          const token = {\n            ha: round(glyph.advanceWidth * scale),\n            x_min: round(glyph.xMin * scale),\n            x_max: round(glyph.xMax * scale),\n            o: \"\"\n          };\n          if (reversed) {\n            glyph.path.commands = reverseCommands(glyph.path.commands);\n          }\n          glyph.path.commands.forEach(function (command) {\n            if (command.type.toLowerCase() === \"c\") {\n              command.type = \"b\";\n            }\n            token.o += command.type.toLowerCase() + \" \";\n            if (command.x !== void 0 && command.y !== void 0) {\n              token.o += round(command.x * scale) + \" \" + round(command.y * scale) + \" \";\n            }\n            if (command.x1 !== void 0 && command.y1 !== void 0) {\n              token.o += round(command.x1 * scale) + \" \" + round(command.y1 * scale) + \" \";\n            }\n            if (command.x2 !== void 0 && command.y2 !== void 0) {\n              token.o += round(command.x2 * scale) + \" \" + round(command.y2 * scale) + \" \";\n            }\n          });\n          glyphs[String.fromCodePoint(glyph.unicode)] = token;\n        }\n      }\n      return {\n        glyphs,\n        familyName: font.getEnglishName(\"fullName\"),\n        ascender: round(font.ascender * scale),\n        descender: round(font.descender * scale),\n        underlinePosition: font.tables.post.underlinePosition,\n        underlineThickness: font.tables.post.underlineThickness,\n        boundingBox: {\n          xMin: font.tables.head.xMin,\n          xMax: font.tables.head.xMax,\n          yMin: font.tables.head.yMin,\n          yMax: font.tables.head.yMax\n        },\n        resolution: 1e3,\n        original_font_information: font.tables.name\n      };\n    }\n    function reverseCommands(commands) {\n      const paths = [];\n      let path;\n      commands.forEach(function (c) {\n        if (c.type.toLowerCase() === \"m\") {\n          path = [c];\n          paths.push(path);\n        } else if (c.type.toLowerCase() !== \"z\") {\n          path.push(c);\n        }\n      });\n      const reversed = [];\n      paths.forEach(function (p) {\n        const result = {\n          type: \"m\",\n          x: p[p.length - 1].x,\n          y: p[p.length - 1].y\n        };\n        reversed.push(result);\n        for (let i = p.length - 1; i > 0; i--) {\n          const command = p[i];\n          const result2 = {\n            type: command.type\n          };\n          if (command.x2 !== void 0 && command.y2 !== void 0) {\n            result2.x1 = command.x2;\n            result2.y1 = command.y2;\n            result2.x2 = command.x1;\n            result2.y2 = command.y1;\n          } else if (command.x1 !== void 0 && command.y1 !== void 0) {\n            result2.x1 = command.x1;\n            result2.y1 = command.y1;\n          }\n          result2.x = p[i - 1].x;\n          result2.y = p[i - 1].y;\n          reversed.push(result2);\n        }\n      });\n      return reversed;\n    }\n    return convert(parseBuffer(arraybuffer), this.reversed);\n  }\n}\nexport { TTFLoader };","map":{"version":3,"sources":["../../src/loaders/TTFLoader.js"],"names":["parse","result"],"mappings":"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","sourcesContent":["import { FileLoader, Loader } from 'three'\nimport { parse } from '../libs/opentype.js'\n\n/**\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nclass TTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.reversed = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(arraybuffer) {\n    function convert(font, reversed) {\n      const round = Math.round\n\n      const glyphs = {}\n      const scale = 100000 / ((font.unitsPerEm || 2048) * 72)\n\n      const glyphIndexMap = font.encoding.cmap.glyphIndexMap\n      const unicodes = Object.keys(glyphIndexMap)\n\n      for (let i = 0; i < unicodes.length; i++) {\n        const unicode = unicodes[i]\n        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]]\n\n        if (unicode !== undefined) {\n          const token = {\n            ha: round(glyph.advanceWidth * scale),\n            x_min: round(glyph.xMin * scale),\n            x_max: round(glyph.xMax * scale),\n            o: '',\n          }\n\n          if (reversed) {\n            glyph.path.commands = reverseCommands(glyph.path.commands)\n          }\n\n          glyph.path.commands.forEach(function (command) {\n            if (command.type.toLowerCase() === 'c') {\n              command.type = 'b'\n            }\n\n            token.o += command.type.toLowerCase() + ' '\n\n            if (command.x !== undefined && command.y !== undefined) {\n              token.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' '\n            }\n\n            if (command.x1 !== undefined && command.y1 !== undefined) {\n              token.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' '\n            }\n\n            if (command.x2 !== undefined && command.y2 !== undefined) {\n              token.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' '\n            }\n          })\n\n          glyphs[String.fromCodePoint(glyph.unicode)] = token\n        }\n      }\n\n      return {\n        glyphs: glyphs,\n        familyName: font.getEnglishName('fullName'),\n        ascender: round(font.ascender * scale),\n        descender: round(font.descender * scale),\n        underlinePosition: font.tables.post.underlinePosition,\n        underlineThickness: font.tables.post.underlineThickness,\n        boundingBox: {\n          xMin: font.tables.head.xMin,\n          xMax: font.tables.head.xMax,\n          yMin: font.tables.head.yMin,\n          yMax: font.tables.head.yMax,\n        },\n        resolution: 1000,\n        original_font_information: font.tables.name,\n      }\n    }\n\n    function reverseCommands(commands) {\n      const paths = []\n      let path\n\n      commands.forEach(function (c) {\n        if (c.type.toLowerCase() === 'm') {\n          path = [c]\n          paths.push(path)\n        } else if (c.type.toLowerCase() !== 'z') {\n          path.push(c)\n        }\n      })\n\n      const reversed = []\n\n      paths.forEach(function (p) {\n        const result = {\n          type: 'm',\n          x: p[p.length - 1].x,\n          y: p[p.length - 1].y,\n        }\n\n        reversed.push(result)\n\n        for (let i = p.length - 1; i > 0; i--) {\n          const command = p[i]\n          const result = { type: command.type }\n\n          if (command.x2 !== undefined && command.y2 !== undefined) {\n            result.x1 = command.x2\n            result.y1 = command.y2\n            result.x2 = command.x1\n            result.y2 = command.y1\n          } else if (command.x1 !== undefined && command.y1 !== undefined) {\n            result.x1 = command.x1\n            result.y1 = command.y1\n          }\n\n          result.x = p[i - 1].x\n          result.y = p[i - 1].y\n          reversed.push(result)\n        }\n      })\n\n      return reversed\n    }\n\n    return convert(parse(arraybuffer), this.reversed)\n  }\n}\n\nexport { TTFLoader }\n"]},"metadata":{},"sourceType":"module"}