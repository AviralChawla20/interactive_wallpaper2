{"ast":null,"code":"import { Vector3, Plane, Line3, Sphere, Box3, Triangle } from \"three\";\nimport { Capsule } from \"./Capsule.js\";\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _plane = new Plane();\nconst _line1 = new Line3();\nconst _line2 = new Line3();\nconst _sphere = new Sphere();\nconst _capsule = new Capsule();\nclass Octree {\n  constructor(box) {\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n  addTriangle(triangle) {\n    if (!this.bounds) this.bounds = new Box3();\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.triangles.push(triangle);\n    return this;\n  }\n  calcBox() {\n    this.box = this.bounds.clone();\n    this.box.min.x -= 0.01;\n    this.box.min.y -= 0.01;\n    this.box.min.z -= 0.01;\n    return this;\n  }\n  split(level) {\n    if (!this.box) return;\n    const subTrees = [];\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3();\n          const v = _v1.set(x, y, z);\n          box.min.copy(this.box.min).add(v.multiply(halfsize));\n          box.max.copy(box.min).add(halfsize);\n          subTrees.push(new Octree(box));\n        }\n      }\n    }\n    let triangle;\n    while (triangle = this.triangles.pop()) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle);\n        }\n      }\n    }\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length;\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1);\n      }\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i]);\n      }\n    }\n    return this;\n  }\n  build() {\n    this.calcBox();\n    this.split(0);\n    return this;\n  }\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!ray.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles);\n      }\n    }\n    return triangles;\n  }\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane);\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n    if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n      return false;\n    }\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n    if (triangle.containsPoint(intersectPoint)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: intersectPoint.clone(),\n        depth: Math.abs(Math.min(d1, d2))\n      };\n    }\n    const r2 = capsule.radius * capsule.radius;\n    const line1 = _line1.set(capsule.start, capsule.end);\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1]);\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2)\n        };\n      }\n    }\n    return false;\n  }\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane);\n    if (!sphere.intersectsPlane(_plane)) return false;\n    const depth = Math.abs(_plane.distanceToSphere(sphere));\n    const r2 = sphere.radius * sphere.radius - depth * depth;\n    const plainPoint = _plane.projectPoint(sphere.center, _v1);\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere))\n      };\n    }\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1]);\n      _line1.closestPointToPoint(plainPoint, true, _v2);\n      const d = _v2.distanceToSquared(sphere.center);\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d)\n        };\n      }\n    }\n    return false;\n  }\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!sphere.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles);\n      }\n    }\n  }\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!capsule.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles);\n      }\n    }\n  }\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getSphereTriangles(sphere, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n        hit = true;\n        _sphere.center.add(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center);\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth\n      };\n    }\n    return false;\n  }\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getCapsuleTriangles(_capsule, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n        hit = true;\n        _capsule.translate(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth\n      };\n    }\n    return false;\n  }\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0) return;\n    const triangles = [];\n    let triangle,\n      position,\n      distance = 1e100;\n    this.getRayTriangles(ray, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n      if (result) {\n        const newdistance = result.sub(ray.origin).length();\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin);\n          distance = newdistance;\n          triangle = triangles[i];\n        }\n      }\n    }\n    return distance < 1e100 ? {\n      distance,\n      triangle,\n      position\n    } : false;\n  }\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true);\n    group.traverse(obj => {\n      if (obj.isMesh === true) {\n        let geometry,\n          isTemp = false;\n        if (obj.geometry.index !== null) {\n          isTemp = true;\n          geometry = obj.geometry.toNonIndexed();\n        } else {\n          geometry = obj.geometry;\n        }\n        const positionAttribute = geometry.getAttribute(\"position\");\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i);\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1);\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2);\n          v1.applyMatrix4(obj.matrixWorld);\n          v2.applyMatrix4(obj.matrixWorld);\n          v3.applyMatrix4(obj.matrixWorld);\n          this.addTriangle(new Triangle(v1, v2, v3));\n        }\n        if (isTemp) {\n          geometry.dispose();\n        }\n      }\n    });\n    this.build();\n    return this;\n  }\n}\nexport { Octree };","map":{"version":3,"sources":["../../src/math/Octree.js"],"names":[],"mappings":"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","sourcesContent":["import { Box3, Line3, Plane, Sphere, Triangle, Vector3 } from 'three'\nimport { Capsule } from '../math/Capsule'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _plane = new Plane()\nconst _line1 = new Line3()\nconst _line2 = new Line3()\nconst _sphere = new Sphere()\nconst _capsule = new Capsule()\n\nclass Octree {\n  constructor(box) {\n    this.triangles = []\n    this.box = box\n    this.subTrees = []\n  }\n\n  addTriangle(triangle) {\n    if (!this.bounds) this.bounds = new Box3()\n\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z)\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z)\n\n    this.triangles.push(triangle)\n\n    return this\n  }\n\n  calcBox() {\n    this.box = this.bounds.clone()\n\n    // offset small amount to account for regular grid\n    this.box.min.x -= 0.01\n    this.box.min.y -= 0.01\n    this.box.min.z -= 0.01\n\n    return this\n  }\n\n  split(level) {\n    if (!this.box) return\n\n    const subTrees = []\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5)\n\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3()\n          const v = _v1.set(x, y, z)\n\n          box.min.copy(this.box.min).add(v.multiply(halfsize))\n          box.max.copy(box.min).add(halfsize)\n\n          subTrees.push(new Octree(box))\n        }\n      }\n    }\n\n    let triangle\n\n    while ((triangle = this.triangles.pop())) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle)\n        }\n      }\n    }\n\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length\n\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1)\n      }\n\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i])\n      }\n    }\n\n    return this\n  }\n\n  build() {\n    this.calcBox()\n    this.split(0)\n\n    return this\n  }\n\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n      if (!ray.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles)\n      }\n    }\n\n    return triangles\n  }\n\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane)\n\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius\n\n    if ((d1 > 0 && d2 > 0) || (d1 < -capsule.radius && d2 < -capsule.radius)) {\n      return false\n    }\n\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)))\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta)\n\n    if (triangle.containsPoint(intersectPoint)) {\n      return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs(Math.min(d1, d2)) }\n    }\n\n    const r2 = capsule.radius * capsule.radius\n\n    const line1 = _line1.set(capsule.start, capsule.end)\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1])\n\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2)\n\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2),\n        }\n      }\n    }\n\n    return false\n  }\n\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane)\n\n    if (!sphere.intersectsPlane(_plane)) return false\n\n    const depth = Math.abs(_plane.distanceToSphere(sphere))\n    const r2 = sphere.radius * sphere.radius - depth * depth\n\n    const plainPoint = _plane.projectPoint(sphere.center, _v1)\n\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere)),\n      }\n    }\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1])\n      _line1.closestPointToPoint(plainPoint, true, _v2)\n\n      const d = _v2.distanceToSquared(sphere.center)\n\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d),\n        }\n      }\n    }\n\n    return false\n  }\n\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!sphere.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles)\n      }\n    }\n  }\n\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!capsule.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles)\n      }\n    }\n  }\n\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getSphereTriangles(sphere, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleSphereIntersect(_sphere, triangles[i]))) {\n        hit = true\n\n        _sphere.center.add(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center)\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getCapsuleTriangles(_capsule, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleCapsuleIntersect(_capsule, triangles[i]))) {\n        hit = true\n\n        _capsule.translate(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1))\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0) return\n\n    const triangles = []\n    let triangle,\n      position,\n      distance = 1e100\n\n    this.getRayTriangles(ray, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1)\n\n      if (result) {\n        const newdistance = result.sub(ray.origin).length()\n\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin)\n          distance = newdistance\n          triangle = triangles[i]\n        }\n      }\n    }\n\n    return distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false\n  }\n\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true)\n\n    group.traverse((obj) => {\n      if (obj.isMesh === true) {\n        let geometry,\n          isTemp = false\n\n        if (obj.geometry.index !== null) {\n          isTemp = true\n          geometry = obj.geometry.toNonIndexed()\n        } else {\n          geometry = obj.geometry\n        }\n\n        const positionAttribute = geometry.getAttribute('position')\n\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i)\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1)\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2)\n\n          v1.applyMatrix4(obj.matrixWorld)\n          v2.applyMatrix4(obj.matrixWorld)\n          v3.applyMatrix4(obj.matrixWorld)\n\n          this.addTriangle(new Triangle(v1, v2, v3))\n        }\n\n        if (isTemp) {\n          geometry.dispose()\n        }\n      }\n    })\n\n    this.build()\n\n    return this\n  }\n}\n\nexport { Octree }\n"]},"metadata":{},"sourceType":"module"}