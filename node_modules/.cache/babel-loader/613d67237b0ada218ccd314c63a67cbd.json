{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== \"string\") throw new Error(\"unsupported data type\");\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = {\n      letterSpacing: 0,\n      lineHeight: 1,\n      ..._options\n    };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\nexport { Font, FontLoader };","map":{"version":3,"sources":["../../src/loaders/FontLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public static isFont: true\n  public static type: 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n"]},"metadata":{},"sourceType":"module"}