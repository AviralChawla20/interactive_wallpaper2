{"ast":null,"code":"import { Vector3, Color, SphericalHarmonics3, LightProbe } from \"three\";\nclass LightProbeGenerator {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  static fromCubeTexture(cubeTexture) {\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const image = cubeTexture.image[faceIndex];\n      const width = image.width;\n      const height = image.height;\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(image, 0, 0, width, height);\n      const imageData = context.getImageData(0, 0, width, height);\n      const data = imageData.data;\n      const imageWidth = imageData.width;\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n        if (\"colorSpace\" in cubeTexture) {\n          if (cubeTexture.colorSpace === \"srgb\") {\n            color.convertSRGBToLinear();\n          }\n        } else if (cubeTexture.encoding === 3001) {\n          color.convertSRGBToLinear();\n        }\n        const pixelIndex = i / 4;\n        const col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n          case 1:\n            coord.set(1, row, col);\n            break;\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        }\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n        dir.copy(coord).normalize();\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n  static fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const imageWidth = cubeRenderTarget.width;\n      const data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n        if (\"colorSpace\" in cubeRenderTarget.texture) {\n          if (cubeRenderTarget.texture.colorSpace === \"srgb\") {\n            color.convertSRGBToLinear();\n          }\n        } else if (cubeRenderTarget.texture.encoding === 3001) {\n          color.convertSRGBToLinear();\n        }\n        const pixelIndex = i / 4;\n        const col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n          case 1:\n            coord.set(-1, row, col);\n            break;\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n          case 3:\n            coord.set(col, -1, row);\n            break;\n          case 4:\n            coord.set(col, row, 1);\n            break;\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        }\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n        dir.copy(coord).normalize();\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n}\nexport { LightProbeGenerator };","map":{"version":3,"sources":["../../src/lights/LightProbeGenerator.js"],"names":[],"mappings":"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","sourcesContent":["import { Color, LightProbe, SphericalHarmonics3, Vector3 } from 'three'\n\nclass LightProbeGenerator {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  static fromCubeTexture(cubeTexture) {\n    let totalWeight = 0\n\n    const coord = new Vector3()\n\n    const dir = new Vector3()\n\n    const color = new Color()\n\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    const sh = new SphericalHarmonics3()\n    const shCoefficients = sh.coefficients\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const image = cubeTexture.image[faceIndex]\n\n      const width = image.width\n      const height = image.height\n\n      const canvas = document.createElement('canvas')\n\n      canvas.width = width\n      canvas.height = height\n\n      const context = canvas.getContext('2d')\n\n      context.drawImage(image, 0, 0, width, height)\n\n      const imageData = context.getImageData(0, 0, width, height)\n\n      const data = imageData.data\n\n      const imageWidth = imageData.width // assumed to be square\n\n      const pixelSize = 2 / imageWidth\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255)\n\n        // convert to linear color space\n        if ('colorSpace' in cubeTexture) {\n          if (cubeTexture.colorSpace === 'srgb') {\n            color.convertSRGBToLinear()\n          }\n        } else if (cubeTexture.encoding === 3001) {\n          // sRGBEncoding\n          color.convertSRGBToLinear()\n        }\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4\n\n        const col = -1 + ((pixelIndex % imageWidth) + 0.5) * pixelSize\n\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col)\n            break\n\n          case 1:\n            coord.set(1, row, col)\n            break\n\n          case 2:\n            coord.set(-col, 1, -row)\n            break\n\n          case 3:\n            coord.set(-col, -1, row)\n            break\n\n          case 4:\n            coord.set(-col, row, 1)\n            break\n\n          case 5:\n            coord.set(col, row, -1)\n            break\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq()\n\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq)\n\n        totalWeight += weight\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize()\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis)\n\n        // accummuulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight\n          shCoefficients[j].y += shBasis[j] * color.g * weight\n          shCoefficients[j].z += shBasis[j] * color.b * weight\n        }\n      }\n    }\n\n    // normalize\n    const norm = (4 * Math.PI) / totalWeight\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm\n      shCoefficients[j].y *= norm\n      shCoefficients[j].z *= norm\n    }\n\n    return new LightProbe(sh)\n  }\n\n  static fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    let totalWeight = 0\n\n    const coord = new Vector3()\n\n    const dir = new Vector3()\n\n    const color = new Color()\n\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    const sh = new SphericalHarmonics3()\n    const shCoefficients = sh.coefficients\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const imageWidth = cubeRenderTarget.width // assumed to be square\n      const data = new Uint8Array(imageWidth * imageWidth * 4)\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex)\n\n      const pixelSize = 2 / imageWidth\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255)\n\n        // convert to linear color space\n        if ('colorSpace' in cubeRenderTarget.texture) {\n          if (cubeRenderTarget.texture.colorSpace === 'srgb') {\n            color.convertSRGBToLinear()\n          }\n        } else if (cubeRenderTarget.texture.encoding === 3001) {\n          // sRGBEncoding\n          color.convertSRGBToLinear()\n        }\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4\n\n        const col = -1 + ((pixelIndex % imageWidth) + 0.5) * pixelSize\n\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col)\n            break\n\n          case 1:\n            coord.set(-1, row, col)\n            break\n\n          case 2:\n            coord.set(col, 1, -row)\n            break\n\n          case 3:\n            coord.set(col, -1, row)\n            break\n\n          case 4:\n            coord.set(col, row, 1)\n            break\n\n          case 5:\n            coord.set(-col, row, -1)\n            break\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq()\n\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq)\n\n        totalWeight += weight\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize()\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis)\n\n        // accummuulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight\n          shCoefficients[j].y += shBasis[j] * color.g * weight\n          shCoefficients[j].z += shBasis[j] * color.b * weight\n        }\n      }\n    }\n\n    // normalize\n    const norm = (4 * Math.PI) / totalWeight\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm\n      shCoefficients[j].y *= norm\n      shCoefficients[j].z *= norm\n    }\n\n    return new LightProbe(sh)\n  }\n}\n\nexport { LightProbeGenerator }\n"]},"metadata":{},"sourceType":"module"}