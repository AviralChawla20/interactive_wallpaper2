{"ast":null,"code":"import { Loader, FileLoader, Matrix3, Vector2, Vector3, ShapeUtils, Box2, Shape, Path, BufferGeometry, Float32BufferAttribute, ShapePath } from \"three\";\nconst COLOR_SPACE_SVG = \"srgb\";\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.defaultDPI = 90;\n    this.defaultUnit = \"px\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      const transform = getNodeTransform(node);\n      let isDefsNode = false;\n      let path = null;\n      switch (node.nodeName) {\n        case \"svg\":\n          style = parseStyle(node, style);\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          isDefsNode = true;\n          break;\n        case \"use\":\n          style = parseStyle(node, style);\n          const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n          const usedNodeId = href.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n      }\n      if (path) {\n        if (style.fill !== void 0 && style.fill !== \"none\") {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node,\n          style\n        };\n      }\n      const childNodes = node.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const node2 = childNodes[i];\n        if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n          continue;\n        }\n        parseNode(node2, style);\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      if (d === \"\" || d === \"none\") return null;\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data2 = command.slice(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0) firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0) firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i2 => i2.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n        }\n      }\n    }\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n      const dx2 = (start.x - end.x) / 2;\n      const dy2 = (start.y - end.y) / 2;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath();\n      path.moveTo(x + rx, y);\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseStyle(node, style) {\n      style = Object.assign({}, style);\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(i => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === void 0) adjustFunction = function copy(v) {\n          if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"fill-rule\", \"fillRule\");\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\",\n        exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current2, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n        if (state === SEP) {\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n      newNumber();\n      return result;\n    }\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = void 0;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform2 = tempTransform0;\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\") continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos);\n            const array = parseFloats(transformText.slice(openParPos + 1));\n            currentTransform2.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = 0;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform2.translate(tx, ty);\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n                  angle = array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    cx = array[1];\n                    cy = array[2];\n                  }\n                  tempTransform1.makeTranslation(-cx, -cy);\n                  tempTransform2.makeRotation(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.makeTranslation(cx, cy);\n                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform2.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform2);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      function transfEllipseGeneric(curve) {\n        const a = curve.xRadius;\n        const b = curve.yRadius;\n        const cosTheta = Math.cos(curve.aRotation);\n        const sinTheta = Math.sin(curve.aRotation);\n        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0);\n        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0);\n        const f1 = v1.applyMatrix3(m);\n        const f2 = v2.applyMatrix3(m);\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n        const mFInv = tempTransform1.copy(mF).invert();\n        const mFInvT = tempTransform2.copy(mFInv).transpose();\n        const mQ = mFInvT.multiply(mFInv);\n        const mQe = mQ.elements;\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n        const rt1sqrt = Math.sqrt(ed.rt1);\n        const rt2sqrt = Math.sqrt(ed.rt2);\n        curve.xRadius = 1 / rt1sqrt;\n        curve.yRadius = 1 / rt2sqrt;\n        curve.aRotation = Math.atan2(ed.sn, ed.cs);\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n          const transformAngle = phi => {\n            const {\n              x: cosR,\n              y: sinR\n            } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n            return Math.atan2(sinR, cosR);\n          };\n          curve.aStartAngle = transformAngle(curve.aStartAngle);\n          curve.aEndAngle = transformAngle(curve.aEndAngle);\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n      }\n      function transfEllipseNoSkew(curve) {\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        curve.xRadius *= sx;\n        curve.yRadius *= sy;\n        const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n        curve.aRotation += theta;\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1;\n          curve.aEndAngle *= -1;\n          curve.aClockwise = !curve.aClockwise;\n        }\n      }\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve);\n            } else {\n              transfEllipseNoSkew(curve);\n            }\n          }\n        }\n      }\n    }\n    function isTransformFlipped(m) {\n      const te = m.elements;\n      return te[0] * te[4] - te[1] * te[3] < 0;\n    }\n    function isTransformSkewed(m) {\n      const te = m.elements;\n      const basisDot = te[0] * te[3] + te[1] * te[4];\n      if (basisDot === 0) return false;\n      const sx = getTransformScaleX(m);\n      const sy = getTransformScaleY(m);\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t;\n      const sm = A + C;\n      const df = A - C;\n      const rt = Math.sqrt(df * df + 4 * B * B);\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt);\n        t = 1 / rt1;\n        rt2 = A * t * C - B * t * B;\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt);\n      } else {\n        rt1 = 0.5 * rt;\n        rt2 = -0.5 * rt;\n      }\n      if (df > 0) {\n        cs = df + rt;\n      } else {\n        cs = df - rt;\n      }\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = -2 * B / cs;\n        sn = 1 / Math.sqrt(1 + t * t);\n        cs = t * sn;\n      } else if (Math.abs(B) === 0) {\n        cs = 1;\n        sn = 0;\n      } else {\n        t = -0.5 * cs / B;\n        cs = 1 / Math.sqrt(1 + t * t);\n        sn = t * cs;\n      }\n      if (df > 0) {\n        t = cs;\n        cs = -sn;\n        sn = t;\n      }\n      return {\n        rt1,\n        rt2,\n        cs,\n        sn\n      };\n    }\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n    parseNode(xml.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    });\n    const data = {\n      paths,\n      xml: xml.documentElement\n    };\n    return data;\n  }\n  static createShapes(shapePath) {\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return {\n              x,\n              y,\n              t: classifyResult.t\n            };\n          }\n        }\n        return null;\n      } else {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return {\n          x,\n          y,\n          t: t1\n        };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach(path => {\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach(p => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p\n            });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n      if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach(i2 => {\n        if (i2.identifier === simplePath.identifier) {\n          baseIntersections.push(i2);\n        } else {\n          otherIntersections.push(i2);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return {\n          identifier: simplePath.identifier,\n          isHole,\n          for: isHoleFor\n        };\n      } else if (_fillRule === \"nonzero\") {\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i2 = 0; i2 < stack.length; i2++) {\n          const identifier = stack[i2];\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n        return {\n          identifier: simplePath.identifier,\n          isHole,\n          for: isHoleFor\n        };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map(p => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n      for (let i = 0; i < points.length; i++) {\n        const p2 = points[i];\n        if (p2.y > maxY) {\n          maxY = p2.y;\n        }\n        if (p2.y < minY) {\n          minY = p2.y;\n        }\n        if (p2.x > maxX) {\n          maxX = p2.x;\n        }\n        if (p2.x < minX) {\n          minX = p2.x;\n        }\n      }\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        curves: p.curves,\n        points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter(sp => sp.points.length > 1);\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier;\n    }\n    const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));\n    const shapesToReturn = [];\n    simplePaths.forEach(p => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n        holes.forEach(h => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    width = width !== void 0 ? width : 1;\n    color = color !== void 0 ? color : \"#000\";\n    lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n    lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n    miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n    minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2) return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n      u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          nextPoint = points[1];\n        } else nextPoint = void 0;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== void 0) {\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n        if (dot > Number.EPSILON) {\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                if (innerSideModified) {\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n      } else {\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 0);\n      addVertex(currentPointR, u1, 1);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u, 1);\n          addVertex(innerPoint, u, 0);\n          addVertex(nextPointR, u, 1);\n        }\n      } else {\n        if (joinIsOnLeftSide2) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points2) {\n      let dupPoints = false;\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints) return points2;\n      const newPoints = [];\n      newPoints.push(points2[0]);\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n          newPoints.push(points2[i]);\n        }\n      }\n      newPoints.push(points2[points2.length - 1]);\n      return newPoints;\n    }\n  }\n}\nexport { SVGLoader };","map":{"version":3,"sources":["../../src/loaders/SVGLoader.js"],"names":["node","data","i","current","currentTransform","scanlineMinX","scanlineMaxX","p","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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","sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Default dots per inch\n    this.defaultDPI = 90\n\n    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n    this.defaultUnit = 'px'\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    const scope = this\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return\n\n      const transform = getNodeTransform(node)\n\n      let isDefsNode = false\n\n      let path = null\n\n      switch (node.nodeName) {\n        case 'svg':\n          style = parseStyle(node, style)\n          break\n\n        case 'style':\n          parseCSSStylesheet(node)\n          break\n\n        case 'g':\n          style = parseStyle(node, style)\n          break\n\n        case 'path':\n          style = parseStyle(node, style)\n          if (node.hasAttribute('d')) path = parsePathNode(node)\n          break\n\n        case 'rect':\n          style = parseStyle(node, style)\n          path = parseRectNode(node)\n          break\n\n        case 'polygon':\n          style = parseStyle(node, style)\n          path = parsePolygonNode(node)\n          break\n\n        case 'polyline':\n          style = parseStyle(node, style)\n          path = parsePolylineNode(node)\n          break\n\n        case 'circle':\n          style = parseStyle(node, style)\n          path = parseCircleNode(node)\n          break\n\n        case 'ellipse':\n          style = parseStyle(node, style)\n          path = parseEllipseNode(node)\n          break\n\n        case 'line':\n          style = parseStyle(node, style)\n          path = parseLineNode(node)\n          break\n\n        case 'defs':\n          isDefsNode = true\n          break\n\n        case 'use':\n          style = parseStyle(node, style)\n\n          const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n          const usedNodeId = href.substring(1)\n          const usedNode = node.viewportElement.getElementById(usedNodeId)\n          if (usedNode) {\n            parseNode(usedNode, style)\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n          }\n\n          break\n\n        default:\n        // console.log( node );\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n        }\n\n        transformPath(path, currentTransform)\n\n        paths.push(path)\n\n        path.userData = { node: node, style: style }\n      }\n\n      const childNodes = node.childNodes\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const node = childNodes[i]\n\n        if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n          // Ignore everything in defs except CSS style definitions\n          // and nested defs, because it is OK by the standard to have\n          // <style/> there.\n          continue\n        }\n\n        parseNode(node, style)\n      }\n\n      if (transform) {\n        transformStack.pop()\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1])\n        } else {\n          currentTransform.identity()\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath()\n\n      const point = new Vector2()\n      const control = new Vector2()\n\n      const firstPoint = new Vector2()\n      let isFirstPoint = true\n      let doSetFirstPoint = false\n\n      const d = node.getAttribute('d')\n\n      if (d === '' || d === 'none') return null\n\n      // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i]\n\n        const type = command.charAt(0)\n        const data = command.slice(1).trim()\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true\n          isFirstPoint = false\n        }\n\n        let numbers\n\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data)\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'H':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'V':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'L':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'C':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5],\n              )\n              control.x = numbers[j + 2]\n              control.y = numbers[j + 3]\n              point.x = numbers[j + 4]\n              point.y = numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'S':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n              )\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'T':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n              const start = point.clone()\n              point.x = numbers[j + 5]\n              point.y = numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'm':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'h':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'v':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'l':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'c':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5],\n              )\n              control.x = point.x + numbers[j + 2]\n              control.y = point.y + numbers[j + 3]\n              point.x += numbers[j + 4]\n              point.y += numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 's':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 't':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = point.x + numbers[j + 0]\n              point.y = point.y + numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n              const start = point.clone()\n              point.x += numbers[j + 5]\n              point.y += numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint)\n              path.currentPath.currentPoint.copy(point)\n              isFirstPoint = true\n            }\n\n            break\n\n          default:\n            console.warn(command)\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false\n      }\n\n      return path\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i]\n\n        if (stylesheet.type !== 1) continue\n\n        const selectorList = stylesheet.selectorText\n          .split(/,/gm)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let j = 0; j < selectorList.length; j++) {\n          // Remove empty rules\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y)\n        return\n      }\n\n      x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n      // Ensure radii are positive\n      rx = Math.abs(rx)\n      ry = Math.abs(ry)\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0\n      const dy2 = (start.y - end.y) / 2.0\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n      // Compute (cx', cy')\n      let rxs = rx * rx\n      let rys = ry * ry\n      const x1ps = x1p * x1p\n      const y1ps = y1p * y1p\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr)\n        rx = s * rx\n        ry = s * ry\n        rxs = rx * rx\n        rys = ry * ry\n      }\n\n      const dq = rxs * y1ps + rys * x1ps\n      const pq = (rxs * rys - dq) / dq\n      let q = Math.sqrt(Math.max(0, pq))\n      if (large_arc_flag === sweep_flag) q = -q\n      const cxp = (q * rx * y1p) / ry\n      const cyp = (-q * ry * x1p) / rx\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n      // Step 4: Compute 1 and \n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang\n      return ang\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n      const w = parseFloatWithUnits(node.getAttribute('width'))\n      const h = parseFloatWithUnits(node.getAttribute('height'))\n\n      // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n      // https://spencermortensen.com/articles/bezier-circle/\n      const bci = 1 - 0.551915024494\n\n      const path = new ShapePath()\n\n      // top left\n      path.moveTo(x + rx, y)\n\n      // top right\n      path.lineTo(x + w - rx, y)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n      }\n\n      // bottom right\n      path.lineTo(x + w, y + h - ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n      }\n\n      // bottom left\n      path.lineTo(x + rx, y + h)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n      }\n\n      // back to top left\n      path.lineTo(x, y + ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n      }\n\n      return path\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = true\n\n      return path\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n      const subpath = new Path()\n      subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n      const subpath = new Path()\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n      const path = new ShapePath()\n      path.moveTo(x1, y1)\n      path.lineTo(x2, y2)\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style) // clone style\n\n      let stylesheetStyles = {}\n\n      if (node.hasAttribute('class')) {\n        const classSelectors = node\n          .getAttribute('class')\n          .split(/\\s/)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined)\n          adjustFunction = function copy(v) {\n            if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n            return v\n          }\n\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v))\n      }\n\n      addStyle('fill', 'fill')\n      addStyle('fill-opacity', 'fillOpacity', clamp)\n      addStyle('fill-rule', 'fillRule')\n      addStyle('opacity', 'opacity', clamp)\n      addStyle('stroke', 'stroke')\n      addStyle('stroke-opacity', 'strokeOpacity', clamp)\n      addStyle('stroke-width', 'strokeWidth', positive)\n      addStyle('stroke-linejoin', 'strokeLineJoin')\n      addStyle('stroke-linecap', 'strokeLineCap')\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n      addStyle('visibility', 'visibility')\n\n      return style\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a)\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input)\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/,\n      }\n\n      // States\n      const SEP = 0\n      const INT = 1\n      const FLOAT = 2\n      const EXP = 3\n\n      let state = SEP\n      let seenComma = true\n      let number = '',\n        exponent = ''\n      const result = []\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n        error.partial = partial\n        throw error\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number))\n          else result.push(Number(number) * Math.pow(10, Number(exponent)))\n        }\n\n        number = ''\n        exponent = ''\n      }\n\n      let current\n      const length = input.length\n\n      for (let i = 0; i < length; i++) {\n        current = input[i]\n\n        // check for flags\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT\n          number = current\n          newNumber()\n          continue\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT\n            number = current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT\n            number = current\n            continue\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result)\n            }\n\n            seenComma = true\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current\n            state = FLOAT\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current\n            continue\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current\n              continue\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = false\n        } else if (RE.COMMA.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = true\n        } else if (RE.SIGN.test(current)) {\n          newNumber()\n          state = INT\n          number = current\n        } else if (RE.POINT.test(current)) {\n          newNumber()\n          state = FLOAT\n          number = current\n        } else {\n          throwSyntaxError(current, i, result)\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber()\n\n      return result\n    }\n\n    // Units\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1,\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1,\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1,\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1,\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1,\n      },\n      px: {\n        px: 1,\n      },\n    }\n\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px'\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i]\n\n          if (string.endsWith(u)) {\n            theUnit = u\n            string = string.substring(0, string.length - u.length)\n            break\n          }\n        }\n      }\n\n      let scale = undefined\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit]\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n        }\n      }\n\n      return scale * parseFloat(string)\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (\n        !(\n          node.hasAttribute('transform') ||\n          (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n        )\n      ) {\n        return null\n      }\n\n      const transform = parseNodeTransform(node)\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1])\n      }\n\n      currentTransform.copy(transform)\n      transformStack.push(transform)\n\n      return transform\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3()\n      const currentTransform = tempTransform0\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'))\n        const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n        transform.translate(tx, ty)\n      }\n\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')')\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim()\n\n          if (transformText === '') continue\n\n          const openParPos = transformText.indexOf('(')\n          const closeParPos = transformText.length\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos)\n\n            const array = parseFloats(transformText.slice(openParPos + 1))\n\n            currentTransform.identity()\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0]\n                  let ty = 0\n\n                  if (array.length >= 2) {\n                    ty = array[1]\n                  }\n\n                  currentTransform.translate(tx, ty)\n                }\n\n                break\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0\n                  let cx = 0\n                  let cy = 0\n\n                  // Angle\n                  angle = (array[0] * Math.PI) / 180\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1]\n                    cy = array[2]\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.makeTranslation(-cx, -cy)\n                  tempTransform2.makeRotation(angle)\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                  tempTransform1.makeTranslation(cx, cy)\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                }\n\n                break\n\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0]\n                  let scaleY = scaleX\n\n                  if (array.length >= 2) {\n                    scaleY = array[1]\n                  }\n\n                  currentTransform.scale(scaleX, scaleY)\n                }\n\n                break\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                }\n\n                break\n            }\n          }\n\n          transform.premultiply(currentTransform)\n        }\n      }\n\n      return transform\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n        v2.set(tempV3.x, tempV3.y)\n      }\n\n      function transfEllipseGeneric(curve) {\n        // For math description see:\n        // https://math.stackexchange.com/questions/4544164\n\n        const a = curve.xRadius\n        const b = curve.yRadius\n\n        const cosTheta = Math.cos(curve.aRotation)\n        const sinTheta = Math.sin(curve.aRotation)\n\n        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n        const f1 = v1.applyMatrix3(m)\n        const f2 = v2.applyMatrix3(m)\n\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n        const mFInv = tempTransform1.copy(mF).invert()\n        const mFInvT = tempTransform2.copy(mFInv).transpose()\n        const mQ = mFInvT.multiply(mFInv)\n        const mQe = mQ.elements\n\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n        const rt1sqrt = Math.sqrt(ed.rt1)\n        const rt2sqrt = Math.sqrt(ed.rt2)\n\n        curve.xRadius = 1 / rt1sqrt\n        curve.yRadius = 1 / rt2sqrt\n        curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n        // Do not touch angles of a full ellipse because after transformation they\n        // would converge to a sinle value effectively removing the whole curve\n\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n          const transformAngle = (phi) => {\n            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n            return Math.atan2(sinR, cosR)\n          }\n\n          curve.aStartAngle = transformAngle(curve.aStartAngle)\n          curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n      }\n\n      function transfEllipseNoSkew(curve) {\n        // Faster shortcut if no skew is applied\n        // (e.g, a euclidean transform of a group containing the ellipse)\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        curve.xRadius *= sx\n        curve.yRadius *= sy\n\n        // Extract rotation angle from the matrix of form:\n        //\n        //  | cos sx   -sin sy |\n        //  | sin sx    cos sy |\n        //\n        // Remembering that tan = sin / cos; and that\n        // `sx`, `sy`, or both might be zero.\n        const theta =\n          sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n        curve.aRotation += theta\n\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1\n          curve.aEndAngle *= -1\n          curve.aClockwise = !curve.aClockwise\n        }\n      }\n\n      const subPaths = path.subPaths\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i]\n        const curves = subPath.curves\n\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j]\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n            transfVec2(curve.v3)\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isEllipseCurve) {\n            // Transform ellipse center point\n\n            tempV2.set(curve.aX, curve.aY)\n            transfVec2(tempV2)\n            curve.aX = tempV2.x\n            curve.aY = tempV2.y\n\n            // Transform ellipse shape parameters\n\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve)\n            } else {\n              transfEllipseNoSkew(curve)\n            }\n          }\n        }\n      }\n    }\n\n    function isTransformFlipped(m) {\n      const te = m.elements\n      return te[0] * te[4] - te[1] * te[3] < 0\n    }\n\n    function isTransformSkewed(m) {\n      const te = m.elements\n      const basisDot = te[0] * te[3] + te[1] * te[4]\n\n      // Shortcut for trivial rotations and transformations\n      if (basisDot === 0) return false\n\n      const sx = getTransformScaleX(m)\n      const sy = getTransformScaleY(m)\n\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n    }\n\n    function getTransformScaleX(m) {\n      const te = m.elements\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n    }\n\n    function getTransformScaleY(m) {\n      const te = m.elements\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n    }\n\n    // Calculates the eigensystem of a real symmetric 2x2 matrix\n    //    [ A  B ]\n    //    [ B  C ]\n    // in the form\n    //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n    //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n    // where rt1 >= rt2.\n    //\n    // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n    // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t\n      const sm = A + C\n      const df = A - C\n      const rt = Math.sqrt(df * df + 4 * B * B)\n\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt)\n        t = 1 / rt1\n        rt2 = A * t * C - B * t * B\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt)\n      } else {\n        // This case needs to be treated separately to avoid div by 0\n\n        rt1 = 0.5 * rt\n        rt2 = -0.5 * rt\n      }\n\n      // Calculate eigenvectors\n\n      if (df > 0) {\n        cs = df + rt\n      } else {\n        cs = df - rt\n      }\n\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = (-2 * B) / cs\n        sn = 1 / Math.sqrt(1 + t * t)\n        cs = t * sn\n      } else if (Math.abs(B) === 0) {\n        cs = 1\n        sn = 0\n      } else {\n        t = (-0.5 * cs) / B\n        cs = 1 / Math.sqrt(1 + t * t)\n        sn = t * cs\n      }\n\n      if (df > 0) {\n        t = cs\n        cs = -sn\n        sn = t\n      }\n\n      return { rt1, rt2, cs, sn }\n    }\n\n    //\n\n    const paths = []\n    const stylesheets = {}\n\n    const transformStack = []\n\n    const tempTransform0 = new Matrix3()\n    const tempTransform1 = new Matrix3()\n    const tempTransform2 = new Matrix3()\n    const tempTransform3 = new Matrix3()\n    const tempV2 = new Vector2()\n    const tempV3 = new Vector3()\n\n    const currentTransform = new Matrix3()\n\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4,\n    })\n\n    const data = { paths: paths, xml: xml.documentElement }\n\n    // console.log( paths );\n    return data\n  }\n\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999\n\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6,\n    }\n\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0,\n    }\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x\n      const x2 = a1.x\n      const x3 = b0.x\n      const x4 = b1.x\n      const y1 = a0.y\n      const y2 = a1.y\n      const y3 = b0.y\n      const y4 = b1.y\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n      const t1 = nom1 / denom\n      const t2 = nom2 / denom\n\n      if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n\n        return null\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n            return { x: x, y: y, t: classifyResult.t }\n          }\n        }\n\n        return null\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n        return { x: x, y: y, t: t1 }\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x\n      const ay = edgeEnd.y - edgeStart.y\n      const bx = p.x - edgeStart.x\n      const by = p.y - edgeStart.y\n      const sa = ax * by - bx * ay\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN\n        classifyResult.t = 0\n        return\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION\n        classifyResult.t = 1\n        return\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT\n        return\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT\n        return\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND\n        return\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND\n        return\n      }\n\n      let t\n\n      if (ax !== 0) {\n        t = bx / ax\n      } else {\n        t = by / ay\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN\n      classifyResult.t = t\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = []\n      const intersections = []\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1]\n        const path1EdgeEnd = path1[index]\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1]\n          const path2EdgeEnd = path2[index2]\n\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n          if (\n            intersection !== null &&\n            intersectionsRaw.find(\n              (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n            ) === undefined\n          ) {\n            intersectionsRaw.push(intersection)\n            intersections.push(new Vector2(intersection.x, intersection.y))\n          }\n        }\n      }\n\n      return intersections\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2()\n      boundingBox.getCenter(center)\n\n      const allIntersections = []\n\n      paths.forEach((path) => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points)\n\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n          })\n        }\n      })\n\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      return allIntersections\n    }\n\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero'\n      }\n\n      const centerBoundingBox = new Vector2()\n      simplePath.boundingBox.getCenter(centerBoundingBox)\n\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)]\n\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      const baseIntersections = []\n      const otherIntersections = []\n\n      scanlineIntersections.forEach((i) => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i)\n        } else {\n          otherIntersections.push(i)\n        }\n      })\n\n      const firstXOfPath = baseIntersections[0].point.x\n\n      // build up the path hierarchy\n      const stack = []\n      let i = 0\n\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop()\n        } else {\n          stack.push(otherIntersections[i].identifier)\n        }\n\n        i++\n      }\n\n      stack.push(simplePath.identifier)\n\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false\n        const isHoleFor = stack[stack.length - 2]\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true\n        let isHoleFor = null\n        let lastCWValue = null\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i]\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = false\n            isHoleFor = identifier\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = true\n          }\n        }\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n      }\n    }\n\n    // check for self intersecting paths\n    // TODO\n\n    // check intersecting paths\n    // TODO\n\n    // prepare paths for hole detection\n    let scanlineMinX = BIGNUMBER\n    let scanlineMaxX = -BIGNUMBER\n\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints()\n      let maxY = -BIGNUMBER\n      let minY = BIGNUMBER\n      let maxX = -BIGNUMBER\n      let minX = BIGNUMBER\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i]\n\n        if (p.y > maxY) {\n          maxY = p.y\n        }\n\n        if (p.y < minY) {\n          minY = p.y\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x\n        }\n\n        if (p.x < minX) {\n          minX = p.x\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1\n      }\n\n      return {\n        curves: p.curves,\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n      }\n    })\n\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier\n    }\n\n    // check if path is solid or a hole\n    const isAHole = simplePaths.map((p) =>\n      isHoleTo(\n        p,\n        simplePaths,\n        scanlineMinX,\n        scanlineMaxX,\n        shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n      ),\n    )\n\n    const shapesToReturn = []\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier]\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape()\n        shape.curves = p.curves\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier]\n          const path = new Path()\n          path.curves = hole.curves\n          shape.holes.push(path)\n        })\n        shapesToReturn.push(shape)\n      }\n    })\n\n    return shapesToReturn\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1\n    color = color !== undefined ? color : '#000'\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n    lineCap = lineCap !== undefined ? lineCap : 'butt'\n    miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit,\n    }\n  }\n\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some width around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = []\n    const normals = []\n    const uvs = []\n\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null\n    }\n\n    const geometry = new BufferGeometry()\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n    return geometry\n  }\n\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2()\n    const tempV2_2 = new Vector2()\n    const tempV2_3 = new Vector2()\n    const tempV2_4 = new Vector2()\n    const tempV2_5 = new Vector2()\n    const tempV2_6 = new Vector2()\n    const tempV2_7 = new Vector2()\n    const lastPointL = new Vector2()\n    const lastPointR = new Vector2()\n    const point0L = new Vector2()\n    const point0R = new Vector2()\n    const currentPointL = new Vector2()\n    const currentPointR = new Vector2()\n    const nextPointL = new Vector2()\n    const nextPointR = new Vector2()\n    const innerPoint = new Vector2()\n    const outerPoint = new Vector2()\n\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n    minDistance = minDistance !== undefined ? minDistance : 0.001\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points)\n\n    const numPoints = points.length\n\n    if (numPoints < 2) return 0\n\n    const isClosed = points[0].equals(points[numPoints - 1])\n\n    let currentPoint\n    let previousPoint = points[0]\n    let nextPoint\n\n    const strokeWidth2 = style.strokeWidth / 2\n\n    const deltaU = 1 / (numPoints - 1)\n    let u0 = 0,\n      u1\n\n    let innerSideModified\n    let joinIsOnLeftSide\n    let isMiter\n    let initialJoinIsOnLeftSide = false\n\n    let numVertices = 0\n    let currentCoordinate = vertexOffset * 3\n    let currentCoordinateUV = vertexOffset * 2\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n    lastPointL.copy(points[0]).sub(tempV2_1)\n    lastPointR.copy(points[0]).add(tempV2_1)\n    point0L.copy(lastPointL)\n    point0R.copy(lastPointR)\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1]\n        } else nextPoint = undefined\n      } else {\n        nextPoint = points[iPoint + 1]\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1\n      getNormal(previousPoint, currentPoint, normal1)\n\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n      currentPointL.copy(currentPoint).sub(tempV2_3)\n      currentPointR.copy(currentPoint).add(tempV2_3)\n\n      u1 = u0 + deltaU\n\n      innerSideModified = false\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2)\n\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n        nextPointL.copy(currentPoint).sub(tempV2_3)\n        nextPointR.copy(currentPoint).add(tempV2_3)\n\n        joinIsOnLeftSide = true\n        tempV2_3.subVectors(nextPoint, previousPoint)\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n        tempV2_3.subVectors(nextPoint, currentPoint)\n        tempV2_3.normalize()\n        const dot = Math.abs(normal1.dot(tempV2_3))\n\n        // If path is straight, don't create join\n        if (dot > Number.EPSILON) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot\n          tempV2_3.multiplyScalar(-miterSide)\n          tempV2_4.subVectors(currentPoint, previousPoint)\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n          innerPoint.copy(tempV2_5).negate()\n          const miterLength2 = tempV2_5.length()\n          const segmentLengthPrev = tempV2_4.length()\n          tempV2_4.divideScalar(segmentLengthPrev)\n          tempV2_6.subVectors(nextPoint, currentPoint)\n          const segmentLengthNext = tempV2_6.length()\n          tempV2_6.divideScalar(segmentLengthNext)\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint)\n          innerPoint.add(currentPoint)\n\n          isMiter = false\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint)\n              currentPointR.copy(innerPoint)\n            } else {\n              nextPointL.copy(innerPoint)\n              currentPointL.copy(innerPoint)\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles()\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n              break\n\n            case 'round':\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n              }\n\n              break\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                  break\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(tempV2_7, u1, 0)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(tempV2_7, u1, 1)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 0)\n\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(innerPoint, u1, 1)\n                  } else {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 1)\n\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(innerPoint, u1, 0)\n                    addVertex(outerPoint, u1, 1)\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint)\n                  } else {\n                    nextPointR.copy(outerPoint)\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n\n                isMiter = true\n              }\n\n              break\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles()\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles()\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n      }\n\n      // Increment loop variables\n\n      u0 = u1\n\n      previousPoint = currentPoint\n\n      lastPointL.copy(nextPointL)\n      lastPointR.copy(nextPointR)\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint\n      let lastInner = innerPoint\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint\n        lastInner = outerPoint\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3)\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3)\n          }\n        }\n      }\n    }\n\n    return numVertices\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1)\n      return result.set(-result.y, result.x).normalize()\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x\n        vertices[currentCoordinate + 1] = position.y\n        vertices[currentCoordinate + 2] = 0\n\n        if (normals) {\n          normals[currentCoordinate] = 0\n          normals[currentCoordinate + 1] = 0\n          normals[currentCoordinate + 2] = 1\n        }\n\n        currentCoordinate += 3\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u\n          uvs[currentCoordinateUV + 1] = v\n\n          currentCoordinateUV += 2\n        }\n      }\n\n      numVertices += 3\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize()\n      tempV2_2.copy(p2).sub(center).normalize()\n\n      let angle = Math.PI\n      const dot = tempV2_1.dot(tempV2_2)\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n      angle /= arcDivisions\n\n      tempV2_3.copy(p1)\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n        addVertex(tempV2_3, u, v)\n        addVertex(tempV2_4, u, v)\n        addVertex(center, u, 0.5)\n\n        tempV2_3.copy(tempV2_4)\n      }\n\n      addVertex(tempV2_4, u, v)\n      addVertex(p2, u, v)\n      addVertex(center, u, 0.5)\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1)\n      addVertex(lastPointL, u0, 0)\n      addVertex(currentPointL, u1, 0)\n\n      addVertex(lastPointR, u0, 1)\n      addVertex(currentPointL, u1, 0)\n      addVertex(currentPointR, u1, 1)\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(innerPoint, u, 0.5)\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1)\n          addVertex(innerPoint, u, 0)\n          addVertex(nextPointR, u, 1)\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        } else {\n          addVertex(currentPointR, u, 1)\n          addVertex(nextPointR, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPointL, u0, 0)\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(nextPointL, u0, 0)\n          addVertex(innerPoint, u1, 1)\n        } else {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(currentPointR, u0, 1)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPoint, u1, 0.5)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 0)\n          addVertex(nextPointR, u0, 1)\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5)\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5)\n          }\n\n          break\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n              tempV2_4.toArray(vertices, 3 * 3)\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3)\n              // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n            }\n          } else {\n            tempV2_1.subVectors(p2, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            const vl = vertices.length\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            } else {\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            }\n          }\n\n          break\n\n        case 'butt':\n        default:\n          // Nothing to do here\n          break\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true\n          break\n        }\n      }\n\n      if (!dupPoints) return points\n\n      const newPoints = []\n      newPoints.push(points[0])\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i])\n        }\n      }\n\n      newPoints.push(points[points.length - 1])\n\n      return newPoints\n    }\n  }\n}\n\nexport { SVGLoader }\n"]},"metadata":{},"sourceType":"module"}