{"ast":null,"code":"import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"srgb-linear\");\n          maxColor.setHex(this.map[j + 1][1], \"srgb-linear\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"srgb-linear\");\n          maxColor.setHex(this.map[j][1], \"srgb-linear\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };","map":{"version":3,"sources":["../../src/math/Lut.js"],"names":[],"mappings":"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","sourcesContent":["import { Color, MathUtils } from 'three'\n\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true\n\n    this.lut = []\n    this.map = []\n    this.n = 0\n    this.minV = 0\n    this.maxV = 1\n\n    this.setColorMap(colormap, count)\n  }\n\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value)\n    }\n\n    return this\n  }\n\n  setMin(min) {\n    this.minV = min\n\n    return this\n  }\n\n  setMax(max) {\n    this.maxV = max\n\n    return this\n  }\n\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow\n    this.n = count\n\n    const step = 1.0 / this.n\n    const minColor = new Color()\n    const maxColor = new Color()\n\n    this.lut.length = 0\n\n    // sample at 0\n\n    this.lut.push(new Color(this.map[0][1]))\n\n    // sample at 1/n, ..., (n-1)/n\n\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step\n\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0]\n          const max = this.map[j + 1][0]\n\n          minColor.setHex(this.map[j][1], 'srgb-linear')\n          maxColor.setHex(this.map[j + 1][1], 'srgb-linear')\n\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min))\n\n          this.lut.push(color)\n        }\n      }\n    }\n\n    // sample at 1\n\n    this.lut.push(new Color(this.map[this.map.length - 1][1]))\n\n    return this\n  }\n\n  copy(lut) {\n    this.lut = lut.lut\n    this.map = lut.map\n    this.n = lut.n\n    this.minV = lut.minV\n    this.maxV = lut.maxV\n\n    return this\n  }\n\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV)\n\n    alpha = (alpha - this.minV) / (this.maxV - this.minV)\n\n    const colorPosition = Math.round(alpha * this.n)\n\n    return this.lut[colorPosition]\n  }\n\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors\n\n    return this\n  }\n\n  createCanvas() {\n    const canvas = document.createElement('canvas')\n    canvas.width = 1\n    canvas.height = this.n\n\n    this.updateCanvas(canvas)\n\n    return canvas\n  }\n\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext('2d', { alpha: false })\n\n    const imageData = ctx.getImageData(0, 0, 1, this.n)\n\n    const data = imageData.data\n\n    let k = 0\n\n    const step = 1.0 / this.n\n\n    const minColor = new Color()\n    const maxColor = new Color()\n    const finalColor = new Color()\n\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0]\n          const max = this.map[j][0]\n\n          minColor.setHex(this.map[j - 1][1], 'srgb-linear')\n          maxColor.setHex(this.map[j][1], 'srgb-linear')\n\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min))\n\n          data[k * 4] = Math.round(finalColor.r * 255)\n          data[k * 4 + 1] = Math.round(finalColor.g * 255)\n          data[k * 4 + 2] = Math.round(finalColor.b * 255)\n          data[k * 4 + 3] = 255\n\n          k += 1\n        }\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0)\n\n    return canvas\n  }\n}\n\nconst ColorMapKeywords = {\n  rainbow: [\n    [0.0, 0x0000ff],\n    [0.2, 0x00ffff],\n    [0.5, 0x00ff00],\n    [0.8, 0xffff00],\n    [1.0, 0xff0000],\n  ],\n  cooltowarm: [\n    [0.0, 0x3c4ec2],\n    [0.2, 0x9bbcff],\n    [0.5, 0xdcdcdc],\n    [0.8, 0xf6a385],\n    [1.0, 0xb40426],\n  ],\n  blackbody: [\n    [0.0, 0x000000],\n    [0.2, 0x780000],\n    [0.5, 0xe63200],\n    [0.8, 0xffff00],\n    [1.0, 0xffffff],\n  ],\n  grayscale: [\n    [0.0, 0x000000],\n    [0.2, 0x404040],\n    [0.5, 0x7f7f80],\n    [0.8, 0xbfbfbf],\n    [1.0, 0xffffff],\n  ],\n}\n\nexport { Lut, ColorMapKeywords }\n"]},"metadata":{},"sourceType":"module"}