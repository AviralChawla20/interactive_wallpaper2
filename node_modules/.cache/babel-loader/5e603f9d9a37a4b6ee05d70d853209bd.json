{"ast":null,"code":"import { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = function () {};\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params);\n    } else if (object.isCamera) {\n      this._setupCamera(object, params);\n    } else if (object.type === \"Audio\") {\n      this._setupAudio(object, params);\n    } else {\n      throw new Error(\"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n    }\n    if (this.configuration.sync) this._syncDuration();\n    return this;\n  }\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object);\n    } else if (object.isCamera) {\n      this._clearCamera(object);\n    } else if (object.type === \"Audio\") {\n      this._clearAudio(object);\n    } else {\n      throw new Error(\"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n    }\n    if (this.configuration.sync) this._syncDuration();\n    return this;\n  }\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null) this.audioManager.control(delta);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta);\n    }\n    if (this.sharedPhysics) this._updateSharedPhysics(delta);\n    if (this.camera !== null) this._animateCamera(this.camera, delta);\n    return this;\n  }\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false) mesh.pose();\n    const bones = mesh.skeleton.bones;\n    const boneParams = vpd.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i;\n    }\n    const vector = new Vector3();\n    const quaternion = new Quaternion();\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i];\n      const boneIndex = boneNameDictionary[boneParam.name];\n      if (boneIndex === void 0) continue;\n      const bone = bones[boneIndex];\n      bone.position.add(vector.fromArray(boneParam.translation));\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n    }\n    mesh.updateMatrixWorld(true);\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update();\n      }\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n    }\n    return this;\n  }\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n    }\n    this.enabled[key] = enabled;\n    if (key === \"physics\") {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled);\n      }\n    }\n    return this;\n  }\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n  }\n  // private methods\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n    }\n    this.meshes.push(mesh);\n    this.objects.set(mesh, {\n      looped: false\n    });\n    this._setupMeshAnimation(mesh, params.animation);\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params);\n    }\n    return this;\n  }\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n    }\n    if (this.camera) this.clearCamera(this.camera);\n    this.camera = camera;\n    camera.add(this.cameraTarget);\n    this.objects.set(camera, {});\n    if (params.animation !== void 0) {\n      this._setupCameraAnimation(camera, params.animation);\n    }\n    return this;\n  }\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n    }\n    if (this.audio) this.clearAudio(this.audio);\n    this.audio = audio;\n    this.audioManager = new AudioManager(audio, params);\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration\n    });\n    return this;\n  }\n  _removeMesh(mesh) {\n    let found = false;\n    let writeIndex = 0;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh);\n        found = true;\n        continue;\n      }\n      this.meshes[writeIndex++] = this.meshes[i];\n    }\n    if (!found) {\n      throw new Error(\"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\");\n    }\n    this.meshes.length = writeIndex;\n    return this;\n  }\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n    }\n    this.camera.remove(this.cameraTarget);\n    this.objects.delete(this.camera);\n    this.camera = null;\n    return this;\n  }\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n    }\n    this.objects.delete(this.audioManager);\n    this.audio = null;\n    this.audioManager = null;\n    return this;\n  }\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh);\n    if (animation !== void 0) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      objects.mixer = new AnimationMixer(mesh);\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n      objects.mixer.addEventListener(\"loop\", function (event) {\n        const tracks = event.action._clip.tracks;\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\") return;\n        objects.looped = true;\n      });\n    }\n    objects.ikSolver = this._createCCDIKSolver(mesh);\n    objects.grantSolver = this.createGrantSolver(mesh);\n    return this;\n  }\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation];\n    const objects = this.objects.get(camera);\n    objects.mixer = new AnimationMixer(camera);\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play();\n    }\n  }\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh);\n    if (params.world === void 0 && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics();\n      if (masterPhysics !== null) world = masterPhysics.world;\n    }\n    objects.physics = this._createMMDPhysics(mesh, params);\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0);\n      objects.physics.reset();\n    }\n    objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n    this._optimizeIK(mesh, true);\n  }\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh);\n    const mixer = objects.mixer;\n    const ikSolver = objects.ikSolver;\n    const grantSolver = objects.grantSolver;\n    const physics = objects.physics;\n    const looped = objects.looped;\n    if (mixer && this.enabled.animation) {\n      this._restoreBones(mesh);\n      mixer.update(delta);\n      this._saveBones(mesh);\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n        this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n    }\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n      objects.looped = false;\n    }\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh);\n      physics.update(delta);\n    }\n  }\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function (a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass;\n      } else {\n        return a.index - b.index;\n      }\n    });\n  }\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0;\n    _grantResultMap.clear();\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n    }\n    mesh.updateMatrixWorld(true);\n    return this;\n  }\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer;\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta);\n      camera.updateProjectionMatrix();\n      camera.up.set(0, 1, 0);\n      camera.up.applyQuaternion(camera.quaternion);\n      camera.lookAt(this.cameraTarget.position);\n    }\n  }\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks;\n    const bones = mesh.geometry.userData.MMD.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const links = ik.links;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j];\n        if (physicsEnabled === true) {\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n        } else {\n          link.enabled = true;\n        }\n      }\n    }\n  }\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n    }\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n  }\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === void 0) {\n      throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n    }\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n  }\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0;\n    const objects = this.objects;\n    const meshes = this.meshes;\n    const camera = this.camera;\n    const audioManager = this.audioManager;\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer;\n      if (mixer === void 0) continue;\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip;\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration\n          });\n        }\n        max = Math.max(max, objects.get(clip).duration);\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n    }\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration);\n    }\n    max += this.configuration.afterglow;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer;\n      if (mixer === void 0) continue;\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max;\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max;\n        }\n      }\n    }\n    if (audioManager !== null) {\n      audioManager.duration = max;\n    }\n  }\n  // workaround\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer;\n    const propertyMixers = mixer._bindings;\n    const accuIndex = mixer._accuIndex;\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i];\n      const buffer = propertyMixer.buffer;\n      const stride = propertyMixer.valueSize;\n      const offset = (accuIndex + 1) * stride;\n      propertyMixer.binding.getValue(buffer, offset);\n    }\n  }\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const bones = mesh.skeleton.bones;\n    let backupBones = objects.backupBones;\n    if (backupBones === void 0) {\n      backupBones = new Float32Array(bones.length * 7);\n      objects.backupBones = backupBones;\n    }\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.toArray(backupBones, i * 7);\n      bone.quaternion.toArray(backupBones, i * 7 + 3);\n    }\n  }\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const backupBones = objects.backupBones;\n    if (backupBones === void 0) return;\n    const bones = mesh.skeleton.bones;\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.fromArray(backupBones, i * 7);\n      bone.quaternion.fromArray(backupBones, i * 7 + 3);\n    }\n  }\n  // experimental\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null) return this.masterPhysics;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics;\n      if (physics !== void 0 && physics !== null) {\n        this.masterPhysics = physics;\n        return this.masterPhysics;\n      }\n    }\n    return null;\n  }\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n    const physics = this._getMasterPhysics();\n    if (physics === null) return;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateRigidBodies();\n      }\n    }\n    physics.stepSimulation(delta);\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateBones();\n      }\n    }\n  }\n}\nconst _quaternions = [];\nlet _quaternionIndex = 0;\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n  return _quaternions[_quaternionIndex++];\n}\nconst _grantResultMap = /* @__PURE__ */new Map();\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones;\n  const bonesData = mesh.geometry.userData.MMD.bones;\n  const boneData = bonesData[boneIndex];\n  const bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex)) return;\n  const quaternion = getQuaternion();\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex;\n    const ratio = boneData.grant.ratio;\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    const links = boneData.ik.links;\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i];\n      if (link.enabled === false) continue;\n      const linkIndex = link.index;\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n  quaternion.copy(bone.quaternion);\n}\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta;\n    this.currentTime += delta;\n    if (this._shouldStopAudio()) this.audio.stop();\n    if (this._shouldStartAudio()) this.audio.play();\n    return this;\n  }\n  // private methods\n  _shouldStartAudio() {\n    if (this.audio.isPlaying) return false;\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration;\n    }\n    if (this.currentTime < this.delayTime) return false;\n    if (this.currentTime - this.delayTime > this.audioDuration) return false;\n    return true;\n  }\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration;\n  }\n}\nconst _q = new Quaternion();\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants;\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i]);\n    }\n    return this;\n  }\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones;\n    const bone = bones[grant.index];\n    const parentBone = bones[grant.parentIndex];\n    if (grant.isLocal) {\n      if (grant.affectPosition) ;\n      if (grant.affectRotation) ;\n    } else {\n      if (grant.affectPosition) ;\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n      }\n    }\n    return this;\n  }\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1);\n    _q.slerp(q, ratio);\n    bone.quaternion.multiply(_q);\n    return this;\n  }\n}\nexport { MMDAnimationHelper };","map":{"version":3,"sources":["../../src/animation/MMDAnimationHelper.js"],"names":[],"mappings":";;;AAgBA,MAAM,kBAAA,CAAmB;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAOvB,WAAA,CAAY,MAAA,GAAS,CAAA,CAAA,EAAI;IACvB,IAAA,CAAK,MAAA,GAAS,EAAE;IAEhB,IAAA,CAAK,MAAA,GAAS,IAAA;IACd,IAAA,CAAK,YAAA,GAAe,IAAI,QAAA,CAAU,CAAA;IAClC,IAAA,CAAK,YAAA,CAAa,IAAA,GAAO,QAAA;IAEzB,IAAA,CAAK,KAAA,GAAQ,IAAA;IACb,IAAA,CAAK,YAAA,GAAe,IAAA;IAEpB,IAAA,CAAK,OAAA,GAAU,eAAA,IAAI,OAAA,CAAS,CAAA;IAE5B,IAAA,CAAK,aAAA,GAAgB;MACnB,IAAA,EAAM,MAAA,CAAO,IAAA,KAAS,KAAA,CAAA,GAAY,MAAA,CAAO,IAAA,GAAO,IAAA;MAChD,SAAA,EAAW,MAAA,CAAO,SAAA,KAAc,KAAA,CAAA,GAAY,MAAA,CAAO,SAAA,GAAY,CAAA;MAC/D,kBAAA,EAAoB,MAAA,CAAO,kBAAA,KAAuB,KAAA,CAAA,GAAY,MAAA,CAAO,kBAAA,GAAqB,IAAA;MAC1F,YAAA,EAAc,MAAA,CAAO,YAAA,KAAiB,KAAA,CAAA,GAAY,MAAA,CAAO,YAAA,GAAe;IACzE,CAAA;IAED,IAAA,CAAK,OAAA,GAAU;MACb,SAAA,EAAW,IAAA;MACX,EAAA,EAAI,IAAA;MACJ,KAAA,EAAO,IAAA;MACP,OAAA,EAAS,IAAA;MACT,eAAA,EAAiB;IAClB,CAAA;IAED,IAAA,CAAK,eAAA,GAAkB,YAAsB,CAAE,CAAA;IAG/C,IAAA,CAAK,aAAA,GAAgB,KAAA;IACrB,IAAA,CAAK,aAAA,GAAgB,IAAA;EACtB;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAkBD,GAAA,CAAI,MAAA,EAAQ,MAAA,GAAS,CAAA,CAAA,EAAI;IACvB,IAAI,MAAA,CAAO,aAAA,EAAe;MACxB,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,MAAM,CAAA;IAClC,CAAA,MAAA,IAAe,MAAA,CAAO,QAAA,EAAU;MAC1B,IAAA,CAAK,YAAA,CAAa,MAAA,EAAQ,MAAM,CAAA;IACtC,CAAA,MAAA,IAAe,MAAA,CAAO,IAAA,KAAS,OAAA,EAAS;MAClC,IAAA,CAAK,WAAA,CAAY,MAAA,EAAQ,MAAM,CAAA;IACrC,CAAA,MAAW;MACL,MAAM,IAAI,KAAA,CACR,uGAKD,CAAA;IACF;IAED,IAAI,IAAA,CAAK,aAAA,CAAc,IAAA,EAAM,IAAA,CAAK,aAAA,CAAe,CAAA;IAEjD,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQD,MAAA,CAAO,MAAA,EAAQ;IACb,IAAI,MAAA,CAAO,aAAA,EAAe;MACxB,IAAA,CAAK,WAAA,CAAY,MAAM,CAAA;IAC7B,CAAA,MAAA,IAAe,MAAA,CAAO,QAAA,EAAU;MAC1B,IAAA,CAAK,YAAA,CAAa,MAAM,CAAA;IAC9B,CAAA,MAAA,IAAe,MAAA,CAAO,IAAA,KAAS,OAAA,EAAS;MAClC,IAAA,CAAK,WAAA,CAAY,MAAM,CAAA;IAC7B,CAAA,MAAW;MACL,MAAM,IAAI,KAAA,CACR,0GAKD,CAAA;IACF;IAED,IAAI,IAAA,CAAK,aAAA,CAAc,IAAA,EAAM,IAAA,CAAK,aAAA,CAAe,CAAA;IAEjD,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQD,MAAA,CAAO,KAAA,EAAO;IACZ,IAAI,IAAA,CAAK,YAAA,KAAiB,IAAA,EAAM,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAA;IAE/D,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC3C,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,EAAG,KAAK,CAAA;IACxC;IAED,IAAI,IAAA,CAAK,aAAA,EAAe,IAAA,CAAK,oBAAA,CAAqB,KAAK,CAAA;IAEvD,IAAI,IAAA,CAAK,MAAA,KAAW,IAAA,EAAM,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;IAEhE,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAaD,IAAA,CAAK,IAAA,EAAM,GAAA,EAAK,MAAA,GAAS,CAAA,CAAA,EAAI;IAC3B,IAAI,MAAA,CAAO,SAAA,KAAc,KAAA,EAAO,IAAA,CAAK,IAAA,CAAM,CAAA;IAE3C,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;IAC5B,MAAM,UAAA,GAAa,GAAA,CAAI,KAAA;IAEvB,MAAM,kBAAA,GAAqB,CAAE,CAAA;IAE7B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,kBAAA,CAAmB,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,GAAI,CAAA;IACrC;IAED,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;IAC5B,MAAM,UAAA,GAAa,IAAI,UAAA,CAAY,CAAA;IAEnC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,UAAA,CAAW,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,MAAM,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA;MAC9B,MAAM,SAAA,GAAY,kBAAA,CAAmB,SAAA,CAAU,IAAI,CAAA;MAEnD,IAAI,SAAA,KAAc,KAAA,CAAA,EAAW;MAE7B,MAAM,IAAA,GAAO,KAAA,CAAM,SAAS,CAAA;MAC5B,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,MAAA,CAAO,SAAA,CAAU,SAAA,CAAU,WAAW,CAAC,CAAA;MACzD,IAAA,CAAK,UAAA,CAAW,QAAA,CAAS,UAAA,CAAW,SAAA,CAAU,SAAA,CAAU,UAAU,CAAC,CAAA;IACpE;IAED,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;IAG3B,IAAI,IAAA,CAAK,aAAA,CAAc,YAAA,IAAgB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,IAAO,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,MAAA,KAAW,KAAA,EAAO;MAChH,MAAM,eAAA,GAAkB,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,KAAA,CAAA,CAAO,CAAA;MACxF,MAAM,QAAA,GAAW,MAAA,CAAO,EAAA,KAAO,KAAA,GAAQ,IAAA,CAAK,kBAAA,CAAmB,IAAI,CAAA,GAAI,IAAA;MACvE,MAAM,WAAA,GAAc,MAAA,CAAO,KAAA,KAAU,KAAA,GAAQ,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA,GAAI,IAAA;MAC5E,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,eAAA,EAAiB,QAAA,EAAU,WAAW,CAAA;IACvE,CAAA,MAAW;MACL,IAAI,MAAA,CAAO,EAAA,KAAO,KAAA,EAAO;QACvB,IAAA,CAAK,kBAAA,CAAmB,IAAI,CAAA,CAAE,MAAA,CAAQ,CAAA;MACvC;MAED,IAAI,MAAA,CAAO,KAAA,KAAU,KAAA,EAAO;QAC1B,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA,CAAE,MAAA,CAAQ,CAAA;MACtC;IACF;IAED,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASD,MAAA,CAAO,GAAA,EAAK,OAAA,EAAS;IACnB,IAAI,IAAA,CAAK,OAAA,CAAQ,GAAG,CAAA,KAAM,KAAA,CAAA,EAAW;MACnC,MAAM,IAAI,KAAA,CAAM,+CAAA,GAAuD,GAAG,CAAA;IAC3E;IAED,IAAA,CAAK,OAAA,CAAQ,GAAG,CAAA,GAAI,OAAA;IAEpB,IAAI,GAAA,KAAQ,SAAA,EAAW;MACrB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACpD,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,EAAG,OAAO,CAAA;MACzC;IACF;IAED,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQD,iBAAA,CAAkB,IAAA,EAAM;IACtB,OAAO,IAAI,WAAA,CAAY,IAAA,EAAM,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,MAAM,CAAA;EAC/D;EAAA;EAID,QAAA,CAAS,IAAA,EAAM,MAAA,EAAQ;IACrB,IAAI,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,IAAI,CAAA,IAAK,CAAA,EAAG;MAClC,MAAM,IAAI,KAAA,CAAM,kDAAA,GAA0D,IAAA,CAAK,IAAA,GAAO,2BAA2B,CAAA;IAClH;IAED,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA;IACrB,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAA,EAAM;MAAE,MAAA,EAAQ;IAAA,CAAO,CAAA;IAExC,IAAA,CAAK,mBAAA,CAAoB,IAAA,EAAM,MAAA,CAAO,SAAS,CAAA;IAE/C,IAAI,MAAA,CAAO,OAAA,KAAY,KAAA,EAAO;MAC5B,IAAA,CAAK,iBAAA,CAAkB,IAAA,EAAM,MAAM,CAAA;IACpC;IAED,OAAO,IAAA;EACR;EAED,YAAA,CAAa,MAAA,EAAQ,MAAA,EAAQ;IAC3B,IAAI,IAAA,CAAK,MAAA,KAAW,MAAA,EAAQ;MAC1B,MAAM,IAAI,KAAA,CAAM,iDAAA,GAAyD,MAAA,CAAO,IAAA,GAAO,yBAAyB,CAAA;IACjH;IAED,IAAI,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAM,CAAA;IAE7C,IAAA,CAAK,MAAA,GAAS,MAAA;IAEd,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,YAAY,CAAA;IAE5B,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAA,EAAQ,CAAA,CAAE,CAAA;IAE3B,IAAI,MAAA,CAAO,SAAA,KAAc,KAAA,CAAA,EAAW;MAClC,IAAA,CAAK,qBAAA,CAAsB,MAAA,EAAQ,MAAA,CAAO,SAAS,CAAA;IACpD;IAED,OAAO,IAAA;EACR;EAED,WAAA,CAAY,KAAA,EAAO,MAAA,EAAQ;IACzB,IAAI,IAAA,CAAK,KAAA,KAAU,KAAA,EAAO;MACxB,MAAM,IAAI,KAAA,CAAM,+CAAA,GAAuD,KAAA,CAAM,IAAA,GAAO,yBAAyB,CAAA;IAC9G;IAED,IAAI,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,KAAK,CAAA;IAE1C,IAAA,CAAK,KAAA,GAAQ,KAAA;IACb,IAAA,CAAK,YAAA,GAAe,IAAI,YAAA,CAAa,KAAA,EAAO,MAAM,CAAA;IAElD,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,YAAA,EAAc;MAClC,QAAA,EAAU,IAAA,CAAK,YAAA,CAAa;IAClC,CAAK,CAAA;IAED,OAAO,IAAA;EACR;EAED,WAAA,CAAY,IAAA,EAAM;IAChB,IAAI,KAAA,GAAQ,KAAA;IACZ,IAAI,UAAA,GAAa,CAAA;IAEjB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,IAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,KAAM,IAAA,EAAM;QAC3B,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,IAAI,CAAA;QACxB,KAAA,GAAQ,IAAA;QAER;MACD;MAED,IAAA,CAAK,MAAA,CAAO,UAAA,EAAY,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA;IAC1C;IAED,IAAI,CAAC,KAAA,EAAO;MACV,MAAM,IAAI,KAAA,CACR,qDAAA,GAA6D,IAAA,CAAK,IAAA,GAAO,2BAC1E,CAAA;IACF;IAED,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,UAAA;IAErB,OAAO,IAAA;EACR;EAED,YAAA,CAAa,MAAA,EAAQ;IACnB,IAAI,MAAA,KAAW,IAAA,CAAK,MAAA,EAAQ;MAC1B,MAAM,IAAI,KAAA,CAAM,iDAAA,GAAyD,MAAA,CAAO,IAAA,GAAO,yBAAyB,CAAA;IACjH;IAED,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,YAAY,CAAA;IAEpC,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA;IAC/B,IAAA,CAAK,MAAA,GAAS,IAAA;IAEd,OAAO,IAAA;EACR;EAED,WAAA,CAAY,KAAA,EAAO;IACjB,IAAI,KAAA,KAAU,IAAA,CAAK,KAAA,EAAO;MACxB,MAAM,IAAI,KAAA,CAAM,+CAAA,GAAuD,KAAA,CAAM,IAAA,GAAO,yBAAyB,CAAA;IAC9G;IAED,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,IAAA,CAAK,YAAY,CAAA;IAErC,IAAA,CAAK,KAAA,GAAQ,IAAA;IACb,IAAA,CAAK,YAAA,GAAe,IAAA;IAEpB,OAAO,IAAA;EACR;EAED,mBAAA,CAAoB,IAAA,EAAM,SAAA,EAAW;IACnC,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA;IAErC,IAAI,SAAA,KAAc,KAAA,CAAA,EAAW;MAC3B,MAAM,UAAA,GAAa,KAAA,CAAM,OAAA,CAAQ,SAAS,CAAA,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA;MAEpE,OAAA,CAAQ,KAAA,GAAQ,IAAI,cAAA,CAAe,IAAI,CAAA;MAEvC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,UAAA,CAAW,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACnD,OAAA,CAAQ,KAAA,CAAM,UAAA,CAAW,UAAA,CAAW,CAAC,CAAC,CAAA,CAAE,IAAA,CAAM,CAAA;MAC/C;MAGD,OAAA,CAAQ,KAAA,CAAM,gBAAA,CAAiB,MAAA,EAAQ,UAAU,KAAA,EAAO;QACtD,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,MAAA;QAElC,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,IAAK,MAAA,CAAO,CAAC,CAAA,CAAE,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,KAAM,QAAA,EAAU;QAElE,OAAA,CAAQ,MAAA,GAAS,IAAA;MACzB,CAAO,CAAA;IACF;IAED,OAAA,CAAQ,QAAA,GAAW,IAAA,CAAK,kBAAA,CAAmB,IAAI,CAAA;IAC/C,OAAA,CAAQ,WAAA,GAAc,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;IAEjD,OAAO,IAAA;EACR;EAED,qBAAA,CAAsB,MAAA,EAAQ,SAAA,EAAW;IACvC,MAAM,UAAA,GAAa,KAAA,CAAM,OAAA,CAAQ,SAAS,CAAA,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA;IAEpE,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA;IAEvC,OAAA,CAAQ,KAAA,GAAQ,IAAI,cAAA,CAAe,MAAM,CAAA;IAEzC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,UAAA,CAAW,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACnD,OAAA,CAAQ,KAAA,CAAM,UAAA,CAAW,UAAA,CAAW,CAAC,CAAC,CAAA,CAAE,IAAA,CAAM,CAAA;IAC/C;EACF;EAED,iBAAA,CAAkB,IAAA,EAAM,MAAA,EAAQ;IAC9B,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA;IAIrC,IAAI,MAAA,CAAO,KAAA,KAAU,KAAA,CAAA,IAAa,IAAA,CAAK,aAAA,EAAe;MACpD,MAAM,aAAA,GAAgB,IAAA,CAAK,iBAAA,CAAmB,CAAA;MAE9C,IAAI,aAAA,KAAkB,IAAA,EAAM,KAAA,GAAQ,aAAA,CAAc,KAAA;IACnD;IAED,OAAA,CAAQ,OAAA,GAAU,IAAA,CAAK,iBAAA,CAAkB,IAAA,EAAM,MAAM,CAAA;IAErD,IAAI,OAAA,CAAQ,KAAA,IAAS,MAAA,CAAO,eAAA,KAAoB,KAAA,EAAO;MACrD,IAAA,CAAK,YAAA,CAAa,IAAA,EAAM,CAAC,CAAA;MACzB,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAO,CAAA;IACxB;IAED,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAO,MAAA,CAAO,MAAA,KAAW,KAAA,CAAA,GAAY,MAAA,CAAO,MAAA,GAAS,EAAE,CAAA;IAEvE,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,IAAI,CAAA;EAC5B;EAED,YAAA,CAAa,IAAA,EAAM,KAAA,EAAO;IACxB,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA;IAErC,MAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA;IACtB,MAAM,QAAA,GAAW,OAAA,CAAQ,QAAA;IACzB,MAAM,WAAA,GAAc,OAAA,CAAQ,WAAA;IAC5B,MAAM,OAAA,GAAU,OAAA,CAAQ,OAAA;IACxB,MAAM,MAAA,GAAS,OAAA,CAAQ,MAAA;IAEvB,IAAI,KAAA,IAAS,IAAA,CAAK,OAAA,CAAQ,SAAA,EAAW;MAKnC,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;MAEvB,KAAA,CAAM,MAAA,CAAO,KAAK,CAAA;MAElB,IAAA,CAAK,UAAA,CAAW,IAAI,CAAA;MAGpB,IACE,IAAA,CAAK,aAAA,CAAc,YAAA,IACnB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,IACvB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,MAAA,KAAW,KAAA,EACtC;QACA,IAAI,CAAC,OAAA,CAAQ,eAAA,EACX,OAAA,CAAQ,eAAA,GAAkB,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,KAAA,CAAA,CAAO,CAAA;QAE5F,IAAA,CAAK,eAAA,CACH,IAAA,EACA,OAAA,CAAQ,eAAA,EACR,QAAA,IAAY,IAAA,CAAK,OAAA,CAAQ,EAAA,GAAK,QAAA,GAAW,IAAA,EACzC,WAAA,IAAe,IAAA,CAAK,OAAA,CAAQ,KAAA,GAAQ,WAAA,GAAc,IACnD,CAAA;MACT,CAAA,MAAa;QACL,IAAI,QAAA,IAAY,IAAA,CAAK,OAAA,CAAQ,EAAA,EAAI;UAC/B,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;UAC3B,QAAA,CAAS,MAAA,CAAQ,CAAA;QAClB;QAED,IAAI,WAAA,IAAe,IAAA,CAAK,OAAA,CAAQ,KAAA,EAAO;UACrC,WAAA,CAAY,MAAA,CAAQ,CAAA;QACrB;MACF;IACF;IAED,IAAI,MAAA,KAAW,IAAA,IAAQ,IAAA,CAAK,OAAA,CAAQ,OAAA,EAAS;MAC3C,IAAI,OAAA,IAAW,IAAA,CAAK,aAAA,CAAc,kBAAA,EAAoB,OAAA,CAAQ,KAAA,CAAO,CAAA;MAErE,OAAA,CAAQ,MAAA,GAAS,KAAA;IAClB;IAED,IAAI,OAAA,IAAW,IAAA,CAAK,OAAA,CAAQ,OAAA,IAAW,CAAC,IAAA,CAAK,aAAA,EAAe;MAC1D,IAAA,CAAK,eAAA,CAAgB,IAAI,CAAA;MACzB,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA;IACrB;EACF;EAAA;EAAA;EAAA;EAKD,kBAAA,CAAmB,aAAA,EAAe;IAChC,OAAO,aAAA,CAAc,IAAA,CAAK,UAAU,CAAA,EAAG,CAAA,EAAG;MACxC,IAAI,CAAA,CAAE,mBAAA,KAAwB,CAAA,CAAE,mBAAA,EAAqB;QACnD,OAAO,CAAA,CAAE,mBAAA,GAAsB,CAAA,CAAE,mBAAA;MACzC,CAAA,MAAa;QACL,OAAO,CAAA,CAAE,KAAA,GAAQ,CAAA,CAAE,KAAA;MACpB;IACP,CAAK,CAAA;EACF;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EASD,eAAA,CAAgB,IAAA,EAAM,eAAA,EAAiB,QAAA,EAAU,WAAA,EAAa;IAC5D,gBAAA,GAAmB,CAAA;IACnB,eAAA,CAAgB,KAAA,CAAO,CAAA;IAEvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,eAAA,CAAgB,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACxD,SAAA,CAAU,IAAA,EAAM,eAAA,CAAgB,CAAC,CAAA,CAAE,KAAA,EAAO,QAAA,EAAU,WAAW,CAAA;IAChE;IAED,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;IAC3B,OAAO,IAAA;EACR;EAED,cAAA,CAAe,MAAA,EAAQ,KAAA,EAAO;IAC5B,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA,CAAE,KAAA;IAEvC,IAAI,KAAA,IAAS,IAAA,CAAK,OAAA,CAAQ,eAAA,EAAiB;MACzC,KAAA,CAAM,MAAA,CAAO,KAAK,CAAA;MAElB,MAAA,CAAO,sBAAA,CAAwB,CAAA;MAE/B,MAAA,CAAO,EAAA,CAAG,GAAA,CAAI,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;MACrB,MAAA,CAAO,EAAA,CAAG,eAAA,CAAgB,MAAA,CAAO,UAAU,CAAA;MAC3C,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA;IACzC;EACF;EAED,WAAA,CAAY,IAAA,EAAM,cAAA,EAAgB;IAChC,MAAM,GAAA,GAAM,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,GAAA;IACvC,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,KAAA;IAEzC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,GAAA,CAAI,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC5C,MAAM,EAAA,GAAK,GAAA,CAAI,CAAC,CAAA;MAChB,MAAM,KAAA,GAAQ,EAAA,CAAG,KAAA;MAEjB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;QAEpB,IAAI,cAAA,KAAmB,IAAA,EAAM;UAG3B,IAAA,CAAK,OAAA,GAAU,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA,CAAE,aAAA,GAAgB,CAAA,GAAI,KAAA,GAAQ,IAAA;QACvE,CAAA,MAAe;UACL,IAAA,CAAK,OAAA,GAAU,IAAA;QAChB;MACF;IACF;EACF;EAED,kBAAA,CAAmB,IAAA,EAAM;IACvB,IAAI,WAAA,KAAgB,KAAA,CAAA,EAAW;MAC7B,MAAM,IAAI,KAAA,CAAM,+CAA+C,CAAA;IAChE;IAED,OAAO,IAAI,WAAA,CAAY,IAAA,EAAM,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,GAAG,CAAA;EAC5D;EAED,iBAAA,CAAkB,IAAA,EAAM,MAAA,EAAQ;IAC9B,IAAI,UAAA,KAAe,KAAA,CAAA,EAAW;MAC5B,MAAM,IAAI,KAAA,CAAM,sCAAsC,CAAA;IACvD;IAED,OAAO,IAAI,UAAA,CAAW,IAAA,EAAM,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,WAAA,EAAa,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,WAAA,EAAa,MAAM,CAAA;EACnH;EAAA;AAAA;AAAA;AAAA;EAMD,aAAA,CAAA,EAAgB;IACd,IAAI,GAAA,GAAM,CAAA;IAEV,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA;IACrB,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;IACpB,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;IACpB,MAAM,YAAA,GAAe,IAAA,CAAK,YAAA;IAI1B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/C,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,KAAA;MAE1C,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAA,CAAS,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA;QAE/B,IAAI,CAAC,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,EAAG;UACtB,OAAA,CAAQ,GAAA,CAAI,IAAA,EAAM;YAChB,QAAA,EAAU,IAAA,CAAK;UAC3B,CAAW,CAAA;QACF;QAED,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,CAAE,QAAQ,CAAA;MAC/C;IACF;IAED,IAAI,MAAA,KAAW,IAAA,EAAM;MACnB,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA,CAAE,KAAA;MAEvC,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;QACvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACvD,MAAM,IAAA,GAAO,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA;UAE/B,IAAI,CAAC,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,EAAG;YACtB,OAAA,CAAQ,GAAA,CAAI,IAAA,EAAM;cAChB,QAAA,EAAU,IAAA,CAAK;YAC7B,CAAa,CAAA;UACF;UAED,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,CAAE,QAAQ,CAAA;QAC/C;MACF;IACF;IAED,IAAI,YAAA,KAAiB,IAAA,EAAM;MACzB,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,OAAA,CAAQ,GAAA,CAAI,YAAY,CAAA,CAAE,QAAQ,CAAA;IACvD;IAED,GAAA,IAAO,IAAA,CAAK,aAAA,CAAc,SAAA;IAI1B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,KAAA;MAE/C,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;MAEzB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;QACvD,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA,CAAM,QAAA,GAAW,GAAA;MACpC;IACF;IAED,IAAI,MAAA,KAAW,IAAA,EAAM;MACnB,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,MAAM,CAAA,CAAE,KAAA;MAEvC,IAAI,KAAA,KAAU,KAAA,CAAA,EAAW;QACvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,QAAA,CAAS,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;UACvD,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,KAAA,CAAM,QAAA,GAAW,GAAA;QACpC;MACF;IACF;IAED,IAAI,YAAA,KAAiB,IAAA,EAAM;MACzB,YAAA,CAAa,QAAA,GAAW,GAAA;IACzB;EACF;EAAA;EAID,2BAAA,CAA4B,IAAA,EAAM;IAChC,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA,CAAE,KAAA;IAErC,MAAM,cAAA,GAAiB,KAAA,CAAM,SAAA;IAC7B,MAAM,SAAA,GAAY,KAAA,CAAM,UAAA;IAExB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,cAAA,CAAe,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACvD,MAAM,aAAA,GAAgB,cAAA,CAAe,CAAC,CAAA;MACtC,MAAM,MAAA,GAAS,aAAA,CAAc,MAAA;MAC7B,MAAM,MAAA,GAAS,aAAA,CAAc,SAAA;MAC7B,MAAM,MAAA,GAAA,CAAU,SAAA,GAAY,CAAA,IAAK,MAAA;MAEjC,aAAA,CAAc,OAAA,CAAQ,QAAA,CAAS,MAAA,EAAQ,MAAM,CAAA;IAC9C;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWD,UAAA,CAAW,IAAA,EAAM;IACf,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA;IAErC,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;IAE5B,IAAI,WAAA,GAAc,OAAA,CAAQ,WAAA;IAE1B,IAAI,WAAA,KAAgB,KAAA,CAAA,EAAW;MAC7B,WAAA,GAAc,IAAI,YAAA,CAAa,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA;MAC/C,OAAA,CAAQ,WAAA,GAAc,WAAA;IACvB;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;MACpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,WAAA,EAAa,CAAA,GAAI,CAAC,CAAA;MACxC,IAAA,CAAK,UAAA,CAAW,OAAA,CAAQ,WAAA,EAAa,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;IAC/C;EACF;EAED,aAAA,CAAc,IAAA,EAAM;IAClB,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,IAAI,CAAA;IAErC,MAAM,WAAA,GAAc,OAAA,CAAQ,WAAA;IAE5B,IAAI,WAAA,KAAgB,KAAA,CAAA,EAAW;IAE/B,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;MACpB,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,WAAA,EAAa,CAAA,GAAI,CAAC,CAAA;MAC1C,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,WAAA,EAAa,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;IACjD;EACF;EAAA;EAID,iBAAA,CAAA,EAAoB;IAClB,IAAI,IAAA,CAAK,aAAA,KAAkB,IAAA,EAAM,OAAO,IAAA,CAAK,aAAA;IAE7C,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,MAAM,OAAA,GAAU,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,OAAA;MAE/B,IAAI,OAAA,KAAY,KAAA,CAAA,IAAa,OAAA,KAAY,IAAA,EAAM;QAC7C,IAAA,CAAK,aAAA,GAAgB,OAAA;QACrB,OAAO,IAAA,CAAK,aAAA;MACb;IACF;IAED,OAAO,IAAA;EACR;EAED,oBAAA,CAAqB,KAAA,EAAO;IAC1B,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,KAAW,CAAA,IAAK,CAAC,IAAA,CAAK,OAAA,CAAQ,OAAA,IAAW,CAAC,IAAA,CAAK,aAAA,EAAe;IAE9E,MAAM,OAAA,GAAU,IAAA,CAAK,iBAAA,CAAmB,CAAA;IAExC,IAAI,OAAA,KAAY,IAAA,EAAM;IAEtB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,MAAM,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,OAAA;MAEzB,IAAI,CAAA,KAAM,IAAA,IAAQ,CAAA,KAAM,KAAA,CAAA,EAAW;QACjC,CAAA,CAAE,iBAAA,CAAmB,CAAA;MACtB;IACF;IAED,OAAA,CAAQ,cAAA,CAAe,KAAK,CAAA;IAE5B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACpD,MAAM,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,OAAA;MAEzB,IAAI,CAAA,KAAM,IAAA,IAAQ,CAAA,KAAM,KAAA,CAAA,EAAW;QACjC,CAAA,CAAE,WAAA,CAAa,CAAA;MAChB;IACF;EACF;AACH;AAGA,MAAM,YAAA,GAAe,EAAE;AACvB,IAAI,gBAAA,GAAmB,CAAA;AAEvB,SAAS,aAAA,CAAA,EAAgB;EACvB,IAAI,gBAAA,IAAoB,YAAA,CAAa,MAAA,EAAQ;IAC3C,YAAA,CAAa,IAAA,CAAK,IAAI,UAAA,CAAA,CAAY,CAAA;EACnC;EAED,OAAO,YAAA,CAAa,gBAAA,EAAkB,CAAA;AACxC;AAIA,MAAM,eAAA,GAAkB,eAAA,IAAI,GAAA,CAAK,CAAA;AAEjC,SAAS,SAAA,CAAU,IAAA,EAAM,SAAA,EAAW,QAAA,EAAU,WAAA,EAAa;EACzD,MAAM,KAAA,GAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;EAC5B,MAAM,SAAA,GAAY,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,GAAA,CAAI,KAAA;EAC7C,MAAM,QAAA,GAAW,SAAA,CAAU,SAAS,CAAA;EACpC,MAAM,IAAA,GAAO,KAAA,CAAM,SAAS,CAAA;EAG5B,IAAI,eAAA,CAAgB,GAAA,CAAI,SAAS,CAAA,EAAG;EAEpC,MAAM,UAAA,GAAa,aAAA,CAAe,CAAA;EAMlC,eAAA,CAAgB,GAAA,CAAI,SAAA,EAAW,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,UAAU,CAAC,CAAA;EAG/D,IAAI,WAAA,IAAe,QAAA,CAAS,KAAA,IAAS,CAAC,QAAA,CAAS,KAAA,CAAM,OAAA,IAAW,QAAA,CAAS,KAAA,CAAM,cAAA,EAAgB;IAC7F,MAAM,WAAA,GAAc,QAAA,CAAS,KAAA,CAAM,WAAA;IACnC,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,KAAA;IAE7B,IAAI,CAAC,eAAA,CAAgB,GAAA,CAAI,WAAW,CAAA,EAAG;MACrC,SAAA,CAAU,IAAA,EAAM,WAAA,EAAa,QAAA,EAAU,WAAW,CAAA;IACnD;IAED,WAAA,CAAY,gBAAA,CAAiB,IAAA,EAAM,eAAA,CAAgB,GAAA,CAAI,WAAW,CAAA,EAAG,KAAK,CAAA;EAC3E;EAED,IAAI,QAAA,IAAY,QAAA,CAAS,EAAA,EAAI;IAG3B,IAAA,CAAK,iBAAA,CAAkB,IAAI,CAAA;IAC3B,QAAA,CAAS,SAAA,CAAU,QAAA,CAAS,EAAE,CAAA;IAG9B,MAAM,KAAA,GAAQ,QAAA,CAAS,EAAA,CAAG,KAAA;IAE1B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,KAAA,CAAM,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC9C,MAAM,IAAA,GAAO,KAAA,CAAM,CAAC,CAAA;MAEpB,IAAI,IAAA,CAAK,OAAA,KAAY,KAAA,EAAO;MAE5B,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA;MAEvB,IAAI,eAAA,CAAgB,GAAA,CAAI,SAAS,CAAA,EAAG;QAClC,eAAA,CAAgB,GAAA,CAAI,SAAA,EAAW,eAAA,CAAgB,GAAA,CAAI,SAAS,CAAA,CAAE,IAAA,CAAK,KAAA,CAAM,SAAS,CAAA,CAAE,UAAU,CAAC,CAAA;MAChG;IACF;EACF;EAGD,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,UAAU,CAAA;AACjC;AAIA,MAAM,YAAA,CAAa;EAAA;AAAA;AAAA;AAAA;AAAA;EAMjB,WAAA,CAAY,KAAA,EAAO,MAAA,GAAS,CAAA,CAAA,EAAI;IAC9B,IAAA,CAAK,KAAA,GAAQ,KAAA;IAEb,IAAA,CAAK,WAAA,GAAc,CAAA;IACnB,IAAA,CAAK,WAAA,GAAc,CAAA;IACnB,IAAA,CAAK,SAAA,GAAY,MAAA,CAAO,SAAA,KAAc,KAAA,CAAA,GAAY,MAAA,CAAO,SAAA,GAAY,CAAA;IAErE,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,QAAA;IACvC,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,SAAA;EAC3C;EAAA;AAAA;AAAA;AAAA;EAMD,OAAA,CAAQ,KAAA,EAAO;IACb,IAAA,CAAK,OAAA,IAAW,KAAA;IAChB,IAAA,CAAK,WAAA,IAAe,KAAA;IAEpB,IAAI,IAAA,CAAK,gBAAA,CAAgB,CAAA,EAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAM,CAAA;IAC9C,IAAI,IAAA,CAAK,iBAAA,CAAiB,CAAA,EAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAM,CAAA;IAE/C,OAAO,IAAA;EACR;EAAA;EAID,iBAAA,CAAA,EAAoB;IAClB,IAAI,IAAA,CAAK,KAAA,CAAM,SAAA,EAAW,OAAO,KAAA;IAEjC,OAAO,IAAA,CAAK,WAAA,IAAe,IAAA,CAAK,QAAA,EAAU;MACxC,IAAA,CAAK,WAAA,IAAe,IAAA,CAAK,QAAA;IAC1B;IAED,IAAI,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,SAAA,EAAW,OAAO,KAAA;IAG9C,IAAI,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,aAAA,EAAe,OAAO,KAAA;IAEnE,OAAO,IAAA;EACR;EAED,gBAAA,CAAA,EAAmB;IACjB,OAAO,IAAA,CAAK,KAAA,CAAM,SAAA,IAAa,IAAA,CAAK,WAAA,IAAe,IAAA,CAAK,QAAA;EACzD;AACH;AAEA,MAAM,EAAA,GAAK,IAAI,UAAA,CAAY,CAAA;AAU3B,MAAM,WAAA,CAAY;EAChB,WAAA,CAAY,IAAA,EAAM,MAAA,GAAS,EAAA,EAAI;IAC7B,IAAA,CAAK,IAAA,GAAO,IAAA;IACZ,IAAA,CAAK,MAAA,GAAS,MAAA;EACf;EAAA;AAAA;AAAA;AAAA;EAMD,MAAA,CAAA,EAAS;IACP,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;IAEpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,MAAA,CAAO,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MAC/C,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,CAAC,CAAC,CAAA;IACzB;IAED,OAAO,IAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;EAOD,SAAA,CAAU,KAAA,EAAO;IACf,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAA;IACjC,MAAM,IAAA,GAAO,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA;IAC9B,MAAM,UAAA,GAAa,KAAA,CAAM,KAAA,CAAM,WAAW,CAAA;IAE1C,IAAI,KAAA,CAAM,OAAA,EAAS;MAEjB,IAAI,KAAA,CAAM,cAAA,EAAgB;MAI1B,IAAI,KAAA,CAAM,cAAA,EAAgB;IAEhC,CAAA,MAAW;MAEL,IAAI,KAAA,CAAM,cAAA,EAAgB;MAG1B,IAAI,KAAA,CAAM,cAAA,EAAgB;QACxB,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAM,UAAA,CAAW,UAAA,EAAY,KAAA,CAAM,KAAK,CAAA;MAC/D;IACF;IAED,OAAO,IAAA;EACR;EAED,gBAAA,CAAiB,IAAA,EAAM,CAAA,EAAG,KAAA,EAAO;IAC/B,EAAA,CAAG,GAAA,CAAI,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;IACjB,EAAA,CAAG,KAAA,CAAM,CAAA,EAAG,KAAK,CAAA;IACjB,IAAA,CAAK,UAAA,CAAW,QAAA,CAAS,EAAE,CAAA;IAE3B,OAAO,IAAA;EACR;AACH","sourcesContent":["import { AnimationMixer, Object3D, Quaternion, Vector3 } from 'three'\nimport { CCDIKSolver } from '../animation/CCDIKSolver'\nimport { MMDPhysics } from '../animation/MMDPhysics'\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = []\n\n    this.camera = null\n    this.cameraTarget = new Object3D()\n    this.cameraTarget.name = 'target'\n\n    this.audio = null\n    this.audioManager = null\n\n    this.objects = new WeakMap()\n\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== undefined ? params.pmxAnimation : false,\n    }\n\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true,\n    }\n\n    this.onBeforePhysics = function (/* mesh */) {}\n\n    // experimental\n    this.sharedPhysics = false\n    this.masterPhysics = null\n  }\n\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params)\n    } else if (object.isCamera) {\n      this._setupCamera(object, params)\n    } else if (object.type === 'Audio') {\n      this._setupAudio(object, params)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.add: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object)\n    } else if (object.isCamera) {\n      this._clearCamera(object)\n    } else if (object.type === 'Audio') {\n      this._clearAudio(object)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.remove: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null) this.audioManager.control(delta)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta)\n    }\n\n    if (this.sharedPhysics) this._updateSharedPhysics(delta)\n\n    if (this.camera !== null) this._animateCamera(this.camera, delta)\n\n    return this\n  }\n\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false) mesh.pose()\n\n    const bones = mesh.skeleton.bones\n    const boneParams = vpd.bones\n\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i\n    }\n\n    const vector = new Vector3()\n    const quaternion = new Quaternion()\n\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i]\n      const boneIndex = boneNameDictionary[boneParam.name]\n\n      if (boneIndex === undefined) continue\n\n      const bone = bones[boneIndex]\n      bone.position.add(vector.fromArray(boneParam.translation))\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion))\n    }\n\n    mesh.updateMatrixWorld(true)\n\n    // PMX animation system special path\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === 'pmx') {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver)\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update()\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === undefined) {\n      throw new Error('THREE.MMDAnimationHelper.enable: ' + 'unknown key ' + key)\n    }\n\n    this.enabled[key] = enabled\n\n    if (key === 'physics') {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants)\n  }\n\n  // private methods\n\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error('THREE.MMDAnimationHelper._addMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has already been added.\")\n    }\n\n    this.meshes.push(mesh)\n    this.objects.set(mesh, { looped: false })\n\n    this._setupMeshAnimation(mesh, params.animation)\n\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params)\n    }\n\n    return this\n  }\n\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error('THREE.MMDAnimationHelper._setupCamera: ' + \"Camera '\" + camera.name + \"' has already been set.\")\n    }\n\n    if (this.camera) this.clearCamera(this.camera)\n\n    this.camera = camera\n\n    camera.add(this.cameraTarget)\n\n    this.objects.set(camera, {})\n\n    if (params.animation !== undefined) {\n      this._setupCameraAnimation(camera, params.animation)\n    }\n\n    return this\n  }\n\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error('THREE.MMDAnimationHelper._setupAudio: ' + \"Audio '\" + audio.name + \"' has already been set.\")\n    }\n\n    if (this.audio) this.clearAudio(this.audio)\n\n    this.audio = audio\n    this.audioManager = new AudioManager(audio, params)\n\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration,\n    })\n\n    return this\n  }\n\n  _removeMesh(mesh) {\n    let found = false\n    let writeIndex = 0\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh)\n        found = true\n\n        continue\n      }\n\n      this.meshes[writeIndex++] = this.meshes[i]\n    }\n\n    if (!found) {\n      throw new Error(\n        'THREE.MMDAnimationHelper._removeMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has not been added yet.\",\n      )\n    }\n\n    this.meshes.length = writeIndex\n\n    return this\n  }\n\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error('THREE.MMDAnimationHelper._clearCamera: ' + \"Camera '\" + camera.name + \"' has not been set yet.\")\n    }\n\n    this.camera.remove(this.cameraTarget)\n\n    this.objects.delete(this.camera)\n    this.camera = null\n\n    return this\n  }\n\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error('THREE.MMDAnimationHelper._clearAudio: ' + \"Audio '\" + audio.name + \"' has not been set yet.\")\n    }\n\n    this.objects.delete(this.audioManager)\n\n    this.audio = null\n    this.audioManager = null\n\n    return this\n  }\n\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh)\n\n    if (animation !== undefined) {\n      const animations = Array.isArray(animation) ? animation : [animation]\n\n      objects.mixer = new AnimationMixer(mesh)\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play()\n      }\n\n      // TODO: find a workaround not to access ._clip looking like a private property\n      objects.mixer.addEventListener('loop', function (event) {\n        const tracks = event.action._clip.tracks\n\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return\n\n        objects.looped = true\n      })\n    }\n\n    objects.ikSolver = this._createCCDIKSolver(mesh)\n    objects.grantSolver = this.createGrantSolver(mesh)\n\n    return this\n  }\n\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation]\n\n    const objects = this.objects.get(camera)\n\n    objects.mixer = new AnimationMixer(camera)\n\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play()\n    }\n  }\n\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh)\n\n    // shared physics is experimental\n\n    if (params.world === undefined && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics()\n\n      if (masterPhysics !== null) world = masterPhysics.world // eslint-disable-line no-undef\n    }\n\n    objects.physics = this._createMMDPhysics(mesh, params)\n\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0)\n      objects.physics.reset()\n    }\n\n    objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60)\n\n    this._optimizeIK(mesh, true)\n  }\n\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh)\n\n    const mixer = objects.mixer\n    const ikSolver = objects.ikSolver\n    const grantSolver = objects.grantSolver\n    const physics = objects.physics\n    const looped = objects.looped\n\n    if (mixer && this.enabled.animation) {\n      // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      this._restoreBones(mesh)\n\n      mixer.update(delta)\n\n      this._saveBones(mesh)\n\n      // PMX animation system special path\n      if (\n        this.configuration.pmxAnimation &&\n        mesh.geometry.userData.MMD &&\n        mesh.geometry.userData.MMD.format === 'pmx'\n      ) {\n        if (!objects.sortedBonesData)\n          objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n\n        this._animatePMXMesh(\n          mesh,\n          objects.sortedBonesData,\n          ikSolver && this.enabled.ik ? ikSolver : null,\n          grantSolver && this.enabled.grant ? grantSolver : null,\n        )\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true)\n          ikSolver.update()\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update()\n        }\n      }\n    }\n\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop) physics.reset()\n\n      objects.looped = false\n    }\n\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh)\n      physics.update(delta)\n    }\n  }\n\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function (a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass\n      } else {\n        return a.index - b.index\n      }\n    })\n  }\n\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0\n    _grantResultMap.clear()\n\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver)\n    }\n\n    mesh.updateMatrixWorld(true)\n    return this\n  }\n\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer\n\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta)\n\n      camera.updateProjectionMatrix()\n\n      camera.up.set(0, 1, 0)\n      camera.up.applyQuaternion(camera.quaternion)\n      camera.lookAt(this.cameraTarget.position)\n    }\n  }\n\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks\n    const bones = mesh.geometry.userData.MMD.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const links = ik.links\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j]\n\n        if (physicsEnabled === true) {\n          // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n          // because its rotation will be overriden by physics\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true\n        } else {\n          link.enabled = true\n        }\n      }\n    }\n  }\n\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === undefined) {\n      throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.')\n    }\n\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks)\n  }\n\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === undefined) {\n      throw new Error('THREE.MMDPhysics: Import MMDPhysics.')\n    }\n\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params)\n  }\n\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0.0\n\n    const objects = this.objects\n    const meshes = this.meshes\n    const camera = this.camera\n    const audioManager = this.audioManager\n\n    // get the longest duration\n\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip\n\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration,\n          })\n        }\n\n        max = Math.max(max, objects.get(clip).duration)\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration,\n            })\n          }\n\n          max = Math.max(max, objects.get(clip).duration)\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration)\n    }\n\n    max += this.configuration.afterglow\n\n    // update the duration\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      audioManager.duration = max\n    }\n  }\n\n  // workaround\n\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer\n\n    const propertyMixers = mixer._bindings\n    const accuIndex = mixer._accuIndex\n\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i]\n      const buffer = propertyMixer.buffer\n      const stride = propertyMixer.valueSize\n      const offset = (accuIndex + 1) * stride\n\n      propertyMixer.binding.getValue(buffer, offset)\n    }\n  }\n\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const bones = mesh.skeleton.bones\n\n    let backupBones = objects.backupBones\n\n    if (backupBones === undefined) {\n      backupBones = new Float32Array(bones.length * 7)\n      objects.backupBones = backupBones\n    }\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.toArray(backupBones, i * 7)\n      bone.quaternion.toArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const backupBones = objects.backupBones\n\n    if (backupBones === undefined) return\n\n    const bones = mesh.skeleton.bones\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.fromArray(backupBones, i * 7)\n      bone.quaternion.fromArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  // experimental\n\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null) return this.masterPhysics\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics\n\n      if (physics !== undefined && physics !== null) {\n        this.masterPhysics = physics\n        return this.masterPhysics\n      }\n    }\n\n    return null\n  }\n\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return\n\n    const physics = this._getMasterPhysics()\n\n    if (physics === null) return\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateRigidBodies()\n      }\n    }\n\n    physics.stepSimulation(delta)\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateBones()\n      }\n    }\n  }\n}\n\n// Keep working quaternions for less GC\nconst _quaternions = []\nlet _quaternionIndex = 0\n\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion())\n  }\n\n  return _quaternions[_quaternionIndex++]\n}\n\n// Save rotation whose grant and IK are already applied\n// used by grant children\nconst _grantResultMap = new Map()\n\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones\n  const bonesData = mesh.geometry.userData.MMD.bones\n  const boneData = bonesData[boneIndex]\n  const bone = bones[boneIndex]\n\n  // Return if already updated by being referred as a grant parent.\n  if (_grantResultMap.has(boneIndex)) return\n\n  const quaternion = getQuaternion()\n\n  // Initialize grant result here to prevent infinite loop.\n  // If it's referred before updating with actual result later\n  // result without applyting IK or grant is gotten\n  // but better than composing of infinite loop.\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion))\n\n  // @TODO: Support global grant and grant position\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex\n    const ratio = boneData.grant.ratio\n\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver)\n    }\n\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio)\n  }\n\n  if (ikSolver && boneData.ik) {\n    // @TODO: Updating world matrices every time solving an IK bone is\n    // costly. Optimize if possible.\n    mesh.updateMatrixWorld(true)\n    ikSolver.updateOne(boneData.ik)\n\n    // No confident, but it seems the grant results with ik links should be updated?\n    const links = boneData.ik.links\n\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i]\n\n      if (link.enabled === false) continue\n\n      const linkIndex = link.index\n\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion))\n      }\n    }\n  }\n\n  // Update with the actual result here\n  quaternion.copy(bone.quaternion)\n}\n\n//\n\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio\n\n    this.elapsedTime = 0.0\n    this.currentTime = 0.0\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0\n\n    this.audioDuration = this.audio.buffer.duration\n    this.duration = this.audioDuration + this.delayTime\n  }\n\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta\n    this.currentTime += delta\n\n    if (this._shouldStopAudio()) this.audio.stop()\n    if (this._shouldStartAudio()) this.audio.play()\n\n    return this\n  }\n\n  // private methods\n\n  _shouldStartAudio() {\n    if (this.audio.isPlaying) return false\n\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration\n    }\n\n    if (this.currentTime < this.delayTime) return false\n\n    // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n    if (this.currentTime - this.delayTime > this.audioDuration) return false\n\n    return true\n  }\n\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration\n  }\n}\n\nconst _q = new Quaternion()\n\n/**\n * Solver for Grant (Fuyo in Japanese. I just google translated because\n * Fuyo may be MMD specific term and may not be common word in 3D CG terms.)\n * Grant propagates a bone's transform to other bones transforms even if\n * they are not children.\n * @param {THREE.SkinnedMesh} mesh\n * @param {Array<Object>} grants\n */\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh\n    this.grants = grants\n  }\n\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants\n\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones\n    const bone = bones[grant.index]\n    const parentBone = bones[grant.parentIndex]\n\n    if (grant.isLocal) {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      // TODO: implement\n      if (grant.affectRotation) {\n      }\n    } else {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio)\n      }\n    }\n\n    return this\n  }\n\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1)\n    _q.slerp(q, ratio)\n    bone.quaternion.multiply(_q)\n\n    return this\n  }\n}\n\nexport { MMDAnimationHelper }\n"]},"metadata":{},"sourceType":"module"}