{"ast":null,"code":"import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from \"three\";\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession();\n    if (environmentEstimation && \"XRWebGLBinding\" in window) {\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext();\n      switch (session.preferredReflectionFormat) {\n        case \"srgba8\":\n          gl.getExtension(\"EXT_sRGB\");\n          break;\n        case \"rgba16f\":\n          gl.getExtension(\"OES_texture_half_float\");\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener(\"reflectionchange\", () => {\n        this.updateReflection();\n      });\n    }\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n  onXRFrame(time, xrFrame) {\n    if (!this.xrLight) {\n      return;\n    }\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n    if (lightEstimate) {\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1;\n      const intensityScalar = Math.max(1, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n}\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight);\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener(\"sessionstart\", () => {\n      const session = renderer.xr.getSession();\n      if (\"requestLightProbe\" in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true;\n            this.dispatchEvent({\n              type: \"estimationstart\"\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener(\"sessionend\", () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        this.dispatchEvent({\n          type: \"estimationend\"\n        });\n      }\n    });\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n}\nexport { XREstimatedLight };","map":{"version":3,"sources":["../../src/webxr/XREstimatedLight.js"],"names":[],"mappings":"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","sourcesContent":["import { DirectionalLight, Group, LightProbe, WebGLCubeRenderTarget } from 'three'\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight\n    this.renderer = renderer\n    this.lightProbe = lightProbe\n    this.xrWebGLBinding = null\n    this.estimationStartCallback = estimationStartCallback\n    this.frameCallback = this.onXRFrame.bind(this)\n\n    const session = renderer.xr.getSession()\n\n    // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16)\n      xrLight.environment = cubeRenderTarget.texture\n\n      const gl = renderer.getContext()\n\n      // Ensure that we have any extensions needed to use the preferred cube map format.\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB')\n          break\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float')\n          break\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl)\n\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection()\n      })\n    }\n\n    // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n    session.requestAnimationFrame(this.frameCallback)\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment)\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe)\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap\n\n        this.xrLight.environment.needsPMREMUpdate = true\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return\n    }\n\n    const session = xrFrame.session\n    session.requestAnimationFrame(this.frameCallback)\n\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe)\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients)\n      this.xrLight.lightProbe.intensity = 1.0\n\n      // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n      const intensityScalar = Math.max(\n        1.0,\n        Math.max(\n          lightEstimate.primaryLightIntensity.x,\n          Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z),\n        ),\n      )\n\n      this.xrLight.directionalLight.color.setRGB(\n        lightEstimate.primaryLightIntensity.x / intensityScalar,\n        lightEstimate.primaryLightIntensity.y / intensityScalar,\n        lightEstimate.primaryLightIntensity.z / intensityScalar,\n      )\n      this.xrLight.directionalLight.intensity = intensityScalar\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection)\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback()\n        this.estimationStartCallback = null\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null\n    this.renderer = null\n    this.lightProbe = null\n    this.xrWebGLBinding = null\n  }\n}\n\nexport class XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super()\n\n    this.lightProbe = new LightProbe()\n    this.lightProbe.intensity = 0\n    this.add(this.lightProbe)\n\n    this.directionalLight = new DirectionalLight()\n    this.directionalLight.intensity = 0\n    this.add(this.directionalLight)\n\n    // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n    this.environment = null\n\n    let sessionLightProbe = null\n    let estimationStarted = false\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession()\n\n      if ('requestLightProbe' in session) {\n        session\n          .requestLightProbe({\n            reflectionFormat: session.preferredReflectionFormat,\n          })\n          .then((probe) => {\n            sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n              estimationStarted = true\n\n              // Fired to indicate that the estimated lighting values are now being updated.\n              this.dispatchEvent({ type: 'estimationstart' })\n            })\n          })\n      }\n    })\n\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose()\n        sessionLightProbe = null\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({ type: 'estimationend' })\n      }\n    })\n\n    // Done inline to provide access to sessionLightProbe.\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose()\n        sessionLightProbe = null\n      }\n\n      this.remove(this.lightProbe)\n      this.lightProbe = null\n\n      this.remove(this.directionalLight)\n      this.directionalLight = null\n\n      this.environment = null\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}