{"ast":null,"code":"import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from \"three\";\nimport { LightningStrike } from \"../geometries/LightningStrike.js\";\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super();\n    this.isLightningStorm = true;\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;\n    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;\n    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;\n    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 11599871\n    });\n    if (stormParams.onRayPosition !== void 0) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n    this.onLightningDown = stormParams.onLightningDown;\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n    if (time >= this.nextLightningTime) {\n      const lightningMesh = this.deadLightningsMeshes.pop();\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      }\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n    let i = 0,\n      il = this.lightningsMeshes.length;\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n}\nexport { LightningStorm };","map":{"version":3,"sources":["../../src/objects/LightningStorm.js"],"names":[],"mappings":"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","sourcesContent":["import { MathUtils, Mesh, MeshBasicMaterial, Object3D } from 'three'\nimport { LightningStrike } from '../geometries/LightningStrike'\n\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\n\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super()\n\n    this.isLightningStorm = true\n\n    // Parameters\n\n    this.stormParams = stormParams\n\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1\n\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3\n\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0\n\n    stormParams.lightningMinDuration =\n      stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0\n    stormParams.lightningMaxDuration =\n      stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5\n\n    this.lightningParameters = LightningStrike.copyParameters(\n      stormParams.lightningParameters,\n      stormParams.lightningParameters,\n    )\n\n    this.lightningParameters.isEternal = false\n\n    this.lightningMaterial =\n      stormParams.lightningMaterial !== undefined\n        ? stormParams.lightningMaterial\n        : new MeshBasicMaterial({ color: 0xb0ffff })\n\n    if (stormParams.onRayPosition !== undefined) {\n      this.onRayPosition = stormParams.onRayPosition\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size)\n\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random())\n\n        source\n          .set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1))\n          .multiplyScalar(height)\n          .add(dest)\n      }\n    }\n\n    this.onLightningDown = stormParams.onLightningDown\n\n    // Internal state\n\n    this.inited = false\n    this.nextLightningTime = 0\n    this.lightningsMeshes = []\n    this.deadLightningsMeshes = []\n\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters))\n      const mesh = new Mesh(lightning, this.lightningMaterial)\n      this.deadLightningsMeshes.push(mesh)\n    }\n  }\n\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random()\n      this.inited = true\n    }\n\n    if (time >= this.nextLightningTime) {\n      // Lightning creation\n\n      const lightningMesh = this.deadLightningsMeshes.pop()\n\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(\n          lightningMesh.geometry.rayParameters,\n          this.lightningParameters,\n        )\n\n        lightningParams1.birthTime = time\n        lightningParams1.deathTime =\n          time +\n          MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random())\n\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset)\n\n        lightningParams1.noiseSeed = Math.random()\n\n        this.add(lightningMesh)\n\n        this.lightningsMeshes.push(lightningMesh)\n      }\n\n      // Schedule next lightning\n      this.nextLightningTime = this.getNextLightningTime(time)\n    }\n\n    let i = 0,\n      il = this.lightningsMeshes.length\n\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i]\n\n      const lightning = mesh.geometry\n\n      const prevState = lightning.state\n\n      lightning.update(time)\n\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning)\n        }\n      }\n\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        // Lightning is to be destroyed\n\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1)\n\n        this.deadLightningsMeshes.push(mesh)\n\n        this.remove(mesh)\n\n        il--\n      } else {\n        i++\n      }\n    }\n  }\n\n  getNextLightningTime(currentTime) {\n    return (\n      currentTime +\n      MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) /\n        (this.stormParams.maxLightnings + 1)\n    )\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.stormParams.size = source.stormParams.size\n    this.stormParams.minHeight = source.stormParams.minHeight\n    this.stormParams.maxHeight = source.stormParams.maxHeight\n    this.stormParams.maxSlope = source.stormParams.maxSlope\n\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings\n\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod\n\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration\n\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters)\n\n    this.lightningMaterial = source.stormParams.lightningMaterial\n\n    this.onLightningDown = source.onLightningDown\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(this.stormParams).copy(this)\n  }\n}\n\nexport { LightningStorm }\n"]},"metadata":{},"sourceType":"module"}