{"ast":null,"code":"import { Object3D, Box2, Color, Vector3, Matrix3, Matrix4, Camera } from \"three\";\nimport { Projector, RenderableSprite, RenderableLine, RenderableFace } from \"./Projector.js\";\nclass SVGObject extends Object3D {\n  constructor(node) {\n    super();\n    this.isSVGObject = true;\n    this.node = node;\n  }\n}\nclass SVGRenderer {\n  constructor() {\n    let _renderData,\n      _elements,\n      _lights,\n      _svgWidth,\n      _svgHeight,\n      _svgWidthHalf,\n      _svgHeightHalf,\n      _v1,\n      _v2,\n      _v3,\n      _svgNode,\n      _pathCount = 0,\n      _precision = null,\n      _quality = 1,\n      _currentPath,\n      _currentStyle;\n    const _this = this,\n      _clipBox = new Box2(),\n      _elemBox = new Box2(),\n      _color = new Color(),\n      _diffuseColor = new Color(),\n      _ambientLight = new Color(),\n      _directionalLights = new Color(),\n      _pointLights = new Color(),\n      _clearColor = new Color(),\n      _vector3 = new Vector3(),\n      _centroid = new Vector3(),\n      _normal = new Vector3(),\n      _normalViewMatrix = new Matrix3(),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _svgPathPool = [],\n      _projector = new Projector(),\n      _svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.domElement = _svg;\n    this.autoClear = true;\n    this.sortObjects = true;\n    this.sortElements = true;\n    this.overdraw = 0.5;\n    this.info = {\n      render: {\n        vertices: 0,\n        faces: 0\n      }\n    };\n    this.setQuality = function (quality) {\n      switch (quality) {\n        case \"high\":\n          _quality = 1;\n          break;\n        case \"low\":\n          _quality = 0;\n          break;\n      }\n    };\n    this.setClearColor = function (color) {\n      _clearColor.set(color);\n    };\n    this.setPixelRatio = function () {};\n    this.setSize = function (width, height) {\n      _svgWidth = width;\n      _svgHeight = height;\n      _svgWidthHalf = _svgWidth / 2;\n      _svgHeightHalf = _svgHeight / 2;\n      _svg.setAttribute(\"viewBox\", -_svgWidthHalf + \" \" + -_svgHeightHalf + \" \" + _svgWidth + \" \" + _svgHeight);\n      _svg.setAttribute(\"width\", _svgWidth);\n      _svg.setAttribute(\"height\", _svgHeight);\n      _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);\n      _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);\n    };\n    this.getSize = function () {\n      return {\n        width: _svgWidth,\n        height: _svgHeight\n      };\n    };\n    this.setPrecision = function (precision) {\n      _precision = precision;\n    };\n    function removeChildNodes() {\n      _pathCount = 0;\n      while (_svg.childNodes.length > 0) {\n        _svg.removeChild(_svg.childNodes[0]);\n      }\n    }\n    function convert(c) {\n      return _precision !== null ? c.toFixed(_precision) : c;\n    }\n    this.clear = function () {\n      removeChildNodes();\n      _svg.style.backgroundColor = _clearColor.getStyle();\n    };\n    this.render = function (scene, camera) {\n      if (camera instanceof Camera === false) {\n        console.error(\"THREE.SVGRenderer.render: camera is not an instance of Camera.\");\n        return;\n      }\n      const background = scene.background;\n      if (background && background.isColor) {\n        removeChildNodes();\n        _svg.style.backgroundColor = background.getStyle();\n      } else if (this.autoClear === true) {\n        this.clear();\n      }\n      _this.info.render.vertices = 0;\n      _this.info.render.faces = 0;\n      _viewMatrix.copy(camera.matrixWorldInverse);\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n      _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\n      _elements = _renderData.elements;\n      _lights = _renderData.lights;\n      _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);\n      calculateLights(_lights);\n      _currentPath = \"\";\n      _currentStyle = \"\";\n      for (let e = 0, el = _elements.length; e < el; e++) {\n        const element = _elements[e];\n        const material = element.material;\n        if (material === void 0 || material.opacity === 0) continue;\n        _elemBox.makeEmpty();\n        if (element instanceof RenderableSprite) {\n          _v1 = element;\n          _v1.x *= _svgWidthHalf;\n          _v1.y *= -_svgHeightHalf;\n          renderSprite(_v1, element, material);\n        } else if (element instanceof RenderableLine) {\n          _v1 = element.v1;\n          _v2 = element.v2;\n          _v1.positionScreen.x *= _svgWidthHalf;\n          _v1.positionScreen.y *= -_svgHeightHalf;\n          _v2.positionScreen.x *= _svgWidthHalf;\n          _v2.positionScreen.y *= -_svgHeightHalf;\n          _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);\n          if (_clipBox.intersectsBox(_elemBox) === true) {\n            renderLine(_v1, _v2, material);\n          }\n        } else if (element instanceof RenderableFace) {\n          _v1 = element.v1;\n          _v2 = element.v2;\n          _v3 = element.v3;\n          if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\n          if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\n          if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\n          _v1.positionScreen.x *= _svgWidthHalf;\n          _v1.positionScreen.y *= -_svgHeightHalf;\n          _v2.positionScreen.x *= _svgWidthHalf;\n          _v2.positionScreen.y *= -_svgHeightHalf;\n          _v3.positionScreen.x *= _svgWidthHalf;\n          _v3.positionScreen.y *= -_svgHeightHalf;\n          if (this.overdraw > 0) {\n            expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);\n            expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);\n            expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);\n          }\n          _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen]);\n          if (_clipBox.intersectsBox(_elemBox) === true) {\n            renderFace3(_v1, _v2, _v3, element, material);\n          }\n        }\n      }\n      flushPath();\n      scene.traverseVisible(function (object) {\n        if (object.isSVGObject) {\n          _vector3.setFromMatrixPosition(object.matrixWorld);\n          _vector3.applyMatrix4(_viewProjectionMatrix);\n          if (_vector3.z < -1 || _vector3.z > 1) return;\n          const x = _vector3.x * _svgWidthHalf;\n          const y = -_vector3.y * _svgHeightHalf;\n          const node = object.node;\n          node.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n          _svg.appendChild(node);\n        }\n      });\n    };\n    function calculateLights(lights) {\n      _ambientLight.setRGB(0, 0, 0);\n      _directionalLights.setRGB(0, 0, 0);\n      _pointLights.setRGB(0, 0, 0);\n      for (let l = 0, ll = lights.length; l < ll; l++) {\n        const light = lights[l];\n        const lightColor = light.color;\n        if (light.isAmbientLight) {\n          _ambientLight.r += lightColor.r;\n          _ambientLight.g += lightColor.g;\n          _ambientLight.b += lightColor.b;\n        } else if (light.isDirectionalLight) {\n          _directionalLights.r += lightColor.r;\n          _directionalLights.g += lightColor.g;\n          _directionalLights.b += lightColor.b;\n        } else if (light.isPointLight) {\n          _pointLights.r += lightColor.r;\n          _pointLights.g += lightColor.g;\n          _pointLights.b += lightColor.b;\n        }\n      }\n    }\n    function calculateLight(lights, position, normal, color) {\n      for (let l = 0, ll = lights.length; l < ll; l++) {\n        const light = lights[l];\n        const lightColor = light.color;\n        if (light.isDirectionalLight) {\n          const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();\n          let amount = normal.dot(lightPosition);\n          if (amount <= 0) continue;\n          amount *= light.intensity;\n          color.r += lightColor.r * amount;\n          color.g += lightColor.g * amount;\n          color.b += lightColor.b * amount;\n        } else if (light.isPointLight) {\n          const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);\n          let amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\n          if (amount <= 0) continue;\n          amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\n          if (amount == 0) continue;\n          amount *= light.intensity;\n          color.r += lightColor.r * amount;\n          color.g += lightColor.g * amount;\n          color.b += lightColor.b * amount;\n        }\n      }\n    }\n    function renderSprite(v1, element, material) {\n      let scaleX = element.scale.x * _svgWidthHalf;\n      let scaleY = element.scale.y * _svgHeightHalf;\n      if (material.isPointsMaterial) {\n        scaleX *= material.size;\n        scaleY *= material.size;\n      }\n      const path = \"M\" + convert(v1.x - scaleX * 0.5) + \",\" + convert(v1.y - scaleY * 0.5) + \"h\" + convert(scaleX) + \"v\" + convert(scaleY) + \"h\" + convert(-scaleX) + \"z\";\n      let style = \"\";\n      if (material.isSpriteMaterial || material.isPointsMaterial) {\n        style = \"fill:\" + material.color.getStyle() + \";fill-opacity:\" + material.opacity;\n      }\n      addPath(style, path);\n    }\n    function renderLine(v1, v2, material) {\n      const path = \"M\" + convert(v1.positionScreen.x) + \",\" + convert(v1.positionScreen.y) + \"L\" + convert(v2.positionScreen.x) + \",\" + convert(v2.positionScreen.y);\n      if (material.isLineBasicMaterial) {\n        let style = \"fill:none;stroke:\" + material.color.getStyle() + \";stroke-opacity:\" + material.opacity + \";stroke-width:\" + material.linewidth + \";stroke-linecap:\" + material.linecap;\n        if (material.isLineDashedMaterial) {\n          style = style + \";stroke-dasharray:\" + material.dashSize + \",\" + material.gapSize;\n        }\n        addPath(style, path);\n      }\n    }\n    function renderFace3(v1, v2, v3, element, material) {\n      _this.info.render.vertices += 3;\n      _this.info.render.faces++;\n      const path = \"M\" + convert(v1.positionScreen.x) + \",\" + convert(v1.positionScreen.y) + \"L\" + convert(v2.positionScreen.x) + \",\" + convert(v2.positionScreen.y) + \"L\" + convert(v3.positionScreen.x) + \",\" + convert(v3.positionScreen.y) + \"z\";\n      let style = \"\";\n      if (material.isMeshBasicMaterial) {\n        _color.copy(material.color);\n        if (material.vertexColors) {\n          _color.multiply(element.color);\n        }\n      } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {\n        _diffuseColor.copy(material.color);\n        if (material.vertexColors) {\n          _diffuseColor.multiply(element.color);\n        }\n        _color.copy(_ambientLight);\n        _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);\n        calculateLight(_lights, _centroid, element.normalModel, _color);\n        _color.multiply(_diffuseColor).add(material.emissive);\n      } else if (material.isMeshNormalMaterial) {\n        _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();\n        _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);\n      }\n      if (material.wireframe) {\n        style = \"fill:none;stroke:\" + _color.getStyle() + \";stroke-opacity:\" + material.opacity + \";stroke-width:\" + material.wireframeLinewidth + \";stroke-linecap:\" + material.wireframeLinecap + \";stroke-linejoin:\" + material.wireframeLinejoin;\n      } else {\n        style = \"fill:\" + _color.getStyle() + \";fill-opacity:\" + material.opacity;\n      }\n      addPath(style, path);\n    }\n    function expand(v1, v2, pixels) {\n      let x = v2.x - v1.x,\n        y = v2.y - v1.y;\n      const det = x * x + y * y;\n      if (det === 0) return;\n      const idet = pixels / Math.sqrt(det);\n      x *= idet;\n      y *= idet;\n      v2.x += x;\n      v2.y += y;\n      v1.x -= x;\n      v1.y -= y;\n    }\n    function addPath(style, path) {\n      if (_currentStyle === style) {\n        _currentPath += path;\n      } else {\n        flushPath();\n        _currentStyle = style;\n        _currentPath = path;\n      }\n    }\n    function flushPath() {\n      if (_currentPath) {\n        _svgNode = getPathNode(_pathCount++);\n        _svgNode.setAttribute(\"d\", _currentPath);\n        _svgNode.setAttribute(\"style\", _currentStyle);\n        _svg.appendChild(_svgNode);\n      }\n      _currentPath = \"\";\n      _currentStyle = \"\";\n    }\n    function getPathNode(id) {\n      if (_svgPathPool[id] == null) {\n        _svgPathPool[id] = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        if (_quality == 0) {\n          _svgPathPool[id].setAttribute(\"shape-rendering\", \"crispEdges\");\n        }\n        return _svgPathPool[id];\n      }\n      return _svgPathPool[id];\n    }\n  }\n}\nexport { SVGObject, SVGRenderer };","map":{"version":3,"sources":["../../src/renderers/SVGRenderer.js"],"names":[],"mappings":"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","sourcesContent":["import { Box2, Camera, Color, Matrix3, Matrix4, Object3D, Vector3 } from 'three'\nimport { Projector, RenderableFace, RenderableLine, RenderableSprite } from '../renderers/Projector'\n\nclass SVGObject extends Object3D {\n  constructor(node) {\n    super()\n\n    this.isSVGObject = true\n\n    this.node = node\n  }\n}\n\nclass SVGRenderer {\n  constructor() {\n    let _renderData,\n      _elements,\n      _lights,\n      _svgWidth,\n      _svgHeight,\n      _svgWidthHalf,\n      _svgHeightHalf,\n      _v1,\n      _v2,\n      _v3,\n      _svgNode,\n      _pathCount = 0,\n      _precision = null,\n      _quality = 1,\n      _currentPath,\n      _currentStyle\n\n    const _this = this,\n      _clipBox = new Box2(),\n      _elemBox = new Box2(),\n      _color = new Color(),\n      _diffuseColor = new Color(),\n      _ambientLight = new Color(),\n      _directionalLights = new Color(),\n      _pointLights = new Color(),\n      _clearColor = new Color(),\n      _vector3 = new Vector3(), // Needed for PointLight\n      _centroid = new Vector3(),\n      _normal = new Vector3(),\n      _normalViewMatrix = new Matrix3(),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _svgPathPool = [],\n      _projector = new Projector(),\n      _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n    this.domElement = _svg\n\n    this.autoClear = true\n    this.sortObjects = true\n    this.sortElements = true\n\n    this.overdraw = 0.5\n\n    this.info = {\n      render: {\n        vertices: 0,\n        faces: 0,\n      },\n    }\n\n    this.setQuality = function (quality) {\n      switch (quality) {\n        case 'high':\n          _quality = 1\n          break\n        case 'low':\n          _quality = 0\n          break\n      }\n    }\n\n    this.setClearColor = function (color) {\n      _clearColor.set(color)\n    }\n\n    this.setPixelRatio = function () {}\n\n    this.setSize = function (width, height) {\n      _svgWidth = width\n      _svgHeight = height\n      _svgWidthHalf = _svgWidth / 2\n      _svgHeightHalf = _svgHeight / 2\n\n      _svg.setAttribute('viewBox', -_svgWidthHalf + ' ' + -_svgHeightHalf + ' ' + _svgWidth + ' ' + _svgHeight)\n      _svg.setAttribute('width', _svgWidth)\n      _svg.setAttribute('height', _svgHeight)\n\n      _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf)\n      _clipBox.max.set(_svgWidthHalf, _svgHeightHalf)\n    }\n\n    this.getSize = function () {\n      return {\n        width: _svgWidth,\n        height: _svgHeight,\n      }\n    }\n\n    this.setPrecision = function (precision) {\n      _precision = precision\n    }\n\n    function removeChildNodes() {\n      _pathCount = 0\n\n      while (_svg.childNodes.length > 0) {\n        _svg.removeChild(_svg.childNodes[0])\n      }\n    }\n\n    function convert(c) {\n      return _precision !== null ? c.toFixed(_precision) : c\n    }\n\n    this.clear = function () {\n      removeChildNodes()\n      _svg.style.backgroundColor = _clearColor.getStyle()\n    }\n\n    this.render = function (scene, camera) {\n      if (camera instanceof Camera === false) {\n        console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.')\n        return\n      }\n\n      const background = scene.background\n\n      if (background && background.isColor) {\n        removeChildNodes()\n        _svg.style.backgroundColor = background.getStyle()\n      } else if (this.autoClear === true) {\n        this.clear()\n      }\n\n      _this.info.render.vertices = 0\n      _this.info.render.faces = 0\n\n      _viewMatrix.copy(camera.matrixWorldInverse)\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix)\n\n      _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements)\n      _elements = _renderData.elements\n      _lights = _renderData.lights\n\n      _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse)\n\n      calculateLights(_lights)\n\n      // reset accumulated path\n\n      _currentPath = ''\n      _currentStyle = ''\n\n      for (let e = 0, el = _elements.length; e < el; e++) {\n        const element = _elements[e]\n        const material = element.material\n\n        if (material === undefined || material.opacity === 0) continue\n\n        _elemBox.makeEmpty()\n\n        if (element instanceof RenderableSprite) {\n          _v1 = element\n          _v1.x *= _svgWidthHalf\n          _v1.y *= -_svgHeightHalf\n\n          renderSprite(_v1, element, material)\n        } else if (element instanceof RenderableLine) {\n          _v1 = element.v1\n          _v2 = element.v2\n\n          _v1.positionScreen.x *= _svgWidthHalf\n          _v1.positionScreen.y *= -_svgHeightHalf\n          _v2.positionScreen.x *= _svgWidthHalf\n          _v2.positionScreen.y *= -_svgHeightHalf\n\n          _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen])\n\n          if (_clipBox.intersectsBox(_elemBox) === true) {\n            renderLine(_v1, _v2, material)\n          }\n        } else if (element instanceof RenderableFace) {\n          _v1 = element.v1\n          _v2 = element.v2\n          _v3 = element.v3\n\n          if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue\n          if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue\n          if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue\n\n          _v1.positionScreen.x *= _svgWidthHalf\n          _v1.positionScreen.y *= -_svgHeightHalf\n          _v2.positionScreen.x *= _svgWidthHalf\n          _v2.positionScreen.y *= -_svgHeightHalf\n          _v3.positionScreen.x *= _svgWidthHalf\n          _v3.positionScreen.y *= -_svgHeightHalf\n\n          if (this.overdraw > 0) {\n            expand(_v1.positionScreen, _v2.positionScreen, this.overdraw)\n            expand(_v2.positionScreen, _v3.positionScreen, this.overdraw)\n            expand(_v3.positionScreen, _v1.positionScreen, this.overdraw)\n          }\n\n          _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen])\n\n          if (_clipBox.intersectsBox(_elemBox) === true) {\n            renderFace3(_v1, _v2, _v3, element, material)\n          }\n        }\n      }\n\n      flushPath() // just to flush last svg:path\n\n      scene.traverseVisible(function (object) {\n        if (object.isSVGObject) {\n          _vector3.setFromMatrixPosition(object.matrixWorld)\n          _vector3.applyMatrix4(_viewProjectionMatrix)\n\n          if (_vector3.z < -1 || _vector3.z > 1) return\n\n          const x = _vector3.x * _svgWidthHalf\n          const y = -_vector3.y * _svgHeightHalf\n\n          const node = object.node\n          node.setAttribute('transform', 'translate(' + x + ',' + y + ')')\n\n          _svg.appendChild(node)\n        }\n      })\n    }\n\n    function calculateLights(lights) {\n      _ambientLight.setRGB(0, 0, 0)\n      _directionalLights.setRGB(0, 0, 0)\n      _pointLights.setRGB(0, 0, 0)\n\n      for (let l = 0, ll = lights.length; l < ll; l++) {\n        const light = lights[l]\n        const lightColor = light.color\n\n        if (light.isAmbientLight) {\n          _ambientLight.r += lightColor.r\n          _ambientLight.g += lightColor.g\n          _ambientLight.b += lightColor.b\n        } else if (light.isDirectionalLight) {\n          _directionalLights.r += lightColor.r\n          _directionalLights.g += lightColor.g\n          _directionalLights.b += lightColor.b\n        } else if (light.isPointLight) {\n          _pointLights.r += lightColor.r\n          _pointLights.g += lightColor.g\n          _pointLights.b += lightColor.b\n        }\n      }\n    }\n\n    function calculateLight(lights, position, normal, color) {\n      for (let l = 0, ll = lights.length; l < ll; l++) {\n        const light = lights[l]\n        const lightColor = light.color\n\n        if (light.isDirectionalLight) {\n          const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize()\n\n          let amount = normal.dot(lightPosition)\n\n          if (amount <= 0) continue\n\n          amount *= light.intensity\n\n          color.r += lightColor.r * amount\n          color.g += lightColor.g * amount\n          color.b += lightColor.b * amount\n        } else if (light.isPointLight) {\n          const lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld)\n\n          let amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize())\n\n          if (amount <= 0) continue\n\n          amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1)\n\n          if (amount == 0) continue\n\n          amount *= light.intensity\n\n          color.r += lightColor.r * amount\n          color.g += lightColor.g * amount\n          color.b += lightColor.b * amount\n        }\n      }\n    }\n\n    function renderSprite(v1, element, material) {\n      let scaleX = element.scale.x * _svgWidthHalf\n      let scaleY = element.scale.y * _svgHeightHalf\n\n      if (material.isPointsMaterial) {\n        scaleX *= material.size\n        scaleY *= material.size\n      }\n\n      const path =\n        'M' +\n        convert(v1.x - scaleX * 0.5) +\n        ',' +\n        convert(v1.y - scaleY * 0.5) +\n        'h' +\n        convert(scaleX) +\n        'v' +\n        convert(scaleY) +\n        'h' +\n        convert(-scaleX) +\n        'z'\n      let style = ''\n\n      if (material.isSpriteMaterial || material.isPointsMaterial) {\n        style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity\n      }\n\n      addPath(style, path)\n    }\n\n    function renderLine(v1, v2, material) {\n      const path =\n        'M' +\n        convert(v1.positionScreen.x) +\n        ',' +\n        convert(v1.positionScreen.y) +\n        'L' +\n        convert(v2.positionScreen.x) +\n        ',' +\n        convert(v2.positionScreen.y)\n\n      if (material.isLineBasicMaterial) {\n        let style =\n          'fill:none;stroke:' +\n          material.color.getStyle() +\n          ';stroke-opacity:' +\n          material.opacity +\n          ';stroke-width:' +\n          material.linewidth +\n          ';stroke-linecap:' +\n          material.linecap\n\n        if (material.isLineDashedMaterial) {\n          style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize\n        }\n\n        addPath(style, path)\n      }\n    }\n\n    function renderFace3(v1, v2, v3, element, material) {\n      _this.info.render.vertices += 3\n      _this.info.render.faces++\n\n      const path =\n        'M' +\n        convert(v1.positionScreen.x) +\n        ',' +\n        convert(v1.positionScreen.y) +\n        'L' +\n        convert(v2.positionScreen.x) +\n        ',' +\n        convert(v2.positionScreen.y) +\n        'L' +\n        convert(v3.positionScreen.x) +\n        ',' +\n        convert(v3.positionScreen.y) +\n        'z'\n      let style = ''\n\n      if (material.isMeshBasicMaterial) {\n        _color.copy(material.color)\n\n        if (material.vertexColors) {\n          _color.multiply(element.color)\n        }\n      } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {\n        _diffuseColor.copy(material.color)\n\n        if (material.vertexColors) {\n          _diffuseColor.multiply(element.color)\n        }\n\n        _color.copy(_ambientLight)\n\n        _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3)\n\n        calculateLight(_lights, _centroid, element.normalModel, _color)\n\n        _color.multiply(_diffuseColor).add(material.emissive)\n      } else if (material.isMeshNormalMaterial) {\n        _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize()\n\n        _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5)\n      }\n\n      if (material.wireframe) {\n        style =\n          'fill:none;stroke:' +\n          _color.getStyle() +\n          ';stroke-opacity:' +\n          material.opacity +\n          ';stroke-width:' +\n          material.wireframeLinewidth +\n          ';stroke-linecap:' +\n          material.wireframeLinecap +\n          ';stroke-linejoin:' +\n          material.wireframeLinejoin\n      } else {\n        style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity\n      }\n\n      addPath(style, path)\n    }\n\n    // Hide anti-alias gaps\n\n    function expand(v1, v2, pixels) {\n      let x = v2.x - v1.x,\n        y = v2.y - v1.y\n      const det = x * x + y * y\n\n      if (det === 0) return\n\n      const idet = pixels / Math.sqrt(det)\n\n      x *= idet\n      y *= idet\n\n      v2.x += x\n      v2.y += y\n      v1.x -= x\n      v1.y -= y\n    }\n\n    function addPath(style, path) {\n      if (_currentStyle === style) {\n        _currentPath += path\n      } else {\n        flushPath()\n\n        _currentStyle = style\n        _currentPath = path\n      }\n    }\n\n    function flushPath() {\n      if (_currentPath) {\n        _svgNode = getPathNode(_pathCount++)\n        _svgNode.setAttribute('d', _currentPath)\n        _svgNode.setAttribute('style', _currentStyle)\n        _svg.appendChild(_svgNode)\n      }\n\n      _currentPath = ''\n      _currentStyle = ''\n    }\n\n    function getPathNode(id) {\n      if (_svgPathPool[id] == null) {\n        _svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\n        if (_quality == 0) {\n          _svgPathPool[id].setAttribute('shape-rendering', 'crispEdges') //optimizeSpeed\n        }\n\n        return _svgPathPool[id]\n      }\n\n      return _svgPathPool[id]\n    }\n  }\n}\n\nexport { SVGObject, SVGRenderer }\n"]},"metadata":{},"sourceType":"module"}