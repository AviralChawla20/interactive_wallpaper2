{"ast":null,"code":"import { Vector2 } from \"three\";\nfunction UVsDebug(geometry, size = 1024) {\n  const abc = \"abc\";\n  const a = new Vector2();\n  const b = new Vector2();\n  const uvs = [new Vector2(), new Vector2(), new Vector2()];\n  const face = [];\n  const canvas = document.createElement(\"canvas\");\n  const width = size;\n  const height = size;\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = \"rgb( 63, 63, 63 )\";\n  ctx.textAlign = \"center\";\n  ctx.fillStyle = \"rgb( 255, 255, 255 )\";\n  ctx.fillRect(0, 0, width, height);\n  const index = geometry.index;\n  const uvAttribute = geometry.attributes.uv;\n  if (index) {\n    for (let i = 0, il = index.count; i < il; i += 3) {\n      face[0] = index.getX(i);\n      face[1] = index.getX(i + 1);\n      face[2] = index.getX(i + 2);\n      uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n      uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n      uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n      processFace(face, uvs, i / 3);\n    }\n  } else {\n    for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\n      face[0] = i;\n      face[1] = i + 1;\n      face[2] = i + 2;\n      uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n      uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n      uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n      processFace(face, uvs, i / 3);\n    }\n  }\n  return canvas;\n  function processFace(face2, uvs2, index2) {\n    ctx.beginPath();\n    a.set(0, 0);\n    for (let j = 0, jl = uvs2.length; j < jl; j++) {\n      const uv = uvs2[j];\n      a.x += uv.x;\n      a.y += uv.y;\n      if (j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n    ctx.closePath();\n    ctx.stroke();\n    a.divideScalar(uvs2.length);\n    ctx.font = \"18px Arial\";\n    ctx.fillStyle = \"rgb( 63, 63, 63 )\";\n    ctx.fillText(index2, a.x * width, (1 - a.y) * height);\n    if (a.x > 0.95) {\n      ctx.fillText(index2, a.x % 1 * width, (1 - a.y) * height);\n    }\n    ctx.font = \"12px Arial\";\n    ctx.fillStyle = \"rgb( 191, 191, 191 )\";\n    for (let j = 0, jl = uvs2.length; j < jl; j++) {\n      const uv = uvs2[j];\n      b.addVectors(a, uv).divideScalar(2);\n      const vnum = face2[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n      if (b.x > 0.95) {\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n}\nexport { UVsDebug };","map":{"version":3,"sources":["../../src/utils/UVsDebug.js"],"names":["face","uvs","index"],"mappings":"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","sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\n\nfunction UVsDebug(geometry, size = 1024) {\n  // handles wrapping of uv.x > 1 only\n\n  const abc = 'abc'\n  const a = new Vector2()\n  const b = new Vector2()\n\n  const uvs = [new Vector2(), new Vector2(), new Vector2()]\n\n  const face = []\n\n  const canvas = document.createElement('canvas')\n  const width = size // power of 2 required for wrapping\n  const height = size\n  canvas.width = width\n  canvas.height = height\n\n  const ctx = canvas.getContext('2d')\n  ctx.lineWidth = 1\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )'\n  ctx.textAlign = 'center'\n\n  // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )'\n  ctx.fillRect(0, 0, width, height)\n\n  const index = geometry.index\n  const uvAttribute = geometry.attributes.uv\n\n  if (index) {\n    // indexed geometry\n\n    for (let i = 0, il = index.count; i < il; i += 3) {\n      face[0] = index.getX(i)\n      face[1] = index.getX(i + 1)\n      face[2] = index.getX(i + 2)\n\n      uvs[0].fromBufferAttribute(uvAttribute, face[0])\n      uvs[1].fromBufferAttribute(uvAttribute, face[1])\n      uvs[2].fromBufferAttribute(uvAttribute, face[2])\n\n      processFace(face, uvs, i / 3)\n    }\n  } else {\n    // non-indexed geometry\n\n    for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\n      face[0] = i\n      face[1] = i + 1\n      face[2] = i + 2\n\n      uvs[0].fromBufferAttribute(uvAttribute, face[0])\n      uvs[1].fromBufferAttribute(uvAttribute, face[1])\n      uvs[2].fromBufferAttribute(uvAttribute, face[2])\n\n      processFace(face, uvs, i / 3)\n    }\n  }\n\n  return canvas\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n\n    ctx.beginPath()\n\n    a.set(0, 0)\n\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\n      const uv = uvs[j]\n\n      a.x += uv.x\n      a.y += uv.y\n\n      if (j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5)\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5)\n      }\n    }\n\n    ctx.closePath()\n    ctx.stroke()\n\n    // calculate center of face\n\n    a.divideScalar(uvs.length)\n\n    // label the face number\n\n    ctx.font = '18px Arial'\n    ctx.fillStyle = 'rgb( 63, 63, 63 )'\n    ctx.fillText(index, a.x * width, (1 - a.y) * height)\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n\n      ctx.fillText(index, (a.x % 1) * width, (1 - a.y) * height)\n    }\n\n    //\n\n    ctx.font = '12px Arial'\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'\n\n    // label uv edge orders\n\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\n      const uv = uvs[j]\n      b.addVectors(a, uv).divideScalar(2)\n\n      const vnum = face[j]\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height)\n\n      if (b.x > 0.95) {\n        // wrap x\n\n        ctx.fillText(abc[j] + vnum, (b.x % 1) * width, (1 - b.y) * height)\n      }\n    }\n  }\n}\n\nexport { UVsDebug }\n"]},"metadata":{},"sourceType":"module"}