{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n        return null;\n      }\n      if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n      return null;\n    }\n    if (itemSize === void 0) itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n      return null;\n    }\n    if (normalized === void 0) normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = attributes => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n    // @ts-ignore\n    material2.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };","map":{"version":3,"sources":["../../src/utils/BufferGeometryUtils.ts"],"names":["buffer","object","material","morphTargetsRelative","a","b","c","i","il"],"mappings":"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","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n"]},"metadata":{},"sourceType":"module"}