{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from \"three\";\nimport { createToken, Lexer, CstParser } from \"../libs/chevrotain.js\";\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data2) {\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n      const lexingResult = lexer.lex(data2);\n      parser.input = lexingResult.tokens;\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n      }\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      const RouteIdentifier = createToken({\n        name: \"RouteIdentifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: \"Identifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      });\n      const nodeTypes = [\"Anchor\", \"Billboard\", \"Collision\", \"Group\", \"Transform\",\n      // grouping nodes\n      \"Inline\", \"LOD\", \"Switch\",\n      // special groups\n      \"AudioClip\", \"DirectionalLight\", \"PointLight\", \"Script\", \"Shape\", \"Sound\", \"SpotLight\", \"WorldInfo\",\n      // common nodes\n      \"CylinderSensor\", \"PlaneSensor\", \"ProximitySensor\", \"SphereSensor\", \"TimeSensor\", \"TouchSensor\", \"VisibilitySensor\",\n      // sensors\n      \"Box\", \"Cone\", \"Cylinder\", \"ElevationGrid\", \"Extrusion\", \"IndexedFaceSet\", \"IndexedLineSet\", \"PointSet\", \"Sphere\",\n      // geometries\n      \"Color\", \"Coordinate\", \"Normal\", \"TextureCoordinate\",\n      // geometric properties\n      \"Appearance\", \"FontStyle\", \"ImageTexture\", \"Material\", \"MovieTexture\", \"PixelTexture\", \"TextureTransform\",\n      // appearance\n      \"ColorInterpolator\", \"CoordinateInterpolator\", \"NormalInterpolator\", \"OrientationInterpolator\", \"PositionInterpolator\", \"ScalarInterpolator\",\n      // interpolators\n      \"Background\", \"Fog\", \"NavigationInfo\", \"Viewpoint\",\n      // bindable nodes\n      \"Text\"\n      // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ];\n      const Version = createToken({\n        name: \"Version\",\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: \"NodeName\",\n        pattern: new RegExp(nodeTypes.join(\"|\")),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: \"DEF\",\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: \"USE\",\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: \"ROUTE\",\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: \"TO\",\n        pattern: /TO/,\n        longer_alt: Identifier\n      });\n      const StringLiteral = createToken({\n        name: \"StringLiteral\",\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({\n        name: \"HexLiteral\",\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: \"NumberLiteral\",\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: \"TrueLiteral\",\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: \"FalseLiteral\",\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: \"NullLiteral\",\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: \"LSquare\",\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: \"RSquare\",\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: \"LCurly\",\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: \"RCurly\",\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: \"Comment\",\n        pattern: /#.*/,\n        group: Lexer.SKIPPED\n      });\n      const WhiteSpace = createToken({\n        name: \"WhiteSpace\",\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED\n      });\n      const tokens = [WhiteSpace,\n      // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n      // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return {\n        tokens,\n        tokenVocabulary\n      };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data2 = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data2.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data2.routes.push(this.visit(route));\n            }\n          }\n          return data2;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data2 = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data2.fields.push(this.visit(field));\n            }\n          }\n          if (ctx.def) {\n            data2.DEF = this.visit(ctx.def[0]);\n          }\n          return data2;\n        },\n        field: function (ctx) {\n          const data2 = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result;\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          }\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data2.type = result.type;\n          data2.values = result.values;\n          return data2;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data2 = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data2;\n        }\n      });\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = \"node\";\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = \"use\";\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = \"string\";\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = \"number\";\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = \"hex\";\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === \"TRUE\") field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === \"FALSE\") field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = \"null\";\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree2) {\n      const nodes = tree2.nodes;\n      const scene2 = new Scene();\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      }\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene2.add(object);\n        if (node.name === \"WorldInfo\") scene2.userData.worldInfo = object;\n      }\n      return scene2;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === \"node\") {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== void 0) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    }\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case \"Group\":\n        case \"Transform\":\n        case \"Collision\":\n          build = buildGroupingNode(node);\n          break;\n        case \"Background\":\n          build = buildBackgroundNode(node);\n          break;\n        case \"Shape\":\n          build = buildShapeNode(node);\n          break;\n        case \"Appearance\":\n          build = buildAppearanceNode(node);\n          break;\n        case \"Material\":\n          build = buildMaterialNode(node);\n          break;\n        case \"ImageTexture\":\n          build = buildImageTextureNode(node);\n          break;\n        case \"PixelTexture\":\n          build = buildPixelTextureNode(node);\n          break;\n        case \"TextureTransform\":\n          build = buildTextureTransformNode(node);\n          break;\n        case \"IndexedFaceSet\":\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case \"IndexedLineSet\":\n          build = buildIndexedLineSetNode(node);\n          break;\n        case \"PointSet\":\n          build = buildPointSetNode(node);\n          break;\n        case \"Box\":\n          build = buildBoxNode(node);\n          break;\n        case \"Cone\":\n          build = buildConeNode(node);\n          break;\n        case \"Cylinder\":\n          build = buildCylinderNode(node);\n          break;\n        case \"Sphere\":\n          build = buildSphereNode(node);\n          break;\n        case \"ElevationGrid\":\n          build = buildElevationGridNode(node);\n          break;\n        case \"Extrusion\":\n          build = buildExtrusionNode(node);\n          break;\n        case \"Color\":\n        case \"Coordinate\":\n        case \"Normal\":\n        case \"TextureCoordinate\":\n          build = buildGeometricNode(node);\n          break;\n        case \"WorldInfo\":\n          build = buildWorldInfoNode(node);\n          break;\n        case \"Anchor\":\n        case \"Billboard\":\n        case \"Inline\":\n        case \"LOD\":\n        case \"Switch\":\n        case \"AudioClip\":\n        case \"DirectionalLight\":\n        case \"PointLight\":\n        case \"Script\":\n        case \"Sound\":\n        case \"SpotLight\":\n        case \"CylinderSensor\":\n        case \"PlaneSensor\":\n        case \"ProximitySensor\":\n        case \"SphereSensor\":\n        case \"TimeSensor\":\n        case \"TouchSensor\":\n        case \"VisibilitySensor\":\n        case \"Text\":\n        case \"FontStyle\":\n        case \"MovieTexture\":\n        case \"ColorInterpolator\":\n        case \"CoordinateInterpolator\":\n        case \"NormalInterpolator\":\n        case \"OrientationInterpolator\":\n        case \"PositionInterpolator\":\n        case \"ScalarInterpolator\":\n        case \"Fog\":\n        case \"NavigationInfo\":\n        case \"Viewpoint\":\n          break;\n        default:\n          console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n          break;\n      }\n      if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group();\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bboxCenter\":\n            break;\n          case \"bboxSize\":\n            break;\n          case \"center\":\n            break;\n          case \"children\":\n            parseFieldChildren(fieldValues, object);\n            break;\n          case \"collide\":\n            break;\n          case \"rotation\":\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize();\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case \"scale\":\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"scaleOrientation\":\n            break;\n          case \"translation\":\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"proxy\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"groundAngle\":\n            groundAngle = fieldValues;\n            break;\n          case \"groundColor\":\n            groundColor = fieldValues;\n            break;\n          case \"backUrl\":\n            break;\n          case \"bottomUrl\":\n            break;\n          case \"frontUrl\":\n            break;\n          case \"leftUrl\":\n            break;\n          case \"rightUrl\":\n            break;\n          case \"topUrl\":\n            break;\n          case \"skyAngle\":\n            skyAngle = fieldValues;\n            break;\n          case \"skyColor\":\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const radius = 1e4;\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      }\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      }\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields;\n      let material = new MeshBasicMaterial({\n        color: 0\n      });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"appearance\":\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case \"geometry\":\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === \"points\") {\n          const pointsMaterial = new PointsMaterial({\n            color: 16777215\n          });\n          if (geometry.attributes.color !== void 0) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === \"line\") {\n          const lineMaterial = new LineBasicMaterial({\n            color: 16777215\n          });\n          if (geometry.attributes.color !== void 0) {\n            lineMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          if (geometry._solid !== void 0) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          }\n          if (geometry.attributes.color !== void 0) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D();\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"material\":\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              material = new MeshBasicMaterial({\n                color: 0\n              });\n            }\n            break;\n          case \"texture\":\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                material.map = getNode(textureNode);\n              }\n            }\n            break;\n          case \"textureTransform\":\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (material.map) {\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1;\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(16777215);\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(16777215);\n              material.opacity = 1;\n              break;\n          }\n          delete material.map.__type;\n        }\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"ambientIntensity\":\n            break;\n          case \"diffuseColor\":\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"emissiveColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"shininess\":\n            materialData.shininess = fieldValues[0];\n            break;\n          case \"specularColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"transparency\":\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          value = parseInt(\"0x\" + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt(\"0x\" + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = parseInt(\"0x\" + hex.substring(8, 10));\n          break;\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"image\":\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data2 = new Uint8Array(4 * width * height);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data2[stride + 0] = color.r;\n              data2[stride + 1] = color.g;\n              data2[stride + 2] = color.b;\n              data2[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data2, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType;\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"url\":\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"center\":\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"rotation\":\n            transformData.rotation = fieldValues[0];\n            break;\n          case \"scale\":\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"translation\":\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"title\":\n            worldInfo.title = fieldValues[0];\n            break;\n          case \"info\":\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n        normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalIndex\":\n            normalIndex = fieldValues;\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"texCoordIndex\":\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (coordIndex === void 0) {\n        console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n        return new BufferGeometry();\n      }\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          if (normalIndex && normalIndex.length > 0) {\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          if (normalIndex && normalIndex.length > 0) {\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      if (uvAttribute) geometry.setAttribute(\"uv\", uvAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex);\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            const expandedColorIndex = expandLineIndex(colorIndex);\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            const flattenLineColors = flattenData(color, colorIndex);\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          } else {\n            const expandedLineColors = expandLineData(color, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          }\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      geometry._type = \"line\";\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry._type = \"points\";\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"size\":\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            openEnded = !fieldValues[0];\n            break;\n          case \"bottomRadius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            break;\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          case \"top\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"height\":\n            height = fieldValues;\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"xDimension\":\n            xDimension = fieldValues[0];\n            break;\n          case \"xSpacing\":\n            xSpacing = fieldValues[0];\n            break;\n          case \"zDimension\":\n            zDimension = fieldValues[0];\n            break;\n          case \"zSpacing\":\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          const index = i * xDimension + j;\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z);\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          }\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          }\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      }\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension;\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute;\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2];\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry.setAttribute(\"uv\", uvAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"beginCap\":\n            beginCap = fieldValues[0];\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"crossSection\":\n            crossSection = fieldValues;\n            break;\n          case \"endCap\":\n            endCap = fieldValues[0];\n            break;\n          case \"orientation\":\n            orientation = fieldValues;\n            break;\n          case \"scale\":\n            scale = fieldValues;\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"spine\":\n            spine = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1];\n          vertex.multiply(scaling);\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion);\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      }\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        }\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        }\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1);\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node);\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data2, index) {\n      const flattenData2 = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        flattenData2.push(x, y, z);\n      }\n      return flattenData2;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n      const array = [];\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data2, a * itemSize);\n          uvB.fromArray(data2, b * itemSize);\n          uvC.fromArray(data2, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data2, a * itemSize);\n          vB.fromArray(data2, b * itemSize);\n          vC.fromArray(data2, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {};\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === void 0) vertexNormals[a] = [];\n        if (vertexNormals[b] === void 0) vertexNormals[b] = [];\n        if (vertexNormals[c] === void 0) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      }\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      }\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute(\"color\", colorAttribute);\n    }\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    if (data.indexOf(\"#VRML V2.0\") === -1) {\n      throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n    }\n    const tree = generateVRMLTree(data);\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens);\n  }\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n    }\n    return lexingResult;\n  }\n}\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary[\"Version\"];\n    const LCurly = tokenVocabulary[\"LCurly\"];\n    const RCurly = tokenVocabulary[\"RCurly\"];\n    const LSquare = tokenVocabulary[\"LSquare\"];\n    const RSquare = tokenVocabulary[\"RSquare\"];\n    const Identifier = tokenVocabulary[\"Identifier\"];\n    const RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    const StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    const HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    const NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    const TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    const FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    const NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    const DEF = tokenVocabulary[\"DEF\"];\n    const USE = tokenVocabulary[\"USE\"];\n    const ROUTE = tokenVocabulary[\"ROUTE\"];\n    const TO = tokenVocabulary[\"TO\"];\n    const NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function () {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE(\"def\", function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"use\", function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"singleFieldValue\", function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"sources":["../../src/loaders/VRMLLoader.js"],"names":["data","tree","scene","flattenData"],"mappings":"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","sourcesContent":["import {\n  BackSide,\n  BoxGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  ConeGeometry,\n  CylinderGeometry,\n  DataTexture,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Points,\n  PointsMaterial,\n  Quaternion,\n  RepeatWrapping,\n  Scene,\n  ShapeUtils,\n  SphereGeometry,\n  TextureLoader,\n  Vector2,\n  Vector3,\n} from 'three'\nimport { Lexer, CstParser, createToken } from '../libs/chevrotain'\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, path) {\n    const nodeMap = {}\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n\n      const tokenData = createTokens()\n\n      const lexer = new VRMLLexer(tokenData.tokens)\n      const parser = new VRMLParser(tokenData.tokenVocabulary)\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor())\n\n      // lexing\n\n      const lexingResult = lexer.lex(data)\n      parser.input = lexingResult.tokens\n\n      // parsing\n\n      const cstOutput = parser.vrml()\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors)\n\n        throw Error('THREE.VRMLLoader: Parsing errors detected.')\n      }\n\n      // actions\n\n      const ast = visitor.visit(cstOutput)\n\n      return ast\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n      })\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier,\n      })\n\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = [\n        'Anchor',\n        'Billboard',\n        'Collision',\n        'Group',\n        'Transform', // grouping nodes\n        'Inline',\n        'LOD',\n        'Switch', // special groups\n        'AudioClip',\n        'DirectionalLight',\n        'PointLight',\n        'Script',\n        'Shape',\n        'Sound',\n        'SpotLight',\n        'WorldInfo', // common nodes\n        'CylinderSensor',\n        'PlaneSensor',\n        'ProximitySensor',\n        'SphereSensor',\n        'TimeSensor',\n        'TouchSensor',\n        'VisibilitySensor', // sensors\n        'Box',\n        'Cone',\n        'Cylinder',\n        'ElevationGrid',\n        'Extrusion',\n        'IndexedFaceSet',\n        'IndexedLineSet',\n        'PointSet',\n        'Sphere', // geometries\n        'Color',\n        'Coordinate',\n        'Normal',\n        'TextureCoordinate', // geometric properties\n        'Appearance',\n        'FontStyle',\n        'ImageTexture',\n        'Material',\n        'MovieTexture',\n        'PixelTexture',\n        'TextureTransform', // appearance\n        'ColorInterpolator',\n        'CoordinateInterpolator',\n        'NormalInterpolator',\n        'OrientationInterpolator',\n        'PositionInterpolator',\n        'ScalarInterpolator', // interpolators\n        'Background',\n        'Fog',\n        'NavigationInfo',\n        'Viewpoint', // bindable nodes\n        'Text', // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]\n\n      //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier,\n      })\n\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier,\n      })\n\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier,\n      })\n\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier,\n      })\n\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier,\n      })\n\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier,\n      })\n\n      //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/,\n      })\n      const HexLiteral = createToken({ name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ })\n      const NumberLiteral = createToken({ name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ })\n      const TrueLiteral = createToken({ name: 'TrueLiteral', pattern: /TRUE/ })\n      const FalseLiteral = createToken({ name: 'FalseLiteral', pattern: /FALSE/ })\n      const NullLiteral = createToken({ name: 'NullLiteral', pattern: /NULL/ })\n      const LSquare = createToken({ name: 'LSquare', pattern: /\\[/ })\n      const RSquare = createToken({ name: 'RSquare', pattern: /]/ })\n      const LCurly = createToken({ name: 'LCurly', pattern: /{/ })\n      const RCurly = createToken({ name: 'RCurly', pattern: /}/ })\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED,\n      })\n\n      // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED,\n      })\n\n      const tokens = [\n        WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName,\n        DEF,\n        USE,\n        ROUTE,\n        TO,\n        TrueLiteral,\n        FalseLiteral,\n        NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version,\n        Identifier,\n        RouteIdentifier,\n        StringLiteral,\n        HexLiteral,\n        NumberLiteral,\n        LSquare,\n        RSquare,\n        LCurly,\n        RCurly,\n        Comment,\n      ]\n\n      const tokenVocabulary = {}\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i]\n\n        tokenVocabulary[token.name] = token\n      }\n\n      return { tokens: tokens, tokenVocabulary: tokenVocabulary }\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this)\n\n        this.validateVisitor()\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: [],\n          }\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            data.nodes.push(this.visit(node))\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i]\n\n              data.routes.push(this.visit(route))\n            }\n          }\n\n          return data\n        },\n\n        version: function (ctx) {\n          return ctx.Version[0].image\n        },\n\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: [],\n          }\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i]\n\n              data.fields.push(this.visit(field))\n            }\n          }\n\n          // DEF\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0])\n          }\n\n          return data\n        },\n\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null,\n          }\n\n          let result\n\n          // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0])\n          }\n\n          // MFValue\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0])\n          }\n\n          data.type = result.type\n          data.values = result.values\n\n          return data\n        },\n\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image\n        },\n\n        use: function (ctx) {\n          return { USE: (ctx.Identifier || ctx.NodeName)[0].image }\n        },\n\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image,\n          }\n\n          return data\n        },\n      })\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: [],\n        }\n\n        if (ctx.node) {\n          field.type = 'node'\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            field.values.push(scope.visit(node))\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use'\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i]\n\n            field.values.push(scope.visit(use))\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string'\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i]\n\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''))\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number'\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i]\n\n            field.values.push(parseFloat(numberLiteral.image))\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex'\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i]\n\n            field.values.push(hexLiteral.image)\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i]\n\n            if (trueLiteral.image === 'TRUE') field.values.push(true)\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i]\n\n            if (falseLiteral.image === 'FALSE') field.values.push(false)\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null'\n\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null)\n          })\n        }\n\n        return field\n      }\n\n      return new VRMLToASTVisitor()\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n\n      const nodes = tree.nodes\n      const scene = new Scene()\n\n      // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n\n        buildNodeMap(node)\n      }\n\n      // second iteration: build nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n        const object = getNode(node)\n\n        if (object instanceof Object3D) scene.add(object)\n\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object\n      }\n\n      return scene\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n\n        if (field.type === 'node') {\n          const fieldValues = field.values\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j])\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n\n      if (node.USE) {\n        return resolveUSE(node.USE)\n      }\n\n      if (node.build !== undefined) return node.build\n\n      node.build = buildNode(node)\n\n      return node.build\n    }\n\n    // node builder\n\n    function buildNode(node) {\n      const nodeName = node.name\n      let build\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node)\n          break\n\n        case 'Background':\n          build = buildBackgroundNode(node)\n          break\n\n        case 'Shape':\n          build = buildShapeNode(node)\n          break\n\n        case 'Appearance':\n          build = buildAppearanceNode(node)\n          break\n\n        case 'Material':\n          build = buildMaterialNode(node)\n          break\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node)\n          break\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node)\n          break\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node)\n          break\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node)\n          break\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node)\n          break\n\n        case 'PointSet':\n          build = buildPointSetNode(node)\n          break\n\n        case 'Box':\n          build = buildBoxNode(node)\n          break\n\n        case 'Cone':\n          build = buildConeNode(node)\n          break\n\n        case 'Cylinder':\n          build = buildCylinderNode(node)\n          break\n\n        case 'Sphere':\n          build = buildSphereNode(node)\n          break\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node)\n          break\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node)\n          break\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node)\n          break\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node)\n          break\n\n        case 'Anchor':\n        case 'Billboard':\n\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n\n        case 'Text':\n\n        case 'FontStyle':\n        case 'MovieTexture':\n\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName)\n          break\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF\n      }\n\n      return build\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group()\n\n      //\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break\n\n          case 'bboxSize':\n            // field not supported\n            break\n\n          case 'center':\n            // field not supported\n            break\n\n          case 'children':\n            parseFieldChildren(fieldValues, object)\n            break\n\n          case 'collide':\n            // field not supported\n            break\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize()\n            const angle = fieldValues[3]\n            object.quaternion.setFromAxisAngle(axis, angle)\n            break\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'scaleOrientation':\n            // field not supported\n            break\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'proxy':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return object\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group()\n\n      let groundAngle, groundColor\n      let skyAngle, skyColor\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues\n            break\n\n          case 'groundColor':\n            groundColor = fieldValues\n            break\n\n          case 'backUrl':\n            // field not supported\n            break\n\n          case 'bottomUrl':\n            // field not supported\n            break\n\n          case 'frontUrl':\n            // field not supported\n            break\n\n          case 'leftUrl':\n            // field not supported\n            break\n\n          case 'rightUrl':\n            // field not supported\n            break\n\n          case 'topUrl':\n            // field not supported\n            break\n\n          case 'skyAngle':\n            skyAngle = fieldValues\n            break\n\n          case 'skyColor':\n            skyColor = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const radius = 10000\n\n      // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16)\n        const skyMaterial = new MeshBasicMaterial({ fog: false, side: BackSide, depthWrite: false, depthTest: false })\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true)\n          skyMaterial.vertexColors = true\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2])\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial)\n        group.add(sky)\n      }\n\n      // ground\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI)\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false,\n          })\n\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false)\n\n          const ground = new Mesh(groundGeometry, groundMaterial)\n          group.add(ground)\n        }\n      }\n\n      // render background group first\n\n      group.renderOrder = -Infinity\n\n      return group\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields\n\n      // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({ color: 0x000000 })\n      let geometry\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0])\n            }\n\n            break\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build 3D object\n\n      let object\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type\n\n        if (type === 'points') {\n          // points\n\n          const pointsMaterial = new PointsMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial)\n        } else if (type === 'line') {\n          // lines\n\n          const lineMaterial = new LineBasicMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial)\n        } else {\n          // consider meshes\n\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide\n          }\n\n          // check for vertex colors\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true\n          }\n\n          object = new Mesh(geometry, material)\n        }\n      } else {\n        object = new Object3D()\n\n        // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false\n      }\n\n      return object\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial()\n      let transformData\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0])\n\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor)\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor)\n              if (materialData.shininess) material.shininess = materialData.shininess\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor)\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency\n              if (materialData.transparency > 0) material.transparent = true\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n              material = new MeshBasicMaterial({ color: 0x000000 })\n            }\n\n            break\n\n          case 'texture':\n            const textureNode = fieldValues[0]\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode)\n              } else {\n                // MovieTexture not supported yet\n              }\n            }\n\n            break\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // only apply texture transform data if a texture was defined\n\n      if (material.map) {\n        // respect VRML lighting model\n\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1 // ignore transparency\n              break\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff) // ignore material color\n              break\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff) // ignore material color\n              material.opacity = 1 // ignore transparency\n              break\n\n            default:\n          }\n\n          delete material.map.__type\n        }\n\n        // apply texture transform\n\n        if (transformData) {\n          material.map.center.copy(transformData.center)\n          material.map.rotation = transformData.rotation\n          material.map.repeat.copy(transformData.scale)\n          material.map.offset.copy(transformData.translation)\n        }\n      }\n\n      return material\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0]\n            break\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return materialData\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex)\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4))\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = parseInt('0x' + hex.substring(4, 6))\n          break\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = parseInt('0x' + hex.substring(8, 10))\n          break\n\n        default:\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY\n          break\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA\n          break\n\n        case 3:\n          type = TEXTURE_TYPE.RGB\n          break\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA\n          break\n\n        default:\n      }\n\n      return type\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0]\n            const height = fieldValues[1]\n            const num_components = fieldValues[2]\n\n            const textureType = getTextureType(num_components)\n\n            const data = new Uint8Array(4 * width * height)\n\n            const color = { r: 0, g: 0, b: 0, a: 0 }\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color)\n\n              const stride = k * 4\n\n              data[stride + 0] = color.r\n              data[stride + 1] = color.g\n              data[stride + 2] = color.b\n              data[stride + 3] = color.a\n            }\n\n            texture = new DataTexture(data, width, height)\n            texture.needsUpdate = true\n            texture.__type = textureType // needed for material modifications\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildImageTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0]\n            if (url) texture = textureLoader.load(url)\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2(),\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0]\n            break\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1])\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return transformData\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0]\n            break\n\n          case 'info':\n            worldInfo.info = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return worldInfo\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0\n      let colorIndex, coordIndex, normalIndex, texCoordIndex\n      let colorPerVertex = true,\n        normalPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalIndex':\n            normalIndex = fieldValues\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.')\n\n        return new BufferGeometry() // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw)\n\n      let colorAttribute\n      let normalAttribute\n      let uvAttribute\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw)\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3)\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n            const flattenFaceColors = flattenData(color, colorIndex)\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw)\n            normalAttribute = computeAttributeFromIndexedData(\n              triangulatedCoordIndex,\n              triangulatedNormalIndex,\n              normal,\n              3,\n            )\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3))\n          }\n        } else {\n          // consider face normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n            const flattenFaceNormals = flattenData(normal, normalIndex)\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle)\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw)\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2)\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2))\n        }\n      }\n\n      const geometry = new BufferGeometry()\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3))\n\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n\n      // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord\n      let colorIndex, coordIndex\n      let colorPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build lines\n\n      let colorAttribute\n\n      const expandedLineIndex = expandLineIndex(coordIndex) // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n            const expandedColorIndex = expandLineIndex(colorIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n            const flattenLineColors = flattenData(color, colorIndex) // compute colors for each VRML primitve\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            const expandedLineColors = expandLineData(color, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          }\n        }\n      }\n\n      //\n\n      const geometry = new BufferGeometry()\n\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3))\n      geometry.setAttribute('position', positionAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      geometry._type = 'line'\n\n      return geometry\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BufferGeometry()\n\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3))\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n      geometry._type = 'points'\n\n      return geometry\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2)\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0]\n            size.y = fieldValues[1]\n            size.z = fieldValues[2]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z)\n\n      return geometry\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0]\n            break\n\n          case 'bottomRadius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded)\n\n      return geometry\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break\n\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          case 'top':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1)\n\n      return geometry\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16)\n\n      return geometry\n    }\n\n    function buildElevationGridNode(node) {\n      let color\n      let normal\n      let texCoord\n      let height\n\n      let colorPerVertex = true\n      let normalPerVertex = true\n      let solid = true\n      let ccw = true\n      let creaseAngle = 0\n      let xDimension = 2\n      let zDimension = 2\n      let xSpacing = 1\n      let zSpacing = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'height':\n            height = fieldValues\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'xDimension':\n            xDimension = fieldValues[0]\n            break\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0]\n            break\n\n          case 'zDimension':\n            zDimension = fieldValues[0]\n            break\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // vertex data\n\n      const vertices = []\n      const normals = []\n      const colors = []\n      const uvs = []\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n\n          const index = i * xDimension + j\n\n          // vertices\n\n          const x = xSpacing * i\n          const y = height[index]\n          const z = zSpacing * j\n\n          vertices.push(x, y, z)\n\n          // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0]\n            const g = color[index * 3 + 1]\n            const b = color[index * 3 + 2]\n\n            colors.push(r, g, b)\n          }\n\n          // normals\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0]\n            const yn = normal[index * 3 + 1]\n            const zn = normal[index * 3 + 2]\n\n            normals.push(xn, yn, zn)\n          }\n\n          // uvs\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0]\n            const t = texCoord[index * 2 + 1]\n\n            uvs.push(s, t)\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1))\n          }\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n          const a = i + j * xDimension\n          const b = i + (j + 1) * xDimension\n          const c = i + 1 + (j + 1) * xDimension\n          const d = i + 1 + j * xDimension\n\n          // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b)\n            indices.push(c, a, d)\n          } else {\n            indices.push(a, b, c)\n            indices.push(c, d, a)\n          }\n        }\n      }\n\n      //\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2))\n      let colorAttribute\n      let normalAttribute\n\n      // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const r = color[index * 3 + 0]\n              const g = color[index * 3 + 1]\n              const b = color[index * 3 + 2]\n\n              // one color per quad\n\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3)\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3))\n        }\n      }\n\n      // normal attribute\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const xn = normal[index * 3 + 0]\n              const yn = normal[index * 3 + 1]\n              const zn = normal[index * 3 + 2]\n\n              // one normal per quad\n\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3)\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3))\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n      }\n\n      // build geometry\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      geometry.setAttribute('uv', uvAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1]\n      let spine = [0, 0, 0, 0, 1, 0]\n      let scale\n      let orientation\n\n      let beginCap = true\n      let ccw = true\n      let creaseAngle = 0\n      let endCap = true\n      let solid = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0]\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'crossSection':\n            crossSection = fieldValues\n            break\n\n          case 'endCap':\n            endCap = fieldValues[0]\n            break\n\n          case 'orientation':\n            orientation = fieldValues\n            break\n\n          case 'scale':\n            scale = fieldValues\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'spine':\n            spine = fieldValues // only extrusion along the Y-axis are supported so far\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const crossSectionClosed =\n        crossSection[0] === crossSection[crossSection.length - 2] &&\n        crossSection[1] === crossSection[crossSection.length - 1]\n\n      // vertices\n\n      const vertices = []\n      const spineVector = new Vector3()\n      const scaling = new Vector3()\n\n      const axis = new Vector3()\n      const vertex = new Vector3()\n      const quaternion = new Quaternion()\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i)\n\n        scaling.x = scale ? scale[j + 0] : 1\n        scaling.y = 1\n        scaling.z = scale ? scale[j + 1] : 1\n\n        axis.x = orientation ? orientation[o + 0] : 0\n        axis.y = orientation ? orientation[o + 1] : 0\n        axis.z = orientation ? orientation[o + 2] : 1\n        const angle = orientation ? orientation[o + 3] : 0\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0]\n          vertex.y = 0\n          vertex.z = crossSection[k + 1]\n\n          // scale\n\n          vertex.multiply(scaling)\n\n          // rotate\n\n          quaternion.setFromAxisAngle(axis, angle)\n          vertex.applyQuaternion(quaternion)\n\n          // translate\n\n          vertex.add(spineVector)\n\n          vertices.push(vertex.x, vertex.y, vertex.z)\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      const spineCount = spine.length / 3\n      const crossSectionCount = crossSection.length / 2\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount\n          let b = j + 1 + i * crossSectionCount\n          const c = j + (i + 1) * crossSectionCount\n          let d = j + 1 + (i + 1) * crossSectionCount\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount\n            d = (i + 1) * crossSectionCount\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c)\n            indices.push(c, b, d)\n          } else {\n            indices.push(a, c, b)\n            indices.push(c, d, b)\n          }\n        }\n      }\n\n      // triangulate cap\n\n      if (beginCap === true || endCap === true) {\n        const contour = []\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]))\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, [])\n        const capIndices = []\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i]\n\n          capIndices.push(face[0], face[1], face[2])\n        }\n\n        // begin cap\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2])\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1])\n            }\n          }\n        }\n\n        // end cap\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1) // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 2],\n                indexOffset + capIndices[i + 1],\n              )\n            } else {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 1],\n                indexOffset + capIndices[i + 2],\n              )\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      // no uvs yet\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    // helper functions\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier]\n      const build = getNode(node)\n\n      // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i])\n\n        if (object instanceof Object3D) owner.add(object)\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []\n\n      // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start]\n        const i2 = index[i + (ccw ? 1 : 2)]\n        const i3 = index[i + (ccw ? 2 : 1)]\n\n        indices.push(i1, i2, i3)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start = i + 1\n        }\n      }\n\n      return indices\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    function flattenData(data, index) {\n      const flattenData = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n\n        const stride = i1 * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        flattenData.push(x, y, z)\n      }\n\n      return flattenData\n    }\n\n    function expandLineIndex(index) {\n      const indices = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n        const i2 = index[i + 1]\n\n        indices.push(i1, i2)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n        }\n      }\n\n      return indices\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    const vA = new Vector3()\n    const vB = new Vector3()\n    const vC = new Vector3()\n\n    const uvA = new Vector2()\n    const uvB = new Vector2()\n    const uvC = new Vector2()\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []\n\n      // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize)\n          uvB.fromArray(data, b * itemSize)\n          uvC.fromArray(data, c * itemSize)\n\n          array.push(uvA.x, uvA.y)\n          array.push(uvB.x, uvB.y)\n          array.push(uvC.x, uvC.y)\n        } else {\n          vA.fromArray(data, a * itemSize)\n          vB.fromArray(data, b * itemSize)\n          vC.fromArray(data, c * itemSize)\n\n          array.push(vA.x, vA.y, vA.z)\n          array.push(vB.x, vB.y, vB.z)\n          array.push(vC.x, vC.y, vC.z)\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize)\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      const array2 = new array.constructor(indices.length * itemSize)\n\n      let index = 0,\n        index2 = 0\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++]\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize)\n    }\n\n    const ab = new Vector3()\n    const cb = new Vector3()\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = []\n      const vertexNormals = {}\n\n      // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        const face = new Face(a, b, c)\n\n        vA.fromArray(coord, a * 3)\n        vB.fromArray(coord, b * 3)\n        vC.fromArray(coord, c * 3)\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        cb.normalize()\n\n        face.normal.copy(cb)\n\n        if (vertexNormals[a] === undefined) vertexNormals[a] = []\n        if (vertexNormals[b] === undefined) vertexNormals[b] = []\n        if (vertexNormals[c] === undefined) vertexNormals[c] = []\n\n        vertexNormals[a].push(face.normal)\n        vertexNormals[b].push(face.normal)\n        vertexNormals[c].push(face.normal)\n\n        faces.push(face)\n      }\n\n      // compute vertex normals and build final geometry\n\n      const normals = []\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i]\n\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle)\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle)\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle)\n\n        vA.fromArray(coord, face.a * 3)\n        vB.fromArray(coord, face.b * 3)\n        vC.fromArray(coord, face.c * 3)\n\n        normals.push(nA.x, nA.y, nA.z)\n        normals.push(nB.x, nB.y, nB.z)\n        normals.push(nC.x, nC.y, nC.z)\n      }\n\n      return new Float32BufferAttribute(normals, 3)\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3()\n\n      if (creaseAngle === 0) {\n        normal.copy(vector)\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i])\n          }\n        }\n      }\n\n      return normal.normalize()\n    }\n\n    function toColorArray(colors) {\n      const array = []\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]))\n      }\n\n      return array\n    }\n\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n\n      const thresholds = []\n      const startAngle = topDown === true ? 0 : Math.PI\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1]\n        angle = topDown === true ? angle : startAngle - angle\n\n        const point = new Vector3()\n        point.setFromSphericalCoords(radius, angle, 0)\n\n        thresholds.push(point)\n      }\n\n      // generate vertex colors\n\n      const indices = geometry.index\n      const positionAttribute = geometry.attributes.position\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3)\n\n      const position = new Vector3()\n      const color = new Color()\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i)\n        position.fromBufferAttribute(positionAttribute, index)\n\n        let thresholdIndexA, thresholdIndexB\n        let t = 1\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1\n          thresholdIndexB = j\n\n          const thresholdA = thresholds[thresholdIndexA]\n          const thresholdB = thresholds[thresholdIndexB]\n\n          if (topDown === true) {\n            // interpolation for sky color\n\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          } else {\n            // interpolation for ground color\n\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA]\n        const colorB = colors[thresholdIndexB]\n\n        color.copy(colorA).lerp(colorB, t)\n\n        colorAttribute.setXYZ(index, color.r, color.g, color.b)\n      }\n\n      geometry.setAttribute('color', colorAttribute)\n    }\n\n    //\n\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.')\n    }\n\n    // create JSON representing the tree structure of the VRML asset\n\n    const tree = generateVRMLTree(data)\n\n    // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree)\n\n    return scene\n  }\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens)\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText)\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors)\n\n      throw Error('THREE.VRMLLexer: Lexing errors detected.')\n    }\n\n    return lexingResult\n  }\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary)\n\n    const $ = this\n\n    const Version = tokenVocabulary['Version']\n    const LCurly = tokenVocabulary['LCurly']\n    const RCurly = tokenVocabulary['RCurly']\n    const LSquare = tokenVocabulary['LSquare']\n    const RSquare = tokenVocabulary['RSquare']\n    const Identifier = tokenVocabulary['Identifier']\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier']\n    const StringLiteral = tokenVocabulary['StringLiteral']\n    const HexLiteral = tokenVocabulary['HexLiteral']\n    const NumberLiteral = tokenVocabulary['NumberLiteral']\n    const TrueLiteral = tokenVocabulary['TrueLiteral']\n    const FalseLiteral = tokenVocabulary['FalseLiteral']\n    const NullLiteral = tokenVocabulary['NullLiteral']\n    const DEF = tokenVocabulary['DEF']\n    const USE = tokenVocabulary['USE']\n    const ROUTE = tokenVocabulary['ROUTE']\n    const TO = tokenVocabulary['TO']\n    const NodeName = tokenVocabulary['NodeName']\n\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version)\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node)\n      })\n      $.MANY(function () {\n        $.SUBRULE($.route)\n      })\n    })\n\n    $.RULE('version', function () {\n      $.CONSUME(Version)\n    })\n\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def)\n      })\n\n      $.CONSUME(NodeName)\n      $.CONSUME(LCurly)\n      $.MANY(function () {\n        $.SUBRULE($.field)\n      })\n      $.CONSUME(RCurly)\n    })\n\n    $.RULE('field', function () {\n      $.CONSUME(Identifier)\n\n      $.OR2([\n        {\n          ALT: function () {\n            $.SUBRULE($.singleFieldValue)\n          },\n        },\n        {\n          ALT: function () {\n            $.SUBRULE($.multiFieldValue)\n          },\n        },\n      ])\n    })\n\n    $.RULE('def', function () {\n      $.CONSUME(DEF)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('use', function () {\n      $.CONSUME(USE)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(TrueLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(FalseLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n    })\n\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare)\n      $.MANY(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n      $.CONSUME(RSquare)\n    })\n\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE)\n      $.CONSUME(RouteIdentifier)\n      $.CONSUME(TO)\n      $.CONSUME2(RouteIdentifier)\n    })\n\n    this.performSelfAnalysis()\n  }\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a\n    this.b = b\n    this.c = c\n    this.normal = new Vector3()\n  }\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4,\n}\n\nexport { VRMLLoader }\n"]},"metadata":{},"sourceType":"module"}