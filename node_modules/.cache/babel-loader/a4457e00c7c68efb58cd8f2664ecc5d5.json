{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nconst _BasisTextureLoader = class extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = \"\";\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.workerConfig = null;\n  }\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n      etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n      etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n      dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n      bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n      pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n    };\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setWithCredentials(this.withCredentials);\n    const texture = new CompressedTexture();\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  }\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync(options) {\n    const {\n      levels\n    } = options;\n    const buffers = /* @__PURE__ */new Set();\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n    return this._createTexture(Array.from(buffers), {\n      ...options,\n      lowLevel: true\n    });\n  }\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    let worker;\n    let taskID;\n    const taskConfig = config;\n    let taskCost = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n    const texturePending = this._allocateWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"transcode\",\n          id: taskID,\n          buffers,\n          taskConfig\n        }, buffers);\n      });\n    }).then(message => {\n      const {\n        mipmaps,\n        width,\n        height,\n        format\n      } = message;\n      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    });\n    texturePending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    });\n    _taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n    return texturePending;\n  }\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load(\"basis_transcoder.js\", resolve, void 0, reject);\n      });\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load(\"basis_transcoder.wasm\", resolve, void 0, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n        const fn = _BasisTextureLoader.BasisWorker.toString();\n        const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_BasisTextureLoader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_BasisTextureLoader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_BasisTextureLoader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent2;\n      });\n    }\n    return this.transcoderPending;\n  }\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary\n        });\n        worker2.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"transcode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n};\nlet BasisTextureLoader = _BasisTextureLoader;\n/* CONSTANTS */\n__publicField(BasisTextureLoader, \"BasisFormat\", {\n  ETC1S: 0,\n  UASTC_4x4: 1\n});\n__publicField(BasisTextureLoader, \"TranscoderFormat\", {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n});\n__publicField(BasisTextureLoader, \"EngineFormat\", {\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format\n});\n/* WEB WORKER */\n__publicField(BasisTextureLoader, \"BasisWorker\", function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat;\n  const TranscoderFormat = _TranscoderFormat;\n  const BasisFormat = _BasisFormat;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n      case \"transcode\":\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n            const buffers = [];\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n            self.postMessage({\n              type: \"transcode\",\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule);\n    }).then(() => {\n      BasisModule.initializeBasis();\n    });\n  }\n  function transcodeLowLevel(taskConfig) {\n    const {\n      basisFormat,\n      width,\n      height,\n      hasAlpha\n    } = taskConfig;\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), \"THREE.BasisTextureLoader: Unsupported format.\");\n    const mipmaps = [];\n    if (basisFormat === BasisFormat.ETC1S) {\n      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      const {\n        endpointCount,\n        endpointsData,\n        selectorCount,\n        selectorsData,\n        tablesData\n      } = taskConfig.globalData;\n      try {\n        let ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, \"THREE.BasisTextureLoader: decodePalettes() failed.\");\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, \"THREE.BasisTextureLoader: decodeTables() failed.\");\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i];\n          const imageDesc = taskConfig.globalData.imageDescs[i];\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          const dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, \"THREE.BasisTextureLoader: transcodeImage() failed for level \" + level.index + \".\");\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (let i = 0; i < taskConfig.levels.length; i++) {\n        const level = taskConfig.levels[i];\n        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        const dst = new Uint8Array(dstByteLength);\n        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, \"THREE.BasisTextureLoader: transcodeUASTCImage() failed for level \" + level.index + \".\");\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n  function transcode(buffer) {\n    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = basisFile.getImageWidth(0, 0);\n    const height = basisFile.getImageHeight(0, 0);\n    const levels = basisFile.getNumLevels(0);\n    const hasAlpha = basisFile.getHasAlpha();\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error(\"THREE.BasisTextureLoader:\tInvalid texture\");\n    }\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error(\"THREE.BasisTextureLoader: .startTranscoding failed\");\n    }\n    const mipmaps = [];\n    for (let mip = 0; mip < levels; mip++) {\n      const mipWidth = basisFile.getImageWidth(0, mip);\n      const mipHeight = basisFile.getImageHeight(0, mip);\n      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n      if (!status) {\n        cleanup();\n        throw new Error(\"THREE.BasisTextureLoader: .transcodeImage failed.\");\n      }\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n  const FORMAT_OPTIONS = [{\n    if: \"astcSupported\",\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: \"bptcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: \"dxtSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc2Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc1Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: \"pvrtcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    console.warn(\"THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.\");\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      const paddedWidth = width + 3 & ~3;\n      const paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n});\nexport { BasisTextureLoader };","map":{"version":3,"sources":["../../src/loaders/BasisTextureLoader.js"],"names":["jsContent","binaryContent","worker"],"mappings":"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","sourcesContent":["import {\n  CompressedTexture,\n  FileLoader,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  UnsignedByteType,\n} from 'three'\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap()\n\nclass BasisTextureLoader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    const EngineFormat = _EngineFormat\n    const TranscoderFormat = _TranscoderFormat\n    const BasisFormat = _BasisFormat\n\n    onmessage = function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel\n                ? transcodeLowLevel(message.taskConfig)\n                : transcode(message.buffers[0])\n\n              const buffers = []\n\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer)\n              }\n\n              self.postMessage({ type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format }, buffers)\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    }\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n      })\n    }\n\n    function transcodeLowLevel(taskConfig) {\n      const { basisFormat, width, height, hasAlpha } = taskConfig\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.')\n\n      const mipmaps = []\n\n      if (basisFormat === BasisFormat.ETC1S) {\n        const transcoder = new BasisModule.LowLevelETC1SImageTranscoder()\n\n        const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData\n\n        try {\n          let ok\n\n          ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.')\n\n          ok = transcoder.decodeTables(tablesData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.')\n\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i]\n            const imageDesc = taskConfig.globalData.imageDescs[i]\n\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n            const dst = new Uint8Array(dstByteLength)\n\n            ok = transcoder.transcodeImage(\n              transcoderFormat,\n              dst,\n              dstByteLength / blockByteLength,\n              level.data,\n              getWidthInBlocks(transcoderFormat, level.width),\n              getHeightInBlocks(transcoderFormat, level.height),\n              level.width,\n              level.height,\n              level.index,\n              imageDesc.rgbSliceByteOffset,\n              imageDesc.rgbSliceByteLength,\n              imageDesc.alphaSliceByteOffset,\n              imageDesc.alphaSliceByteLength,\n              imageDesc.imageFlags,\n              hasAlpha,\n              false,\n              0,\n              0,\n            )\n\n            assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.')\n\n            mipmaps.push({ data: dst, width: level.width, height: level.height })\n          }\n        } finally {\n          transcoder.delete()\n        }\n      } else {\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i]\n\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n          const dst = new Uint8Array(dstByteLength)\n\n          const ok = BasisModule.transcodeUASTCImage(\n            transcoderFormat,\n            dst,\n            dstByteLength / blockByteLength,\n            level.data,\n            getWidthInBlocks(transcoderFormat, level.width),\n            getHeightInBlocks(transcoderFormat, level.height),\n            level.width,\n            level.height,\n            level.index,\n            0,\n            level.data.byteLength,\n            0,\n            hasAlpha,\n            false,\n            0,\n            0,\n            -1,\n            -1,\n          )\n\n          assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.')\n\n          mipmaps.push({ data: dst, width: level.width, height: level.height })\n        }\n      }\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    function transcode(buffer) {\n      const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer))\n\n      const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = basisFile.getImageWidth(0, 0)\n      const height = basisFile.getImageHeight(0, 0)\n      const levels = basisFile.getNumLevels(0)\n      const hasAlpha = basisFile.getHasAlpha()\n\n      function cleanup() {\n        basisFile.close()\n        basisFile.delete()\n      }\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levels) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader:\tInvalid texture')\n      }\n\n      if (!basisFile.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader: .startTranscoding failed')\n      }\n\n      const mipmaps = []\n\n      for (let mip = 0; mip < levels; mip++) {\n        const mipWidth = basisFile.getImageWidth(0, mip)\n        const mipHeight = basisFile.getImageHeight(0, mip)\n        const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat))\n\n        const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha)\n\n        if (!status) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.')\n        }\n\n        mipmaps.push({ data: dst, width: mipWidth, height: mipHeight })\n      }\n\n      cleanup()\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function assert(ok, message) {\n      if (!ok) throw new Error(message)\n    }\n\n    function getWidthInBlocks(transcoderFormat, width) {\n      return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat))\n    }\n\n    function getHeightInBlocks(transcoderFormat, height) {\n      return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat))\n    }\n\n    function getTranscodedImageByteLength(transcoderFormat, width, height) {\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n        return width * height * blockByteLength\n      }\n\n      if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n        // GL requires extra padding for very small textures:\n        // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n        const paddedWidth = (width + 3) & ~3\n        const paddedHeight = (height + 3) & ~3\n\n        return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8\n      }\n\n      return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = null\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    const texture = new CompressedTexture()\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture([buffer])\n          .then(function (_texture) {\n            texture.copy(_texture)\n            texture.needsUpdate = true\n\n            if (onLoad) onLoad(texture)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n\n    return texture\n  }\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync(options) {\n    const { levels } = options\n\n    const buffers = new Set()\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer)\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options, lowLevel: true })\n  }\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    let worker\n    let taskID\n\n    const taskConfig = config\n    let taskCost = 0\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength\n    }\n\n    const texturePending = this._allocateWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'transcode', id: taskID, buffers: buffers, taskConfig: taskConfig }, buffers)\n        })\n      })\n      .then((message) => {\n        const { mipmaps, width, height, format } = message\n\n        const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n        texture.magFilter = LinearFilter\n        texture.generateMipmaps = false\n        texture.needsUpdate = true\n\n        return texture\n      })\n\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    texturePending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost\n          delete worker._callbacks[taskID]\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffers[0], { promise: texturePending })\n\n    return texturePending\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject)\n      })\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject)\n      })\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n      })\n    }\n\n    return this.transcoderPending\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\nexport { BasisTextureLoader }\n"]},"metadata":{},"sourceType":"module"}