{"ast":null,"code":"import { Vector2, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter, RGBAFormat } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    var _a, _b;\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_a = options.normalEdgeStrength) != null ? _a : 0.3;\n    this.depthEdgeStrength = (_b = options.depthEdgeStrength) != null ? _b : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    var _a, _b, _c;\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const {\n      x,\n      y\n    } = this.renderResolution;\n    (_a = this.rgbRenderTarget) == null ? void 0 : _a.setSize(x, y);\n    (_b = this.normalRenderTarget) == null ? void 0 : _b.setSize(x, y);\n    (_c = this.fsQuad) == null ? void 0 : _c.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n    }\n    this.fsQuad.render(renderer);\n  }\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        tDepth: {\n          value: null\n        },\n        tNormal: {\n          value: null\n        },\n        resolution: {\n          value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)\n        },\n        normalEdgeStrength: {\n          value: 0\n        },\n        depthEdgeStrength: {\n          value: 0\n        }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n}\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? void 0 : {\n    depthTexture: new DepthTexture(resolution.x, resolution.y),\n    depthBuffer: true\n  });\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\nexport { RenderPixelatedPass };","map":{"version":3,"sources":["../../src/postprocessing/RenderPixelatedPass.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  WebGLRenderTarget,\n  RGBAFormat,\n  MeshNormalMaterial,\n  ShaderMaterial,\n  Vector2,\n  Vector4,\n  DepthTexture,\n  NearestFilter,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\n\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    super()\n\n    this.pixelSize = pixelSize\n    this.resolution = new Vector2()\n    this.renderResolution = new Vector2()\n    this.setSize(resolution.x, resolution.y)\n\n    this.fsQuad = new FullScreenQuad(this.material())\n    this.scene = scene\n    this.camera = camera\n\n    this.normalEdgeStrength = options.normalEdgeStrength ?? 0.3\n    this.depthEdgeStrength = options.depthEdgeStrength ?? 0.4\n\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true)\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false)\n\n    this.normalMaterial = new MeshNormalMaterial()\n  }\n\n  dispose() {\n    this.rgbRenderTarget.dispose()\n    this.normalRenderTarget.dispose()\n    this.fsQuad.dispose()\n  }\n\n  setSize(width, height) {\n    this.resolution.set(width, height)\n    this.renderResolution.set((width / this.pixelSize) | 0, (height / this.pixelSize) | 0)\n    const { x, y } = this.renderResolution\n    this.rgbRenderTarget?.setSize(x, y)\n    this.normalRenderTarget?.setSize(x, y)\n    this.fsQuad?.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y)\n  }\n\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize\n    this.setSize(this.resolution.x, this.resolution.y)\n  }\n\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength\n\n    renderer.setRenderTarget(this.rgbRenderTarget)\n    renderer.render(this.scene, this.camera)\n\n    const overrideMaterial_old = this.scene.overrideMaterial\n    renderer.setRenderTarget(this.normalRenderTarget)\n    this.scene.overrideMaterial = this.normalMaterial\n    renderer.render(this.scene, this.camera)\n    this.scene.overrideMaterial = overrideMaterial_old\n\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture\n    uniforms.tNormal.value = this.normalRenderTarget.texture\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n    } else {\n      renderer.setRenderTarget(writeBuffer)\n\n      if (this.clear) renderer.clear()\n    }\n\n    this.fsQuad.render(renderer)\n  }\n\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: { value: null },\n        tDepth: { value: null },\n        tNormal: { value: null },\n        resolution: {\n          value: new Vector4(\n            this.renderResolution.x,\n            this.renderResolution.y,\n            1 / this.renderResolution.x,\n            1 / this.renderResolution.y,\n          ),\n        },\n        normalEdgeStrength: { value: 0 },\n        depthEdgeStrength: { value: 0 },\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`,\n    })\n  }\n}\n\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(\n    resolution.x,\n    resolution.y,\n    !useDepthTexture\n      ? undefined\n      : {\n          depthTexture: new DepthTexture(resolution.x, resolution.y),\n          depthBuffer: true,\n        },\n  )\n  renderTarget.texture.format = pixelFormat\n  renderTarget.texture.minFilter = NearestFilter\n  renderTarget.texture.magFilter = NearestFilter\n  renderTarget.texture.generateMipmaps = false\n  renderTarget.stencilBuffer = false\n  return renderTarget\n}\n\nexport { RenderPixelatedPass }\n"]},"metadata":{},"sourceType":"module"}