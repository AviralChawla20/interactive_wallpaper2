{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending } from \"three\";\nimport { ConvolutionShader } from \"../shaders/ConvolutionShader.js\";\nclass BloomPass extends Pass {\n  constructor(strength = 1, kernelSize = 25, sigma = 4, resolution = 256) {\n    super();\n    __publicField(this, \"renderTargetX\");\n    __publicField(this, \"renderTargetY\");\n    __publicField(this, \"materialCombine\");\n    __publicField(this, \"materialConvolution\");\n    __publicField(this, \"fsQuad\");\n    __publicField(this, \"combineUniforms\");\n    __publicField(this, \"convolutionUniforms\");\n    __publicField(this, \"blurX\", new Vector2(1953125e-9, 0));\n    __publicField(this, \"blurY\", new Vector2(0, 1953125e-9));\n    this.renderTargetX = new WebGLRenderTarget(resolution, resolution);\n    this.renderTargetX.texture.name = \"BloomPass.x\";\n    this.renderTargetY = new WebGLRenderTarget(resolution, resolution);\n    this.renderTargetY.texture.name = \"BloomPass.y\";\n    this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms);\n    this.combineUniforms[\"strength\"].value = strength;\n    this.materialCombine = new ShaderMaterial({\n      uniforms: this.combineUniforms,\n      vertexShader: CombineShader.vertexShader,\n      fragmentShader: CombineShader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true\n    });\n    if (ConvolutionShader === void 0) console.error(\"BloomPass relies on ConvolutionShader\");\n    const convolutionShader = ConvolutionShader;\n    this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n    this.convolutionUniforms[\"uImageIncrement\"].value = this.blurX;\n    this.convolutionUniforms[\"cKernel\"].value = ConvolutionShader.buildKernel(sigma);\n    this.materialConvolution = new ShaderMaterial({\n      uniforms: this.convolutionUniforms,\n      vertexShader: convolutionShader.vertexShader,\n      fragmentShader: convolutionShader.fragmentShader,\n      defines: {\n        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n        KERNEL_SIZE_INT: kernelSize.toFixed(0)\n      }\n    });\n    this.needsSwap = false;\n    this.fsQuad = new FullScreenQuad(this.materialConvolution);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n    this.fsQuad.material = this.materialConvolution;\n    this.convolutionUniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.convolutionUniforms[\"uImageIncrement\"].value = this.blurX;\n    renderer.setRenderTarget(this.renderTargetX);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n    this.convolutionUniforms[\"tDiffuse\"].value = this.renderTargetX.texture;\n    this.convolutionUniforms[\"uImageIncrement\"].value = this.blurY;\n    renderer.setRenderTarget(this.renderTargetY);\n    renderer.clear();\n    this.fsQuad.render(renderer);\n    this.fsQuad.material = this.materialCombine;\n    this.combineUniforms[\"tDiffuse\"].value = this.renderTargetY.texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    this.fsQuad.render(renderer);\n  }\n}\nconst CombineShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    strength: {\n      value: 1\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }`),\n  fragmentShader: (/* glsl */\n  `\n  uniform float strength;\n  uniform sampler2D tDiffuse;\n  varying vec2 vUv;\n  void main() {\n    vec4 texel = texture2D( tDiffuse, vUv );\n    gl_FragColor = strength * texel;\n  }`)\n};\nexport { BloomPass };","map":{"version":3,"sources":["../../src/postprocessing/BloomPass.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAYA,MAAM,SAAA,SAAkB,IAAA,CAAK;EAY3B,WAAA,CAAY,QAAA,GAAW,CAAA,EAAG,UAAA,GAAa,EAAA,EAAI,KAAA,GAAQ,CAAA,EAAG,UAAA,GAAa,GAAA,EAAK;IAChE,KAAA,CAAA,CAAA;IAZD,aAAA,CAAA,IAAA,EAAA,eAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,eAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,iBAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,qBAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,QAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,iBAAA,CAAA;IACA,aAAA,CAAA,IAAA,EAAA,qBAAA,CAAA;IAEA,aAAA,CAAA,IAAA,EAAA,OAAA,EAAQ,IAAI,OAAA,CAAQ,UAAA,EAAa,CAAG,CAAA,CAAA;IACpC,aAAA,CAAA,IAAA,EAAA,OAAA,EAAQ,IAAI,OAAA,CAAQ,CAAA,EAAK,UAAW,CAAA,CAAA;IAKzC,IAAA,CAAK,aAAA,GAAgB,IAAI,iBAAA,CAAkB,UAAA,EAAY,UAAU,CAAA;IAC5D,IAAA,CAAA,aAAA,CAAc,OAAA,CAAQ,IAAA,GAAO,aAAA;IAClC,IAAA,CAAK,aAAA,GAAgB,IAAI,iBAAA,CAAkB,UAAA,EAAY,UAAU,CAAA;IAC5D,IAAA,CAAA,aAAA,CAAc,OAAA,CAAQ,IAAA,GAAO,aAAA;IAElC,IAAA,CAAK,eAAA,GAAkB,aAAA,CAAc,KAAA,CAAM,aAAA,CAAc,QAAQ,CAAA;IAC5D,IAAA,CAAA,eAAA,CAAgB,UAAU,CAAA,CAAE,KAAA,GAAQ,QAAA;IACpC,IAAA,CAAA,eAAA,GAAkB,IAAI,cAAA,CAAe;MACxC,QAAA,EAAU,IAAA,CAAK,eAAA;MACf,YAAA,EAAc,aAAA,CAAc,YAAA;MAC5B,cAAA,EAAgB,aAAA,CAAc,cAAA;MAC9B,QAAA,EAAU,gBAAA;MACV,WAAA,EAAa;IAAA,CACd,CAAA;IAED,IAAI,iBAAA,KAAsB,KAAA,CAAA,EAAW,OAAA,CAAQ,KAAA,CAAM,uCAAuC,CAAA;IAC1F,MAAM,iBAAA,GAAoB,iBAAA;IAC1B,IAAA,CAAK,mBAAA,GAAsB,aAAA,CAAc,KAAA,CAAM,iBAAA,CAAkB,QAAQ,CAAA;IACzE,IAAA,CAAK,mBAAA,CAAoB,iBAAiB,CAAA,CAAE,KAAA,GAAQ,IAAA,CAAK,KAAA;IACzD,IAAA,CAAK,mBAAA,CAAoB,SAAS,CAAA,CAAE,KAAA,GAAQ,iBAAA,CAAkB,WAAA,CAAY,KAAK,CAAA;IAC1E,IAAA,CAAA,mBAAA,GAAsB,IAAI,cAAA,CAAe;MAC5C,QAAA,EAAU,IAAA,CAAK,mBAAA;MACf,YAAA,EAAc,iBAAA,CAAkB,YAAA;MAChC,cAAA,EAAgB,iBAAA,CAAkB,cAAA;MAClC,OAAA,EAAS;QACP,iBAAA,EAAmB,UAAA,CAAW,OAAA,CAAQ,CAAC,CAAA;QACvC,eAAA,EAAiB,UAAA,CAAW,OAAA,CAAQ,CAAC;MACvC;IAAA,CACD,CAAA;IACD,IAAA,CAAK,SAAA,GAAY,KAAA;IACjB,IAAA,CAAK,MAAA,GAAS,IAAI,cAAA,CAAe,IAAA,CAAK,mBAAmB,CAAA;EAC3D;EAEO,MAAA,CACL,QAAA,EACA,WAAA,EACA,UAAA,EACA,SAAA,EACA,UAAA,EACM;IACF,IAAA,UAAA,EAAY,QAAA,CAAS,KAAA,CAAM,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,KAAK,CAAA;IAEvD,IAAA,CAAA,MAAA,CAAO,QAAA,GAAW,IAAA,CAAK,mBAAA;IAC5B,IAAA,CAAK,mBAAA,CAAoB,UAAU,CAAA,CAAE,KAAA,GAAQ,UAAA,CAAW,OAAA;IACxD,IAAA,CAAK,mBAAA,CAAoB,iBAAiB,CAAA,CAAE,KAAA,GAAQ,IAAA,CAAK,KAAA;IAChD,QAAA,CAAA,eAAA,CAAgB,IAAA,CAAK,aAAa,CAAA;IAC3C,QAAA,CAAS,KAAA,CAAM,CAAA;IACV,IAAA,CAAA,MAAA,CAAO,MAAA,CAAO,QAAQ,CAAA;IAE3B,IAAA,CAAK,mBAAA,CAAoB,UAAU,CAAA,CAAE,KAAA,GAAQ,IAAA,CAAK,aAAA,CAAc,OAAA;IAChE,IAAA,CAAK,mBAAA,CAAoB,iBAAiB,CAAA,CAAE,KAAA,GAAQ,IAAA,CAAK,KAAA;IAChD,QAAA,CAAA,eAAA,CAAgB,IAAA,CAAK,aAAa,CAAA;IAC3C,QAAA,CAAS,KAAA,CAAM,CAAA;IACV,IAAA,CAAA,MAAA,CAAO,MAAA,CAAO,QAAQ,CAAA;IAEtB,IAAA,CAAA,MAAA,CAAO,QAAA,GAAW,IAAA,CAAK,eAAA;IAC5B,IAAA,CAAK,eAAA,CAAgB,UAAU,CAAA,CAAE,KAAA,GAAQ,IAAA,CAAK,aAAA,CAAc,OAAA;IACxD,IAAA,UAAA,EAAY,QAAA,CAAS,KAAA,CAAM,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA;IAC3D,QAAA,CAAS,eAAA,CAAgB,UAAU,CAAA;IACnC,IAAI,IAAA,CAAK,KAAA,EAAO,QAAA,CAAS,KAAA,CAAM,CAAA;IAC1B,IAAA,CAAA,MAAA,CAAO,MAAA,CAAO,QAAQ,CAAA;EAC7B;AACF;AAEA,MAAM,aAAA,GAAgB;EACpB,QAAA,EAAU;IACR,QAAA,EAAU;MACR,KAAA,EAAO;IACT,CAAA;IACA,QAAA,EAAU;MACR,KAAA,EAAO;IACT;EACF,CAAA;EACA,YAAA,GAAA;EAEE;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA,CAAA;EAMF,cAAA,GAAA;EAEE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA;AAQJ,CAAA","sourcesContent":["import { Pass, FullScreenQuad } from './Pass'\nimport {\n  AdditiveBlending,\n  IUniform,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  WebGLRenderer,\n  WebGLRenderTarget,\n} from 'three'\nimport { ConvolutionShader } from '../shaders/ConvolutionShader'\n\nclass BloomPass extends Pass {\n  public renderTargetX: WebGLRenderTarget\n  public renderTargetY: WebGLRenderTarget\n  public materialCombine: ShaderMaterial\n  public materialConvolution: ShaderMaterial\n  public fsQuad: FullScreenQuad\n  public combineUniforms: Record<keyof typeof CombineShader['uniforms'], IUniform<any>>\n  public convolutionUniforms: Record<keyof typeof ConvolutionShader['uniforms'], IUniform<any>>\n\n  public blurX = new Vector2(0.001953125, 0.0)\n  public blurY = new Vector2(0.0, 0.001953125)\n\n  constructor(strength = 1, kernelSize = 25, sigma = 4, resolution = 256) {\n    super() // render targets\n\n    this.renderTargetX = new WebGLRenderTarget(resolution, resolution)\n    this.renderTargetX.texture.name = 'BloomPass.x'\n    this.renderTargetY = new WebGLRenderTarget(resolution, resolution)\n    this.renderTargetY.texture.name = 'BloomPass.y' // combine material\n\n    this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms)\n    this.combineUniforms['strength'].value = strength\n    this.materialCombine = new ShaderMaterial({\n      uniforms: this.combineUniforms,\n      vertexShader: CombineShader.vertexShader,\n      fragmentShader: CombineShader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n    }) // convolution material\n\n    if (ConvolutionShader === undefined) console.error('BloomPass relies on ConvolutionShader')\n    const convolutionShader = ConvolutionShader\n    this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms)\n    this.convolutionUniforms['uImageIncrement'].value = this.blurX\n    this.convolutionUniforms['cKernel'].value = ConvolutionShader.buildKernel(sigma)\n    this.materialConvolution = new ShaderMaterial({\n      uniforms: this.convolutionUniforms,\n      vertexShader: convolutionShader.vertexShader,\n      fragmentShader: convolutionShader.fragmentShader,\n      defines: {\n        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n        KERNEL_SIZE_INT: kernelSize.toFixed(0),\n      },\n    })\n    this.needsSwap = false\n    this.fsQuad = new FullScreenQuad(this.materialConvolution)\n  }\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget,\n    deltaTime: number,\n    maskActive: boolean,\n  ): void {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false) // Render quad with blured scene into texture (convolution pass 1)\n\n    this.fsQuad.material = this.materialConvolution\n    this.convolutionUniforms['tDiffuse'].value = readBuffer.texture\n    this.convolutionUniforms['uImageIncrement'].value = this.blurX\n    renderer.setRenderTarget(this.renderTargetX)\n    renderer.clear()\n    this.fsQuad.render(renderer) // Render quad with blured scene into texture (convolution pass 2)\n\n    this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture\n    this.convolutionUniforms['uImageIncrement'].value = this.blurY\n    renderer.setRenderTarget(this.renderTargetY)\n    renderer.clear()\n    this.fsQuad.render(renderer) // Render original scene with superimposed blur to texture\n\n    this.fsQuad.material = this.materialCombine\n    this.combineUniforms['tDiffuse'].value = this.renderTargetY.texture\n    if (maskActive) renderer.state.buffers.stencil.setTest(true)\n    renderer.setRenderTarget(readBuffer)\n    if (this.clear) renderer.clear()\n    this.fsQuad.render(renderer)\n  }\n}\n\nconst CombineShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null,\n    },\n    strength: {\n      value: 1.0,\n    },\n  },\n  vertexShader:\n    /* glsl */\n    `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }`,\n  fragmentShader:\n    /* glsl */\n    `\n  uniform float strength;\n  uniform sampler2D tDiffuse;\n  varying vec2 vUv;\n  void main() {\n    vec4 texel = texture2D( tDiffuse, vUv );\n    gl_FragColor = strength * texel;\n  }`,\n}\n\nexport { BloomPass }\n"]},"metadata":{},"sourceType":"module"}