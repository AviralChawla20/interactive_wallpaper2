{"ast":null,"code":"import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from \"three\";\nimport { Pass } from \"./Pass.js\";\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super();\n    this.camera = camera;\n    this.needsSwap = false;\n    this.cubeShader = ShaderLib[\"cube\"];\n    this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n      vertexShader: this.cubeShader.vertexShader,\n      fragmentShader: this.cubeShader.fragmentShader,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    }));\n    Object.defineProperty(this.cubeMesh.material, \"envMap\", {\n      get: function () {\n        return this.uniforms.tCube.value;\n      }\n    });\n    this.tCube = tCube;\n    this.opacity = opacity;\n    this.cubeScene = new Scene();\n    this.cubeCamera = new PerspectiveCamera();\n    this.cubeScene.add(this.cubeMesh);\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube;\n    this.cubeMesh.material.uniforms.tFlip.value = this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n  dispose() {\n    this.cubeMesh.geometry.dispose();\n    this.cubeMesh.material.dispose();\n  }\n}\nexport { CubeTexturePass };","map":{"version":3,"sources":["../../src/postprocessing/CubeTexturePass.js"],"names":[],"mappings":";;AAGA,MAAM,eAAA,SAAwB,IAAA,CAAK;EACjC,WAAA,CAAY,MAAA,EAAQ,KAAA,EAAO,OAAA,GAAU,CAAA,EAAG;IACtC,KAAA,CAAO,CAAA;IAEP,IAAA,CAAK,MAAA,GAAS,MAAA;IAEd,IAAA,CAAK,SAAA,GAAY,KAAA;IAEjB,IAAA,CAAK,UAAA,GAAa,SAAA,CAAU,MAAM,CAAA;IAClC,IAAA,CAAK,QAAA,GAAW,IAAI,IAAA,CAClB,IAAI,WAAA,CAAY,EAAA,EAAI,EAAA,EAAI,EAAE,CAAA,EAC1B,IAAI,cAAA,CAAe;MACjB,QAAA,EAAU,aAAA,CAAc,KAAA,CAAM,IAAA,CAAK,UAAA,CAAW,QAAQ,CAAA;MACtD,YAAA,EAAc,IAAA,CAAK,UAAA,CAAW,YAAA;MAC9B,cAAA,EAAgB,IAAA,CAAK,UAAA,CAAW,cAAA;MAChC,SAAA,EAAW,KAAA;MACX,UAAA,EAAY,KAAA;MACZ,IAAA,EAAM;IACd,CAAO,CACF,CAAA;IAED,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,QAAA,CAAS,QAAA,EAAU,QAAA,EAAU;MACtD,GAAA,EAAK,SAAA,CAAA,EAAY;QACf,OAAO,IAAA,CAAK,QAAA,CAAS,KAAA,CAAM,KAAA;MAC5B;IACP,CAAK,CAAA;IAED,IAAA,CAAK,KAAA,GAAQ,KAAA;IACb,IAAA,CAAK,OAAA,GAAU,OAAA;IAEf,IAAA,CAAK,SAAA,GAAY,IAAI,KAAA,CAAO,CAAA;IAC5B,IAAA,CAAK,UAAA,GAAa,IAAI,iBAAA,CAAmB,CAAA;IACzC,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,IAAA,CAAK,QAAQ,CAAA;EACjC;EAED,MAAA,CAAO,QAAA,EAAU,WAAA,EAAa,UAAA,EAAwC;IACpE,MAAM,YAAA,GAAe,QAAA,CAAS,SAAA;IAC9B,QAAA,CAAS,SAAA,GAAY,KAAA;IAErB,IAAA,CAAK,UAAA,CAAW,gBAAA,CAAiB,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA;IAClE,IAAA,CAAK,UAAA,CAAW,UAAA,CAAW,qBAAA,CAAsB,IAAA,CAAK,MAAA,CAAO,WAAW,CAAA;IAExE,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,QAAA,CAAS,KAAA,CAAM,KAAA,GAAQ,IAAA,CAAK,KAAA;IACnD,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,QAAA,CAAS,KAAA,CAAM,KAAA,GACpC,IAAA,CAAK,KAAA,CAAM,aAAA,IAAiB,IAAA,CAAK,KAAA,CAAM,qBAAA,KAA0B,KAAA,GAAQ,CAAA,CAAA,GAAK,CAAA;IAChF,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,QAAA,CAAS,OAAA,CAAQ,KAAA,GAAQ,IAAA,CAAK,OAAA;IACrD,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,WAAA,GAAc,IAAA,CAAK,OAAA,GAAU,CAAA;IAEpD,QAAA,CAAS,eAAA,CAAgB,IAAA,CAAK,cAAA,GAAiB,IAAA,GAAO,UAAU,CAAA;IAChE,IAAI,IAAA,CAAK,KAAA,EAAO,QAAA,CAAS,KAAA,CAAO,CAAA;IAChC,QAAA,CAAS,MAAA,CAAO,IAAA,CAAK,SAAA,EAAW,IAAA,CAAK,UAAU,CAAA;IAE/C,QAAA,CAAS,SAAA,GAAY,YAAA;EACtB;EAED,OAAA,CAAA,EAAU;IACR,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,OAAA,CAAS,CAAA;IAChC,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,OAAA,CAAS,CAAA;EACjC;AACH","sourcesContent":["import { BackSide, BoxGeometry, Mesh, PerspectiveCamera, Scene, ShaderLib, ShaderMaterial, UniformsUtils } from 'three'\nimport { Pass } from './Pass'\n\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super()\n\n    this.camera = camera\n\n    this.needsSwap = false\n\n    this.cubeShader = ShaderLib['cube']\n    this.cubeMesh = new Mesh(\n      new BoxGeometry(10, 10, 10),\n      new ShaderMaterial({\n        uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n        vertexShader: this.cubeShader.vertexShader,\n        fragmentShader: this.cubeShader.fragmentShader,\n        depthTest: false,\n        depthWrite: false,\n        side: BackSide,\n      }),\n    )\n\n    Object.defineProperty(this.cubeMesh.material, 'envMap', {\n      get: function () {\n        return this.uniforms.tCube.value\n      },\n    })\n\n    this.tCube = tCube\n    this.opacity = opacity\n\n    this.cubeScene = new Scene()\n    this.cubeCamera = new PerspectiveCamera()\n    this.cubeScene.add(this.cubeMesh)\n  }\n\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive*/) {\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix)\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld)\n\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube\n    this.cubeMesh.material.uniforms.tFlip.value =\n      this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity\n    this.cubeMesh.material.transparent = this.opacity < 1.0\n\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer)\n    if (this.clear) renderer.clear()\n    renderer.render(this.cubeScene, this.cubeCamera)\n\n    renderer.autoClear = oldAutoClear\n  }\n\n  dispose() {\n    this.cubeMesh.geometry.dispose()\n    this.cubeMesh.material.dispose()\n  }\n}\n\nexport { CubeTexturePass }\n"]},"metadata":{},"sourceType":"module"}