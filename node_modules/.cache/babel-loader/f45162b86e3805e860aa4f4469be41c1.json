{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Quaternion, Matrix4 } from \"three\";\nimport { CharsetEncoder } from \"../libs/mmdparser.js\";\nclass MMDExporter {\n  constructor() {\n    // Unicode to Shift_JIS table\n    __publicField(this, \"u2sTable\");\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n  parseVpd(skin, outputShiftJis, useOriginalBones) {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn(\"THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.\");\n      return null;\n    }\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6) num = 0;\n      let a = num.toString();\n      if (a.indexOf(\".\") === -1) {\n        a += \".\";\n      }\n      a += \"000000\";\n      const index = a.indexOf(\".\");\n      const d = a.slice(0, index);\n      const p = a.slice(index + 1, index + 7);\n      return d + \".\" + p;\n    }\n    function toStringsFromArray(array2) {\n      const a = [];\n      for (let i = 0, il = array2.length; i < il; i++) {\n        a.push(toStringsFromNumber(array2[i]));\n      }\n      return a.join(\",\");\n    }\n    skin.updateMatrixWorld(true);\n    const bones = skin.skeleton.bones;\n    const bones2 = this.getBindBones(skin);\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const quaternion2 = new Quaternion();\n    const matrix = new Matrix4();\n    const array = [];\n    array.push(\"Vocaloid Pose Data file\");\n    array.push(\"\");\n    array.push((skin.name !== \"\" ? skin.name.replace(/\\s/g, \"_\") : \"skin\") + \".osm;\");\n    array.push(bones.length + \";\");\n    array.push(\"\");\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      const bone2 = bones2[i];\n      if (useOriginalBones === true && bone.userData.ik !== void 0 && bone.userData.ik.originalMatrix !== void 0) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      const pArray = position.sub(bone2.position).toArray();\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(\"Bone\" + i + \"{\" + bone.name);\n      array.push(\"  \" + toStringsFromArray(pArray) + \";\");\n      array.push(\"  \" + toStringsFromArray(qArray) + \";\");\n      array.push(\"}\");\n      array.push(\"\");\n    }\n    array.push(\"\");\n    const lines = array.join(\"\\n\");\n    return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines;\n  }\n  unicodeToShiftjis(str) {\n    if (this.u2sTable === void 0) {\n      const encoder = new CharsetEncoder();\n      const table = encoder.s2uTable;\n      this.u2sTable = {};\n      const keys = Object.keys(table);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i];\n        const value = table[key];\n        this.u2sTable[value] = parseInt(key);\n      }\n    }\n    const array = [];\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i);\n      const value = this.u2sTable[code];\n      if (value === void 0) {\n        throw \"cannot convert charcode 0x\" + code.toString(16);\n      } else if (value > 255) {\n        array.push(value >> 8 & 255);\n        array.push(value & 255);\n      } else {\n        array.push(value & 255);\n      }\n    }\n    return new Uint8Array(array);\n  }\n  getBindBones(skin) {\n    const poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n}\nexport { MMDExporter };","map":{"version":3,"sources":["../../src/exporters/MMDExporter.ts"],"names":["array"],"mappings":"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","sourcesContent":["import { Matrix4, Quaternion, Vector3, Bone, SkinnedMesh } from 'three'\n// @ts-ignore\nimport { CharsetEncoder } from '../libs/mmdparser'\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nclass MMDExporter {\n  /* TODO: implement\n\t// mesh -> pmd\n\tthis.parsePmd = function ( object ) {\n\t};\n\t*/\n\n  /* TODO: implement\n\t// mesh -> pmx\n\tthis.parsePmx = function ( object ) {\n\t};\n\t*/\n\n  /* TODO: implement\n\t// animation + skeleton -> vmd\n\tthis.parseVmd = function ( object ) {\n\t};\n\t*/\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n  public parseVpd(skin: SkinnedMesh, outputShiftJis: boolean, useOriginalBones: boolean): Uint8Array | string | null {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.')\n      return null\n    }\n\n    function toStringsFromNumber(num: number): string {\n      if (Math.abs(num) < 1e-6) num = 0\n\n      let a = num.toString()\n\n      if (a.indexOf('.') === -1) {\n        a += '.'\n      }\n\n      a += '000000'\n\n      const index = a.indexOf('.')\n\n      const d = a.slice(0, index)\n      const p = a.slice(index + 1, index + 7)\n\n      return d + '.' + p\n    }\n\n    function toStringsFromArray(array: number[]): string {\n      const a = []\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]))\n      }\n\n      return a.join(',')\n    }\n\n    skin.updateMatrixWorld(true)\n\n    const bones = skin.skeleton.bones\n    const bones2 = this.getBindBones(skin)\n\n    const position = new Vector3()\n    const quaternion = new Quaternion()\n    const quaternion2 = new Quaternion()\n    const matrix = new Matrix4()\n\n    const array = []\n    array.push('Vocaloid Pose Data file')\n    array.push('')\n    array.push((skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin') + '.osm;')\n    array.push(bones.length + ';')\n    array.push('')\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      const bone2 = bones2[i]\n\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n      if (\n        useOriginalBones === true &&\n        bone.userData.ik !== undefined &&\n        bone.userData.ik.originalMatrix !== undefined\n      ) {\n        matrix.fromArray(bone.userData.ik.originalMatrix)\n      } else {\n        matrix.copy(bone.matrix)\n      }\n\n      position.setFromMatrixPosition(matrix)\n      quaternion.setFromRotationMatrix(matrix)\n\n      const pArray = position.sub(bone2.position).toArray()\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray()\n\n      // right to left\n      pArray[2] = -pArray[2]\n      qArray[0] = -qArray[0]\n      qArray[1] = -qArray[1]\n\n      array.push('Bone' + i + '{' + bone.name)\n      array.push('  ' + toStringsFromArray(pArray) + ';')\n      array.push('  ' + toStringsFromArray(qArray) + ';')\n      array.push('}')\n      array.push('')\n    }\n\n    array.push('')\n\n    const lines = array.join('\\n')\n\n    return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines\n  }\n\n  // Unicode to Shift_JIS table\n  private u2sTable: { [key: string]: number | undefined } | undefined\n\n  private unicodeToShiftjis(str: string): Uint8Array {\n    if (this.u2sTable === undefined) {\n      const encoder = new CharsetEncoder()\n      const table = encoder.s2uTable\n      this.u2sTable = {}\n\n      const keys = Object.keys(table)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i]\n\n        const value = table[key]\n\n        this.u2sTable[value] = parseInt(key)\n      }\n    }\n\n    const array = []\n\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i)\n\n      const value = this.u2sTable[code]\n\n      if (value === undefined) {\n        throw 'cannot convert charcode 0x' + code.toString(16)\n      } else if (value > 0xff) {\n        array.push((value >> 8) & 0xff)\n        array.push(value & 0xff)\n      } else {\n        array.push(value & 0xff)\n      }\n    }\n\n    return new Uint8Array(array)\n  }\n\n  private getBindBones(skin: SkinnedMesh): Bone[] {\n    // any more efficient ways?\n    const poseSkin = skin.clone()\n    poseSkin.pose()\n    return poseSkin.skeleton.bones\n  }\n}\n\nexport { MMDExporter }\n"]},"metadata":{},"sourceType":"module"}