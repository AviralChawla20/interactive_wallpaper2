{"ast":null,"code":"import { Loader, FileLoader, MeshStandardMaterial, Color, TextureLoader, Object3D, Matrix4, BufferGeometryLoader, DirectionalLight, PointLight, RectAreaLight, Vector3, SpotLight, CanvasTexture, LinearFilter, ClampToEdgeWrapping, SpriteMaterial, Sprite, LineBasicMaterial, Line, Mesh, PointsMaterial, Points } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nclass Rhino3dmLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.libraryPath = \"\";\n    this.libraryPending = null;\n    this.libraryBinary = null;\n    this.libraryConfig = {};\n    this.url = \"\";\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.workerConfig = {};\n    this.materials = [];\n  }\n  setLibraryPath(path) {\n    this.libraryPath = path;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    this.url = url;\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this.decodeObjects(buffer, url).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map(worker => worker._taskLoad));\n  }\n  decodeObjects(buffer, url) {\n    let worker;\n    let taskID;\n    const taskCost = buffer.byteLength;\n    const objectPending = this._getWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"decode\",\n          id: taskID,\n          buffer\n        }, [buffer]);\n      });\n    }).then(message => this._createGeometry(message.data));\n    objectPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      url,\n      promise: objectPending\n    });\n    return objectPending;\n  }\n  parse(data, onLoad, onError) {\n    this.decodeObjects(data, \"\").then(onLoad).catch(onError);\n  }\n  _compareMaterials(material) {\n    const mat = {};\n    mat.name = material.name;\n    mat.color = {};\n    mat.color.r = material.color.r;\n    mat.color.g = material.color.g;\n    mat.color.b = material.color.b;\n    mat.type = material.type;\n    for (let i = 0; i < this.materials.length; i++) {\n      const m = this.materials[i];\n      const _mat = {};\n      _mat.name = m.name;\n      _mat.color = {};\n      _mat.color.r = m.color.r;\n      _mat.color.g = m.color.g;\n      _mat.color.b = m.color.b;\n      _mat.type = m.type;\n      if (JSON.stringify(mat) === JSON.stringify(_mat)) {\n        return m;\n      }\n    }\n    this.materials.push(material);\n    return material;\n  }\n  _createMaterial(material) {\n    if (material === void 0) {\n      return new MeshStandardMaterial({\n        color: new Color(1, 1, 1),\n        metalness: 0.8,\n        name: \"default\",\n        side: 2\n      });\n    }\n    const _diffuseColor = material.diffuseColor;\n    const diffusecolor = new Color(_diffuseColor.r / 255, _diffuseColor.g / 255, _diffuseColor.b / 255);\n    if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {\n      diffusecolor.r = 1;\n      diffusecolor.g = 1;\n      diffusecolor.b = 1;\n    }\n    const mat = new MeshStandardMaterial({\n      color: diffusecolor,\n      name: material.name,\n      side: 2,\n      transparent: material.transparency > 0 ? true : false,\n      opacity: 1 - material.transparency\n    });\n    const textureLoader = new TextureLoader();\n    for (let i = 0; i < material.textures.length; i++) {\n      const texture = material.textures[i];\n      if (texture.image !== null) {\n        const map = textureLoader.load(texture.image);\n        switch (texture.type) {\n          case \"Diffuse\":\n            mat.map = map;\n            break;\n          case \"Bump\":\n            mat.bumpMap = map;\n            break;\n          case \"Transparency\":\n            mat.alphaMap = map;\n            mat.transparent = true;\n            break;\n          case \"Emap\":\n            mat.envMap = map;\n            break;\n        }\n      }\n    }\n    return mat;\n  }\n  _createGeometry(data) {\n    const object = new Object3D();\n    const instanceDefinitionObjects = [];\n    const instanceDefinitions = [];\n    const instanceReferences = [];\n    object.userData[\"layers\"] = data.layers;\n    object.userData[\"groups\"] = data.groups;\n    object.userData[\"settings\"] = data.settings;\n    object.userData[\"objectType\"] = \"File3dm\";\n    object.userData[\"materials\"] = null;\n    object.name = this.url;\n    let objects = data.objects;\n    const materials = data.materials;\n    for (let i = 0; i < objects.length; i++) {\n      const obj = objects[i];\n      const attributes = obj.attributes;\n      switch (obj.objectType) {\n        case \"InstanceDefinition\":\n          instanceDefinitions.push(obj);\n          break;\n        case \"InstanceReference\":\n          instanceReferences.push(obj);\n          break;\n        default:\n          let _object;\n          if (attributes.materialIndex >= 0) {\n            const rMaterial = materials[attributes.materialIndex];\n            let material = this._createMaterial(rMaterial);\n            material = this._compareMaterials(material);\n            _object = this._createObject(obj, material);\n          } else {\n            const material = this._createMaterial();\n            _object = this._createObject(obj, material);\n          }\n          if (_object === void 0) {\n            continue;\n          }\n          const layer = data.layers[attributes.layerIndex];\n          _object.visible = layer ? data.layers[attributes.layerIndex].visible : true;\n          if (attributes.isInstanceDefinitionObject) {\n            instanceDefinitionObjects.push(_object);\n          } else {\n            object.add(_object);\n          }\n          break;\n      }\n    }\n    for (let i = 0; i < instanceDefinitions.length; i++) {\n      const iDef = instanceDefinitions[i];\n      objects = [];\n      for (let j = 0; j < iDef.attributes.objectIds.length; j++) {\n        const objId = iDef.attributes.objectIds[j];\n        for (let p = 0; p < instanceDefinitionObjects.length; p++) {\n          const idoId = instanceDefinitionObjects[p].userData.attributes.id;\n          if (objId === idoId) {\n            objects.push(instanceDefinitionObjects[p]);\n          }\n        }\n      }\n      for (let j = 0; j < instanceReferences.length; j++) {\n        const iRef = instanceReferences[j];\n        if (iRef.geometry.parentIdefId === iDef.attributes.id) {\n          const iRefObject = new Object3D();\n          const xf = iRef.geometry.xform.array;\n          const matrix = new Matrix4();\n          matrix.set(xf[0], xf[1], xf[2], xf[3], xf[4], xf[5], xf[6], xf[7], xf[8], xf[9], xf[10], xf[11], xf[12], xf[13], xf[14], xf[15]);\n          iRefObject.applyMatrix4(matrix);\n          for (let p = 0; p < objects.length; p++) {\n            iRefObject.add(objects[p].clone(true));\n          }\n          object.add(iRefObject);\n        }\n      }\n    }\n    object.userData[\"materials\"] = this.materials;\n    return object;\n  }\n  _createObject(obj, mat) {\n    const loader = new BufferGeometryLoader();\n    const attributes = obj.attributes;\n    let geometry, material, _color, color;\n    switch (obj.objectType) {\n      case \"Point\":\n      case \"PointSet\":\n        geometry = loader.parse(obj.geometry);\n        if (geometry.attributes.hasOwnProperty(\"color\")) {\n          material = new PointsMaterial({\n            vertexColors: true,\n            sizeAttenuation: false,\n            size: 2\n          });\n        } else {\n          _color = attributes.drawColor;\n          color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n          material = new PointsMaterial({\n            color,\n            sizeAttenuation: false,\n            size: 2\n          });\n        }\n        material = this._compareMaterials(material);\n        const points = new Points(geometry, material);\n        points.userData[\"attributes\"] = attributes;\n        points.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          points.name = attributes.name;\n        }\n        return points;\n      case \"Mesh\":\n      case \"Extrusion\":\n      case \"SubD\":\n      case \"Brep\":\n        if (obj.geometry === null) return;\n        geometry = loader.parse(obj.geometry);\n        if (geometry.attributes.hasOwnProperty(\"color\")) {\n          mat.vertexColors = true;\n        }\n        if (mat === null) {\n          mat = this._createMaterial();\n          mat = this._compareMaterials(mat);\n        }\n        const mesh = new Mesh(geometry, mat);\n        mesh.castShadow = attributes.castsShadows;\n        mesh.receiveShadow = attributes.receivesShadows;\n        mesh.userData[\"attributes\"] = attributes;\n        mesh.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          mesh.name = attributes.name;\n        }\n        return mesh;\n      case \"Curve\":\n        geometry = loader.parse(obj.geometry);\n        _color = attributes.drawColor;\n        color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n        material = new LineBasicMaterial({\n          color\n        });\n        material = this._compareMaterials(material);\n        const lines = new Line(geometry, material);\n        lines.userData[\"attributes\"] = attributes;\n        lines.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          lines.name = attributes.name;\n        }\n        return lines;\n      case \"TextDot\":\n        geometry = obj.geometry;\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        const font = `${geometry.fontHeight}px ${geometry.fontFace}`;\n        ctx.font = font;\n        const width = ctx.measureText(geometry.text).width + 10;\n        const height = geometry.fontHeight + 10;\n        const r = window.devicePixelRatio;\n        ctx.canvas.width = width * r;\n        ctx.canvas.height = height * r;\n        ctx.canvas.style.width = width + \"px\";\n        ctx.canvas.style.height = height + \"px\";\n        ctx.setTransform(r, 0, 0, r, 0, 0);\n        ctx.font = font;\n        ctx.textBaseline = \"middle\";\n        ctx.textAlign = \"center\";\n        color = attributes.drawColor;\n        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;\n        ctx.fillRect(0, 0, width, height);\n        ctx.fillStyle = \"white\";\n        ctx.fillText(geometry.text, width / 2, height / 2);\n        const texture = new CanvasTexture(ctx.canvas);\n        texture.minFilter = LinearFilter;\n        texture.wrapS = ClampToEdgeWrapping;\n        texture.wrapT = ClampToEdgeWrapping;\n        material = new SpriteMaterial({\n          map: texture,\n          depthTest: false\n        });\n        const sprite = new Sprite(material);\n        sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2]);\n        sprite.scale.set(width / 10, height / 10, 1);\n        sprite.userData[\"attributes\"] = attributes;\n        sprite.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          sprite.name = attributes.name;\n        }\n        return sprite;\n      case \"Light\":\n        geometry = obj.geometry;\n        let light;\n        if (geometry.isDirectionalLight) {\n          light = new DirectionalLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isPointLight) {\n          light = new PointLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isRectangularLight) {\n          light = new RectAreaLight();\n          const width2 = Math.abs(geometry.width[2]);\n          const height2 = Math.abs(geometry.length[0]);\n          light.position.set(geometry.location[0] - height2 / 2, geometry.location[1], geometry.location[2] - width2 / 2);\n          light.height = height2;\n          light.width = width2;\n          light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]));\n        } else if (geometry.isSpotLight) {\n          light = new SpotLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n          light.angle = geometry.spotAngleRadians;\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isLinearLight) {\n          console.warn(\"THREE.3DMLoader:  No conversion exists for linear lights.\");\n          return;\n        }\n        if (light) {\n          light.intensity = geometry.intensity;\n          _color = geometry.diffuse;\n          color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n          light.color = color;\n          light.userData[\"attributes\"] = attributes;\n          light.userData[\"objectType\"] = obj.objectType;\n        }\n        return light;\n    }\n  }\n  _initLibrary() {\n    if (!this.libraryPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.libraryPath);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load(\"rhino3dm.js\", resolve, void 0, reject);\n      });\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.libraryPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load(\"rhino3dm.wasm\", resolve, void 0, reject);\n      });\n      this.libraryPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n        this.libraryConfig.wasmBinary = binaryContent2;\n        const fn = Rhino3dmWorker.toString();\n        const body = [\"/* rhino3dm.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n    }\n    return this.libraryPending;\n  }\n  _getWorker(taskCost) {\n    return this._initLibrary().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          libraryConfig: this.libraryConfig\n        });\n        worker2.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction Rhino3dmWorker() {\n  let libraryPending;\n  let libraryConfig;\n  let rhino;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        libraryConfig = message.libraryConfig;\n        const wasmBinary = libraryConfig.wasmBinary;\n        let RhinoModule;\n        libraryPending = new Promise(function (resolve) {\n          RhinoModule = {\n            wasmBinary,\n            onRuntimeInitialized: resolve\n          };\n          rhino3dm(RhinoModule);\n        }).then(() => {\n          rhino = RhinoModule;\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        libraryPending.then(() => {\n          const data = decodeObjects(rhino, buffer);\n          self.postMessage({\n            type: \"decode\",\n            id: message.id,\n            data\n          });\n        });\n        break;\n    }\n  };\n  function decodeObjects(rhino2, buffer) {\n    const arr = new Uint8Array(buffer);\n    const doc = rhino2.File3dm.fromByteArray(arr);\n    const objects = [];\n    const materials = [];\n    const layers = [];\n    const views = [];\n    const namedViews = [];\n    const groups = [];\n    const objs = doc.objects();\n    const cnt = objs.count;\n    for (let i = 0; i < cnt; i++) {\n      const _object = objs.get(i);\n      const object = extractObjectData(_object, doc);\n      _object.delete();\n      if (object) {\n        objects.push(object);\n      }\n    }\n    for (let i = 0; i < doc.instanceDefinitions().count(); i++) {\n      const idef = doc.instanceDefinitions().get(i);\n      const idefAttributes = extractProperties(idef);\n      idefAttributes.objectIds = idef.getObjectIds();\n      objects.push({\n        geometry: null,\n        attributes: idefAttributes,\n        objectType: \"InstanceDefinition\"\n      });\n    }\n    const textureTypes = [\n    // rhino.TextureType.Bitmap,\n    rhino2.TextureType.Diffuse, rhino2.TextureType.Bump, rhino2.TextureType.Transparency, rhino2.TextureType.Opacity, rhino2.TextureType.Emap];\n    const pbrTextureTypes = [rhino2.TextureType.PBR_BaseColor, rhino2.TextureType.PBR_Subsurface, rhino2.TextureType.PBR_SubsurfaceScattering, rhino2.TextureType.PBR_SubsurfaceScatteringRadius, rhino2.TextureType.PBR_Metallic, rhino2.TextureType.PBR_Specular, rhino2.TextureType.PBR_SpecularTint, rhino2.TextureType.PBR_Roughness, rhino2.TextureType.PBR_Anisotropic, rhino2.TextureType.PBR_Anisotropic_Rotation, rhino2.TextureType.PBR_Sheen, rhino2.TextureType.PBR_SheenTint, rhino2.TextureType.PBR_Clearcoat, rhino2.TextureType.PBR_ClearcoatBump, rhino2.TextureType.PBR_ClearcoatRoughness, rhino2.TextureType.PBR_OpacityIor, rhino2.TextureType.PBR_OpacityRoughness, rhino2.TextureType.PBR_Emission, rhino2.TextureType.PBR_AmbientOcclusion, rhino2.TextureType.PBR_Displacement];\n    for (let i = 0; i < doc.materials().count(); i++) {\n      const _material = doc.materials().get(i);\n      const _pbrMaterial = _material.physicallyBased();\n      let material = extractProperties(_material);\n      const textures = [];\n      for (let j = 0; j < textureTypes.length; j++) {\n        const _texture = _material.getTexture(textureTypes[j]);\n        if (_texture) {\n          let textureType = textureTypes[j].constructor.name;\n          textureType = textureType.substring(12, textureType.length);\n          const texture = {\n            type: textureType\n          };\n          const image = doc.getEmbeddedFileAsBase64(_texture.fileName);\n          if (image) {\n            texture.image = \"data:image/png;base64,\" + image;\n          } else {\n            console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`);\n            texture.image = null;\n          }\n          textures.push(texture);\n          _texture.delete();\n        }\n      }\n      material.textures = textures;\n      if (_pbrMaterial.supported) {\n        console.log(\"pbr true\");\n        for (let j = 0; j < pbrTextureTypes.length; j++) {\n          const _texture = _material.getTexture(textureTypes[j]);\n          if (_texture) {\n            const image = doc.getEmbeddedFileAsBase64(_texture.fileName);\n            let textureType = textureTypes[j].constructor.name;\n            textureType = textureType.substring(12, textureType.length);\n            const texture = {\n              type: textureType,\n              image: \"data:image/png;base64,\" + image\n            };\n            textures.push(texture);\n            _texture.delete();\n          }\n        }\n        const pbMaterialProperties = extractProperties(_material.physicallyBased());\n        material = Object.assign(pbMaterialProperties, material);\n      }\n      materials.push(material);\n      _material.delete();\n      _pbrMaterial.delete();\n    }\n    for (let i = 0; i < doc.layers().count(); i++) {\n      const _layer = doc.layers().get(i);\n      const layer = extractProperties(_layer);\n      layers.push(layer);\n      _layer.delete();\n    }\n    for (let i = 0; i < doc.views().count(); i++) {\n      const _view = doc.views().get(i);\n      const view = extractProperties(_view);\n      views.push(view);\n      _view.delete();\n    }\n    for (let i = 0; i < doc.namedViews().count(); i++) {\n      const _namedView = doc.namedViews().get(i);\n      const namedView = extractProperties(_namedView);\n      namedViews.push(namedView);\n      _namedView.delete();\n    }\n    for (let i = 0; i < doc.groups().count(); i++) {\n      const _group = doc.groups().get(i);\n      const group = extractProperties(_group);\n      groups.push(group);\n      _group.delete();\n    }\n    const settings = extractProperties(doc.settings());\n    doc.delete();\n    return {\n      objects,\n      materials,\n      layers,\n      views,\n      namedViews,\n      groups,\n      settings\n    };\n  }\n  function extractObjectData(object, doc) {\n    const _geometry = object.geometry();\n    const _attributes = object.attributes();\n    let objectType = _geometry.objectType;\n    let geometry, attributes, position, data, mesh;\n    switch (objectType) {\n      case rhino.ObjectType.Curve:\n        const pts = curveToPoints(_geometry, 100);\n        position = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = \"Float32Array\";\n        position.array = [];\n        for (let j = 0; j < pts.length; j++) {\n          position.array.push(pts[j][0]);\n          position.array.push(pts[j][1]);\n          position.array.push(pts[j][2]);\n        }\n        attributes.position = position;\n        data.attributes = attributes;\n        geometry = {\n          data\n        };\n        break;\n      case rhino.ObjectType.Point:\n        const pt = _geometry.location;\n        position = {};\n        const color = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = \"Float32Array\";\n        position.array = [pt[0], pt[1], pt[2]];\n        const _color = _attributes.drawColor(doc);\n        color.itemSize = 3;\n        color.type = \"Float32Array\";\n        color.array = [_color.r / 255, _color.g / 255, _color.b / 255];\n        attributes.position = position;\n        attributes.color = color;\n        data.attributes = attributes;\n        geometry = {\n          data\n        };\n        break;\n      case rhino.ObjectType.PointSet:\n      case rhino.ObjectType.Mesh:\n        geometry = _geometry.toThreejsJSON();\n        break;\n      case rhino.ObjectType.Brep:\n        const faces = _geometry.faces();\n        mesh = new rhino.Mesh();\n        for (let faceIndex = 0; faceIndex < faces.count; faceIndex++) {\n          const face = faces.get(faceIndex);\n          const _mesh = face.getMesh(rhino.MeshType.Any);\n          if (_mesh) {\n            mesh.append(_mesh);\n            _mesh.delete();\n          }\n          face.delete();\n        }\n        if (mesh.faces().count > 0) {\n          mesh.compact();\n          geometry = mesh.toThreejsJSON();\n          faces.delete();\n        }\n        mesh.delete();\n        break;\n      case rhino.ObjectType.Extrusion:\n        mesh = _geometry.getMesh(rhino.MeshType.Any);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n      case rhino.ObjectType.TextDot:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.Light:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.InstanceReference:\n        geometry = extractProperties(_geometry);\n        geometry.xform = extractProperties(_geometry.xform);\n        geometry.xform.array = _geometry.xform.toFloatArray(true);\n        break;\n      case rhino.ObjectType.SubD:\n        _geometry.subdivide(3);\n        mesh = rhino.Mesh.createFromSubDControlNet(_geometry);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n      default:\n        console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`);\n        break;\n    }\n    if (geometry) {\n      attributes = extractProperties(_attributes);\n      attributes.geometry = extractProperties(_geometry);\n      if (_attributes.groupCount > 0) {\n        attributes.groupIds = _attributes.getGroupList();\n      }\n      if (_attributes.userStringCount > 0) {\n        attributes.userStrings = _attributes.getUserStrings();\n      }\n      if (_geometry.userStringCount > 0) {\n        attributes.geometry.userStrings = _geometry.getUserStrings();\n      }\n      attributes.drawColor = _attributes.drawColor(doc);\n      objectType = objectType.constructor.name;\n      objectType = objectType.substring(11, objectType.length);\n      return {\n        geometry,\n        attributes,\n        objectType\n      };\n    } else {\n      console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`);\n    }\n  }\n  function extractProperties(object) {\n    const result = {};\n    for (const property in object) {\n      const value = object[property];\n      if (typeof value !== \"function\") {\n        if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"constructor\")) {\n          result[property] = {\n            name: value.constructor.name,\n            value: value.value\n          };\n        } else {\n          result[property] = value;\n        }\n      }\n    }\n    return result;\n  }\n  function curveToPoints(curve, pointLimit) {\n    let pointCount = pointLimit;\n    let rc = [];\n    const ts = [];\n    if (curve instanceof rhino.LineCurve) {\n      return [curve.pointAtStart, curve.pointAtEnd];\n    }\n    if (curve instanceof rhino.PolylineCurve) {\n      pointCount = curve.pointCount;\n      for (let i = 0; i < pointCount; i++) {\n        rc.push(curve.point(i));\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.PolyCurve) {\n      const segmentCount = curve.segmentCount;\n      for (let i = 0; i < segmentCount; i++) {\n        const segment = curve.segmentCurve(i);\n        const segmentArray = curveToPoints(segment, pointCount);\n        rc = rc.concat(segmentArray);\n        segment.delete();\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.ArcCurve) {\n      pointCount = Math.floor(curve.angleDegrees / 5);\n      pointCount = pointCount < 2 ? 2 : pointCount;\n    }\n    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {\n      const pLine = curve.tryGetPolyline();\n      for (let i = 0; i < pLine.count; i++) {\n        rc.push(pLine.get(i));\n      }\n      pLine.delete();\n      return rc;\n    }\n    const domain = curve.domain;\n    const divisions = pointCount - 1;\n    for (let j = 0; j < pointCount; j++) {\n      const t = domain[0] + j / divisions * (domain[1] - domain[0]);\n      if (t === domain[0] || t === domain[1]) {\n        ts.push(t);\n        continue;\n      }\n      const tan = curve.tangentAt(t);\n      const prevTan = curve.tangentAt(ts.slice(-1)[0]);\n      const tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2];\n      const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2];\n      const denominator = Math.sqrt(tS * ptS);\n      let angle;\n      if (denominator === 0) {\n        angle = Math.PI / 2;\n      } else {\n        const theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator;\n        angle = Math.acos(Math.max(-1, Math.min(1, theta)));\n      }\n      if (angle < 0.1) continue;\n      ts.push(t);\n    }\n    rc = ts.map(t => curve.pointAt(t));\n    return rc;\n  }\n}\nexport { Rhino3dmLoader };","map":{"version":3,"sources":["../../src/loaders/3DMLoader.js"],"names":["width","height","jsContent","binaryContent","worker","rhino"],"mappings":";AA0BA,MAAM,UAAA,GAAa,eAAA,IAAI,OAAA,CAAS,CAAA;AAEhC,MAAM,cAAA,SAAuB,MAAA,CAAO;EAClC,WAAA,CAAY,OAAA,EAAS;IACnB,KAAA,CAAM,OAAO,CAAA;IAEb,IAAA,CAAK,WAAA,GAAc,EAAA;IACnB,IAAA,CAAK,cAAA,GAAiB,IAAA;IACtB,IAAA,CAAK,aAAA,GAAgB,IAAA;IACrB,IAAA,CAAK,aAAA,GAAgB,CAAE,CAAA;IAEvB,IAAA,CAAK,GAAA,GAAM,EAAA;IAEX,IAAA,CAAK,WAAA,GAAc,CAAA;IACnB,IAAA,CAAK,UAAA,GAAa,EAAE;IACpB,IAAA,CAAK,gBAAA,GAAmB,CAAA;IACxB,IAAA,CAAK,eAAA,GAAkB,EAAA;IACvB,IAAA,CAAK,YAAA,GAAe,CAAE,CAAA;IAEtB,IAAA,CAAK,SAAA,GAAY,EAAE;EACpB;EAED,cAAA,CAAe,IAAA,EAAM;IACnB,IAAA,CAAK,WAAA,GAAc,IAAA;IAEnB,OAAO,IAAA;EACR;EAED,cAAA,CAAe,WAAA,EAAa;IAC1B,IAAA,CAAK,WAAA,GAAc,WAAA;IAEnB,OAAO,IAAA;EACR;EAED,IAAA,CAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;IACrC,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;IAE1C,MAAA,CAAO,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA;IACxB,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;IACpC,MAAA,CAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAA;IAE1C,IAAA,CAAK,GAAA,GAAM,GAAA;IAEX,MAAA,CAAO,IAAA,CACL,GAAA,EACC,MAAA,IAAW;MAGV,IAAI,UAAA,CAAW,GAAA,CAAI,MAAM,CAAA,EAAG;QAC1B,MAAM,UAAA,GAAa,UAAA,CAAW,GAAA,CAAI,MAAM,CAAA;QAExC,OAAO,UAAA,CAAW,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA,CAAE,KAAA,CAAM,OAAO,CAAA;MACrD;MAED,IAAA,CAAK,aAAA,CAAc,MAAA,EAAQ,GAAG,CAAA,CAAE,IAAA,CAAK,MAAM,CAAA,CAAE,KAAA,CAAM,OAAO,CAAA;IAC3D,CAAA,EACD,UAAA,EACA,OACD,CAAA;EACF;EAED,KAAA,CAAA,EAAQ;IACN,OAAA,CAAQ,GAAA,CACN,aAAA,EACA,IAAA,CAAK,UAAA,CAAW,GAAA,CAAK,MAAA,IAAW,MAAA,CAAO,SAAS,CACjD,CAAA;EACF;EAED,aAAA,CAAc,MAAA,EAAQ,GAAA,EAAK;IACzB,IAAI,MAAA;IACJ,IAAI,MAAA;IAEJ,MAAM,QAAA,GAAW,MAAA,CAAO,UAAA;IAExB,MAAM,aAAA,GAAgB,IAAA,CAAK,UAAA,CAAW,QAAQ,CAAA,CAC3C,IAAA,CAAM,OAAA,IAAY;MACjB,MAAA,GAAS,OAAA;MACT,MAAA,GAAS,IAAA,CAAK,gBAAA,EAAA;MAEd,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;QACtC,MAAA,CAAO,UAAA,CAAW,MAAM,CAAA,GAAI;UAAE,OAAA;UAAS;QAAQ,CAAA;QAE/C,MAAA,CAAO,WAAA,CAAY;UAAE,IAAA,EAAM,QAAA;UAAU,EAAA,EAAI,MAAA;UAAQ;QAAM,CAAA,EAAI,CAAC,MAAM,CAAC,CAAA;MAG7E,CAAS,CAAA;IACT,CAAO,CAAA,CACA,IAAA,CAAM,OAAA,IAAY,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,IAAI,CAAC,CAAA;IAIvD,aAAA,CACG,KAAA,CAAM,MAAM,IAAI,CAAA,CAChB,IAAA,CAAK,MAAM;MACV,IAAI,MAAA,IAAU,MAAA,EAAQ;QACpB,IAAA,CAAK,YAAA,CAAa,MAAA,EAAQ,MAAM,CAAA;MAGjC;IACT,CAAO,CAAA;IAGH,UAAA,CAAW,GAAA,CAAI,MAAA,EAAQ;MACrB,GAAA;MACA,OAAA,EAAS;IACf,CAAK,CAAA;IAED,OAAO,aAAA;EACR;EAED,KAAA,CAAM,IAAA,EAAM,MAAA,EAAQ,OAAA,EAAS;IAC3B,IAAA,CAAK,aAAA,CAAc,IAAA,EAAM,EAAE,CAAA,CAAE,IAAA,CAAK,MAAM,CAAA,CAAE,KAAA,CAAM,OAAO,CAAA;EACxD;EAED,iBAAA,CAAkB,QAAA,EAAU;IAC1B,MAAM,GAAA,GAAM,CAAE,CAAA;IACd,GAAA,CAAI,IAAA,GAAO,QAAA,CAAS,IAAA;IACpB,GAAA,CAAI,KAAA,GAAQ,CAAE,CAAA;IACd,GAAA,CAAI,KAAA,CAAM,CAAA,GAAI,QAAA,CAAS,KAAA,CAAM,CAAA;IAC7B,GAAA,CAAI,KAAA,CAAM,CAAA,GAAI,QAAA,CAAS,KAAA,CAAM,CAAA;IAC7B,GAAA,CAAI,KAAA,CAAM,CAAA,GAAI,QAAA,CAAS,KAAA,CAAM,CAAA;IAC7B,GAAA,CAAI,IAAA,GAAO,QAAA,CAAS,IAAA;IAEpB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,MAAA,EAAQ,CAAA,EAAA,EAAK;MAC9C,MAAM,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;MAC1B,MAAM,IAAA,GAAO,CAAE,CAAA;MACf,IAAA,CAAK,IAAA,GAAO,CAAA,CAAE,IAAA;MACd,IAAA,CAAK,KAAA,GAAQ,CAAE,CAAA;MACf,IAAA,CAAK,KAAA,CAAM,CAAA,GAAI,CAAA,CAAE,KAAA,CAAM,CAAA;MACvB,IAAA,CAAK,KAAA,CAAM,CAAA,GAAI,CAAA,CAAE,KAAA,CAAM,CAAA;MACvB,IAAA,CAAK,KAAA,CAAM,CAAA,GAAI,CAAA,CAAE,KAAA,CAAM,CAAA;MACvB,IAAA,CAAK,IAAA,GAAO,CAAA,CAAE,IAAA;MAEd,IAAI,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,KAAM,IAAA,CAAK,SAAA,CAAU,IAAI,CAAA,EAAG;QAChD,OAAO,CAAA;MACR;IACF;IAED,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ,CAAA;IAE5B,OAAO,QAAA;EACR;EAED,eAAA,CAAgB,QAAA,EAAU;IACxB,IAAI,QAAA,KAAa,KAAA,CAAA,EAAW;MAC1B,OAAO,IAAI,oBAAA,CAAqB;QAC9B,KAAA,EAAO,IAAI,KAAA,CAAM,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;QACxB,SAAA,EAAW,GAAA;QACX,IAAA,EAAM,SAAA;QACN,IAAA,EAAM;MACd,CAAO,CAAA;IACF;IAED,MAAM,aAAA,GAAgB,QAAA,CAAS,YAAA;IAE/B,MAAM,YAAA,GAAe,IAAI,KAAA,CAAM,aAAA,CAAc,CAAA,GAAI,GAAA,EAAO,aAAA,CAAc,CAAA,GAAI,GAAA,EAAO,aAAA,CAAc,CAAA,GAAI,GAAK,CAAA;IAExG,IAAI,aAAA,CAAc,CAAA,KAAM,CAAA,IAAK,aAAA,CAAc,CAAA,KAAM,CAAA,IAAK,aAAA,CAAc,CAAA,KAAM,CAAA,EAAG;MAC3E,YAAA,CAAa,CAAA,GAAI,CAAA;MACjB,YAAA,CAAa,CAAA,GAAI,CAAA;MACjB,YAAA,CAAa,CAAA,GAAI,CAAA;IAClB;IAID,MAAM,GAAA,GAAM,IAAI,oBAAA,CAAqB;MACnC,KAAA,EAAO,YAAA;MACP,IAAA,EAAM,QAAA,CAAS,IAAA;MACf,IAAA,EAAM,CAAA;MACN,WAAA,EAAa,QAAA,CAAS,YAAA,GAAe,CAAA,GAAI,IAAA,GAAO,KAAA;MAChD,OAAA,EAAS,CAAA,GAAM,QAAA,CAAS;IAC9B,CAAK,CAAA;IAED,MAAM,aAAA,GAAgB,IAAI,aAAA,CAAe,CAAA;IAEzC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAA,CAAS,MAAA,EAAQ,CAAA,EAAA,EAAK;MACjD,MAAM,OAAA,GAAU,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA;MAEnC,IAAI,OAAA,CAAQ,KAAA,KAAU,IAAA,EAAM;QAC1B,MAAM,GAAA,GAAM,aAAA,CAAc,IAAA,CAAK,OAAA,CAAQ,KAAK,CAAA;QAE5C,QAAQ,OAAA,CAAQ,IAAA;UACd,KAAK,SAAA;YACH,GAAA,CAAI,GAAA,GAAM,GAAA;YAEV;UAEF,KAAK,MAAA;YACH,GAAA,CAAI,OAAA,GAAU,GAAA;YAEd;UAEF,KAAK,cAAA;YACH,GAAA,CAAI,QAAA,GAAW,GAAA;YACf,GAAA,CAAI,WAAA,GAAc,IAAA;YAElB;UAEF,KAAK,MAAA;YACH,GAAA,CAAI,MAAA,GAAS,GAAA;YAEb;QACH;MACF;IACF;IAED,OAAO,GAAA;EACR;EAED,eAAA,CAAgB,IAAA,EAAM;IAGpB,MAAM,MAAA,GAAS,IAAI,QAAA,CAAU,CAAA;IAC7B,MAAM,yBAAA,GAA4B,EAAE;IACpC,MAAM,mBAAA,GAAsB,EAAE;IAC9B,MAAM,kBAAA,GAAqB,EAAE;IAE7B,MAAA,CAAO,QAAA,CAAS,QAAQ,CAAA,GAAI,IAAA,CAAK,MAAA;IACjC,MAAA,CAAO,QAAA,CAAS,QAAQ,CAAA,GAAI,IAAA,CAAK,MAAA;IACjC,MAAA,CAAO,QAAA,CAAS,UAAU,CAAA,GAAI,IAAA,CAAK,QAAA;IACnC,MAAA,CAAO,QAAA,CAAS,YAAY,CAAA,GAAI,SAAA;IAChC,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA,GAAI,IAAA;IAC/B,MAAA,CAAO,IAAA,GAAO,IAAA,CAAK,GAAA;IAEnB,IAAI,OAAA,GAAU,IAAA,CAAK,OAAA;IACnB,MAAM,SAAA,GAAY,IAAA,CAAK,SAAA;IAEvB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,EAAA,EAAK;MACvC,MAAM,GAAA,GAAM,OAAA,CAAQ,CAAC,CAAA;MACrB,MAAM,UAAA,GAAa,GAAA,CAAI,UAAA;MAEvB,QAAQ,GAAA,CAAI,UAAA;QACV,KAAK,oBAAA;UACH,mBAAA,CAAoB,IAAA,CAAK,GAAG,CAAA;UAE5B;QAEF,KAAK,mBAAA;UACH,kBAAA,CAAmB,IAAA,CAAK,GAAG,CAAA;UAE3B;QAEF;UACE,IAAI,OAAA;UAEJ,IAAI,UAAA,CAAW,aAAA,IAAiB,CAAA,EAAG;YACjC,MAAM,SAAA,GAAY,SAAA,CAAU,UAAA,CAAW,aAAa,CAAA;YACpD,IAAI,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB,SAAS,CAAA;YAC7C,QAAA,GAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ,CAAA;YAC1C,OAAA,GAAU,IAAA,CAAK,aAAA,CAAc,GAAA,EAAK,QAAQ,CAAA;UACtD,CAAA,MAAiB;YACL,MAAM,QAAA,GAAW,IAAA,CAAK,eAAA,CAAiB,CAAA;YACvC,OAAA,GAAU,IAAA,CAAK,aAAA,CAAc,GAAA,EAAK,QAAQ,CAAA;UAC3C;UAED,IAAI,OAAA,KAAY,KAAA,CAAA,EAAW;YACzB;UACD;UAED,MAAM,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,UAAU,CAAA;UAE/C,OAAA,CAAQ,OAAA,GAAU,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,UAAU,CAAA,CAAE,OAAA,GAAU,IAAA;UAEvE,IAAI,UAAA,CAAW,0BAAA,EAA4B;YACzC,yBAAA,CAA0B,IAAA,CAAK,OAAO,CAAA;UAClD,CAAA,MAAiB;YACL,MAAA,CAAO,GAAA,CAAI,OAAO,CAAA;UACnB;UAED;MACH;IACF;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,mBAAA,CAAoB,MAAA,EAAQ,CAAA,EAAA,EAAK;MACnD,MAAM,IAAA,GAAO,mBAAA,CAAoB,CAAC,CAAA;MAElC,OAAA,GAAU,EAAE;MAEZ,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,MAAA,EAAQ,CAAA,EAAA,EAAK;QACzD,MAAM,KAAA,GAAQ,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,CAAC,CAAA;QAEzC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,yBAAA,CAA0B,MAAA,EAAQ,CAAA,EAAA,EAAK;UACzD,MAAM,KAAA,GAAQ,yBAAA,CAA0B,CAAC,CAAA,CAAE,QAAA,CAAS,UAAA,CAAW,EAAA;UAE/D,IAAI,KAAA,KAAU,KAAA,EAAO;YACnB,OAAA,CAAQ,IAAA,CAAK,yBAAA,CAA0B,CAAC,CAAC,CAAA;UAC1C;QACF;MACF;MAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,kBAAA,CAAmB,MAAA,EAAQ,CAAA,EAAA,EAAK;QAClD,MAAM,IAAA,GAAO,kBAAA,CAAmB,CAAC,CAAA;QAEjC,IAAI,IAAA,CAAK,QAAA,CAAS,YAAA,KAAiB,IAAA,CAAK,UAAA,CAAW,EAAA,EAAI;UACrD,MAAM,UAAA,GAAa,IAAI,QAAA,CAAU,CAAA;UACjC,MAAM,EAAA,GAAK,IAAA,CAAK,QAAA,CAAS,KAAA,CAAM,KAAA;UAE/B,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;UAC5B,MAAA,CAAO,GAAA,CACL,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CACN,CAAA;UAED,UAAA,CAAW,YAAA,CAAa,MAAM,CAAA;UAE9B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,EAAA,EAAK;YACvC,UAAA,CAAW,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA,CAAM,IAAI,CAAC,CAAA;UACtC;UAED,MAAA,CAAO,GAAA,CAAI,UAAU,CAAA;QACtB;MACF;IACF;IAED,MAAA,CAAO,QAAA,CAAS,WAAW,CAAA,GAAI,IAAA,CAAK,SAAA;IACpC,OAAO,MAAA;EACR;EAED,aAAA,CAAc,GAAA,EAAK,GAAA,EAAK;IACtB,MAAM,MAAA,GAAS,IAAI,oBAAA,CAAsB,CAAA;IAEzC,MAAM,UAAA,GAAa,GAAA,CAAI,UAAA;IAEvB,IAAI,QAAA,EAAU,QAAA,EAAU,MAAA,EAAQ,KAAA;IAEhC,QAAQ,GAAA,CAAI,UAAA;MACV,KAAK,OAAA;MACL,KAAK,UAAA;QACH,QAAA,GAAW,MAAA,CAAO,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAA;QAEpC,IAAI,QAAA,CAAS,UAAA,CAAW,cAAA,CAAe,OAAO,CAAA,EAAG;UAC/C,QAAA,GAAW,IAAI,cAAA,CAAe;YAAE,YAAA,EAAc,IAAA;YAAM,eAAA,EAAiB,KAAA;YAAO,IAAA,EAAM;UAAA,CAAG,CAAA;QAC/F,CAAA,MAAe;UACL,MAAA,GAAS,UAAA,CAAW,SAAA;UACpB,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAK,CAAA;UACtE,QAAA,GAAW,IAAI,cAAA,CAAe;YAAE,KAAA;YAAc,eAAA,EAAiB,KAAA;YAAO,IAAA,EAAM;UAAA,CAAG,CAAA;QAChF;QAED,QAAA,GAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ,CAAA;QAE1C,MAAM,MAAA,GAAS,IAAI,MAAA,CAAO,QAAA,EAAU,QAAQ,CAAA;QAC5C,MAAA,CAAO,QAAA,CAAS,YAAY,CAAA,GAAI,UAAA;QAChC,MAAA,CAAO,QAAA,CAAS,YAAY,CAAA,GAAI,GAAA,CAAI,UAAA;QAEpC,IAAI,UAAA,CAAW,IAAA,EAAM;UACnB,MAAA,CAAO,IAAA,GAAO,UAAA,CAAW,IAAA;QAC1B;QAED,OAAO,MAAA;MAET,KAAK,MAAA;MACL,KAAK,WAAA;MACL,KAAK,MAAA;MACL,KAAK,MAAA;QACH,IAAI,GAAA,CAAI,QAAA,KAAa,IAAA,EAAM;QAE3B,QAAA,GAAW,MAAA,CAAO,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAA;QAEpC,IAAI,QAAA,CAAS,UAAA,CAAW,cAAA,CAAe,OAAO,CAAA,EAAG;UAC/C,GAAA,CAAI,YAAA,GAAe,IAAA;QACpB;QAED,IAAI,GAAA,KAAQ,IAAA,EAAM;UAChB,GAAA,GAAM,IAAA,CAAK,eAAA,CAAiB,CAAA;UAC5B,GAAA,GAAM,IAAA,CAAK,iBAAA,CAAkB,GAAG,CAAA;QACjC;QAED,MAAM,IAAA,GAAO,IAAI,IAAA,CAAK,QAAA,EAAU,GAAG,CAAA;QACnC,IAAA,CAAK,UAAA,GAAa,UAAA,CAAW,YAAA;QAC7B,IAAA,CAAK,aAAA,GAAgB,UAAA,CAAW,eAAA;QAChC,IAAA,CAAK,QAAA,CAAS,YAAY,CAAA,GAAI,UAAA;QAC9B,IAAA,CAAK,QAAA,CAAS,YAAY,CAAA,GAAI,GAAA,CAAI,UAAA;QAElC,IAAI,UAAA,CAAW,IAAA,EAAM;UACnB,IAAA,CAAK,IAAA,GAAO,UAAA,CAAW,IAAA;QACxB;QAED,OAAO,IAAA;MAET,KAAK,OAAA;QACH,QAAA,GAAW,MAAA,CAAO,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAA;QAEpC,MAAA,GAAS,UAAA,CAAW,SAAA;QACpB,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAK,CAAA;QAEtE,QAAA,GAAW,IAAI,iBAAA,CAAkB;UAAE;QAAY,CAAE,CAAA;QACjD,QAAA,GAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ,CAAA;QAE1C,MAAM,KAAA,GAAQ,IAAI,IAAA,CAAK,QAAA,EAAU,QAAQ,CAAA;QACzC,KAAA,CAAM,QAAA,CAAS,YAAY,CAAA,GAAI,UAAA;QAC/B,KAAA,CAAM,QAAA,CAAS,YAAY,CAAA,GAAI,GAAA,CAAI,UAAA;QAEnC,IAAI,UAAA,CAAW,IAAA,EAAM;UACnB,KAAA,CAAM,IAAA,GAAO,UAAA,CAAW,IAAA;QACzB;QAED,OAAO,KAAA;MAET,KAAK,SAAA;QACH,QAAA,GAAW,GAAA,CAAI,QAAA;QAEf,MAAM,GAAA,GAAM,QAAA,CAAS,aAAA,CAAc,QAAQ,CAAA,CAAE,UAAA,CAAW,IAAI,CAAA;QAC5D,MAAM,IAAA,GAAO,GAAG,QAAA,CAAS,UAAA,MAAgB,QAAA,CAAS,QAAA,EAAA;QAClD,GAAA,CAAI,IAAA,GAAO,IAAA;QACX,MAAM,KAAA,GAAQ,GAAA,CAAI,WAAA,CAAY,QAAA,CAAS,IAAI,CAAA,CAAE,KAAA,GAAQ,EAAA;QACrD,MAAM,MAAA,GAAS,QAAA,CAAS,UAAA,GAAa,EAAA;QAErC,MAAM,CAAA,GAAI,MAAA,CAAO,gBAAA;QAEjB,GAAA,CAAI,MAAA,CAAO,KAAA,GAAQ,KAAA,GAAQ,CAAA;QAC3B,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,MAAA,GAAS,CAAA;QAC7B,GAAA,CAAI,MAAA,CAAO,KAAA,CAAM,KAAA,GAAQ,KAAA,GAAQ,IAAA;QACjC,GAAA,CAAI,MAAA,CAAO,KAAA,CAAM,MAAA,GAAS,MAAA,GAAS,IAAA;QACnC,GAAA,CAAI,YAAA,CAAa,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAC,CAAA;QAEjC,GAAA,CAAI,IAAA,GAAO,IAAA;QACX,GAAA,CAAI,YAAA,GAAe,QAAA;QACnB,GAAA,CAAI,SAAA,GAAY,QAAA;QAChB,KAAA,GAAQ,UAAA,CAAW,SAAA;QACnB,GAAA,CAAI,SAAA,GAAY,QAAQ,KAAA,CAAM,CAAA,IAAK,KAAA,CAAM,CAAA,IAAK,KAAA,CAAM,CAAA,IAAK,KAAA,CAAM,CAAA,GAAA;QAC/D,GAAA,CAAI,QAAA,CAAS,CAAA,EAAG,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;QAChC,GAAA,CAAI,SAAA,GAAY,OAAA;QAChB,GAAA,CAAI,QAAA,CAAS,QAAA,CAAS,IAAA,EAAM,KAAA,GAAQ,CAAA,EAAG,MAAA,GAAS,CAAC,CAAA;QAEjD,MAAM,OAAA,GAAU,IAAI,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;QAC5C,OAAA,CAAQ,SAAA,GAAY,YAAA;QACpB,OAAA,CAAQ,KAAA,GAAQ,mBAAA;QAChB,OAAA,CAAQ,KAAA,GAAQ,mBAAA;QAEhB,QAAA,GAAW,IAAI,cAAA,CAAe;UAAE,GAAA,EAAK,OAAA;UAAS,SAAA,EAAW;QAAA,CAAO,CAAA;QAChE,MAAM,MAAA,GAAS,IAAI,MAAA,CAAO,QAAQ,CAAA;QAClC,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA,EAAG,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA,EAAG,QAAA,CAAS,KAAA,CAAM,CAAC,CAAC,CAAA;QAC3E,MAAA,CAAO,KAAA,CAAM,GAAA,CAAI,KAAA,GAAQ,EAAA,EAAI,MAAA,GAAS,EAAA,EAAI,CAAG,CAAA;QAE7C,MAAA,CAAO,QAAA,CAAS,YAAY,CAAA,GAAI,UAAA;QAChC,MAAA,CAAO,QAAA,CAAS,YAAY,CAAA,GAAI,GAAA,CAAI,UAAA;QAEpC,IAAI,UAAA,CAAW,IAAA,EAAM;UACnB,MAAA,CAAO,IAAA,GAAO,UAAA,CAAW,IAAA;QAC1B;QAED,OAAO,MAAA;MAET,KAAK,OAAA;QACH,QAAA,GAAW,GAAA,CAAI,QAAA;QAEf,IAAI,KAAA;QAEJ,IAAI,QAAA,CAAS,kBAAA,EAAoB;UAC/B,KAAA,GAAQ,IAAI,gBAAA,CAAkB,CAAA;UAC9B,KAAA,CAAM,UAAA,GAAa,UAAA,CAAW,YAAA;UAC9B,KAAA,CAAM,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAC,CAAA;UACnF,KAAA,CAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAC,CAAA;UAC7F,KAAA,CAAM,MAAA,CAAO,UAAA,GAAa,GAAA;QACpC,CAAA,MAAA,IAAmB,QAAA,CAAS,YAAA,EAAc;UAChC,KAAA,GAAQ,IAAI,UAAA,CAAY,CAAA;UACxB,KAAA,CAAM,UAAA,GAAa,UAAA,CAAW,YAAA;UAC9B,KAAA,CAAM,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAC,CAAA;UACnF,KAAA,CAAM,MAAA,CAAO,UAAA,GAAa,GAAA;QACpC,CAAA,MAAA,IAAmB,QAAA,CAAS,kBAAA,EAAoB;UACtC,KAAA,GAAQ,IAAI,aAAA,CAAe,CAAA;UAE3B,MAAMA,MAAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,KAAA,CAAM,CAAC,CAAC,CAAA;UACxC,MAAMC,OAAAA,GAAS,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAA;UAE1C,KAAA,CAAM,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,GAAIA,OAAAA,GAAS,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,GAAID,MAAAA,GAAQ,CAAC,CAAA;UAE5G,KAAA,CAAM,MAAA,GAASC,OAAAA;UACf,KAAA,CAAM,KAAA,GAAQD,MAAAA;UAEd,KAAA,CAAM,MAAA,CAAO,IAAI,OAAA,CAAQ,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAC,CAAC,CAAA;QACvG,CAAA,MAAA,IAAmB,QAAA,CAAS,WAAA,EAAa;UAC/B,KAAA,GAAQ,IAAI,SAAA,CAAW,CAAA;UACvB,KAAA,CAAM,UAAA,GAAa,UAAA,CAAW,YAAA;UAC9B,KAAA,CAAM,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAA,EAAG,QAAA,CAAS,QAAA,CAAS,CAAC,CAAC,CAAA;UACnF,KAAA,CAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAA,EAAG,QAAA,CAAS,SAAA,CAAU,CAAC,CAAC,CAAA;UAC7F,KAAA,CAAM,KAAA,GAAQ,QAAA,CAAS,gBAAA;UACvB,KAAA,CAAM,MAAA,CAAO,UAAA,GAAa,GAAA;QACpC,CAAA,MAAA,IAAmB,QAAA,CAAS,aAAA,EAAe;UACjC,OAAA,CAAQ,IAAA,CAAK,2DAA2D,CAAA;UAExE;QACD;QAED,IAAI,KAAA,EAAO;UACT,KAAA,CAAM,SAAA,GAAY,QAAA,CAAS,SAAA;UAC3B,MAAA,GAAS,QAAA,CAAS,OAAA;UAClB,KAAA,GAAQ,IAAI,KAAA,CAAM,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAK,CAAA;UACtE,KAAA,CAAM,KAAA,GAAQ,KAAA;UACd,KAAA,CAAM,QAAA,CAAS,YAAY,CAAA,GAAI,UAAA;UAC/B,KAAA,CAAM,QAAA,CAAS,YAAY,CAAA,GAAI,GAAA,CAAI,UAAA;QACpC;QAED,OAAO,KAAA;IACV;EACF;EAED,YAAA,CAAA,EAAe;IACb,IAAI,CAAC,IAAA,CAAK,cAAA,EAAgB;MAExB,MAAM,QAAA,GAAW,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;MAC5C,QAAA,CAAS,OAAA,CAAQ,IAAA,CAAK,WAAW,CAAA;MACjC,MAAM,SAAA,GAAY,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;QACjD,QAAA,CAAS,IAAA,CAAK,aAAA,EAAe,OAAA,EAAS,KAAA,CAAA,EAAW,MAAM,CAAA;MAC/D,CAAO,CAAA;MAGD,MAAM,YAAA,GAAe,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,CAAA;MAChD,YAAA,CAAa,OAAA,CAAQ,IAAA,CAAK,WAAW,CAAA;MACrC,YAAA,CAAa,eAAA,CAAgB,aAAa,CAAA;MAC1C,MAAM,aAAA,GAAgB,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAA,KAAW;QACrD,YAAA,CAAa,IAAA,CAAK,eAAA,EAAiB,OAAA,EAAS,KAAA,CAAA,EAAW,MAAM,CAAA;MACrE,CAAO,CAAA;MAED,IAAA,CAAK,cAAA,GAAiB,OAAA,CAAQ,GAAA,CAAI,CAAC,SAAA,EAAW,aAAa,CAAC,CAAA,CAAE,IAAA,CAAK,CAAC,CAACE,UAAAA,EAAWC,cAAa,CAAA,KAAM;QAEjG,IAAA,CAAK,aAAA,CAAc,UAAA,GAAaA,cAAAA;QAEhC,MAAM,EAAA,GAAK,cAAA,CAAe,QAAA,CAAU,CAAA;QAEpC,MAAM,IAAA,GAAO,CACX,mBAAA,EACA,UAAA,EACA,cAAA,EACA,EAAA,CAAG,SAAA,CAAU,EAAA,CAAG,OAAA,CAAQ,GAAG,CAAA,GAAI,CAAA,EAAG,EAAA,CAAG,WAAA,CAAY,GAAG,CAAC,CAAA,CAC/D,CAAU,IAAA,CAAK,IAAI,CAAA;QAEX,IAAA,CAAK,eAAA,GAAkB,GAAA,CAAI,eAAA,CAAgB,IAAI,IAAA,CAAK,CAAC,IAAI,CAAC,CAAC,CAAA;MACnE,CAAO,CAAA;IACF;IAED,OAAO,IAAA,CAAK,cAAA;EACb;EAED,UAAA,CAAW,QAAA,EAAU;IACnB,OAAO,IAAA,CAAK,YAAA,CAAA,CAAA,CAAe,IAAA,CAAK,MAAM;MACpC,IAAI,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS,IAAA,CAAK,WAAA,EAAa;QAC7C,MAAMC,OAAAA,GAAS,IAAI,MAAA,CAAO,IAAA,CAAK,eAAe,CAAA;QAE9C,OAAA,CAAO,UAAA,GAAa,CAAE,CAAA;QACtB,OAAA,CAAO,UAAA,GAAa,CAAE,CAAA;QACtB,OAAA,CAAO,SAAA,GAAY,CAAA;QAEnB,OAAA,CAAO,WAAA,CAAY;UACjB,IAAA,EAAM,MAAA;UACN,aAAA,EAAe,IAAA,CAAK;QAC9B,CAAS,CAAA;QAED,OAAA,CAAO,SAAA,GAAY,UAAU,CAAA,EAAG;UAC9B,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA;UAElB,QAAQ,OAAA,CAAQ,IAAA;YACd,KAAK,QAAA;cACH,OAAA,CAAO,UAAA,CAAW,OAAA,CAAQ,EAAE,CAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;cAC7C;YAEF,KAAK,OAAA;cACH,OAAA,CAAO,UAAA,CAAW,OAAA,CAAQ,EAAE,CAAA,CAAE,MAAA,CAAO,OAAO,CAAA;cAC5C;YAEF;cACE,OAAA,CAAQ,KAAA,CAAM,6CAAA,GAAgD,OAAA,CAAQ,IAAA,GAAO,GAAG,CAAA;UACnF;QACF,CAAA;QAED,IAAA,CAAK,UAAA,CAAW,IAAA,CAAKA,OAAM,CAAA;MACnC,CAAA,MAAa;QACL,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,UAAU,CAAA,EAAG,CAAA,EAAG;UACnC,OAAO,CAAA,CAAE,SAAA,GAAY,CAAA,CAAE,SAAA,GAAY,CAAA,CAAA,GAAK,CAAA;QAClD,CAAS,CAAA;MACF;MAED,MAAM,MAAA,GAAS,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA;MAEzD,MAAA,CAAO,SAAA,IAAa,QAAA;MAEpB,OAAO,MAAA;IACb,CAAK,CAAA;EACF;EAED,YAAA,CAAa,MAAA,EAAQ,MAAA,EAAQ;IAC3B,MAAA,CAAO,SAAA,IAAa,MAAA,CAAO,UAAA,CAAW,MAAM,CAAA;IAC5C,OAAO,MAAA,CAAO,UAAA,CAAW,MAAM,CAAA;IAC/B,OAAO,MAAA,CAAO,UAAA,CAAW,MAAM,CAAA;EAChC;EAED,OAAA,CAAA,EAAU;IACR,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,UAAA,CAAW,MAAA,EAAQ,EAAE,CAAA,EAAG;MAC/C,IAAA,CAAK,UAAA,CAAW,CAAC,CAAA,CAAE,SAAA,CAAW,CAAA;IAC/B;IAED,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS,CAAA;IAEzB,OAAO,IAAA;EACR;AACH;AAIA,SAAS,cAAA,CAAA,EAAiB;EACxB,IAAI,cAAA;EACJ,IAAI,aAAA;EACJ,IAAI,KAAA;EAEJ,SAAA,GAAY,SAAA,CAAU,CAAA,EAAG;IACvB,MAAM,OAAA,GAAU,CAAA,CAAE,IAAA;IAElB,QAAQ,OAAA,CAAQ,IAAA;MACd,KAAK,MAAA;QACH,aAAA,GAAgB,OAAA,CAAQ,aAAA;QACxB,MAAM,UAAA,GAAa,aAAA,CAAc,UAAA;QACjC,IAAI,WAAA;QACJ,cAAA,GAAiB,IAAI,OAAA,CAAQ,UAAU,OAAA,EAAS;UAE9C,WAAA,GAAc;YAAE,UAAA;YAAY,oBAAA,EAAsB;UAAS,CAAA;UAE3D,QAAA,CAAS,WAAW,CAAA;QAC9B,CAAS,CAAA,CAAE,IAAA,CAAK,MAAM;UACZ,KAAA,GAAQ,WAAA;QAClB,CAAS,CAAA;QAED;MAEF,KAAK,QAAA;QACH,MAAM,MAAA,GAAS,OAAA,CAAQ,MAAA;QACvB,cAAA,CAAe,IAAA,CAAK,MAAM;UACxB,MAAM,IAAA,GAAO,aAAA,CAAc,KAAA,EAAO,MAAM,CAAA;UAExC,IAAA,CAAK,WAAA,CAAY;YAAE,IAAA,EAAM,QAAA;YAAU,EAAA,EAAI,OAAA,CAAQ,EAAA;YAAI;UAAA,CAAM,CAAA;QACnE,CAAS,CAAA;QAED;IACH;EACF,CAAA;EAED,SAAS,aAAA,CAAcC,MAAAA,EAAO,MAAA,EAAQ;IACpC,MAAM,GAAA,GAAM,IAAI,UAAA,CAAW,MAAM,CAAA;IACjC,MAAM,GAAA,GAAMA,MAAAA,CAAM,OAAA,CAAQ,aAAA,CAAc,GAAG,CAAA;IAE3C,MAAM,OAAA,GAAU,EAAE;IAClB,MAAM,SAAA,GAAY,EAAE;IACpB,MAAM,MAAA,GAAS,EAAE;IACjB,MAAM,KAAA,GAAQ,EAAE;IAChB,MAAM,UAAA,GAAa,EAAE;IACrB,MAAM,MAAA,GAAS,EAAE;IAIjB,MAAM,IAAA,GAAO,GAAA,CAAI,OAAA,CAAS,CAAA;IAC1B,MAAM,GAAA,GAAM,IAAA,CAAK,KAAA;IAEjB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,CAAA,EAAA,EAAK;MAC5B,MAAM,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;MAE1B,MAAM,MAAA,GAAS,iBAAA,CAAkB,OAAA,EAAS,GAAG,CAAA;MAE7C,OAAA,CAAQ,MAAA,CAAQ,CAAA;MAEhB,IAAI,MAAA,EAAQ;QACV,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA;MACpB;IACF;IAKD,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,mBAAA,CAAA,CAAA,CAAsB,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MAC1D,MAAM,IAAA,GAAO,GAAA,CAAI,mBAAA,CAAmB,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MAC5C,MAAM,cAAA,GAAiB,iBAAA,CAAkB,IAAI,CAAA;MAC7C,cAAA,CAAe,SAAA,GAAY,IAAA,CAAK,YAAA,CAAc,CAAA;MAE9C,OAAA,CAAQ,IAAA,CAAK;QAAE,QAAA,EAAU,IAAA;QAAM,UAAA,EAAY,cAAA;QAAgB,UAAA,EAAY;MAAA,CAAsB,CAAA;IAC9F;IAID,MAAM,YAAA,GAAe;IAAA;IAEnBA,MAAAA,CAAM,WAAA,CAAY,OAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,IAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,YAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,OAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,IAAA,CACnB;IAED,MAAM,eAAA,GAAkB,CACtBA,MAAAA,CAAM,WAAA,CAAY,aAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,cAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,wBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,8BAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,YAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,YAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,gBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,aAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,eAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,wBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,SAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,aAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,aAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,iBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,sBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,cAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,oBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,YAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,oBAAA,EAClBA,MAAAA,CAAM,WAAA,CAAY,gBAAA,CACnB;IAED,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,SAAA,CAAA,CAAA,CAAY,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MAChD,MAAM,SAAA,GAAY,GAAA,CAAI,SAAA,CAAS,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MACvC,MAAM,YAAA,GAAe,SAAA,CAAU,eAAA,CAAiB,CAAA;MAEhD,IAAI,QAAA,GAAW,iBAAA,CAAkB,SAAS,CAAA;MAE1C,MAAM,QAAA,GAAW,EAAE;MAEnB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC5C,MAAM,QAAA,GAAW,SAAA,CAAU,UAAA,CAAW,YAAA,CAAa,CAAC,CAAC,CAAA;QACrD,IAAI,QAAA,EAAU;UACZ,IAAI,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,IAAA;UAC9C,WAAA,GAAc,WAAA,CAAY,SAAA,CAAU,EAAA,EAAI,WAAA,CAAY,MAAM,CAAA;UAC1D,MAAM,OAAA,GAAU;YAAE,IAAA,EAAM;UAAa,CAAA;UAErC,MAAM,KAAA,GAAQ,GAAA,CAAI,uBAAA,CAAwB,QAAA,CAAS,QAAQ,CAAA;UAE3D,IAAI,KAAA,EAAO;YACT,OAAA,CAAQ,KAAA,GAAQ,wBAAA,GAA2B,KAAA;UACvD,CAAA,MAAiB;YACL,OAAA,CAAQ,IAAA,CAAK,8BAA8B,WAAA,gCAA2C,CAAA;YACtF,OAAA,CAAQ,KAAA,GAAQ,IAAA;UACjB;UAED,QAAA,CAAS,IAAA,CAAK,OAAO,CAAA;UAErB,QAAA,CAAS,MAAA,CAAQ,CAAA;QAClB;MACF;MAED,QAAA,CAAS,QAAA,GAAW,QAAA;MAEpB,IAAI,YAAA,CAAa,SAAA,EAAW;QAC1B,OAAA,CAAQ,GAAA,CAAI,UAAU,CAAA;QAEtB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,eAAA,CAAgB,MAAA,EAAQ,CAAA,EAAA,EAAK;UAC/C,MAAM,QAAA,GAAW,SAAA,CAAU,UAAA,CAAW,YAAA,CAAa,CAAC,CAAC,CAAA;UACrD,IAAI,QAAA,EAAU;YACZ,MAAM,KAAA,GAAQ,GAAA,CAAI,uBAAA,CAAwB,QAAA,CAAS,QAAQ,CAAA;YAC3D,IAAI,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,IAAA;YAC9C,WAAA,GAAc,WAAA,CAAY,SAAA,CAAU,EAAA,EAAI,WAAA,CAAY,MAAM,CAAA;YAC1D,MAAM,OAAA,GAAU;cAAE,IAAA,EAAM,WAAA;cAAa,KAAA,EAAO,wBAAA,GAA2B;YAAO,CAAA;YAC9E,QAAA,CAAS,IAAA,CAAK,OAAO,CAAA;YAErB,QAAA,CAAS,MAAA,CAAQ,CAAA;UAClB;QACF;QAED,MAAM,oBAAA,GAAuB,iBAAA,CAAkB,SAAA,CAAU,eAAA,CAAe,CAAE,CAAA;QAE1E,QAAA,GAAW,MAAA,CAAO,MAAA,CAAO,oBAAA,EAAsB,QAAQ,CAAA;MACxD;MAED,SAAA,CAAU,IAAA,CAAK,QAAQ,CAAA;MAEvB,SAAA,CAAU,MAAA,CAAQ,CAAA;MAClB,YAAA,CAAa,MAAA,CAAQ,CAAA;IACtB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,MAAA,CAAA,CAAA,CAAS,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MAC7C,MAAM,MAAA,GAAS,GAAA,CAAI,MAAA,CAAM,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MACjC,MAAM,KAAA,GAAQ,iBAAA,CAAkB,MAAM,CAAA;MAEtC,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;MAEjB,MAAA,CAAO,MAAA,CAAQ,CAAA;IAChB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,KAAA,CAAA,CAAA,CAAQ,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MAC5C,MAAM,KAAA,GAAQ,GAAA,CAAI,KAAA,CAAK,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MAC/B,MAAM,IAAA,GAAO,iBAAA,CAAkB,KAAK,CAAA;MAEpC,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;MAEf,KAAA,CAAM,MAAA,CAAQ,CAAA;IACf;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,UAAA,CAAA,CAAA,CAAa,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MACjD,MAAM,UAAA,GAAa,GAAA,CAAI,UAAA,CAAU,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MACzC,MAAM,SAAA,GAAY,iBAAA,CAAkB,UAAU,CAAA;MAE9C,UAAA,CAAW,IAAA,CAAK,SAAS,CAAA;MAEzB,UAAA,CAAW,MAAA,CAAQ,CAAA;IACpB;IAID,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,MAAA,CAAA,CAAA,CAAS,KAAA,CAAA,CAAA,EAAS,CAAA,EAAA,EAAK;MAC7C,MAAM,MAAA,GAAS,GAAA,CAAI,MAAA,CAAM,CAAA,CAAG,GAAA,CAAI,CAAC,CAAA;MACjC,MAAM,KAAA,GAAQ,iBAAA,CAAkB,MAAM,CAAA;MAEtC,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;MAEjB,MAAA,CAAO,MAAA,CAAQ,CAAA;IAChB;IAID,MAAM,QAAA,GAAW,iBAAA,CAAkB,GAAA,CAAI,QAAA,CAAQ,CAAE,CAAA;IA4BjD,GAAA,CAAI,MAAA,CAAQ,CAAA;IAEZ,OAAO;MAAE,OAAA;MAAS,SAAA;MAAW,MAAA;MAAQ,KAAA;MAAO,UAAA;MAAY,MAAA;MAAQ;IAAU,CAAA;EAC3E;EAED,SAAS,iBAAA,CAAkB,MAAA,EAAQ,GAAA,EAAK;IACtC,MAAM,SAAA,GAAY,MAAA,CAAO,QAAA,CAAU,CAAA;IACnC,MAAM,WAAA,GAAc,MAAA,CAAO,UAAA,CAAY,CAAA;IACvC,IAAI,UAAA,GAAa,SAAA,CAAU,UAAA;IAC3B,IAAI,QAAA,EAAU,UAAA,EAAY,QAAA,EAAU,IAAA,EAAM,IAAA;IAM1C,QAAQ,UAAA;MACN,KAAK,KAAA,CAAM,UAAA,CAAW,KAAA;QACpB,MAAM,GAAA,GAAM,aAAA,CAAc,SAAA,EAAW,GAAG,CAAA;QAExC,QAAA,GAAW,CAAE,CAAA;QACb,UAAA,GAAa,CAAE,CAAA;QACf,IAAA,GAAO,CAAE,CAAA;QAET,QAAA,CAAS,QAAA,GAAW,CAAA;QACpB,QAAA,CAAS,IAAA,GAAO,cAAA;QAChB,QAAA,CAAS,KAAA,GAAQ,EAAE;QAEnB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;UACnC,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC,CAAA;UAC7B,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC,CAAA;UAC7B,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC,CAAA;QAC9B;QAED,UAAA,CAAW,QAAA,GAAW,QAAA;QACtB,IAAA,CAAK,UAAA,GAAa,UAAA;QAElB,QAAA,GAAW;UAAE;QAAM,CAAA;QAEnB;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,KAAA;QACpB,MAAM,EAAA,GAAK,SAAA,CAAU,QAAA;QAErB,QAAA,GAAW,CAAE,CAAA;QACb,MAAM,KAAA,GAAQ,CAAE,CAAA;QAChB,UAAA,GAAa,CAAE,CAAA;QACf,IAAA,GAAO,CAAE,CAAA;QAET,QAAA,CAAS,QAAA,GAAW,CAAA;QACpB,QAAA,CAAS,IAAA,GAAO,cAAA;QAChB,QAAA,CAAS,KAAA,GAAQ,CAAC,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAC,CAAA;QAErC,MAAM,MAAA,GAAS,WAAA,CAAY,SAAA,CAAU,GAAG,CAAA;QAExC,KAAA,CAAM,QAAA,GAAW,CAAA;QACjB,KAAA,CAAM,IAAA,GAAO,cAAA;QACb,KAAA,CAAM,KAAA,GAAQ,CAAC,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAA,EAAO,MAAA,CAAO,CAAA,GAAI,GAAK,CAAA;QAEnE,UAAA,CAAW,QAAA,GAAW,QAAA;QACtB,UAAA,CAAW,KAAA,GAAQ,KAAA;QACnB,IAAA,CAAK,UAAA,GAAa,UAAA;QAElB,QAAA,GAAW;UAAE;QAAM,CAAA;QAEnB;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,QAAA;MACtB,KAAK,KAAA,CAAM,UAAA,CAAW,IAAA;QACpB,QAAA,GAAW,SAAA,CAAU,aAAA,CAAe,CAAA;QAEpC;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,IAAA;QACpB,MAAM,KAAA,GAAQ,SAAA,CAAU,KAAA,CAAO,CAAA;QAC/B,IAAA,GAAO,IAAI,KAAA,CAAM,IAAA,CAAM,CAAA;QAEvB,KAAA,IAAS,SAAA,GAAY,CAAA,EAAG,SAAA,GAAY,KAAA,CAAM,KAAA,EAAO,SAAA,EAAA,EAAa;UAC5D,MAAM,IAAA,GAAO,KAAA,CAAM,GAAA,CAAI,SAAS,CAAA;UAChC,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA;UAE7C,IAAI,KAAA,EAAO;YACT,IAAA,CAAK,MAAA,CAAO,KAAK,CAAA;YACjB,KAAA,CAAM,MAAA,CAAQ,CAAA;UACf;UAED,IAAA,CAAK,MAAA,CAAQ,CAAA;QACd;QAED,IAAI,IAAA,CAAK,KAAA,CAAA,CAAA,CAAQ,KAAA,GAAQ,CAAA,EAAG;UAC1B,IAAA,CAAK,OAAA,CAAS,CAAA;UACd,QAAA,GAAW,IAAA,CAAK,aAAA,CAAe,CAAA;UAC/B,KAAA,CAAM,MAAA,CAAQ,CAAA;QACf;QAED,IAAA,CAAK,MAAA,CAAQ,CAAA;QAEb;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,SAAA;QACpB,IAAA,GAAO,SAAA,CAAU,OAAA,CAAQ,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA;QAE3C,IAAI,IAAA,EAAM;UACR,QAAA,GAAW,IAAA,CAAK,aAAA,CAAe,CAAA;UAC/B,IAAA,CAAK,MAAA,CAAQ,CAAA;QACd;QAED;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,OAAA;QACpB,QAAA,GAAW,iBAAA,CAAkB,SAAS,CAAA;QAEtC;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,KAAA;QACpB,QAAA,GAAW,iBAAA,CAAkB,SAAS,CAAA;QAEtC;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,iBAAA;QACpB,QAAA,GAAW,iBAAA,CAAkB,SAAS,CAAA;QACtC,QAAA,CAAS,KAAA,GAAQ,iBAAA,CAAkB,SAAA,CAAU,KAAK,CAAA;QAClD,QAAA,CAAS,KAAA,CAAM,KAAA,GAAQ,SAAA,CAAU,KAAA,CAAM,YAAA,CAAa,IAAI,CAAA;QAExD;MAEF,KAAK,KAAA,CAAM,UAAA,CAAW,IAAA;QAEpB,SAAA,CAAU,SAAA,CAAU,CAAC,CAAA;QACrB,IAAA,GAAO,KAAA,CAAM,IAAA,CAAK,wBAAA,CAAyB,SAAS,CAAA;QACpD,IAAI,IAAA,EAAM;UACR,QAAA,GAAW,IAAA,CAAK,aAAA,CAAe,CAAA;UAC/B,IAAA,CAAK,MAAA,CAAQ,CAAA;QACd;QAED;MAQF;QACE,OAAA,CAAQ,IAAA,CAAK,oCAAoC,UAAA,CAAW,WAAA,CAAY,IAAA,EAAM,CAAA;QAC9E;IACH;IAED,IAAI,QAAA,EAAU;MACZ,UAAA,GAAa,iBAAA,CAAkB,WAAW,CAAA;MAC1C,UAAA,CAAW,QAAA,GAAW,iBAAA,CAAkB,SAAS,CAAA;MAEjD,IAAI,WAAA,CAAY,UAAA,GAAa,CAAA,EAAG;QAC9B,UAAA,CAAW,QAAA,GAAW,WAAA,CAAY,YAAA,CAAc,CAAA;MACjD;MAED,IAAI,WAAA,CAAY,eAAA,GAAkB,CAAA,EAAG;QACnC,UAAA,CAAW,WAAA,GAAc,WAAA,CAAY,cAAA,CAAgB,CAAA;MACtD;MAED,IAAI,SAAA,CAAU,eAAA,GAAkB,CAAA,EAAG;QACjC,UAAA,CAAW,QAAA,CAAS,WAAA,GAAc,SAAA,CAAU,cAAA,CAAgB,CAAA;MAC7D;MAED,UAAA,CAAW,SAAA,GAAY,WAAA,CAAY,SAAA,CAAU,GAAG,CAAA;MAEhD,UAAA,GAAa,UAAA,CAAW,WAAA,CAAY,IAAA;MACpC,UAAA,GAAa,UAAA,CAAW,SAAA,CAAU,EAAA,EAAI,UAAA,CAAW,MAAM,CAAA;MAEvD,OAAO;QAAE,QAAA;QAAU,UAAA;QAAY;MAAY,CAAA;IACjD,CAAA,MAAW;MACL,OAAA,CAAQ,IAAA,CAAK,oBAAoB,UAAA,CAAW,WAAA,CAAY,IAAA,mCAAuC,CAAA;IAChG;EACF;EAED,SAAS,iBAAA,CAAkB,MAAA,EAAQ;IACjC,MAAM,MAAA,GAAS,CAAE,CAAA;IAEjB,KAAA,MAAW,QAAA,IAAY,MAAA,EAAQ;MAC7B,MAAM,KAAA,GAAQ,MAAA,CAAO,QAAQ,CAAA;MAE7B,IAAI,OAAO,KAAA,KAAU,UAAA,EAAY;QAC/B,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,IAAA,IAAQ,KAAA,CAAM,cAAA,CAAe,aAAa,CAAA,EAAG;UACtF,MAAA,CAAO,QAAQ,CAAA,GAAI;YAAE,IAAA,EAAM,KAAA,CAAM,WAAA,CAAY,IAAA;YAAM,KAAA,EAAO,KAAA,CAAM;UAAO,CAAA;QACjF,CAAA,MAAe;UACL,MAAA,CAAO,QAAQ,CAAA,GAAI,KAAA;QACpB;MAIF;IACF;IAED,OAAO,MAAA;EACR;EAED,SAAS,aAAA,CAAc,KAAA,EAAO,UAAA,EAAY;IACxC,IAAI,UAAA,GAAa,UAAA;IACjB,IAAI,EAAA,GAAK,EAAE;IACX,MAAM,EAAA,GAAK,EAAE;IAEb,IAAI,KAAA,YAAiB,KAAA,CAAM,SAAA,EAAW;MACpC,OAAO,CAAC,KAAA,CAAM,YAAA,EAAc,KAAA,CAAM,UAAU,CAAA;IAC7C;IAED,IAAI,KAAA,YAAiB,KAAA,CAAM,aAAA,EAAe;MACxC,UAAA,GAAa,KAAA,CAAM,UAAA;MACnB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,EAAY,CAAA,EAAA,EAAK;QACnC,EAAA,CAAG,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,CAAC,CAAC,CAAA;MACvB;MAED,OAAO,EAAA;IACR;IAED,IAAI,KAAA,YAAiB,KAAA,CAAM,SAAA,EAAW;MACpC,MAAM,YAAA,GAAe,KAAA,CAAM,YAAA;MAE3B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,EAAc,CAAA,EAAA,EAAK;QACrC,MAAM,OAAA,GAAU,KAAA,CAAM,YAAA,CAAa,CAAC,CAAA;QACpC,MAAM,YAAA,GAAe,aAAA,CAAc,OAAA,EAAS,UAAU,CAAA;QACtD,EAAA,GAAK,EAAA,CAAG,MAAA,CAAO,YAAY,CAAA;QAC3B,OAAA,CAAQ,MAAA,CAAQ,CAAA;MACjB;MAED,OAAO,EAAA;IACR;IAED,IAAI,KAAA,YAAiB,KAAA,CAAM,QAAA,EAAU;MACnC,UAAA,GAAa,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,YAAA,GAAe,CAAC,CAAA;MAC9C,UAAA,GAAa,UAAA,GAAa,CAAA,GAAI,CAAA,GAAI,UAAA;IAEnC;IAED,IAAI,KAAA,YAAiB,KAAA,CAAM,UAAA,IAAc,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;MAC3D,MAAM,KAAA,GAAQ,KAAA,CAAM,cAAA,CAAgB,CAAA;MAEpC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,KAAA,EAAO,CAAA,EAAA,EAAK;QACpC,EAAA,CAAG,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,CAAC,CAAA;MACrB;MAED,KAAA,CAAM,MAAA,CAAQ,CAAA;MAEd,OAAO,EAAA;IACR;IAED,MAAM,MAAA,GAAS,KAAA,CAAM,MAAA;IACrB,MAAM,SAAA,GAAY,UAAA,GAAa,CAAA;IAE/B,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,EAAY,CAAA,EAAA,EAAK;MACnC,MAAM,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA,GAAK,CAAA,GAAI,SAAA,IAAc,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA,CAAA;MAE7D,IAAI,CAAA,KAAM,MAAA,CAAO,CAAC,CAAA,IAAK,CAAA,KAAM,MAAA,CAAO,CAAC,CAAA,EAAG;QACtC,EAAA,CAAG,IAAA,CAAK,CAAC,CAAA;QACT;MACD;MAED,MAAM,GAAA,GAAM,KAAA,CAAM,SAAA,CAAU,CAAC,CAAA;MAC7B,MAAM,OAAA,GAAU,KAAA,CAAM,SAAA,CAAU,EAAA,CAAG,KAAA,CAAM,CAAA,CAAE,CAAA,CAAE,CAAC,CAAC,CAAA;MAK/C,MAAM,EAAA,GAAK,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA;MAC7D,MAAM,GAAA,GAAM,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA;MAEtF,MAAM,WAAA,GAAc,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,GAAG,CAAA;MAEtC,IAAI,KAAA;MAEJ,IAAI,WAAA,KAAgB,CAAA,EAAG;QACrB,KAAA,GAAQ,IAAA,CAAK,EAAA,GAAK,CAAA;MAC1B,CAAA,MAAa;QACL,MAAM,KAAA,GAAA,CAAS,GAAA,CAAI,CAAA,GAAI,OAAA,CAAQ,CAAA,GAAI,GAAA,CAAI,CAAA,GAAI,OAAA,CAAQ,CAAA,GAAI,GAAA,CAAI,CAAA,GAAI,OAAA,CAAQ,CAAA,IAAK,WAAA;QAC5E,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,CAAA,CAAA,EAAI,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,KAAK,CAAC,CAAC,CAAA;MACnD;MAED,IAAI,KAAA,GAAQ,GAAA,EAAK;MAEjB,EAAA,CAAG,IAAA,CAAK,CAAC,CAAA;IACV;IAED,EAAA,GAAK,EAAA,CAAG,GAAA,CAAK,CAAA,IAAM,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAC,CAAA;IACnC,OAAO,EAAA;EACR;AACH","sourcesContent":["import {\n  BufferGeometryLoader,\n  FileLoader,\n  Loader,\n  Object3D,\n  MeshStandardMaterial,\n  Mesh,\n  Color,\n  Points,\n  PointsMaterial,\n  Line,\n  LineBasicMaterial,\n  Matrix4,\n  DirectionalLight,\n  PointLight,\n  SpotLight,\n  RectAreaLight,\n  Vector3,\n  Sprite,\n  SpriteMaterial,\n  CanvasTexture,\n  LinearFilter,\n  ClampToEdgeWrapping,\n  TextureLoader,\n} from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass Rhino3dmLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.libraryPath = ''\n    this.libraryPending = null\n    this.libraryBinary = null\n    this.libraryConfig = {}\n\n    this.url = ''\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = {}\n\n    this.materials = []\n  }\n\n  setLibraryPath(path) {\n    this.libraryPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n\n    this.url = url\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this.decodeObjects(buffer, url).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  decodeObjects(buffer, url) {\n    let worker\n    let taskID\n\n    const taskCost = buffer.byteLength\n\n    const objectPending = this._getWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++ //hmmm\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, buffer }, [buffer])\n\n          //this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.data))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    objectPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          //this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      url: url,\n      promise: objectPending,\n    })\n\n    return objectPending\n  }\n\n  parse(data, onLoad, onError) {\n    this.decodeObjects(data, '').then(onLoad).catch(onError)\n  }\n\n  _compareMaterials(material) {\n    const mat = {}\n    mat.name = material.name\n    mat.color = {}\n    mat.color.r = material.color.r\n    mat.color.g = material.color.g\n    mat.color.b = material.color.b\n    mat.type = material.type\n\n    for (let i = 0; i < this.materials.length; i++) {\n      const m = this.materials[i]\n      const _mat = {}\n      _mat.name = m.name\n      _mat.color = {}\n      _mat.color.r = m.color.r\n      _mat.color.g = m.color.g\n      _mat.color.b = m.color.b\n      _mat.type = m.type\n\n      if (JSON.stringify(mat) === JSON.stringify(_mat)) {\n        return m\n      }\n    }\n\n    this.materials.push(material)\n\n    return material\n  }\n\n  _createMaterial(material) {\n    if (material === undefined) {\n      return new MeshStandardMaterial({\n        color: new Color(1, 1, 1),\n        metalness: 0.8,\n        name: 'default',\n        side: 2,\n      })\n    }\n\n    const _diffuseColor = material.diffuseColor\n\n    const diffusecolor = new Color(_diffuseColor.r / 255.0, _diffuseColor.g / 255.0, _diffuseColor.b / 255.0)\n\n    if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {\n      diffusecolor.r = 1\n      diffusecolor.g = 1\n      diffusecolor.b = 1\n    }\n\n    // console.log( material );\n\n    const mat = new MeshStandardMaterial({\n      color: diffusecolor,\n      name: material.name,\n      side: 2,\n      transparent: material.transparency > 0 ? true : false,\n      opacity: 1.0 - material.transparency,\n    })\n\n    const textureLoader = new TextureLoader()\n\n    for (let i = 0; i < material.textures.length; i++) {\n      const texture = material.textures[i]\n\n      if (texture.image !== null) {\n        const map = textureLoader.load(texture.image)\n\n        switch (texture.type) {\n          case 'Diffuse':\n            mat.map = map\n\n            break\n\n          case 'Bump':\n            mat.bumpMap = map\n\n            break\n\n          case 'Transparency':\n            mat.alphaMap = map\n            mat.transparent = true\n\n            break\n\n          case 'Emap':\n            mat.envMap = map\n\n            break\n        }\n      }\n    }\n\n    return mat\n  }\n\n  _createGeometry(data) {\n    // console.log(data);\n\n    const object = new Object3D()\n    const instanceDefinitionObjects = []\n    const instanceDefinitions = []\n    const instanceReferences = []\n\n    object.userData['layers'] = data.layers\n    object.userData['groups'] = data.groups\n    object.userData['settings'] = data.settings\n    object.userData['objectType'] = 'File3dm'\n    object.userData['materials'] = null\n    object.name = this.url\n\n    let objects = data.objects\n    const materials = data.materials\n\n    for (let i = 0; i < objects.length; i++) {\n      const obj = objects[i]\n      const attributes = obj.attributes\n\n      switch (obj.objectType) {\n        case 'InstanceDefinition':\n          instanceDefinitions.push(obj)\n\n          break\n\n        case 'InstanceReference':\n          instanceReferences.push(obj)\n\n          break\n\n        default:\n          let _object\n\n          if (attributes.materialIndex >= 0) {\n            const rMaterial = materials[attributes.materialIndex]\n            let material = this._createMaterial(rMaterial)\n            material = this._compareMaterials(material)\n            _object = this._createObject(obj, material)\n          } else {\n            const material = this._createMaterial()\n            _object = this._createObject(obj, material)\n          }\n\n          if (_object === undefined) {\n            continue\n          }\n\n          const layer = data.layers[attributes.layerIndex]\n\n          _object.visible = layer ? data.layers[attributes.layerIndex].visible : true\n\n          if (attributes.isInstanceDefinitionObject) {\n            instanceDefinitionObjects.push(_object)\n          } else {\n            object.add(_object)\n          }\n\n          break\n      }\n    }\n\n    for (let i = 0; i < instanceDefinitions.length; i++) {\n      const iDef = instanceDefinitions[i]\n\n      objects = []\n\n      for (let j = 0; j < iDef.attributes.objectIds.length; j++) {\n        const objId = iDef.attributes.objectIds[j]\n\n        for (let p = 0; p < instanceDefinitionObjects.length; p++) {\n          const idoId = instanceDefinitionObjects[p].userData.attributes.id\n\n          if (objId === idoId) {\n            objects.push(instanceDefinitionObjects[p])\n          }\n        }\n      }\n\n      // Currently clones geometry and does not take advantage of instancing\n\n      for (let j = 0; j < instanceReferences.length; j++) {\n        const iRef = instanceReferences[j]\n\n        if (iRef.geometry.parentIdefId === iDef.attributes.id) {\n          const iRefObject = new Object3D()\n          const xf = iRef.geometry.xform.array\n\n          const matrix = new Matrix4()\n          matrix.set(\n            xf[0],\n            xf[1],\n            xf[2],\n            xf[3],\n            xf[4],\n            xf[5],\n            xf[6],\n            xf[7],\n            xf[8],\n            xf[9],\n            xf[10],\n            xf[11],\n            xf[12],\n            xf[13],\n            xf[14],\n            xf[15],\n          )\n\n          iRefObject.applyMatrix4(matrix)\n\n          for (let p = 0; p < objects.length; p++) {\n            iRefObject.add(objects[p].clone(true))\n          }\n\n          object.add(iRefObject)\n        }\n      }\n    }\n\n    object.userData['materials'] = this.materials\n    return object\n  }\n\n  _createObject(obj, mat) {\n    const loader = new BufferGeometryLoader()\n\n    const attributes = obj.attributes\n\n    let geometry, material, _color, color\n\n    switch (obj.objectType) {\n      case 'Point':\n      case 'PointSet':\n        geometry = loader.parse(obj.geometry)\n\n        if (geometry.attributes.hasOwnProperty('color')) {\n          material = new PointsMaterial({ vertexColors: true, sizeAttenuation: false, size: 2 })\n        } else {\n          _color = attributes.drawColor\n          color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n          material = new PointsMaterial({ color: color, sizeAttenuation: false, size: 2 })\n        }\n\n        material = this._compareMaterials(material)\n\n        const points = new Points(geometry, material)\n        points.userData['attributes'] = attributes\n        points.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          points.name = attributes.name\n        }\n\n        return points\n\n      case 'Mesh':\n      case 'Extrusion':\n      case 'SubD':\n      case 'Brep':\n        if (obj.geometry === null) return\n\n        geometry = loader.parse(obj.geometry)\n\n        if (geometry.attributes.hasOwnProperty('color')) {\n          mat.vertexColors = true\n        }\n\n        if (mat === null) {\n          mat = this._createMaterial()\n          mat = this._compareMaterials(mat)\n        }\n\n        const mesh = new Mesh(geometry, mat)\n        mesh.castShadow = attributes.castsShadows\n        mesh.receiveShadow = attributes.receivesShadows\n        mesh.userData['attributes'] = attributes\n        mesh.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          mesh.name = attributes.name\n        }\n\n        return mesh\n\n      case 'Curve':\n        geometry = loader.parse(obj.geometry)\n\n        _color = attributes.drawColor\n        color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n\n        material = new LineBasicMaterial({ color: color })\n        material = this._compareMaterials(material)\n\n        const lines = new Line(geometry, material)\n        lines.userData['attributes'] = attributes\n        lines.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          lines.name = attributes.name\n        }\n\n        return lines\n\n      case 'TextDot':\n        geometry = obj.geometry\n\n        const ctx = document.createElement('canvas').getContext('2d')\n        const font = `${geometry.fontHeight}px ${geometry.fontFace}`\n        ctx.font = font\n        const width = ctx.measureText(geometry.text).width + 10\n        const height = geometry.fontHeight + 10\n\n        const r = window.devicePixelRatio\n\n        ctx.canvas.width = width * r\n        ctx.canvas.height = height * r\n        ctx.canvas.style.width = width + 'px'\n        ctx.canvas.style.height = height + 'px'\n        ctx.setTransform(r, 0, 0, r, 0, 0)\n\n        ctx.font = font\n        ctx.textBaseline = 'middle'\n        ctx.textAlign = 'center'\n        color = attributes.drawColor\n        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = 'white'\n        ctx.fillText(geometry.text, width / 2, height / 2)\n\n        const texture = new CanvasTexture(ctx.canvas)\n        texture.minFilter = LinearFilter\n        texture.wrapS = ClampToEdgeWrapping\n        texture.wrapT = ClampToEdgeWrapping\n\n        material = new SpriteMaterial({ map: texture, depthTest: false })\n        const sprite = new Sprite(material)\n        sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2])\n        sprite.scale.set(width / 10, height / 10, 1.0)\n\n        sprite.userData['attributes'] = attributes\n        sprite.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          sprite.name = attributes.name\n        }\n\n        return sprite\n\n      case 'Light':\n        geometry = obj.geometry\n\n        let light\n\n        if (geometry.isDirectionalLight) {\n          light = new DirectionalLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2])\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isPointLight) {\n          light = new PointLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isRectangularLight) {\n          light = new RectAreaLight()\n\n          const width = Math.abs(geometry.width[2])\n          const height = Math.abs(geometry.length[0])\n\n          light.position.set(geometry.location[0] - height / 2, geometry.location[1], geometry.location[2] - width / 2)\n\n          light.height = height\n          light.width = width\n\n          light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]))\n        } else if (geometry.isSpotLight) {\n          light = new SpotLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2])\n          light.angle = geometry.spotAngleRadians\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isLinearLight) {\n          console.warn('THREE.3DMLoader:  No conversion exists for linear lights.')\n\n          return\n        }\n\n        if (light) {\n          light.intensity = geometry.intensity\n          _color = geometry.diffuse\n          color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n          light.color = color\n          light.userData['attributes'] = attributes\n          light.userData['objectType'] = obj.objectType\n        }\n\n        return light\n    }\n  }\n\n  _initLibrary() {\n    if (!this.libraryPending) {\n      // Load rhino3dm wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.libraryPath)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('rhino3dm.js', resolve, undefined, reject)\n      })\n\n      // Load rhino3dm WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.libraryPath)\n      binaryLoader.setResponseType('arraybuffer')\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('rhino3dm.wasm', resolve, undefined, reject)\n      })\n\n      this.libraryPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        //this.libraryBinary = binaryContent;\n        this.libraryConfig.wasmBinary = binaryContent\n\n        const fn = Rhino3dmWorker.toString()\n\n        const body = [\n          '/* rhino3dm.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n      })\n    }\n\n    return this.libraryPending\n  }\n\n  _getWorker(taskCost) {\n    return this._initLibrary().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          libraryConfig: this.libraryConfig,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction Rhino3dmWorker() {\n  let libraryPending\n  let libraryConfig\n  let rhino\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        libraryConfig = message.libraryConfig\n        const wasmBinary = libraryConfig.wasmBinary\n        let RhinoModule\n        libraryPending = new Promise(function (resolve) {\n          /* Like Basis Loader */\n          RhinoModule = { wasmBinary, onRuntimeInitialized: resolve }\n\n          rhino3dm(RhinoModule)\n        }).then(() => {\n          rhino = RhinoModule\n        })\n\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        libraryPending.then(() => {\n          const data = decodeObjects(rhino, buffer)\n\n          self.postMessage({ type: 'decode', id: message.id, data })\n        })\n\n        break\n    }\n  }\n\n  function decodeObjects(rhino, buffer) {\n    const arr = new Uint8Array(buffer)\n    const doc = rhino.File3dm.fromByteArray(arr)\n\n    const objects = []\n    const materials = []\n    const layers = []\n    const views = []\n    const namedViews = []\n    const groups = []\n\n    //Handle objects\n\n    const objs = doc.objects()\n    const cnt = objs.count\n\n    for (let i = 0; i < cnt; i++) {\n      const _object = objs.get(i)\n\n      const object = extractObjectData(_object, doc)\n\n      _object.delete()\n\n      if (object) {\n        objects.push(object)\n      }\n    }\n\n    // Handle instance definitions\n    // console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` );\n\n    for (let i = 0; i < doc.instanceDefinitions().count(); i++) {\n      const idef = doc.instanceDefinitions().get(i)\n      const idefAttributes = extractProperties(idef)\n      idefAttributes.objectIds = idef.getObjectIds()\n\n      objects.push({ geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' })\n    }\n\n    // Handle materials\n\n    const textureTypes = [\n      // rhino.TextureType.Bitmap,\n      rhino.TextureType.Diffuse,\n      rhino.TextureType.Bump,\n      rhino.TextureType.Transparency,\n      rhino.TextureType.Opacity,\n      rhino.TextureType.Emap,\n    ]\n\n    const pbrTextureTypes = [\n      rhino.TextureType.PBR_BaseColor,\n      rhino.TextureType.PBR_Subsurface,\n      rhino.TextureType.PBR_SubsurfaceScattering,\n      rhino.TextureType.PBR_SubsurfaceScatteringRadius,\n      rhino.TextureType.PBR_Metallic,\n      rhino.TextureType.PBR_Specular,\n      rhino.TextureType.PBR_SpecularTint,\n      rhino.TextureType.PBR_Roughness,\n      rhino.TextureType.PBR_Anisotropic,\n      rhino.TextureType.PBR_Anisotropic_Rotation,\n      rhino.TextureType.PBR_Sheen,\n      rhino.TextureType.PBR_SheenTint,\n      rhino.TextureType.PBR_Clearcoat,\n      rhino.TextureType.PBR_ClearcoatBump,\n      rhino.TextureType.PBR_ClearcoatRoughness,\n      rhino.TextureType.PBR_OpacityIor,\n      rhino.TextureType.PBR_OpacityRoughness,\n      rhino.TextureType.PBR_Emission,\n      rhino.TextureType.PBR_AmbientOcclusion,\n      rhino.TextureType.PBR_Displacement,\n    ]\n\n    for (let i = 0; i < doc.materials().count(); i++) {\n      const _material = doc.materials().get(i)\n      const _pbrMaterial = _material.physicallyBased()\n\n      let material = extractProperties(_material)\n\n      const textures = []\n\n      for (let j = 0; j < textureTypes.length; j++) {\n        const _texture = _material.getTexture(textureTypes[j])\n        if (_texture) {\n          let textureType = textureTypes[j].constructor.name\n          textureType = textureType.substring(12, textureType.length)\n          const texture = { type: textureType }\n\n          const image = doc.getEmbeddedFileAsBase64(_texture.fileName)\n\n          if (image) {\n            texture.image = 'data:image/png;base64,' + image\n          } else {\n            console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`)\n            texture.image = null\n          }\n\n          textures.push(texture)\n\n          _texture.delete()\n        }\n      }\n\n      material.textures = textures\n\n      if (_pbrMaterial.supported) {\n        console.log('pbr true')\n\n        for (let j = 0; j < pbrTextureTypes.length; j++) {\n          const _texture = _material.getTexture(textureTypes[j])\n          if (_texture) {\n            const image = doc.getEmbeddedFileAsBase64(_texture.fileName)\n            let textureType = textureTypes[j].constructor.name\n            textureType = textureType.substring(12, textureType.length)\n            const texture = { type: textureType, image: 'data:image/png;base64,' + image }\n            textures.push(texture)\n\n            _texture.delete()\n          }\n        }\n\n        const pbMaterialProperties = extractProperties(_material.physicallyBased())\n\n        material = Object.assign(pbMaterialProperties, material)\n      }\n\n      materials.push(material)\n\n      _material.delete()\n      _pbrMaterial.delete()\n    }\n\n    // Handle layers\n\n    for (let i = 0; i < doc.layers().count(); i++) {\n      const _layer = doc.layers().get(i)\n      const layer = extractProperties(_layer)\n\n      layers.push(layer)\n\n      _layer.delete()\n    }\n\n    // Handle views\n\n    for (let i = 0; i < doc.views().count(); i++) {\n      const _view = doc.views().get(i)\n      const view = extractProperties(_view)\n\n      views.push(view)\n\n      _view.delete()\n    }\n\n    // Handle named views\n\n    for (let i = 0; i < doc.namedViews().count(); i++) {\n      const _namedView = doc.namedViews().get(i)\n      const namedView = extractProperties(_namedView)\n\n      namedViews.push(namedView)\n\n      _namedView.delete()\n    }\n\n    // Handle groups\n\n    for (let i = 0; i < doc.groups().count(); i++) {\n      const _group = doc.groups().get(i)\n      const group = extractProperties(_group)\n\n      groups.push(group)\n\n      _group.delete()\n    }\n\n    // Handle settings\n\n    const settings = extractProperties(doc.settings())\n\n    //TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.\n\n    // Handle dimstyles\n    // console.log( `Dimstyle Count: ${doc.dimstyles().count()}` );\n\n    // Handle bitmaps\n    // console.log( `Bitmap Count: ${doc.bitmaps().count()}` );\n\n    // Handle strings -- this seems to be broken at the moment in rhino3dm\n    // console.log( `Document Strings Count: ${doc.strings().count()}` );\n\n    /*\n\t\tfor( var i = 0; i < doc.strings().count(); i++ ){\n\n\t\t\tvar _string= doc.strings().get( i );\n\n\t\t\tconsole.log(_string);\n\t\t\tvar string = extractProperties( _group );\n\n\t\t\tstrings.push( string );\n\n\t\t\t_string.delete();\n\n\t\t}\n\t\t*/\n\n    doc.delete()\n\n    return { objects, materials, layers, views, namedViews, groups, settings }\n  }\n\n  function extractObjectData(object, doc) {\n    const _geometry = object.geometry()\n    const _attributes = object.attributes()\n    let objectType = _geometry.objectType\n    let geometry, attributes, position, data, mesh\n\n    // skip instance definition objects\n    //if( _attributes.isInstanceDefinitionObject ) { continue; }\n\n    // TODO: handle other geometry types\n    switch (objectType) {\n      case rhino.ObjectType.Curve:\n        const pts = curveToPoints(_geometry, 100)\n\n        position = {}\n        attributes = {}\n        data = {}\n\n        position.itemSize = 3\n        position.type = 'Float32Array'\n        position.array = []\n\n        for (let j = 0; j < pts.length; j++) {\n          position.array.push(pts[j][0])\n          position.array.push(pts[j][1])\n          position.array.push(pts[j][2])\n        }\n\n        attributes.position = position\n        data.attributes = attributes\n\n        geometry = { data }\n\n        break\n\n      case rhino.ObjectType.Point:\n        const pt = _geometry.location\n\n        position = {}\n        const color = {}\n        attributes = {}\n        data = {}\n\n        position.itemSize = 3\n        position.type = 'Float32Array'\n        position.array = [pt[0], pt[1], pt[2]]\n\n        const _color = _attributes.drawColor(doc)\n\n        color.itemSize = 3\n        color.type = 'Float32Array'\n        color.array = [_color.r / 255.0, _color.g / 255.0, _color.b / 255.0]\n\n        attributes.position = position\n        attributes.color = color\n        data.attributes = attributes\n\n        geometry = { data }\n\n        break\n\n      case rhino.ObjectType.PointSet:\n      case rhino.ObjectType.Mesh:\n        geometry = _geometry.toThreejsJSON()\n\n        break\n\n      case rhino.ObjectType.Brep:\n        const faces = _geometry.faces()\n        mesh = new rhino.Mesh()\n\n        for (let faceIndex = 0; faceIndex < faces.count; faceIndex++) {\n          const face = faces.get(faceIndex)\n          const _mesh = face.getMesh(rhino.MeshType.Any)\n\n          if (_mesh) {\n            mesh.append(_mesh)\n            _mesh.delete()\n          }\n\n          face.delete()\n        }\n\n        if (mesh.faces().count > 0) {\n          mesh.compact()\n          geometry = mesh.toThreejsJSON()\n          faces.delete()\n        }\n\n        mesh.delete()\n\n        break\n\n      case rhino.ObjectType.Extrusion:\n        mesh = _geometry.getMesh(rhino.MeshType.Any)\n\n        if (mesh) {\n          geometry = mesh.toThreejsJSON()\n          mesh.delete()\n        }\n\n        break\n\n      case rhino.ObjectType.TextDot:\n        geometry = extractProperties(_geometry)\n\n        break\n\n      case rhino.ObjectType.Light:\n        geometry = extractProperties(_geometry)\n\n        break\n\n      case rhino.ObjectType.InstanceReference:\n        geometry = extractProperties(_geometry)\n        geometry.xform = extractProperties(_geometry.xform)\n        geometry.xform.array = _geometry.xform.toFloatArray(true)\n\n        break\n\n      case rhino.ObjectType.SubD:\n        // TODO: precalculate resulting vertices and faces and warn on excessive results\n        _geometry.subdivide(3)\n        mesh = rhino.Mesh.createFromSubDControlNet(_geometry)\n        if (mesh) {\n          geometry = mesh.toThreejsJSON()\n          mesh.delete()\n        }\n\n        break\n\n      /*\n\t\t\t\tcase rhino.ObjectType.Annotation:\n\t\t\t\tcase rhino.ObjectType.Hatch:\n\t\t\t\tcase rhino.ObjectType.ClipPlane:\n\t\t\t\t*/\n\n      default:\n        console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`)\n        break\n    }\n\n    if (geometry) {\n      attributes = extractProperties(_attributes)\n      attributes.geometry = extractProperties(_geometry)\n\n      if (_attributes.groupCount > 0) {\n        attributes.groupIds = _attributes.getGroupList()\n      }\n\n      if (_attributes.userStringCount > 0) {\n        attributes.userStrings = _attributes.getUserStrings()\n      }\n\n      if (_geometry.userStringCount > 0) {\n        attributes.geometry.userStrings = _geometry.getUserStrings()\n      }\n\n      attributes.drawColor = _attributes.drawColor(doc)\n\n      objectType = objectType.constructor.name\n      objectType = objectType.substring(11, objectType.length)\n\n      return { geometry, attributes, objectType }\n    } else {\n      console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`)\n    }\n  }\n\n  function extractProperties(object) {\n    const result = {}\n\n    for (const property in object) {\n      const value = object[property]\n\n      if (typeof value !== 'function') {\n        if (typeof value === 'object' && value !== null && value.hasOwnProperty('constructor')) {\n          result[property] = { name: value.constructor.name, value: value.value }\n        } else {\n          result[property] = value\n        }\n      } else {\n        // these are functions that could be called to extract more data.\n        //console.log( `${property}: ${object[ property ].constructor.name}` );\n      }\n    }\n\n    return result\n  }\n\n  function curveToPoints(curve, pointLimit) {\n    let pointCount = pointLimit\n    let rc = []\n    const ts = []\n\n    if (curve instanceof rhino.LineCurve) {\n      return [curve.pointAtStart, curve.pointAtEnd]\n    }\n\n    if (curve instanceof rhino.PolylineCurve) {\n      pointCount = curve.pointCount\n      for (let i = 0; i < pointCount; i++) {\n        rc.push(curve.point(i))\n      }\n\n      return rc\n    }\n\n    if (curve instanceof rhino.PolyCurve) {\n      const segmentCount = curve.segmentCount\n\n      for (let i = 0; i < segmentCount; i++) {\n        const segment = curve.segmentCurve(i)\n        const segmentArray = curveToPoints(segment, pointCount)\n        rc = rc.concat(segmentArray)\n        segment.delete()\n      }\n\n      return rc\n    }\n\n    if (curve instanceof rhino.ArcCurve) {\n      pointCount = Math.floor(curve.angleDegrees / 5)\n      pointCount = pointCount < 2 ? 2 : pointCount\n      // alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399\n    }\n\n    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {\n      const pLine = curve.tryGetPolyline()\n\n      for (let i = 0; i < pLine.count; i++) {\n        rc.push(pLine.get(i))\n      }\n\n      pLine.delete()\n\n      return rc\n    }\n\n    const domain = curve.domain\n    const divisions = pointCount - 1.0\n\n    for (let j = 0; j < pointCount; j++) {\n      const t = domain[0] + (j / divisions) * (domain[1] - domain[0])\n\n      if (t === domain[0] || t === domain[1]) {\n        ts.push(t)\n        continue\n      }\n\n      const tan = curve.tangentAt(t)\n      const prevTan = curve.tangentAt(ts.slice(-1)[0])\n\n      // Duplicated from THREE.Vector3\n      // How to pass imports to worker?\n\n      const tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2]\n      const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2]\n\n      const denominator = Math.sqrt(tS * ptS)\n\n      let angle\n\n      if (denominator === 0) {\n        angle = Math.PI / 2\n      } else {\n        const theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator\n        angle = Math.acos(Math.max(-1, Math.min(1, theta)))\n      }\n\n      if (angle < 0.1) continue\n\n      ts.push(t)\n    }\n\n    rc = ts.map((t) => curve.pointAt(t))\n    return rc\n  }\n}\n\nexport { Rhino3dmLoader }\n"]},"metadata":{},"sourceType":"module"}