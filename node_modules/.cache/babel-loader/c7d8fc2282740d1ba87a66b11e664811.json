{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst _Refractor = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    this.onBeforeRender = function (renderer, scene, camera) {\n      if (camera.userData.refractor === true) return;\n      if (!visible(camera) === true) return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n  fragmentShader: (/* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`)\n});\nexport { Refractor };","map":{"version":3,"sources":["../../src/objects/Refractor.js"],"names":["visible","updateRefractorPlane","updateVirtualCamera"],"mappings":"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","sourcesContent":["import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  Quaternion,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  NoToneMapping,\n  HalfFloatType,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass Refractor extends Mesh {\n  static RefractorShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      tDiffuse: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isRefractor = true\n\n    this.type = 'Refractor'\n    this.camera = new PerspectiveCamera()\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || Refractor.RefractorShader\n    const multisample = options.multisample !== undefined ? options.multisample : 4\n\n    //\n\n    const virtualCamera = this.camera\n    virtualCamera.matrixAutoUpdate = false\n    virtualCamera.userData.refractor = true\n\n    //\n\n    const refractorPlane = new Plane()\n    const textureMatrix = new Matrix4()\n\n    // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType,\n    })\n\n    // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true, // ensures, refractors are drawn from farthest to closest\n    })\n\n    this.material.uniforms['color'].value = color\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture\n    this.material.uniforms['textureMatrix'].value = textureMatrix\n\n    // functions\n\n    const visible = (function () {\n      const refractorWorldPosition = new Vector3()\n      const cameraWorldPosition = new Vector3()\n      const rotationMatrix = new Matrix4()\n\n      const view = new Vector3()\n      const normal = new Vector3()\n\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n        view.subVectors(refractorWorldPosition, cameraWorldPosition)\n\n        rotationMatrix.extractRotation(scope.matrixWorld)\n\n        normal.set(0, 0, 1)\n        normal.applyMatrix4(rotationMatrix)\n\n        return view.dot(normal) < 0\n      }\n    })()\n\n    const updateRefractorPlane = (function () {\n      const normal = new Vector3()\n      const position = new Vector3()\n      const quaternion = new Quaternion()\n      const scale = new Vector3()\n\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale)\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize()\n\n        // flip the normal because we want to cull everything above the plane\n\n        normal.negate()\n\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position)\n      }\n    })()\n\n    const updateVirtualCamera = (function () {\n      const clipPlane = new Plane()\n      const clipVector = new Vector4()\n      const q = new Vector4()\n\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld)\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert()\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n        virtualCamera.far = camera.far // used in WebGLBackground\n\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane)\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse)\n\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant)\n\n        // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix\n\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n        q.z = -1.0\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n        // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q))\n\n        // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x\n        projectionMatrix.elements[6] = clipVector.y\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias\n        projectionMatrix.elements[14] = clipVector.w\n      }\n    })()\n\n    // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n\n      // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix)\n      textureMatrix.multiply(camera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n    }\n\n    //\n\n    function render(renderer, scene, camera) {\n      scope.visible = false\n\n      const currentRenderTarget = renderer.getRenderTarget()\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentToneMapping = renderer.toneMapping\n\n      let isSRGB = false\n      if ('outputColorSpace' in renderer) isSRGB = renderer.outputColorSpace === 'srgb'\n      else isSRGB = renderer.outputEncoding === 3001 // sRGBEncoding\n\n      renderer.xr.enabled = false // avoid camera modification\n      renderer.shadowMap.autoUpdate = false // avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.outputEncoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      renderer.setRenderTarget(renderTarget)\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.toneMapping = currentToneMapping\n      renderer.setRenderTarget(currentRenderTarget)\n\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = isSRGB ? 'srgb' : 'srgb-linear'\n      else renderer.outputEncoding = isSRGB ? 3001 : 3000\n\n      // restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      scope.visible = true\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return\n\n      // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return\n\n      // update\n\n      updateRefractorPlane()\n\n      updateTextureMatrix(camera)\n\n      updateVirtualCamera(camera)\n\n      render(renderer, scene, camera)\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n\n    this.dispose = function () {\n      renderTarget.dispose()\n      scope.material.dispose()\n    }\n  }\n}\n\nexport { Refractor }\n"]},"metadata":{},"sourceType":"module"}