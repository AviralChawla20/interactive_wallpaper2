{"ast":null,"code":"import { DataTextureLoader, LinearMipmapLinearFilter } from \"three\";\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer) {\n    function tgaCheckHeader(header2) {\n      switch (header2.image_type) {\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n          }\n          break;\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header2.colormap_type) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n          }\n          break;\n        case TGA_TYPE_NO_DATA:\n          console.error(\"THREE.TGALoader: No data.\");\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header2.image_type);\n      }\n      if (header2.width <= 0 || header2.height <= 0) {\n        console.error(\"THREE.TGALoader: Invalid image size.\");\n      }\n      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header2.pixel_size);\n      }\n    }\n    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {\n      let pixel_data, palettes;\n      const pixel_size = header2.pixel_size >> 3;\n      const pixel_total = header2.width * header2.height * pixel_size;\n      if (use_pal2) {\n        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));\n      }\n      if (use_rle2) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let shift = 0;\n        const pixels = new Uint8Array(pixel_size);\n        while (shift < pixel_total) {\n          c = data[offset2++];\n          count = (c & 127) + 1;\n          if (c & 128) {\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset2++];\n            }\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n            shift += pixel_size * count;\n          } else {\n            count *= pixel_size;\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset2++];\n            }\n            shift += count;\n          }\n        }\n      } else {\n        pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);\n      }\n      return {\n        pixel_data,\n        palettes\n      };\n    }\n    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes;\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8);\n          imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;\n          imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;\n          imageData2[(x + width * y) * 4 + 2] = (color & 31) >> 3;\n          imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 0] = color;\n          imageData2[(x + width * y) * 4 + 1] = color;\n          imageData2[(x + width * y) * 4 + 2] = color;\n          imageData2[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData2[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n      return imageData2;\n    }\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end;\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      }\n      return data;\n    }\n    const TGA_TYPE_NO_DATA = 0,\n      TGA_TYPE_INDEXED = 1,\n      TGA_TYPE_RGB = 2,\n      TGA_TYPE_GREY = 3,\n      TGA_TYPE_RLE_INDEXED = 9,\n      TGA_TYPE_RLE_RGB = 10,\n      TGA_TYPE_RLE_GREY = 11,\n      TGA_ORIGIN_MASK = 48,\n      TGA_ORIGIN_SHIFT = 4,\n      TGA_ORIGIN_BL = 0,\n      TGA_ORIGIN_BR = 1,\n      TGA_ORIGIN_UL = 2,\n      TGA_ORIGIN_UR = 3;\n    if (buffer.length < 19) console.error(\"THREE.TGALoader: Not enough data to contain header.\");\n    let offset = 0;\n    const content = new Uint8Array(buffer),\n      header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | content[offset++] << 8,\n        colormap_length: content[offset++] | content[offset++] << 8,\n        colormap_size: content[offset++],\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n        width: content[offset++] | content[offset++] << 8,\n        height: content[offset++] | content[offset++] << 8,\n        pixel_size: content[offset++],\n        flags: content[offset++]\n      };\n    tgaCheckHeader(header);\n    if (header.id_length + offset > buffer.length) {\n      console.error(\"THREE.TGALoader: No data.\");\n    }\n    offset += header.id_length;\n    let use_rle = false,\n      use_pal = false,\n      use_grey = false;\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n      case TGA_TYPE_RGB:\n        break;\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n    const imageData = new Uint8Array(header.width * header.height * 4);\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n}\nexport { TGALoader };","map":{"version":3,"sources":["../../src/loaders/TGALoader.js"],"names":["header","use_rle","use_pal","offset","imageData"],"mappings":"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","sourcesContent":["import { DataTextureLoader, LinearMipmapLinearFilter } from 'three'\n\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.')\n          }\n\n          break\n\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.')\n          }\n\n          break\n\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.')\n\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type)\n      }\n\n      // check image width and height\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.')\n      }\n\n      // check image pixel size\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size)\n      }\n    }\n\n    // parse tga image buffer\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      let pixel_data, palettes\n\n      const pixel_size = header.pixel_size >> 3\n      const pixel_total = header.width * header.height * pixel_size\n\n      // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)))\n      }\n\n      // read RLE\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total)\n\n        let c, count, i\n        let shift = 0\n        const pixels = new Uint8Array(pixel_size)\n\n        while (shift < pixel_total) {\n          c = data[offset++]\n          count = (c & 0x7f) + 1\n\n          // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++]\n            }\n\n            // copy pixel array\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size)\n            }\n\n            shift += pixel_size * count\n          } else {\n            // raw pixels\n\n            count *= pixel_size\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++]\n            }\n\n            shift += count\n          }\n        }\n      } else {\n        // raw pixels\n\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total))\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes,\n      }\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i]\n          imageData[(x + width * y) * 4 + 3] = 255\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0]\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1]\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8) // Inversed ?\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 1]\n          imageData[(x + width * y) * 4 + 0] = image[i + 2]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 1]\n          imageData[(x + width * y) * 4 + 0] = image[i + 2]\n          imageData[(x + width * y) * 4 + 3] = image[i + 3]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i]\n          imageData[(x + width * y) * 4 + 0] = color\n          imageData[(x + width * y) * 4 + 1] = color\n          imageData[(x + width * y) * 4 + 2] = color\n          imageData[(x + width * y) * 4 + 3] = 255\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 0]\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 3] = image[i + 1]\n        }\n      }\n\n      return imageData\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0\n          x_step = 1\n          x_end = width\n          y_start = 0\n          y_step = 1\n          y_end = height\n          break\n\n        case TGA_ORIGIN_BL:\n          x_start = 0\n          x_step = 1\n          x_end = width\n          y_start = height - 1\n          y_step = -1\n          y_end = -1\n          break\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1\n          x_step = -1\n          x_end = -1\n          y_start = 0\n          y_step = 1\n          y_end = height\n          break\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1\n          x_step = -1\n          x_end = -1\n          y_start = height - 1\n          y_step = -1\n          y_end = -1\n          break\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.')\n            break\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette)\n            break\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.')\n            break\n        }\n      }\n\n      // Load image data according to specific method\n      // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n      return data\n    }\n\n    // TGA constants\n\n    const TGA_TYPE_NO_DATA = 0,\n      TGA_TYPE_INDEXED = 1,\n      TGA_TYPE_RGB = 2,\n      TGA_TYPE_GREY = 3,\n      TGA_TYPE_RLE_INDEXED = 9,\n      TGA_TYPE_RLE_RGB = 10,\n      TGA_TYPE_RLE_GREY = 11,\n      TGA_ORIGIN_MASK = 0x30,\n      TGA_ORIGIN_SHIFT = 0x04,\n      TGA_ORIGIN_BL = 0x00,\n      TGA_ORIGIN_BR = 0x01,\n      TGA_ORIGIN_UL = 0x02,\n      TGA_ORIGIN_UR = 0x03\n\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.')\n\n    let offset = 0\n\n    const content = new Uint8Array(buffer),\n      header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | (content[offset++] << 8),\n        colormap_length: content[offset++] | (content[offset++] << 8),\n        colormap_size: content[offset++],\n        origin: [content[offset++] | (content[offset++] << 8), content[offset++] | (content[offset++] << 8)],\n        width: content[offset++] | (content[offset++] << 8),\n        height: content[offset++] | (content[offset++] << 8),\n        pixel_size: content[offset++],\n        flags: content[offset++],\n      }\n\n    // check tga if it is valid format\n\n    tgaCheckHeader(header)\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.')\n    }\n\n    // skip the needn't data\n\n    offset += header.id_length\n\n    // get targa information about RLE compression and palette\n\n    let use_rle = false,\n      use_pal = false,\n      use_grey = false\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true\n        use_pal = true\n        break\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true\n        break\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true\n        break\n\n      case TGA_TYPE_RGB:\n        break\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true\n        use_grey = true\n        break\n\n      case TGA_TYPE_GREY:\n        use_grey = true\n        break\n    }\n\n    //\n\n    const imageData = new Uint8Array(header.width * header.height * 4)\n    const result = tgaParse(use_rle, use_pal, header, offset, content)\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes)\n\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter,\n    }\n  }\n}\n\nexport { TGALoader }\n"]},"metadata":{},"sourceType":"module"}