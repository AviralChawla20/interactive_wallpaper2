{"ast":null,"code":"import { Frustum, Vector3 } from \"three\";\nconst frustum = new Frustum();\nconst center = new Vector3();\nconst tmpPoint = new Vector3();\nconst vecNear = new Vector3();\nconst vecTopLeft = new Vector3();\nconst vecTopRight = new Vector3();\nconst vecDownRight = new Vector3();\nconst vecDownLeft = new Vector3();\nconst vecFarTopLeft = new Vector3();\nconst vecFarTopRight = new Vector3();\nconst vecFarDownRight = new Vector3();\nconst vecFarDownLeft = new Vector3();\nconst vectemp1 = new Vector3();\nconst vectemp2 = new Vector3();\nconst vectemp3 = new Vector3();\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera;\n    this.scene = scene;\n    this.startPoint = new Vector3();\n    this.endPoint = new Vector3();\n    this.collection = [];\n    this.deep = deep || Number.MAX_VALUE;\n  }\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint;\n    this.endPoint = endPoint || this.endPoint;\n    this.collection = [];\n    this.updateFrustum(this.startPoint, this.endPoint);\n    this.searchChildInFrustum(frustum, this.scene);\n    return this.collection;\n  }\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint;\n    endPoint = endPoint || this.endPoint;\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON;\n    }\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON;\n    }\n    this.camera.updateProjectionMatrix();\n    this.camera.updateMatrixWorld();\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint);\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n      endPoint.x = Math.max(startPoint.x, endPoint.x);\n      endPoint.y = Math.min(startPoint.y, endPoint.y);\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n      vecTopLeft.copy(tmpPoint);\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n      vecDownRight.copy(endPoint);\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vectemp1.copy(vecTopLeft).sub(vecNear);\n      vectemp2.copy(vecTopRight).sub(vecNear);\n      vectemp3.copy(vecDownRight).sub(vecNear);\n      vectemp1.normalize();\n      vectemp2.normalize();\n      vectemp3.normalize();\n      vectemp1.multiplyScalar(this.deep);\n      vectemp2.multiplyScalar(this.deep);\n      vectemp3.multiplyScalar(this.deep);\n      vectemp1.add(vecNear);\n      vectemp2.add(vecNear);\n      vectemp3.add(vecNear);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n      planes[5].normal.multiplyScalar(-1);\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x);\n      const top = Math.max(startPoint.y, endPoint.y);\n      const right = Math.max(startPoint.x, endPoint.x);\n      const down = Math.min(startPoint.y, endPoint.y);\n      vecTopLeft.set(left, top, -1);\n      vecTopRight.set(right, top, -1);\n      vecDownRight.set(right, down, -1);\n      vecDownLeft.set(left, down, -1);\n      vecFarTopLeft.set(left, top, 1);\n      vecFarTopRight.set(right, top, 1);\n      vecFarDownRight.set(right, down, 1);\n      vecFarDownLeft.set(left, down, 1);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vecFarTopLeft.unproject(this.camera);\n      vecFarTopRight.unproject(this.camera);\n      vecFarDownRight.unproject(this.camera);\n      vecFarDownLeft.unproject(this.camera);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n      planes[5].normal.multiplyScalar(-1);\n    } else {\n      console.error(\"THREE.SelectionBox: Unsupported camera type.\");\n    }\n  }\n  searchChildInFrustum(frustum2, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== void 0) {\n        if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n        center.copy(object.geometry.boundingSphere.center);\n        center.applyMatrix4(object.matrixWorld);\n        if (frustum2.containsPoint(center)) {\n          this.collection.push(object);\n        }\n      }\n    }\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum2, object.children[x]);\n      }\n    }\n  }\n}\nexport { SelectionBox };","map":{"version":3,"sources":["../../src/interactive/SelectionBox.js"],"names":["frustum"],"mappings":"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","sourcesContent":["import { Frustum, Vector3 } from 'three'\n\nconst frustum = new Frustum()\nconst center = new Vector3()\n\nconst tmpPoint = new Vector3()\n\nconst vecNear = new Vector3()\nconst vecTopLeft = new Vector3()\nconst vecTopRight = new Vector3()\nconst vecDownRight = new Vector3()\nconst vecDownLeft = new Vector3()\n\nconst vecFarTopLeft = new Vector3()\nconst vecFarTopRight = new Vector3()\nconst vecFarDownRight = new Vector3()\nconst vecFarDownLeft = new Vector3()\n\nconst vectemp1 = new Vector3()\nconst vectemp2 = new Vector3()\nconst vectemp3 = new Vector3()\n\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera\n    this.scene = scene\n    this.startPoint = new Vector3()\n    this.endPoint = new Vector3()\n    this.collection = []\n    this.deep = deep || Number.MAX_VALUE\n  }\n\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint\n    this.endPoint = endPoint || this.endPoint\n    this.collection = []\n\n    this.updateFrustum(this.startPoint, this.endPoint)\n    this.searchChildInFrustum(frustum, this.scene)\n\n    return this.collection\n  }\n\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint\n    endPoint = endPoint || this.endPoint\n\n    // Avoid invalid frustum\n\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON\n    }\n\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON\n    }\n\n    this.camera.updateProjectionMatrix()\n    this.camera.updateMatrixWorld()\n\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint)\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x)\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y)\n      endPoint.x = Math.max(startPoint.x, endPoint.x)\n      endPoint.y = Math.min(startPoint.y, endPoint.y)\n\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld)\n      vecTopLeft.copy(tmpPoint)\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0)\n      vecDownRight.copy(endPoint)\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0)\n\n      vecTopLeft.unproject(this.camera)\n      vecTopRight.unproject(this.camera)\n      vecDownRight.unproject(this.camera)\n      vecDownLeft.unproject(this.camera)\n\n      vectemp1.copy(vecTopLeft).sub(vecNear)\n      vectemp2.copy(vecTopRight).sub(vecNear)\n      vectemp3.copy(vecDownRight).sub(vecNear)\n      vectemp1.normalize()\n      vectemp2.normalize()\n      vectemp3.normalize()\n\n      vectemp1.multiplyScalar(this.deep)\n      vectemp2.multiplyScalar(this.deep)\n      vectemp3.multiplyScalar(this.deep)\n      vectemp1.add(vecNear)\n      vectemp2.add(vecNear)\n      vectemp3.add(vecNear)\n\n      var planes = frustum.planes\n\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight)\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight)\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear)\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear)\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft)\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1)\n      planes[5].normal.multiplyScalar(-1)\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x)\n      const top = Math.max(startPoint.y, endPoint.y)\n      const right = Math.max(startPoint.x, endPoint.x)\n      const down = Math.min(startPoint.y, endPoint.y)\n\n      vecTopLeft.set(left, top, -1)\n      vecTopRight.set(right, top, -1)\n      vecDownRight.set(right, down, -1)\n      vecDownLeft.set(left, down, -1)\n\n      vecFarTopLeft.set(left, top, 1)\n      vecFarTopRight.set(right, top, 1)\n      vecFarDownRight.set(right, down, 1)\n      vecFarDownLeft.set(left, down, 1)\n\n      vecTopLeft.unproject(this.camera)\n      vecTopRight.unproject(this.camera)\n      vecDownRight.unproject(this.camera)\n      vecDownLeft.unproject(this.camera)\n\n      vecFarTopLeft.unproject(this.camera)\n      vecFarTopRight.unproject(this.camera)\n      vecFarDownRight.unproject(this.camera)\n      vecFarDownLeft.unproject(this.camera)\n\n      var planes = frustum.planes\n\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight)\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight)\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft)\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft)\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft)\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft)\n      planes[5].normal.multiplyScalar(-1)\n    } else {\n      console.error('THREE.SelectionBox: Unsupported camera type.')\n    }\n  }\n\n  searchChildInFrustum(frustum, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== undefined) {\n        if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere()\n\n        center.copy(object.geometry.boundingSphere.center)\n\n        center.applyMatrix4(object.matrixWorld)\n\n        if (frustum.containsPoint(center)) {\n          this.collection.push(object)\n        }\n      }\n    }\n\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum, object.children[x])\n      }\n    }\n  }\n}\n\nexport { SelectionBox }\n"]},"metadata":{},"sourceType":"module"}