{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */new Map();\n  const cloneLookup = /* @__PURE__ */new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = {\n  retarget,\n  retargetClip,\n  clone\n};\nexport { SkeletonUtils };","map":{"version":3,"sources":["../../src/utils/SkeletonUtils.js"],"names":["clone"],"mappings":"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","sourcesContent":["import {\n  AnimationClip,\n  AnimationMixer,\n  Matrix4,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  SkeletonHelper,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4()\n\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false\n  options.hip = options.hip !== undefined ? options.hip : 'hip'\n  options.names = options.names || {}\n\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target)\n\n  let bindBones, bone, name, boneTo, bonesPosition\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose()\n  } else {\n    options.useTargetMatrix = true\n    options.preserveMatrix = false\n  }\n\n  if (options.preservePosition) {\n    bonesPosition = []\n\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone())\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld()\n\n    target.matrixWorld.identity()\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true)\n    }\n  }\n\n  if (options.offsets) {\n    bindBones = []\n\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name])\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n        bone.updateMatrixWorld()\n      }\n\n      bindBones.push(bone.matrixWorld.clone())\n    }\n  }\n\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i]\n    name = options.names[bone.name] || bone.name\n\n    boneTo = getBoneByName(name, sourceBones)\n\n    globalMatrix.copy(bone.matrixWorld)\n\n    if (boneTo) {\n      boneTo.updateMatrixWorld()\n\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld)\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert()\n        relativeMatrix.multiply(boneTo.matrixWorld)\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix)\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z))\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix))\n\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones\n            ? bindBones[boneIndex]\n            : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert()\n\n        globalMatrix.multiply(wBindMatrix)\n      }\n\n      globalMatrix.copyPosition(relativeMatrix)\n    }\n\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert()\n      bone.matrix.multiply(globalMatrix)\n    } else {\n      bone.matrix.copy(globalMatrix)\n    }\n\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0))\n    }\n\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n    bone.updateMatrixWorld()\n  }\n\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i])\n      }\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true)\n  }\n}\n\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false\n  options.fps = options.fps !== undefined ? options.fps : 30\n  options.names = options.names || []\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source)\n  }\n\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = []\n  let positionOffset, bone, boneTo, boneData, name\n\n  mixer.clipAction(clip).play()\n  mixer.update(0)\n\n  source.updateMatrixWorld()\n\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta\n\n    retarget(target, source, options)\n\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name\n\n      boneTo = getBoneByName(name, source.skeleton)\n\n      if (boneTo) {\n        bone = bones[j]\n        boneData = boneDatas[j] = boneDatas[j] || { bone: bone }\n\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3),\n            }\n          }\n\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone()\n            }\n\n            bone.position.sub(positionOffset)\n          }\n\n          boneData.pos.times[i] = time\n\n          bone.position.toArray(boneData.pos.values, i * 3)\n        }\n\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4),\n          }\n        }\n\n        boneData.quat.times[i] = time\n\n        bone.quaternion.toArray(boneData.quat.values, i * 4)\n      }\n    }\n\n    mixer.update(delta)\n\n    source.updateMatrixWorld()\n  }\n\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i]\n\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            '.bones[' + boneData.bone.name + '].position',\n            boneData.pos.times,\n            boneData.pos.values,\n          ),\n        )\n      }\n\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          '.bones[' + boneData.bone.name + '].quaternion',\n          boneData.quat.times,\n          boneData.quat.values,\n        ),\n      )\n    }\n  }\n\n  mixer.uncacheAction(clip)\n\n  return new AnimationClip(clip.name, -1, convertedTracks)\n}\n\nfunction clone(source) {\n  const sourceLookup = new Map()\n  const cloneLookup = new Map()\n\n  const clone = source.clone()\n\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode)\n    cloneLookup.set(sourceNode, clonedNode)\n  })\n\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return\n\n    const clonedMesh = node\n    const sourceMesh = sourceLookup.get(node)\n    const sourceBones = sourceMesh.skeleton.bones\n\n    clonedMesh.skeleton = sourceMesh.skeleton.clone()\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix)\n\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone)\n    })\n\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix)\n  })\n\n  return clone\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i]\n  }\n}\n\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones\n}\n\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0])\n  source.skeleton = skeleton\n\n  return source\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b)\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback)\n  }\n}\n\nexport const SkeletonUtils = { retarget, retargetClip, clone }\n"]},"metadata":{},"sourceType":"module"}