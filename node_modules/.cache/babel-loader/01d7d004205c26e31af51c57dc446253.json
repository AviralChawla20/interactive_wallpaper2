{"ast":null,"code":"import { Mesh, AnimationMixer, AnimationClip } from \"three\";\nclass MorphAnimMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = \"MorphAnimMesh\";\n    this.mixer = new AnimationMixer(this);\n    this.activeAction = null;\n  }\n  setDirectionForward() {\n    this.mixer.timeScale = 1;\n  }\n  setDirectionBackward() {\n    this.mixer.timeScale = -1;\n  }\n  playAnimation(label, fps) {\n    if (this.activeAction) {\n      this.activeAction.stop();\n      this.activeAction = null;\n    }\n    const clip = AnimationClip.findByName(this, label);\n    if (clip) {\n      const action = this.mixer.clipAction(clip);\n      action.timeScale = clip.tracks.length * fps / clip.duration;\n      this.activeAction = action.play();\n    } else {\n      throw new Error(\"THREE.MorphAnimMesh: animations[\" + label + \"] undefined in .playAnimation()\");\n    }\n  }\n  updateAnimation(delta) {\n    this.mixer.update(delta);\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.mixer = new AnimationMixer(this);\n    return this;\n  }\n}\nexport { MorphAnimMesh };","map":{"version":3,"sources":["../../src/misc/MorphAnimMesh.js"],"names":[],"mappings":";AAEA,MAAM,aAAA,SAAsB,IAAA,CAAK;EAC/B,WAAA,CAAY,QAAA,EAAU,QAAA,EAAU;IAC9B,KAAA,CAAM,QAAA,EAAU,QAAQ,CAAA;IAExB,IAAA,CAAK,IAAA,GAAO,eAAA;IAEZ,IAAA,CAAK,KAAA,GAAQ,IAAI,cAAA,CAAe,IAAI,CAAA;IACpC,IAAA,CAAK,YAAA,GAAe,IAAA;EACrB;EAED,mBAAA,CAAA,EAAsB;IACpB,IAAA,CAAK,KAAA,CAAM,SAAA,GAAY,CAAA;EACxB;EAED,oBAAA,CAAA,EAAuB;IACrB,IAAA,CAAK,KAAA,CAAM,SAAA,GAAY,CAAA,CAAA;EACxB;EAED,aAAA,CAAc,KAAA,EAAO,GAAA,EAAK;IACxB,IAAI,IAAA,CAAK,YAAA,EAAc;MACrB,IAAA,CAAK,YAAA,CAAa,IAAA,CAAM,CAAA;MACxB,IAAA,CAAK,YAAA,GAAe,IAAA;IACrB;IAED,MAAM,IAAA,GAAO,aAAA,CAAc,UAAA,CAAW,IAAA,EAAM,KAAK,CAAA;IAEjD,IAAI,IAAA,EAAM;MACR,MAAM,MAAA,GAAS,IAAA,CAAK,KAAA,CAAM,UAAA,CAAW,IAAI,CAAA;MACzC,MAAA,CAAO,SAAA,GAAa,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,GAAA,GAAO,IAAA,CAAK,QAAA;MACrD,IAAA,CAAK,YAAA,GAAe,MAAA,CAAO,IAAA,CAAM,CAAA;IACvC,CAAA,MAAW;MACL,MAAM,IAAI,KAAA,CAAM,kCAAA,GAAqC,KAAA,GAAQ,iCAAiC,CAAA;IAC/F;EACF;EAED,eAAA,CAAgB,KAAA,EAAO;IACrB,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,KAAK,CAAA;EACxB;EAED,IAAA,CAAK,MAAA,EAAQ,SAAA,EAAW;IACtB,KAAA,CAAM,IAAA,CAAK,MAAA,EAAQ,SAAS,CAAA;IAE5B,IAAA,CAAK,KAAA,GAAQ,IAAI,cAAA,CAAe,IAAI,CAAA;IAEpC,OAAO,IAAA;EACR;AACH","sourcesContent":["import { AnimationClip, AnimationMixer, Mesh } from 'three'\n\nclass MorphAnimMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material)\n\n    this.type = 'MorphAnimMesh'\n\n    this.mixer = new AnimationMixer(this)\n    this.activeAction = null\n  }\n\n  setDirectionForward() {\n    this.mixer.timeScale = 1.0\n  }\n\n  setDirectionBackward() {\n    this.mixer.timeScale = -1.0\n  }\n\n  playAnimation(label, fps) {\n    if (this.activeAction) {\n      this.activeAction.stop()\n      this.activeAction = null\n    }\n\n    const clip = AnimationClip.findByName(this, label)\n\n    if (clip) {\n      const action = this.mixer.clipAction(clip)\n      action.timeScale = (clip.tracks.length * fps) / clip.duration\n      this.activeAction = action.play()\n    } else {\n      throw new Error('THREE.MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()')\n    }\n  }\n\n  updateAnimation(delta) {\n    this.mixer.update(delta)\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.mixer = new AnimationMixer(this)\n\n    return this\n  }\n}\n\nexport { MorphAnimMesh }\n"]},"metadata":{},"sourceType":"module"}