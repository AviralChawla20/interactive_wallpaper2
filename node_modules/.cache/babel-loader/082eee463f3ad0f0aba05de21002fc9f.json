{"ast":null,"code":"import { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, LinearFilter, ClampToEdgeWrapping } from \"three\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nclass LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    str = str.replace(/^#.*?(\\n|\\r)/gm, \"\").replace(/^\\s*?(\\n|\\r)/gm, \"\").trim();\n    let title = null;\n    let size = null;\n    const domainMin = new Vector3(0, 0, 0);\n    const domainMax = new Vector3(1, 1, 1);\n    const lines = str.split(/[\\n\\r]+/g);\n    let data = null;\n    let currIndex = 0;\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      switch (split[0]) {\n        case \"TITLE\":\n          title = line.substring(7, line.length - 1);\n          break;\n        case \"LUT_3D_SIZE\":\n          const sizeToken = split[1];\n          size = parseFloat(sizeToken);\n          data = new Uint8Array(size * size * size * 4);\n          break;\n        case \"DOMAIN_MIN\":\n          domainMin.x = parseFloat(split[1]);\n          domainMin.y = parseFloat(split[2]);\n          domainMin.z = parseFloat(split[3]);\n          break;\n        case \"DOMAIN_MAX\":\n          domainMax.x = parseFloat(split[1]);\n          domainMax.y = parseFloat(split[2]);\n          domainMax.z = parseFloat(split[3]);\n          break;\n        default:\n          const r = parseFloat(split[0]);\n          const g = parseFloat(split[1]);\n          const b = parseFloat(split[2]);\n          if (r > 1 || r < 0 || g > 1 || g < 0 || b > 1 || b < 0) {\n            throw new Error(\"LUTCubeLoader : Non normalized values not supported.\");\n          }\n          data[currIndex + 0] = r * 255;\n          data[currIndex + 1] = g * 255;\n          data[currIndex + 2] = b * 255;\n          data[currIndex + 3] = 255;\n          currIndex += 4;\n      }\n    }\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUTCubeLoader };","map":{"version":3,"sources":["../../src/loaders/LUTCubeLoader.js"],"names":[],"mappings":"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","sourcesContent":["// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf\n\nimport { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, ClampToEdgeWrapping, LinearFilter } from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nexport class LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('text')\n    loader.load(\n      url,\n      (text) => {\n        try {\n          onLoad(this.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          this.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(str) {\n    // Remove empty lines and comments\n    str = str\n      .replace(/^#.*?(\\n|\\r)/gm, '')\n      .replace(/^\\s*?(\\n|\\r)/gm, '')\n      .trim()\n\n    let title = null\n    let size = null\n    const domainMin = new Vector3(0, 0, 0)\n    const domainMax = new Vector3(1, 1, 1)\n\n    const lines = str.split(/[\\n\\r]+/g)\n    let data = null\n\n    let currIndex = 0\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim()\n      const split = line.split(/\\s/g)\n\n      switch (split[0]) {\n        case 'TITLE':\n          title = line.substring(7, line.length - 1)\n          break\n        case 'LUT_3D_SIZE':\n          // TODO: A .CUBE LUT file specifies floating point values and could be represented with\n          // more precision than can be captured with Uint8Array.\n          const sizeToken = split[1]\n          size = parseFloat(sizeToken)\n          data = new Uint8Array(size * size * size * 4)\n          break\n        case 'DOMAIN_MIN':\n          domainMin.x = parseFloat(split[1])\n          domainMin.y = parseFloat(split[2])\n          domainMin.z = parseFloat(split[3])\n          break\n        case 'DOMAIN_MAX':\n          domainMax.x = parseFloat(split[1])\n          domainMax.y = parseFloat(split[2])\n          domainMax.z = parseFloat(split[3])\n          break\n        default:\n          const r = parseFloat(split[0])\n          const g = parseFloat(split[1])\n          const b = parseFloat(split[2])\n\n          if (r > 1.0 || r < 0.0 || g > 1.0 || g < 0.0 || b > 1.0 || b < 0.0) {\n            throw new Error('LUTCubeLoader : Non normalized values not supported.')\n          }\n\n          data[currIndex + 0] = r * 255\n          data[currIndex + 1] = g * 255\n          data[currIndex + 2] = b * 255\n          data[currIndex + 3] = 255\n          currIndex += 4\n      }\n    }\n\n    const texture = new DataTexture()\n    texture.image.data = data\n    texture.image.width = size\n    texture.image.height = size * size\n    texture.type = UnsignedByteType\n    texture.magFilter = LinearFilter\n    texture.minFilter = LinearFilter\n    texture.wrapS = ClampToEdgeWrapping\n    texture.wrapT = ClampToEdgeWrapping\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const texture3D = new Data3DTexture()\n    texture3D.image.data = data\n    texture3D.image.width = size\n    texture3D.image.height = size\n    texture3D.image.depth = size\n    texture3D.type = UnsignedByteType\n    texture3D.magFilter = LinearFilter\n    texture3D.minFilter = LinearFilter\n    texture3D.wrapS = ClampToEdgeWrapping\n    texture3D.wrapT = ClampToEdgeWrapping\n    texture3D.wrapR = ClampToEdgeWrapping\n    texture3D.generateMipmaps = false\n    texture3D.needsUpdate = true\n\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D,\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}