{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass TessellateModifier {\n  constructor(maxEdgeLength = 0.1, maxIterations = 6) {\n    __publicField(this, \"maxEdgeLength\");\n    __publicField(this, \"maxIterations\");\n    __publicField(this, \"modify\", geometry => {\n      if (geometry.index !== null) {\n        geometry = geometry.toNonIndexed();\n      }\n      const maxIterations = this.maxIterations;\n      const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;\n      const va = new Vector3();\n      const vb = new Vector3();\n      const vc = new Vector3();\n      const vm = new Vector3();\n      const vs = [va, vb, vc, vm];\n      const na = new Vector3();\n      const nb = new Vector3();\n      const nc = new Vector3();\n      const nm = new Vector3();\n      const ns = [na, nb, nc, nm];\n      const ca = new Color();\n      const cb = new Color();\n      const cc = new Color();\n      const cm = new Color();\n      const cs = [ca, cb, cc, cm];\n      const ua = new Vector2();\n      const ub = new Vector2();\n      const uc = new Vector2();\n      const um = new Vector2();\n      const us = [ua, ub, uc, um];\n      const u2a = new Vector2();\n      const u2b = new Vector2();\n      const u2c = new Vector2();\n      const u2m = new Vector2();\n      const u2s = [u2a, u2b, u2c, u2m];\n      const attributes = geometry.attributes;\n      const hasNormals = attributes.normal !== void 0;\n      const hasColors = attributes.color !== void 0;\n      const hasUVs = attributes.uv !== void 0;\n      const hasUV1s = attributes[UV1] !== void 0;\n      let positions = attributes.position.array;\n      let normals = hasNormals ? attributes.normal.array : null;\n      let colors = hasColors ? attributes.color.array : null;\n      let uvs = hasUVs ? attributes.uv.array : null;\n      let uv1s = hasUV1s ? attributes.uv1.array : null;\n      let positions2 = positions;\n      let normals2 = normals;\n      let colors2 = colors;\n      let uvs2 = uvs;\n      let uv1s2 = uv1s;\n      let iteration = 0;\n      let tessellating = true;\n      function addTriangle(a, b, c) {\n        const v1 = vs[a];\n        const v2 = vs[b];\n        const v3 = vs[c];\n        positions2.push(v1.x, v1.y, v1.z);\n        positions2.push(v2.x, v2.y, v2.z);\n        positions2.push(v3.x, v3.y, v3.z);\n        if (hasNormals) {\n          const n1 = ns[a];\n          const n2 = ns[b];\n          const n3 = ns[c];\n          normals2.push(n1.x, n1.y, n1.z);\n          normals2.push(n2.x, n2.y, n2.z);\n          normals2.push(n3.x, n3.y, n3.z);\n        }\n        if (hasColors) {\n          const c1 = cs[a];\n          const c2 = cs[b];\n          const c3 = cs[c];\n          colors2.push(c1.r, c1.g, c1.b);\n          colors2.push(c2.r, c2.g, c2.b);\n          colors2.push(c3.r, c3.g, c3.b);\n        }\n        if (hasUVs) {\n          const u1 = us[a];\n          const u2 = us[b];\n          const u3 = us[c];\n          uvs2.push(u1.x, u1.y);\n          uvs2.push(u2.x, u2.y);\n          uvs2.push(u3.x, u3.y);\n        }\n        if (hasUV1s) {\n          const u21 = u2s[a];\n          const u22 = u2s[b];\n          const u23 = u2s[c];\n          uv1s2.push(u21.x, u21.y);\n          uv1s2.push(u22.x, u22.y);\n          uv1s2.push(u23.x, u23.y);\n        }\n      }\n      while (tessellating && iteration < maxIterations) {\n        iteration++;\n        tessellating = false;\n        positions = positions2;\n        positions2 = [];\n        if (hasNormals) {\n          normals = normals2;\n          normals2 = [];\n        }\n        if (hasColors) {\n          colors = colors2;\n          colors2 = [];\n        }\n        if (hasUVs) {\n          uvs = uvs2;\n          uvs2 = [];\n        }\n        if (hasUV1s) {\n          uv1s = uv1s2;\n          uv1s2 = [];\n        }\n        for (let i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6) {\n          va.fromArray(positions, i + 0);\n          vb.fromArray(positions, i + 3);\n          vc.fromArray(positions, i + 6);\n          if (hasNormals && normals) {\n            na.fromArray(normals, i + 0);\n            nb.fromArray(normals, i + 3);\n            nc.fromArray(normals, i + 6);\n          }\n          if (hasColors && colors) {\n            ca.fromArray(colors, i + 0);\n            cb.fromArray(colors, i + 3);\n            cc.fromArray(colors, i + 6);\n          }\n          if (hasUVs && uvs) {\n            ua.fromArray(uvs, i2 + 0);\n            ub.fromArray(uvs, i2 + 2);\n            uc.fromArray(uvs, i2 + 4);\n          }\n          if (hasUV1s && uv1s) {\n            u2a.fromArray(uv1s, i2 + 0);\n            u2b.fromArray(uv1s, i2 + 2);\n            u2c.fromArray(uv1s, i2 + 4);\n          }\n          const dab = va.distanceToSquared(vb);\n          const dbc = vb.distanceToSquared(vc);\n          const dac = va.distanceToSquared(vc);\n          if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {\n            tessellating = true;\n            if (dab >= dbc && dab >= dac) {\n              vm.lerpVectors(va, vb, 0.5);\n              if (hasNormals) nm.lerpVectors(na, nb, 0.5);\n              if (hasColors) cm.lerpColors(ca, cb, 0.5);\n              if (hasUVs) um.lerpVectors(ua, ub, 0.5);\n              if (hasUV1s) u2m.lerpVectors(u2a, u2b, 0.5);\n              addTriangle(0, 3, 2);\n              addTriangle(3, 1, 2);\n            } else if (dbc >= dab && dbc >= dac) {\n              vm.lerpVectors(vb, vc, 0.5);\n              if (hasNormals) nm.lerpVectors(nb, nc, 0.5);\n              if (hasColors) cm.lerpColors(cb, cc, 0.5);\n              if (hasUVs) um.lerpVectors(ub, uc, 0.5);\n              if (hasUV1s) u2m.lerpVectors(u2b, u2c, 0.5);\n              addTriangle(0, 1, 3);\n              addTriangle(3, 2, 0);\n            } else {\n              vm.lerpVectors(va, vc, 0.5);\n              if (hasNormals) nm.lerpVectors(na, nc, 0.5);\n              if (hasColors) cm.lerpColors(ca, cc, 0.5);\n              if (hasUVs) um.lerpVectors(ua, uc, 0.5);\n              if (hasUV1s) u2m.lerpVectors(u2a, u2c, 0.5);\n              addTriangle(0, 1, 3);\n              addTriangle(3, 1, 2);\n            }\n          } else {\n            addTriangle(0, 1, 2);\n          }\n        }\n      }\n      const geometry2 = new BufferGeometry();\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(positions2, 3));\n      if (hasNormals) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(normals2, 3));\n      }\n      if (hasColors) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(colors2, 3));\n      }\n      if (hasUVs) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(uvs2, 2));\n      }\n      if (hasUV1s) {\n        geometry2.setAttribute(UV1, new Float32BufferAttribute(uv1s2, 2));\n      }\n      return geometry2;\n    });\n    this.maxEdgeLength = maxEdgeLength;\n    this.maxIterations = maxIterations;\n  }\n}\nexport { TessellateModifier };","map":{"version":3,"sources":["../../src/modifiers/TessellateModifier.ts"],"names":[],"mappings":"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","sourcesContent":["import { BufferGeometry, Color, Float32BufferAttribute, Vector2, Vector3 } from 'three'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Break faces with edges longer than maxEdgeLength\n */\n\nclass TessellateModifier {\n  public maxEdgeLength: number\n  public maxIterations: number\n\n  constructor(maxEdgeLength = 0.1, maxIterations = 6) {\n    this.maxEdgeLength = maxEdgeLength\n    this.maxIterations = maxIterations\n  }\n\n  public modify = (geometry: BufferGeometry): BufferGeometry => {\n    if (geometry.index !== null) {\n      geometry = geometry.toNonIndexed()\n    }\n\n    //\n\n    const maxIterations = this.maxIterations\n    const maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength\n\n    const va = new Vector3()\n    const vb = new Vector3()\n    const vc = new Vector3()\n    const vm = new Vector3()\n    const vs = [va, vb, vc, vm]\n\n    const na = new Vector3()\n    const nb = new Vector3()\n    const nc = new Vector3()\n    const nm = new Vector3()\n    const ns = [na, nb, nc, nm]\n\n    const ca = new Color()\n    const cb = new Color()\n    const cc = new Color()\n    const cm = new Color()\n    const cs = [ca, cb, cc, cm]\n\n    const ua = new Vector2()\n    const ub = new Vector2()\n    const uc = new Vector2()\n    const um = new Vector2()\n    const us = [ua, ub, uc, um]\n\n    const u2a = new Vector2()\n    const u2b = new Vector2()\n    const u2c = new Vector2()\n    const u2m = new Vector2()\n    const u2s = [u2a, u2b, u2c, u2m]\n\n    const attributes = geometry.attributes\n    const hasNormals = attributes.normal !== undefined\n    const hasColors = attributes.color !== undefined\n    const hasUVs = attributes.uv !== undefined\n    const hasUV1s = attributes[UV1] !== undefined\n\n    let positions = attributes.position.array\n    let normals = hasNormals ? attributes.normal.array : null\n    let colors = hasColors ? attributes.color.array : null\n    let uvs = hasUVs ? attributes.uv.array : null\n    let uv1s = hasUV1s ? attributes.uv1.array : null\n\n    let positions2 = (positions as unknown) as number[]\n    let normals2 = (normals as unknown) as number[]\n    let colors2 = (colors as unknown) as number[]\n    let uvs2 = (uvs as unknown) as number[]\n    let uv1s2 = (uv1s as unknown) as number[]\n\n    let iteration = 0\n    let tessellating = true\n\n    function addTriangle(a: number, b: number, c: number): void {\n      const v1 = vs[a]\n      const v2 = vs[b]\n      const v3 = vs[c]\n\n      positions2.push(v1.x, v1.y, v1.z)\n      positions2.push(v2.x, v2.y, v2.z)\n      positions2.push(v3.x, v3.y, v3.z)\n\n      if (hasNormals) {\n        const n1 = ns[a]\n        const n2 = ns[b]\n        const n3 = ns[c]\n\n        normals2.push(n1.x, n1.y, n1.z)\n        normals2.push(n2.x, n2.y, n2.z)\n        normals2.push(n3.x, n3.y, n3.z)\n      }\n\n      if (hasColors) {\n        const c1 = cs[a]\n        const c2 = cs[b]\n        const c3 = cs[c]\n\n        colors2.push(c1.r, c1.g, c1.b)\n        colors2.push(c2.r, c2.g, c2.b)\n        colors2.push(c3.r, c3.g, c3.b)\n      }\n\n      if (hasUVs) {\n        const u1 = us[a]\n        const u2 = us[b]\n        const u3 = us[c]\n\n        uvs2.push(u1.x, u1.y)\n        uvs2.push(u2.x, u2.y)\n        uvs2.push(u3.x, u3.y)\n      }\n\n      if (hasUV1s) {\n        const u21 = u2s[a]\n        const u22 = u2s[b]\n        const u23 = u2s[c]\n\n        uv1s2.push(u21.x, u21.y)\n        uv1s2.push(u22.x, u22.y)\n        uv1s2.push(u23.x, u23.y)\n      }\n    }\n\n    while (tessellating && iteration < maxIterations) {\n      iteration++\n      tessellating = false\n\n      positions = positions2 as any\n      positions2 = []\n\n      if (hasNormals) {\n        normals = normals2 as any\n        normals2 = []\n      }\n\n      if (hasColors) {\n        colors = colors2 as any\n        colors2 = []\n      }\n\n      if (hasUVs) {\n        uvs = uvs2 as any\n        uvs2 = []\n      }\n\n      if (hasUV1s) {\n        uv1s = uv1s2 as any\n        uv1s2 = []\n      }\n\n      for (let i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6) {\n        va.fromArray(positions, i + 0)\n        vb.fromArray(positions, i + 3)\n        vc.fromArray(positions, i + 6)\n\n        if (hasNormals && normals) {\n          na.fromArray(normals, i + 0)\n          nb.fromArray(normals, i + 3)\n          nc.fromArray(normals, i + 6)\n        }\n\n        if (hasColors && colors) {\n          ca.fromArray(colors, i + 0)\n          cb.fromArray(colors, i + 3)\n          cc.fromArray(colors, i + 6)\n        }\n\n        if (hasUVs && uvs) {\n          ua.fromArray(uvs, i2 + 0)\n          ub.fromArray(uvs, i2 + 2)\n          uc.fromArray(uvs, i2 + 4)\n        }\n\n        if (hasUV1s && uv1s) {\n          u2a.fromArray(uv1s, i2 + 0)\n          u2b.fromArray(uv1s, i2 + 2)\n          u2c.fromArray(uv1s, i2 + 4)\n        }\n\n        const dab = va.distanceToSquared(vb)\n        const dbc = vb.distanceToSquared(vc)\n        const dac = va.distanceToSquared(vc)\n\n        if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {\n          tessellating = true\n\n          if (dab >= dbc && dab >= dac) {\n            vm.lerpVectors(va, vb, 0.5)\n            if (hasNormals) nm.lerpVectors(na, nb, 0.5)\n            if (hasColors) cm.lerpColors(ca, cb, 0.5)\n            if (hasUVs) um.lerpVectors(ua, ub, 0.5)\n            if (hasUV1s) u2m.lerpVectors(u2a, u2b, 0.5)\n\n            addTriangle(0, 3, 2)\n            addTriangle(3, 1, 2)\n          } else if (dbc >= dab && dbc >= dac) {\n            vm.lerpVectors(vb, vc, 0.5)\n            if (hasNormals) nm.lerpVectors(nb, nc, 0.5)\n            if (hasColors) cm.lerpColors(cb, cc, 0.5)\n            if (hasUVs) um.lerpVectors(ub, uc, 0.5)\n            if (hasUV1s) u2m.lerpVectors(u2b, u2c, 0.5)\n\n            addTriangle(0, 1, 3)\n            addTriangle(3, 2, 0)\n          } else {\n            vm.lerpVectors(va, vc, 0.5)\n            if (hasNormals) nm.lerpVectors(na, nc, 0.5)\n            if (hasColors) cm.lerpColors(ca, cc, 0.5)\n            if (hasUVs) um.lerpVectors(ua, uc, 0.5)\n            if (hasUV1s) u2m.lerpVectors(u2a, u2c, 0.5)\n\n            addTriangle(0, 1, 3)\n            addTriangle(3, 1, 2)\n          }\n        } else {\n          addTriangle(0, 1, 2)\n        }\n      }\n    }\n\n    const geometry2 = new BufferGeometry()\n\n    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3))\n\n    if (hasNormals) {\n      geometry2.setAttribute('normal', new Float32BufferAttribute(normals2 as any, 3))\n    }\n\n    if (hasColors) {\n      geometry2.setAttribute('color', new Float32BufferAttribute(colors2 as any, 3))\n    }\n\n    if (hasUVs) {\n      geometry2.setAttribute('uv', new Float32BufferAttribute(uvs2 as any, 2))\n    }\n\n    if (hasUV1s) {\n      geometry2.setAttribute(UV1, new Float32BufferAttribute(uv1s2 as any, 2))\n    }\n\n    return geometry2\n  }\n}\n\nexport { TessellateModifier }\n"]},"metadata":{},"sourceType":"module"}