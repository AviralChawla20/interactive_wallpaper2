{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4 } from \"three\";\nconst geometry = new BufferGeometry();\nconst float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\nconst interleavedBuffer = new InterleavedBuffer(float32Array, 5);\ngeometry.setIndex([0, 1, 2, 0, 2, 3]);\ngeometry.setAttribute(\"position\", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\ngeometry.setAttribute(\"uv\", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\nconst _Lensflare = class extends Mesh {\n  constructor() {\n    super(_Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.isLensflare = true;\n    this.type = \"Lensflare\";\n    this.frustumCulled = false;\n    this.renderOrder = Infinity;\n    const positionScreen = new Vector3();\n    const positionView = new Vector3();\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping;\n    const geometry2 = _Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: (/* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n      fragmentShader: (/* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`),\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader: (/* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n      fragmentShader: (/* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`),\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    });\n    const mesh1 = new Mesh(geometry2, material1a);\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(16777215)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry2, material2);\n    this.addElement = function (element) {\n      elements.push(element);\n    };\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2;\n      const halfViewportHeight = viewport.w / 2;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return;\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n      if (validArea.containsPoint(screenPositionPixels)) {\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n        let uniforms = material1a.uniforms;\n        uniforms[\"scale\"].value = scale;\n        uniforms[\"screenPosition\"].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry2, material1a, mesh1, null);\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n        uniforms = material1b.uniforms;\n        uniforms[\"scale\"].value = scale;\n        uniforms[\"screenPosition\"].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry2, material1b, mesh1, null);\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms2 = material2.uniforms;\n          uniforms2[\"color\"].value.copy(element.color);\n          uniforms2[\"map\"].value = element.texture;\n          uniforms2[\"screenPosition\"].value.x = positionScreen.x + vecX * element.distance;\n          uniforms2[\"screenPosition\"].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect2 = viewport.w / viewport.z;\n          uniforms2[\"scale\"].value.set(size * invAspect2, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry2, material2, mesh2, null);\n        }\n      }\n    };\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n};\nlet Lensflare = _Lensflare;\n__publicField(Lensflare, \"Geometry\", geometry);\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(16777215)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n}\n__publicField(LensflareElement, \"Shader\", {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`),\n  fragmentShader: (/* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`)\n});\nexport { Lensflare, LensflareElement };","map":{"version":3,"sources":["../../src/objects/Lensflare.js"],"names":["geometry","uniforms","invAspect"],"mappings":"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","sourcesContent":["import {\n  AdditiveBlending,\n  Box2,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DataTexture,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Mesh,\n  MeshBasicMaterial,\n  NearestFilter,\n  RGBAFormat,\n  RawShaderMaterial,\n  Vector2,\n  Vector3,\n  Vector4,\n} from 'three'\n\nconst geometry = new BufferGeometry()\n\nconst float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1])\n\nconst interleavedBuffer = new InterleavedBuffer(float32Array, 5)\n\ngeometry.setIndex([0, 1, 2, 0, 2, 3])\ngeometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false))\ngeometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false))\n\nclass Lensflare extends Mesh {\n  static Geometry = geometry\n\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({ opacity: 0, transparent: true }))\n\n    this.isLensflare = true\n\n    this.type = 'Lensflare'\n    this.frustumCulled = false\n    this.renderOrder = Infinity\n\n    //\n\n    const positionScreen = new Vector3()\n    const positionView = new Vector3()\n\n    // textures\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    tempMap.minFilter = NearestFilter\n    tempMap.magFilter = NearestFilter\n    tempMap.wrapS = ClampToEdgeWrapping\n    tempMap.wrapT = ClampToEdgeWrapping\n\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    occlusionMap.minFilter = NearestFilter\n    occlusionMap.magFilter = NearestFilter\n    occlusionMap.wrapS = ClampToEdgeWrapping\n    occlusionMap.wrapT = ClampToEdgeWrapping\n\n    // material\n\n    const geometry = Lensflare.Geometry\n\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: { value: tempMap },\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a)\n\n    //\n\n    const elements = []\n\n    const shader = LensflareElement.Shader\n\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: { value: null },\n        occlusionMap: { value: occlusionMap },\n        color: { value: new Color(0xffffff) },\n        scale: { value: new Vector2() },\n        screenPosition: { value: new Vector3() },\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false,\n    })\n\n    const mesh2 = new Mesh(geometry, material2)\n\n    this.addElement = function (element) {\n      elements.push(element)\n    }\n\n    //\n\n    const scale = new Vector2()\n    const screenPositionPixels = new Vector2()\n    const validArea = new Box2()\n    const viewport = new Vector4()\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport)\n\n      const invAspect = viewport.w / viewport.z\n      const halfViewportWidth = viewport.z / 2.0\n      const halfViewportHeight = viewport.w / 2.0\n\n      let size = 16 / viewport.w\n      scale.set(size * invAspect, size)\n\n      validArea.min.set(viewport.x, viewport.y)\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16))\n\n      // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld)\n      positionView.applyMatrix4(camera.matrixWorldInverse)\n\n      if (positionView.z > 0) return // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix)\n\n      // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8\n\n      // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap)\n\n        // render pink quad\n\n        let uniforms = material1a.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null)\n\n        // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap)\n\n        // restore graphics\n\n        uniforms = material1b.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null)\n\n        // render elements\n\n        const vecX = -positionScreen.x * 2\n        const vecY = -positionScreen.y * 2\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i]\n\n          const uniforms = material2.uniforms\n\n          uniforms['color'].value.copy(element.color)\n          uniforms['map'].value = element.texture\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance\n\n          size = element.size / viewport.w\n          const invAspect = viewport.w / viewport.z\n\n          uniforms['scale'].value.set(size * invAspect, size)\n\n          material2.uniformsNeedUpdate = true\n\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null)\n        }\n      }\n    }\n\n    this.dispose = function () {\n      material1a.dispose()\n      material1b.dispose()\n      material2.dispose()\n\n      tempMap.dispose()\n      occlusionMap.dispose()\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose()\n      }\n    }\n  }\n}\n\n//\n\nclass LensflareElement {\n  static Shader = {\n    uniforms: {\n      map: { value: null },\n      occlusionMap: { value: null },\n      color: { value: null },\n      scale: { value: null },\n      screenPosition: { value: null },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`,\n  }\n\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture\n    this.size = size\n    this.distance = distance\n    this.color = color\n  }\n}\n\nexport { Lensflare, LensflareElement }\n"]},"metadata":{},"sourceType":"module"}