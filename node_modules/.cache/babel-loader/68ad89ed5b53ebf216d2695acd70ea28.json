{"ast":null,"code":"import { Vector3, Vector4, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _viewport = new Vector4();\nclass Wireframe extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 16777215\n  })) {\n    super(geometry, material);\n    this.isWireframe = true;\n    this.type = \"Wireframe\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nexport { Wireframe };","map":{"version":3,"sources":["../../src/lines/Wireframe.js"],"names":[],"mappings":";;;AAIA,MAAM,MAAA,GAAS,IAAI,OAAA,CAAS,CAAA;AAC5B,MAAM,IAAA,GAAO,IAAI,OAAA,CAAS,CAAA;AAC1B,MAAM,SAAA,GAAY,IAAI,OAAA,CAAA,CAAA;AAEtB,MAAM,SAAA,SAAkB,IAAA,CAAK;EAC3B,WAAA,CAAY,QAAA,GAAW,IAAI,oBAAA,CAAsB,CAAA,EAAE,QAAA,GAAW,IAAI,YAAA,CAAa;IAAE,KAAA,EAAO,IAAA,CAAK,MAAA,CAAA,CAAA,GAAW;EAAU,CAAA,CAAA,EAAG;IACnH,KAAA,CAAM,QAAA,EAAU,QAAQ,CAAA;IAExB,IAAA,CAAK,WAAA,GAAc,IAAA;IAEnB,IAAA,CAAK,IAAA,GAAO,WAAA;EACb;EAAA;EAID,oBAAA,CAAA,EAAuB;IACrB,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA;IAEtB,MAAM,aAAA,GAAgB,QAAA,CAAS,UAAA,CAAW,aAAA;IAC1C,MAAM,WAAA,GAAc,QAAA,CAAS,UAAA,CAAW,WAAA;IACxC,MAAM,aAAA,GAAgB,IAAI,YAAA,CAAa,CAAA,GAAI,aAAA,CAAc,KAAK,CAAA;IAE9D,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,aAAA,CAAc,KAAA,EAAO,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK,CAAA,IAAK,CAAA,EAAG;MAClE,MAAA,CAAO,mBAAA,CAAoB,aAAA,EAAe,CAAC,CAAA;MAC3C,IAAA,CAAK,mBAAA,CAAoB,WAAA,EAAa,CAAC,CAAA;MAEvC,aAAA,CAAc,CAAC,CAAA,GAAI,CAAA,KAAM,CAAA,GAAI,CAAA,GAAI,aAAA,CAAc,CAAA,GAAI,CAAC,CAAA;MACpD,aAAA,CAAc,CAAA,GAAI,CAAC,CAAA,GAAI,aAAA,CAAc,CAAC,CAAA,GAAI,MAAA,CAAO,UAAA,CAAW,IAAI,CAAA;IACjE;IAED,MAAM,sBAAA,GAAyB,IAAI,0BAAA,CAA2B,aAAA,EAAe,CAAA,EAAG,CAAC,CAAA;IAEjF,QAAA,CAAS,YAAA,CAAa,uBAAA,EAAyB,IAAI,0BAAA,CAA2B,sBAAA,EAAwB,CAAA,EAAG,CAAC,CAAC,CAAA;IAC3G,QAAA,CAAS,YAAA,CAAa,qBAAA,EAAuB,IAAI,0BAAA,CAA2B,sBAAA,EAAwB,CAAA,EAAG,CAAC,CAAC,CAAA;IAEzG,OAAO,IAAA;EACR;EAED,cAAA,CAAe,QAAA,EAAU;IAEvB,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA,CAAS,QAAA;IAE/B,IAAI,QAAA,IAAY,QAAA,CAAS,UAAA,EAAY;MAEnC,QAAA,CAAS,WAAA,CAAY,SAAS,CAAA;MAC9B,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,UAAA,CAAW,KAAA,CAAM,GAAA,CAAI,SAAA,CAAU,CAAA,EAAG,SAAA,CAAU,CAAC,CAAA;IAErE;EAEF;AACH","sourcesContent":["import { InstancedInterleavedBuffer, InterleavedBufferAttribute, Mesh, Vector3, Vector4 } from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nconst _start = new Vector3()\nconst _end = new Vector3()\nconst _viewport = new Vector4();\n\nclass Wireframe extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isWireframe = true\n\n    this.type = 'Wireframe'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { Wireframe }\n"]},"metadata":{},"sourceType":"module"}