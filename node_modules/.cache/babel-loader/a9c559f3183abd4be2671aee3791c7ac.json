{"ast":null,"code":"import { ShaderChunk, UniformsUtils, ShaderLib, Color } from \"three\";\nlet _SubsurfaceScatteringShader;\nfunction get() {\n  if (_SubsurfaceScatteringShader) return _SubsurfaceScatteringShader;\n  const meshphong_frag_head = ShaderChunk[\"meshphong_frag\"].slice(0, ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\"));\n  const meshphong_frag_body = ShaderChunk[\"meshphong_frag\"].slice(ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\"));\n  _SubsurfaceScatteringShader = {\n    uniforms: UniformsUtils.merge([ShaderLib[\"phong\"].uniforms, {\n      thicknessMap: {\n        value: null\n      },\n      thicknessColor: {\n        value: new Color(16777215)\n      },\n      thicknessDistortion: {\n        value: 0.1\n      },\n      thicknessAmbient: {\n        value: 0\n      },\n      thicknessAttenuation: {\n        value: 0.1\n      },\n      thicknessPower: {\n        value: 2\n      },\n      thicknessScale: {\n        value: 10\n      }\n    }]),\n    vertexShader: (/* glsl */\n    `\n    #define USE_UV\n    ${ShaderChunk[\"meshphong_vert\"]}\n  `),\n    fragmentShader: (/* glsl */\n    `\n    #define USE_UV',\n    #define SUBSURFACE',\n\n    ${meshphong_frag_head}\n\n    uniform sampler2D thicknessMap;\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n    \tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\n    \tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n    \tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n    \tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n    \treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n\n    ${meshphong_frag_body.replace(\"#include <lights_fragment_begin>\", ShaderChunk[\"lights_fragment_begin\"].replace(/RE_Direct\\( directLight, geometry, material, reflectedLight \\);/g, /* glsl */\n    `\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      `))}\n  `)\n  };\n  return _SubsurfaceScatteringShader;\n}\nconst SubsurfaceScatteringShader = {\n  get uniforms() {\n    return get().uniforms;\n  },\n  set uniforms(value) {\n    get().uniforms = value;\n  },\n  get vertexShader() {\n    return get().vertexShader;\n  },\n  set vertexShader(value) {\n    get().vertexShader = value;\n  },\n  get fragmentShader() {\n    return get().vertexShader;\n  },\n  set fragmentShader(value) {\n    get().vertexShader = value;\n  }\n};\nexport { SubsurfaceScatteringShader };","map":{"version":3,"sources":["../../src/shaders/SubsurfaceScatteringShader.ts"],"names":[],"mappings":";AAUA,IAAI,2BAAA;AAEJ,SAAS,GAAA,CAAA,EAAM;EACT,IAAA,2BAAA,EAAoC,OAAA,2BAAA;EAElC,MAAA,mBAAA,GAAsB,WAAA,CAAY,gBAAgB,CAAA,CAAE,KAAA,CACxD,CAAA,EACA,WAAA,CAAY,gBAAgB,CAAA,CAAE,OAAA,CAAQ,eAAe,CAAA,CAAA;EAEjD,MAAA,mBAAA,GAAsB,WAAA,CAAY,gBAAgB,CAAA,CAAE,KAAA,CACxD,WAAA,CAAY,gBAAgB,CAAA,CAAE,OAAA,CAAQ,eAAe,CAAA,CAAA;EAGzB,2BAAA,GAAA;IAC5B,QAAA,EAAU,aAAA,CAAc,KAAA,CAAM,CAC5B,SAAA,CAAU,OAAO,CAAA,CAAE,QAAA,EACnB;MACE,YAAA,EAAc;QAAE,KAAA,EAAO;MAAK,CAAA;MAC5B,cAAA,EAAgB;QAAE,KAAA,EAAO,IAAI,KAAA,CAAM,QAAQ;MAAE,CAAA;MAC7C,mBAAA,EAAqB;QAAE,KAAA,EAAO;MAAI,CAAA;MAClC,gBAAA,EAAkB;QAAE,KAAA,EAAO;MAAI,CAAA;MAC/B,oBAAA,EAAsB;QAAE,KAAA,EAAO;MAAI,CAAA;MACnC,cAAA,EAAgB;QAAE,KAAA,EAAO;MAAI,CAAA;MAC7B,cAAA,EAAgB;QAAE,KAAA,EAAO;MAAK;IAChC,CAAA,CACD,CAAA;IAED,YAAA,GAAA;IAAyB;AAAA;AAAA,MAEvB,WAAA,CAAY,gBAAgB,CAAA;AAAA,GAAA,CAAA;IAE9B,cAAA,GAAA;IAA2B;AAAA;AAAA;AAAA;AAAA,MAIzB,mBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAkBA,mBAAA,CAAoB,OAAA,CACpB,kCAAA,EACA,WAAA,CAAY,uBAAuB,CAAA,CAAE,OAAA,CACnC,kEAAA,EAAA;IACW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAOb,CAAA,CAAA;AAAA,GAAA;EACF,CAAA;EAIK,OAAA,2BAAA;AACT;AAEO,MAAM,0BAAA,GAA6B;EACxC,IAAI,QAAA,CAAA,EAAW;IACb,OAAO,GAAA,CAAM,CAAA,CAAA,QAAA;EACf,CAAA;EACA,IAAI,QAAA,CAAS,KAAA,EAAO;IAClB,GAAA,CAAA,CAAA,CAAM,QAAA,GAAW,KAAA;EACnB,CAAA;EACA,IAAI,YAAA,CAAA,EAAe;IACjB,OAAO,GAAA,CAAM,CAAA,CAAA,YAAA;EACf,CAAA;EACA,IAAI,YAAA,CAAa,KAAA,EAAO;IACtB,GAAA,CAAA,CAAA,CAAM,YAAA,GAAe,KAAA;EACvB,CAAA;EACA,IAAI,cAAA,CAAA,EAAiB;IACnB,OAAO,GAAA,CAAM,CAAA,CAAA,YAAA;EACf,CAAA;EACA,IAAI,cAAA,CAAe,KAAA,EAAO;IACxB,GAAA,CAAA,CAAA,CAAM,YAAA,GAAe,KAAA;EACvB;AACF,CAAA","sourcesContent":["import { Color, ShaderChunk, ShaderLib, UniformsUtils } from 'three'\n\n/**\n * ------------------------------------------------------------------------------------------\n * Subsurface Scattering shader\n * Based on GDC 2011 â€“ Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n *------------------------------------------------------------------------------------------\n */\n\nlet _SubsurfaceScatteringShader: any\n\nfunction get() {\n  if (_SubsurfaceScatteringShader) return _SubsurfaceScatteringShader\n\n  const meshphong_frag_head = ShaderChunk['meshphong_frag'].slice(\n    0,\n    ShaderChunk['meshphong_frag'].indexOf('void main() {'),\n  )\n  const meshphong_frag_body = ShaderChunk['meshphong_frag'].slice(\n    ShaderChunk['meshphong_frag'].indexOf('void main() {'),\n  )\n\n  _SubsurfaceScatteringShader = {\n    uniforms: UniformsUtils.merge([\n      ShaderLib['phong'].uniforms,\n      {\n        thicknessMap: { value: null },\n        thicknessColor: { value: new Color(0xffffff) },\n        thicknessDistortion: { value: 0.1 },\n        thicknessAmbient: { value: 0.0 },\n        thicknessAttenuation: { value: 0.1 },\n        thicknessPower: { value: 2.0 },\n        thicknessScale: { value: 10.0 },\n      },\n    ]),\n\n    vertexShader: /* glsl */ `\n    #define USE_UV\n    ${ShaderChunk['meshphong_vert']}\n  `,\n    fragmentShader: /* glsl */ `\n    #define USE_UV',\n    #define SUBSURFACE',\n\n    ${meshphong_frag_head}\n\n    uniform sampler2D thicknessMap;\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n    \tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\n    \tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n    \tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n    \tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n    \treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n\n    ${meshphong_frag_body.replace(\n      '#include <lights_fragment_begin>',\n      ShaderChunk['lights_fragment_begin'].replace(\n        /RE_Direct\\( directLight, geometry, material, reflectedLight \\);/g,\n        /* glsl */ `\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      `,\n      ),\n    )}\n  `,\n  }\n\n  return _SubsurfaceScatteringShader\n}\n\nexport const SubsurfaceScatteringShader = {\n  get uniforms() {\n    return get().uniforms\n  },\n  set uniforms(value) {\n    get().uniforms = value\n  },\n  get vertexShader() {\n    return get().vertexShader\n  },\n  set vertexShader(value) {\n    get().vertexShader = value\n  },\n  get fragmentShader() {\n    return get().vertexShader\n  },\n  set fragmentShader(value) {\n    get().vertexShader = value\n  },\n}\n"]},"metadata":{},"sourceType":"module"}