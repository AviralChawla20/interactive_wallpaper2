{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass } from \"./Pass.js\";\nclass MaskPass extends Pass {\n  constructor(scene, camera) {\n    super();\n    __publicField(this, \"scene\");\n    __publicField(this, \"camera\");\n    __publicField(this, \"inverse\");\n    this.scene = scene;\n    this.camera = camera;\n    this.clear = true;\n    this.needsSwap = false;\n    this.inverse = false;\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    const context = renderer.getContext();\n    const state = renderer.state;\n    state.buffers.color.setMask(false);\n    state.buffers.depth.setMask(false);\n    state.buffers.color.setLocked(true);\n    state.buffers.depth.setLocked(true);\n    let writeValue, clearValue;\n    if (this.inverse) {\n      writeValue = 0;\n      clearValue = 1;\n    } else {\n      writeValue = 1;\n      clearValue = 0;\n    }\n    state.buffers.stencil.setTest(true);\n    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n    state.buffers.stencil.setClear(clearValue);\n    state.buffers.stencil.setLocked(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(writeBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n    state.buffers.color.setLocked(false);\n    state.buffers.depth.setLocked(false);\n    state.buffers.stencil.setLocked(false);\n    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    state.buffers.stencil.setLocked(true);\n  }\n}\nclass ClearMaskPass extends Pass {\n  constructor() {\n    super();\n    this.needsSwap = false;\n  }\n  render(renderer) {\n    renderer.state.buffers.stencil.setLocked(false);\n    renderer.state.buffers.stencil.setTest(false);\n  }\n}\nexport { ClearMaskPass, MaskPass };","map":{"version":3,"sources":["../../src/postprocessing/MaskPass.ts"],"names":[],"mappings":"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","sourcesContent":["import { Camera, Scene, WebGLRenderer, WebGLRenderTarget } from 'three'\nimport { Pass } from './Pass'\n\nclass MaskPass extends Pass {\n  public scene: Scene\n  public camera: Camera\n  public inverse: boolean\n\n  constructor(scene: Scene, camera: Camera) {\n    super()\n\n    this.scene = scene\n    this.camera = camera\n\n    this.clear = true\n    this.needsSwap = false\n\n    this.inverse = false\n  }\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget /*, deltaTime, maskActive */,\n  ): void {\n    const context = renderer.getContext()\n    const state = renderer.state\n\n    // don't update color or depth\n\n    state.buffers.color.setMask(false)\n    state.buffers.depth.setMask(false)\n\n    // lock buffers\n\n    state.buffers.color.setLocked(true)\n    state.buffers.depth.setLocked(true)\n\n    // set up stencil\n\n    let writeValue, clearValue\n\n    if (this.inverse) {\n      writeValue = 0\n      clearValue = 1\n    } else {\n      writeValue = 1\n      clearValue = 0\n    }\n\n    state.buffers.stencil.setTest(true)\n    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE)\n    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff)\n    state.buffers.stencil.setClear(clearValue)\n    state.buffers.stencil.setLocked(true)\n\n    // draw into the stencil buffer\n\n    renderer.setRenderTarget(readBuffer)\n    if (this.clear) renderer.clear()\n    renderer.render(this.scene, this.camera)\n\n    renderer.setRenderTarget(writeBuffer)\n    if (this.clear) renderer.clear()\n    renderer.render(this.scene, this.camera)\n\n    // unlock color and depth buffer for subsequent rendering\n\n    state.buffers.color.setLocked(false)\n    state.buffers.depth.setLocked(false)\n\n    // only render where stencil is set to 1\n\n    state.buffers.stencil.setLocked(false)\n    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff) // draw if == 1\n    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP)\n    state.buffers.stencil.setLocked(true)\n  }\n}\n\nclass ClearMaskPass extends Pass {\n  constructor() {\n    super()\n    this.needsSwap = false\n  }\n\n  public render(renderer: WebGLRenderer /*, writeBuffer, readBuffer, deltaTime, maskActive */): void {\n    renderer.state.buffers.stencil.setLocked(false)\n    renderer.state.buffers.stencil.setTest(false)\n  }\n}\n\nexport { MaskPass, ClearMaskPass }\n"]},"metadata":{},"sourceType":"module"}