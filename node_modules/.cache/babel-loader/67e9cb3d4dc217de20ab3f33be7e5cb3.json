{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, url));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, url) {\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error(\"Output buffer is not large enough\");\n          if (inPtr + ctrl > inLength) throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 31) << 8) - 1;\n          if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error(\"Output buffer is not large enough\");\n          if (ref < 0) throw new Error(\"Invalid compressed data\");\n          if (ref >= outPtr) throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(data2) {\n      const PCDheader2 = {};\n      const result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n      PCDheader2.data = result2[1];\n      PCDheader2.headerLen = result2[0].length + result1;\n      PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n      PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n      PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n      PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n      PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n      PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n      if (PCDheader2.version !== null) PCDheader2.version = parseFloat(PCDheader2.version[1]);\n      if (PCDheader2.fields !== null) PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n      if (PCDheader2.type !== null) PCDheader2.type = PCDheader2.type[1].split(\" \");\n      if (PCDheader2.width !== null) PCDheader2.width = parseInt(PCDheader2.width[1]);\n      if (PCDheader2.height !== null) PCDheader2.height = parseInt(PCDheader2.height[1]);\n      if (PCDheader2.viewpoint !== null) PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n      if (PCDheader2.points !== null) PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n      if (PCDheader2.points === null) PCDheader2.points = PCDheader2.width * PCDheader2.height;\n      if (PCDheader2.size !== null) {\n        PCDheader2.size = PCDheader2.size[1].split(\" \").map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader2.count !== null) {\n        PCDheader2.count = PCDheader2.count[1].split(\" \").map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader2.count = [];\n        for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n          PCDheader2.count.push(1);\n        }\n      }\n      PCDheader2.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n        if (PCDheader2.data === \"ascii\") {\n          PCDheader2.offset[PCDheader2.fields[i]] = i;\n        } else {\n          PCDheader2.offset[PCDheader2.fields[i]] = sizeSum;\n          sizeSum += PCDheader2.size[i] * PCDheader2.count[i];\n        }\n      }\n      PCDheader2.rowSize = sizeSum;\n      return PCDheader2;\n    }\n    const textData = decodeText(new Uint8Array(data));\n    const PCDheader = parseHeader(textData);\n    const position = [];\n    const normal = [];\n    const color = [];\n    if (PCDheader.data === \"ascii\") {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split(\"\\n\");\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === \"\") continue;\n        const line = lines[i].split(\" \");\n        if (offset.x !== void 0) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== void 0) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 255;\n          const g = rgb >> 8 & 255;\n          const b = rgb >> 0 & 255;\n          color.push(r / 255, g / 255, b / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    }\n    if (PCDheader.data === \"binary_compressed\") {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));\n          normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));\n        }\n      }\n    }\n    if (PCDheader.data === \"binary\") {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    }\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere();\n    const material = new PointsMaterial({\n      size: 5e-3\n    });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 16777215);\n    }\n    const mesh = new Points(geometry, material);\n    let name = url.split(\"\").reverse().join(\"\");\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split(\"\").reverse().join(\"\");\n    mesh.name = name;\n    return mesh;\n  }\n}\nexport { PCDLoader };","map":{"version":3,"sources":["../../src/loaders/PCDLoader.js"],"names":["data","PCDheader"],"mappings":"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","sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Points, PointsMaterial } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.littleEndian = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, url))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length\n      const outData = new Uint8Array(outLength)\n      let inPtr = 0\n      let outPtr = 0\n      let ctrl\n      let len\n      let ref\n      do {\n        ctrl = inData[inPtr++]\n        if (ctrl < 1 << 5) {\n          ctrl++\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough')\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = inData[inPtr++]\n          } while (--ctrl)\n        } else {\n          len = ctrl >> 5\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1\n          if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          if (len === 7) {\n            len += inData[inPtr++]\n            if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          }\n\n          ref -= inData[inPtr++]\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough')\n          if (ref < 0) throw new Error('Invalid compressed data')\n          if (ref >= outPtr) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = outData[ref++]\n          } while (--len + 2)\n        }\n      } while (inPtr < inLength)\n\n      return outData\n    }\n\n    function parseHeader(data) {\n      const PCDheader = {}\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i)\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1))\n\n      PCDheader.data = result2[1]\n      PCDheader.headerLen = result2[0].length + result1\n      PCDheader.str = data.substr(0, PCDheader.headerLen)\n\n      // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, '')\n\n      // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str)\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str)\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str)\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str)\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str)\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str)\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str)\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str)\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str)\n\n      // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1])\n\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ')\n\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ')\n\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1])\n\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1])\n\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1]\n\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10)\n\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      } else {\n        PCDheader.count = []\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1)\n        }\n      }\n\n      PCDheader.offset = {}\n\n      let sizeSum = 0\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum\n          sizeSum += PCDheader.size[i] * PCDheader.count[i]\n        }\n      }\n\n      // for binary only\n\n      PCDheader.rowSize = sizeSum\n\n      return PCDheader\n    }\n\n    const textData = decodeText(new Uint8Array(data))\n\n    // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData)\n\n    // parse data\n\n    const position = []\n    const normal = []\n    const color = []\n\n    // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset\n      const pcdData = textData.substr(PCDheader.headerLen)\n      const lines = pcdData.split('\\n')\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue\n\n        const line = lines[i].split(' ')\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]))\n          position.push(parseFloat(line[offset.y]))\n          position.push(parseFloat(line[offset.z]))\n        }\n\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb])\n          const r = (rgb >> 16) & 0x0000ff\n          const g = (rgb >> 8) & 0x0000ff\n          const b = (rgb >> 0) & 0x0000ff\n          color.push(r / 255, g / 255, b / 255)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]))\n          normal.push(parseFloat(line[offset.normal_y]))\n          normal.push(parseFloat(line[offset.normal_z]))\n        }\n      }\n    }\n\n    // binary-compressed\n\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8))\n      const compressedSize = sizes[0]\n      const decompressedSize = sizes[1]\n      const decompressed = decompressLZF(\n        new Uint8Array(data, PCDheader.headerLen + 8, compressedSize),\n        decompressedSize,\n      )\n      const dataview = new DataView(decompressed.buffer)\n\n      const offset = PCDheader.offset\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian),\n          )\n        }\n      }\n    }\n\n    // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen)\n      const offset = PCDheader.offset\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian))\n        }\n      }\n    }\n\n    // build geometry\n\n    const geometry = new BufferGeometry()\n\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3))\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n    geometry.computeBoundingSphere()\n\n    // build material\n\n    const material = new PointsMaterial({ size: 0.005 })\n\n    if (color.length > 0) {\n      material.vertexColors = true\n    } else {\n      material.color.setHex(Math.random() * 0xffffff)\n    }\n\n    // build point cloud\n\n    const mesh = new Points(geometry, material)\n    let name = url.split('').reverse().join('')\n    name = /([^\\/]*)/.exec(name)\n    name = name[1].split('').reverse().join('')\n    mesh.name = name\n\n    return mesh\n  }\n}\n\nexport { PCDLoader }\n"]},"metadata":{},"sourceType":"module"}