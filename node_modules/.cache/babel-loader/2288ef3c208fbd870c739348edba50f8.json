{"ast":null,"code":"import { Vector3 } from \"three\";\nconst hilbert2D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3) => {\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]];\n  if (0 <= --iterations) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3));\n    return tmp;\n  }\n  return vec;\n};\nconst hilbert3D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7) => {\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];\n  if (--iterations >= 0) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7));\n    return tmp;\n  }\n  return vec;\n};\nconst gosper = (size = 1) => {\n  function fractalize(config) {\n    let output = \"\";\n    let input = config.axiom;\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = \"\";\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j];\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n      input = output;\n    }\n    return output;\n  }\n  function toPoints(config) {\n    let currX = 0;\n    let currY = 0;\n    let angle = 0;\n    const path = [0, 0, 0];\n    const fractal = config.fractal;\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i];\n      if (char === \"+\") {\n        angle += config.angle;\n      } else if (char === \"-\") {\n        angle -= config.angle;\n      } else if (char === \"F\") {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n    return path;\n  }\n  const gosper2 = fractalize({\n    axiom: \"A\",\n    steps: 4,\n    rules: {\n      A: \"A+BF++BF-FA--FAFA-BF+\",\n      B: \"-FA+BFBF++BF+FA--FA-B\"\n    }\n  });\n  const points = toPoints({\n    fractal: gosper2,\n    size,\n    angle: Math.PI / 3\n    // 60 degrees\n  });\n  return points;\n};\nconst GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D\n};\nexport { GeometryUtils };","map":{"version":3,"sources":["../../src/utils/GeometryUtils.ts"],"names":["gosper"],"mappings":"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","sourcesContent":["import { Vector3 } from 'three'\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\nconst hilbert2D = (\n  center = new Vector3(0, 0, 0),\n  size = 10,\n  iterations = 1,\n  v0 = 0,\n  v1 = 1,\n  v2 = 2,\n  v3 = 3,\n): Vector3[] => {\n  // Default Vars\n  const half = size / 2\n  const vec_s = [\n    new Vector3(center.x - half, center.y, center.z - half),\n    new Vector3(center.x - half, center.y, center.z + half),\n    new Vector3(center.x + half, center.y, center.z + half),\n    new Vector3(center.x + half, center.y, center.z - half),\n  ]\n\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]\n\n  // Recurse iterations\n  if (0 <= --iterations) {\n    const tmp: Vector3[] = []\n\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3))\n\n    // Return recursive call\n    return tmp\n  }\n\n  // Return complete Hilbert Curve.\n  return vec\n}\n\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\nconst hilbert3D = (\n  center = new Vector3(0, 0, 0),\n  size = 10,\n  iterations = 1,\n  v0 = 0,\n  v1 = 1,\n  v2 = 2,\n  v3 = 3,\n  v4 = 4,\n  v5 = 5,\n  v6 = 6,\n  v7 = 7,\n): Vector3[] => {\n  // Default Vars\n  const half = size / 2\n  const vec_s = [\n    new Vector3(center.x - half, center.y + half, center.z - half),\n    new Vector3(center.x - half, center.y + half, center.z + half),\n    new Vector3(center.x - half, center.y - half, center.z + half),\n    new Vector3(center.x - half, center.y - half, center.z - half),\n    new Vector3(center.x + half, center.y - half, center.z - half),\n    new Vector3(center.x + half, center.y - half, center.z + half),\n    new Vector3(center.x + half, center.y + half, center.z + half),\n    new Vector3(center.x + half, center.y + half, center.z - half),\n  ]\n\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]\n\n  // Recurse iterations\n  if (--iterations >= 0) {\n    const tmp: Vector3[] = []\n\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7))\n\n    // Return recursive call\n    return tmp\n  }\n\n  // Return complete Hilbert Curve.\n  return vec\n}\n\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\nconst gosper = (size = 1): number[] => {\n  function fractalize(config: { axiom: string; steps: number; rules: Record<string, string> }): string {\n    let output = ''\n    let input = config.axiom\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = ''\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j]\n\n        if (char in config.rules) {\n          output += config.rules[char]\n        } else {\n          output += char\n        }\n      }\n\n      input = output\n    }\n\n    return output\n  }\n\n  function toPoints(config: { fractal: string; size: number; angle: number }): number[] {\n    let currX = 0\n    let currY = 0\n    let angle = 0\n    const path = [0, 0, 0]\n    const fractal = config.fractal\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i]\n\n      if (char === '+') {\n        angle += config.angle\n      } else if (char === '-') {\n        angle -= config.angle\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle)\n        currY += -config.size * Math.sin(angle)\n        path.push(currX, currY, 0)\n      }\n    }\n\n    return path\n  }\n\n  //\n\n  const gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B',\n    },\n  })\n\n  const points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3, // 60 degrees\n  })\n\n  return points\n}\n\nexport const GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D,\n}\n"]},"metadata":{},"sourceType":"module"}