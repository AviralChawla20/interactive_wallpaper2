{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    if (UV1 === \"uv2\") this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\") mesh = new Points(geometry, materials);else if (layer.geometry.type === \"lines\") mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  }\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs) return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  }\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes[\"Bump Height\"]) params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"]) params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n      maps.envMap = envMap;\n    }\n  }\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures) return fileName;\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function () {\n      console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\");\n    });\n    return texture;\n  }\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  }\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\") elemSize = 2;\n    if (geoData.type === \"points\") elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return \"./\";\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"sources":["../../src/loaders/LWOLoader.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nimport {\n  AddOperation,\n  BackSide,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Mesh,\n  MeshPhongMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  Points,\n  PointsMaterial,\n  RepeatWrapping,\n  TextureLoader,\n  Vector2,\n} from 'three'\n\nimport { IFFParser } from './lwo/IFFParser.js'\nimport { UV1 } from '../_polyfill/uv1.ts'\n\nlet _lwoTree\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager)\n\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : ''\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path\n\n    // give the mesh a default name based on the filename\n    const modelName = url.split(path).pop().split('.')[0]\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n\n    loader.load(\n      url,\n      function (buffer) {\n        // console.time( 'Total parsing: ' );\n\n        try {\n          onLoad(scope.parse(buffer, path, modelName))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n\n        // console.timeEnd( 'Total parsing: ' );\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer)\n\n    // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new LWOTreeParser(textureLoader).parse(modelName)\n  }\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse()\n    this.defaultLayerName = modelName\n\n    this.meshes = this.parseLayers()\n\n    return {\n      materials: this.materials,\n      meshes: this.meshes,\n    }\n  }\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = []\n\n    // final array containing meshes with scene graph hierarchy set up\n    const finalMeshes = []\n\n    const geometryParser = new GeometryParser()\n\n    const scope = this\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer)\n\n      const mesh = scope.parseMesh(geometry, layer)\n\n      meshes[layer.number] = mesh\n\n      if (layer.parent === -1) finalMeshes.push(mesh)\n      else meshes[layer.parent].add(mesh)\n    })\n\n    this.applyPivots(finalMeshes)\n\n    return finalMeshes\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh\n\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type)\n\n    if (UV1 === 'uv2') this.duplicateUVs(geometry, materials)\n\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials)\n    else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials)\n    else mesh = new Mesh(geometry, materials)\n\n    if (layer.name) mesh.name = layer.name\n    else mesh.name = this.defaultLayerName + '_layer_' + layer.number\n\n    mesh.userData.pivot = layer.pivot\n\n    return mesh\n  }\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot\n\n        child.position.x += pivot[0]\n        child.position.y += pivot[1]\n        child.position.z += pivot[2]\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot\n\n          child.position.x -= parentPivot[0]\n          child.position.y -= parentPivot[1]\n          child.position.z -= parentPivot[2]\n        }\n      })\n    })\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = []\n\n    const scope = this\n\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name)\n    })\n\n    // convert materials to line or point mats if required\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color,\n        }\n\n        if (type === 'points') {\n          spec.size = 0.1\n          spec.map = mat.map\n          spec.morphTargets = mat.morphTargets\n          materials[i] = new PointsMaterial(spec)\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec)\n        }\n      })\n    }\n\n    // if there is only one material, return that directly instead of array\n    const filtered = materials.filter(Boolean)\n    if (filtered.length === 1) return filtered[0]\n\n    return materials\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name\n    })[0]\n  }\n\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true\n      })\n    }\n\n    if (!duplicateUVs) return\n\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2))\n  }\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse() {\n    const materials = []\n    this.textures = {}\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures))\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures))\n      }\n    }\n\n    return materials\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const connections = this.parseConnections(materialData.connections, materialData.nodes)\n\n    const maps = this.parseTextureNodes(connections.maps)\n\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps)\n\n    const attributes = this.parseAttributes(connections.attributes, maps)\n\n    this.parseEnvMap(connections, maps, attributes)\n\n    params = Object.assign(maps, params)\n    params = Object.assign(params, attributes)\n\n    const materialType = this.getMaterialType(connections.attributes)\n\n    return new materialType(params)\n  }\n\n  parseMaterialLwo2(materialData, name /*, textures*/) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const attributes = this.parseAttributes(materialData.attributes, {})\n    params = Object.assign(params, attributes)\n    return new MeshPhongMaterial(params)\n  }\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide\n      case 2:\n        return FrontSide\n      case 3:\n        return DoubleSide\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true\n    return !attributes.smooth\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {},\n    }\n\n    const inputName = connections.inputName\n    const inputNodeName = connections.inputNodeName\n    const nodeName = connections.nodeName\n\n    const scope = this\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes)\n        materialConnections.attributes = matNode.attributes\n        materialConnections.envMap = matNode.fileName\n        materialConnections.name = inputNodeName[index]\n      }\n    })\n\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes)\n      }\n    })\n\n    return materialConnections\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name]\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {}\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name]\n      const path = node.fileName\n\n      if (!path) return\n\n      const texture = this.loadTexture(path)\n\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode)\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode)\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture\n          break\n        case 'Roughness':\n          maps.roughnessMap = texture\n          maps.roughness = 0.5\n          break\n        case 'Specular':\n          maps.specularMap = texture\n          maps.specular = 0xffffff\n          break\n        case 'Luminous':\n          maps.emissiveMap = texture\n          maps.emissive = 0x808080\n          break\n        case 'Luminous Color':\n          maps.emissive = 0x808080\n          break\n        case 'Metallic':\n          maps.metalnessMap = texture\n          maps.metalness = 0.5\n          break\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture\n          maps.transparent = true\n          break\n        case 'Normal':\n          maps.normalMap = texture\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude)\n          break\n        case 'Bump':\n          maps.bumpMap = texture\n          break\n      }\n    }\n\n    // LWO BSDF materials can have both spec and rough, but this is not valid in three\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap\n\n    return maps\n  }\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name]\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0]\n\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures)\n        if (!path) return\n\n        const texture = this.loadTexture(path)\n\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w)\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h)\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture\n            break\n          case 'Diffuse':\n            maps.aoMap = texture\n            break\n          case 'Roughness':\n            maps.roughnessMap = texture\n            maps.roughness = 1\n            break\n          case 'Specular':\n            maps.specularMap = texture\n            maps.specular = 0xffffff\n            break\n          case 'Luminosity':\n            maps.emissiveMap = texture\n            maps.emissive = 0x808080\n            break\n          case 'Metallic':\n            maps.metalnessMap = texture\n            maps.metalness = 1\n            break\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture\n            maps.transparent = true\n            break\n          case 'Normal':\n            maps.normalMap = texture\n            break\n          case 'Bump':\n            maps.bumpMap = texture\n            break\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {}\n\n    // don't use color data if color map is present\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value)\n    } else {\n      params.color = new Color()\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value\n      params.transparent = true\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1\n\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value\n\n    this.parsePhysicalAttributes(params, attributes, maps)\n    this.parseStandardAttributes(params, attributes, maps)\n    this.parsePhongAttributes(params, attributes, maps)\n\n    return params\n  }\n\n  parsePhysicalAttributes(params, attributes /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value)\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value)\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value)\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value\n      params.combine = AddOperation\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color()\n          .setScalar(attributes.Specular.value)\n          .lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value)\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value)\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2)\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap)\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping\n\n        // Reflectivity and refraction mapping don't work well together in Phong materials\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity\n          delete attributes.combine\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping\n      }\n\n      maps.envMap = envMap\n    }\n  }\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = ''\n\n    if (!_lwoTree.textures) return fileName\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName\n    })\n\n    return fileName\n  }\n\n  loadTexture(path) {\n    if (!path) return null\n\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn(\n        'LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.',\n      )\n    })\n\n    return texture\n  }\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js')\n        return ClampToEdgeWrapping\n      case 1:\n        return RepeatWrapping\n      case 2:\n        return MirroredRepeatWrapping\n      case 3:\n        return ClampToEdgeWrapping\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial\n    if (nodeData.Roughness) return MeshStandardMaterial\n    return MeshPhongMaterial\n  }\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3))\n\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions)\n    geometry.setIndex(indices)\n\n    this.parseGroups(geometry, geoData)\n\n    geometry.computeVertexNormals()\n\n    this.parseUVs(geometry, layer, indices)\n    this.parseMorphTargets(geometry, layer, indices)\n\n    // TODO: z may need to be reversed to account for coordinate system change\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2])\n\n    // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry\n  }\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = []\n\n    let i = 0\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k])\n      } else if (dim === 4) {\n        remappedIndices.push(\n          indices[i],\n          indices[i + 1],\n          indices[i + 2],\n\n          indices[i],\n          indices[i + 2],\n          indices[i + 3],\n        )\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1])\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported')\n      }\n\n      i += dim\n    })\n\n    return remappedIndices\n  }\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags\n    const matNames = []\n\n    let elemSize = 3\n    if (geoData.type === 'lines') elemSize = 2\n    if (geoData.type === 'points') elemSize = 1\n\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices)\n\n    let indexNum = 0 // create new indices in numerical order\n    const indexPairs = {} // original indices mapped to numerical indices\n\n    let prevMaterialIndex\n    let materialIndex\n\n    let prevStart = 0\n    let currentCount = 0\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1]\n\n      if (i === 0) matNames[indexNum] = tags[materialIndex]\n\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]]\n        } else {\n          currentIndex = indexNum\n          indexPairs[tags[prevMaterialIndex]] = indexNum\n          matNames[indexNum] = tags[prevMaterialIndex]\n          indexNum++\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex)\n\n        prevStart += currentCount\n\n        prevMaterialIndex = materialIndex\n        currentCount = 0\n      }\n\n      currentCount += elemSize\n    }\n\n    // the loop above doesn't add the last group, do that here.\n    if (geometry.groups.length > 0) {\n      let currentIndex\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]]\n      } else {\n        currentIndex = indexNum\n        indexPairs[tags[materialIndex]] = indexNum\n        matNames[indexNum] = tags[materialIndex]\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex)\n    }\n\n    // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n    geometry.userData.matNames = matNames\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = []\n\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1])\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n        }\n      }\n    })\n\n    return remappedIndices\n  }\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0\n    })\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs\n      const uvIndices = layer.uvs[name].uvIndices\n\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2]\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1]\n      })\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2))\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice()\n\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = []\n\n      const morphPoints = layer.morphTargets[name].points\n      const morphIndices = layer.morphTargets[name].indices\n      const type = layer.morphTargets[name].type\n\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2]\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2]\n        }\n      })\n\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3)\n      geometry.morphAttributes.position[num].name = name\n\n      num++\n    }\n\n    geometry.morphTargetsRelative = false\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir)\n\n  if (index === -1) return './'\n\n  return url.substr(0, index)\n}\n\nexport { LWOLoader }\n"]},"metadata":{},"sourceType":"module"}