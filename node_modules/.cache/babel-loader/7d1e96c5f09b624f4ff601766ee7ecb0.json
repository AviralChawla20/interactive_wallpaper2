{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nclass USDZExporter {\n  constructor() {\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  async parse(scene) {\n    const modelFileName = \"model.usda\";\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split(\"_\")[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1));\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    }\n    let offset = 0;\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      if (file && typeof file.length === \"number\") {\n        offset = file.length;\n      }\n    }\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext(\"2d\");\n      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      if (color !== void 0) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n        if (imagedata) {\n          const data = imagedata == null ? void 0 : imagedata.data;\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n          context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n      return canvas;\n    }\n  }\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  }\n  // Xform\n  buildXform(object, geometry, material) {\n    const name = \"Object_\" + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n    }\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  }\n  // Mesh\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n  buildMesh(geometry) {\n    const name = \"Geometry\";\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(\", \");\n  }\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      return geometry.index.array.join(\", \");\n    }\n    const array = [];\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n    return array.join(\", \");\n  }\n  buildVector3Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: Normals missing.\");\n      return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`);\n    }\n    return array.join(\", \");\n  }\n  buildVector2Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: UVs missing.\");\n      return Array(count).fill(\"(0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 2) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n    return array.join(\", \");\n  }\n  // Materials\n  buildMaterials(materials) {\n    const array = [];\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n    return `def \"Materials\"\n{\n${array.join(\"\")}\n}\n`;\n  }\n  buildMaterial(material) {\n    const pad = \"            \";\n    const inputs = [];\n    const samplers = [];\n    if (material.map !== null) {\n      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n      if (material.transparent || material.alphaTest > 0) {\n        inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      }\n      if (material.alphaTest > 0.01) {\n        inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);\n      } else if (material.transparent || material.alphaTest > 0) {\n        inputs.push(`${pad}float inputs:opacityThreshold = 0.01`);\n      }\n      samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n    if (material.emissiveMap !== null) {\n      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n    if (material.normalMap !== null) {\n      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n    }\n    if (material.aoMap !== null) {\n      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n      samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n    }\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n      samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n      samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join(\"\\n\")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join(\"\\n\")}\n    }\n`;\n  }\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? \"png\" : \"jpg\"}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n          ${material.transparent || material.alphaTest > 0 ? \"float outputs:a\" : \"\"}\n      }`;\n  }\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n}\nexport { USDZExporter };","map":{"version":3,"sources":["../../src/exporters/USDZExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import { zipSync, strToU8, Zippable } from 'fflate'\nimport {\n  BufferGeometry,\n  Color,\n  Matrix4,\n  Mesh,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  Object3D,\n  Texture,\n  Vector2,\n} from 'three'\nimport { Nullable } from '../types/utils'\n\ntype MaterialRepresentaion = MeshStandardMaterial | MeshPhysicalMaterial\n\nclass USDZExporter {\n  private readonly PRECISION = 7\n\n  private materials: { [key: string]: MaterialRepresentaion }\n  private textures: { [key: string]: Texture }\n\n  private files: Nullable<Zippable>\n\n  constructor() {\n    this.materials = {}\n    this.textures = {}\n\n    this.files = {}\n  }\n\n  public async parse(scene: Object3D): Promise<Uint8Array> {\n    const modelFileName = 'model.usda'\n\n    // model file should be first in USDZ archive so we init it here\n    this.files[modelFileName] = null\n\n    let output: string | null = this.buildHeader()\n\n    scene.traverseVisible((object) => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry: BufferGeometry = object.geometry\n        const material: MaterialRepresentaion = object.material\n\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd'\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry)\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject)\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material\n        }\n\n        output += this.buildXform(object, geometry, material)\n      }\n    })\n\n    output += this.buildMaterials(this.materials)\n\n    this.files[modelFileName] = strToU8(output)\n    output = null\n\n    for (const id in this.textures) {\n      const texture = this.textures[id]\n      const color = id.split('_')[1]\n      const isRGBA = texture.format === 1023\n\n      const canvas = this.imageToCanvas(texture.image, color)\n      const blob = await new Promise<Blob | null>((resolve) =>\n        canvas?.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1),\n      )\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer())\n      }\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0\n\n    for (const filename in this.files) {\n      const file = this.files[filename]\n      const headerSize = 34 + filename.length\n\n      offset += headerSize\n\n      const offsetMod64 = offset & 63\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64\n        const padding = new Uint8Array(padLength)\n\n        this.files[filename] = [file, { extra: { 12345: padding } }]\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length\n      }\n    }\n\n    return zipSync(this.files as Zippable, { level: 0 })\n  }\n\n  private imageToCanvas(\n    image: HTMLImageElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap,\n    color: string,\n  ): HTMLCanvasElement | undefined {\n    if (\n      (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||\n      (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas) ||\n      (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n    ) {\n      const scale = 1024 / Math.max(image.width, image.height)\n\n      const canvas = document.createElement('canvas')\n      canvas.width = image.width * Math.min(1, scale)\n      canvas.height = image.height * Math.min(1, scale)\n\n      const context = canvas.getContext('2d')\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height)\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16)\n\n        const r = ((hex >> 16) & 255) / 255\n        const g = ((hex >> 8) & 255) / 255\n        const b = (hex & 255) / 255\n\n        const imagedata = context?.getImageData(0, 0, canvas.width, canvas.height)\n        if (imagedata) {\n          const data = imagedata?.data\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r\n            data[i + 1] = data[i + 1] * g\n            data[i + 2] = data[i + 2] * b\n          }\n\n          context?.putImageData(imagedata, 0, 0)\n        }\n      }\n\n      return canvas\n    }\n  }\n\n  private buildHeader(): string {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`\n  }\n\n  private buildUSDFileAsString(dataToInsert: string): Uint8Array {\n    let output = this.buildHeader()\n    output += dataToInsert\n    return strToU8(output)\n  }\n\n  // Xform\n  private buildXform(object: Object3D, geometry: BufferGeometry, material: MaterialRepresentaion): string {\n    const name = 'Object_' + object.id\n    const transform = this.buildMatrix(object.matrixWorld)\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object)\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`\n  }\n\n  private buildMatrix(matrix: Matrix4): string {\n    const array = matrix.elements\n\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(\n      array,\n      8,\n    )}, ${this.buildMatrixRow(array, 12)} )`\n  }\n\n  private buildMatrixRow(array: number[], offset: number): string {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`\n  }\n\n  // Mesh\n  private buildMeshObject(geometry: BufferGeometry): string {\n    const mesh = this.buildMesh(geometry)\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`\n  }\n\n  private buildMesh(geometry: BufferGeometry): string {\n    const name = 'Geometry'\n    const attributes = geometry.attributes\n    const count = attributes.position.count\n\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`\n  }\n\n  private buildMeshVertexCount(geometry: BufferGeometry): string {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count\n\n    return Array(count / 3)\n      .fill(3)\n      .join(', ')\n  }\n\n  private buildMeshVertexIndices(geometry: BufferGeometry): string {\n    if (geometry.index !== null) {\n      // @ts-ignore\n      return geometry.index.array.join(', ')\n    }\n\n    const array: number[] = []\n    const length = geometry.attributes.position.count\n\n    for (let i = 0; i < length; i++) {\n      array.push(i)\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector3Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.')\n      return Array(count).fill('(0, 0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\n        `(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[\n          i + 2\n        ].toPrecision(this.PRECISION)})`,\n      )\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector2Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.')\n      return Array(count).fill('(0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-ignore\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`)\n    }\n\n    return array.join(', ')\n  }\n\n  // Materials\n  private buildMaterials(materials: USDZExporter['materials']): string {\n    const array: string[] = []\n\n    for (const uuid in materials) {\n      const material = materials[uuid]\n\n      array.push(this.buildMaterial(material))\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`\n  }\n\n  private buildMaterial(material: MaterialRepresentaion): string {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n    const pad = '            '\n    const inputs = []\n    const samplers = []\n\n    if (material.map !== null) {\n      inputs.push(\n        `${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`,\n      )\n\n      // Include alpha input\n      if (material.transparent || material.alphaTest > 0.0) {\n        inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      }\n\n      // Check if alpha test is bigger than minimum of 0.01, if not and it is transparent still apply a 0.01 alpha clip in order to remove white blur in transparent place.\n      if (material.alphaTest > 0.01) {\n        inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);\n      }\n      else if(material.transparent || material.alphaTest > 0.0) {\n        inputs.push(`${pad}float inputs:opacityThreshold = 0.01`);\n      }\n      \n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color))\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`)\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(\n        `${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'))\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`)\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(\n        `${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'))\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(\n        `${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'))\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\n        `${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'))\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`)\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\n        `${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'))\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`)\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`)\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`)\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`)\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`)\n    }\n\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`\n  }\n\n  private buildTexture(material: MaterialRepresentaion, texture: Texture, mapType: string, color?: Color): string {\n    const id = texture.id + (color ? '_' + color.getHexString() : '')\n    const isRGBA = texture.format === 1023\n\n    this.textures[id] = texture\n\n    // Add the alpha output for when transparency is set or the alpha test is above 0\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n          ${material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : ''}\n      }`\n  }\n\n  private buildColor(color: Color): string {\n    return `(${color.r}, ${color.g}, ${color.b})`\n  }\n\n  private buildVector2(vector: Vector2): string {\n    return `(${vector.x}, ${vector.y})`\n  }\n}\n\nexport { USDZExporter }\n"]},"metadata":{},"sourceType":"module"}