{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"sources":["../../src/shaders/DepthLimitedBlurShader.ts"],"names":["stdDev"],"mappings":"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","sourcesContent":["import { Vector2 } from 'three'\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type DepthLimitedBlurShaderDefines = {\n  DEPTH_PACKING: number\n  KERNEL_RADIUS: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type DepthLimitedBlurShaderUniforms = {\n  cameraFar: IUniform<number>\n  cameraNear: IUniform<number>\n  depthCutoff: IUniform<number>\n  sampleUvOffsets: IUniform<Vector2[]>\n  sampleWeights: IUniform<number[]>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IDepthLimitedBlurShader\n  extends IShader<DepthLimitedBlurShaderUniforms, DepthLimitedBlurShaderDefines> {\n  defines: DepthLimitedBlurShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const DepthLimitedBlurShader: IDepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: new Vector2(512, 512) },\n    sampleUvOffsets: { value: [new Vector2(0, 0)] },\n    sampleWeights: { value: [1.0] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1000 },\n    depthCutoff: { value: 10 },\n  },\n  vertexShader: [\n    '#include <common>',\n\n    'uniform vec2 size;',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'void main() {',\n    '\tvUv = uv;',\n    '\tvInvSize = 1.0 / size;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '}',\n  ].join('\\n'),\n  fragmentShader: [\n    '#include <common>',\n    '#include <packing>',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tDepth;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform float depthCutoff;',\n\n    'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];',\n    'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n    '\t#if DEPTH_PACKING == 1',\n    '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n    '\t#else',\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n    '\t#endif',\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n    '\t#if PERSPECTIVE_CAMERA == 1',\n    '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#else',\n    '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#endif',\n    '}',\n\n    'void main() {',\n    '\tfloat depth = getDepth( vUv );',\n    '\tif( depth >= ( 1.0 - EPSILON ) ) {',\n    '\t\tdiscard;',\n    '\t}',\n\n    '\tfloat centerViewZ = -getViewZ( depth );',\n    '\tbool rBreak = false, lBreak = false;',\n\n    '\tfloat weightSum = sampleWeights[0];',\n    '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;',\n\n    '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {',\n\n    '\t\tfloat sampleWeight = sampleWeights[i];',\n    '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;',\n\n    '\t\tvec2 sampleUv = vUv + sampleUvOffset;',\n    '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;',\n\n    '\t\tif( ! rBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t\tsampleUv = vUv - sampleUvOffset;',\n    '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;',\n\n    '\t\tif( ! lBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t}',\n\n    '\tgl_FragColor = diffuseSum / weightSum;',\n    '}',\n  ].join('\\n'),\n}\n\nexport const BlurShaderUtils = {\n  createSampleWeights: (kernelRadius: number, stdDev: number): number[] => {\n    const gaussian = (x: number, stdDev: number): number => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev)\n    }\n\n    const weights: number[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev))\n    }\n\n    return weights\n  },\n\n  createSampleOffsets: (kernelRadius: number, uvIncrement: Vector2): Vector2[] => {\n    const offsets: Vector2[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i))\n    }\n\n    return offsets\n  },\n\n  configure: (shader: IDepthLimitedBlurShader, kernelRadius: number, stdDev: number, uvIncrement: Vector2): void => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement)\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev)\n    shader.needsUpdate = true\n  },\n}\n"]},"metadata":{},"sourceType":"module"}