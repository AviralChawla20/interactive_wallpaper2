{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, MeshPhysicalMaterial, Vector2, Matrix4, Vector3, Quaternion, InstancedMesh, InstancedBufferAttribute, Object3D, TextureLoader, ImageBitmapLoader, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, TriangleStripDrawMode, TriangleFanDrawMode, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateLinear, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, Box3, Sphere, Interpolant } from \"three\";\nimport { toTrianglesDrawMode } from \"../utils/BufferGeometryUtils.js\";\nimport { version } from \"../_polyfill/constants.js\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = LoaderUtils.extractUrlBase(url);\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function (e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        scope.parse(data, resourcePath, function (gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function (key) {\n      return objects[key];\n    },\n    add: function (key, object) {\n      objects[key] = object;\n    },\n    remove: function (key) {\n      delete objects[key];\n    },\n    removeAll: function () {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = {\n      refs: {},\n      uses: {}\n    };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency) return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\") return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0) return null;\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function (res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then(accessor => {\n        attributes[key] = accessor;\n        return attributes[key];\n      }));\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then(results => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new Matrix4();\n        const p = new Vector3();\n        const q = new Quaternion();\n        const s = new Vector3(1, 1, 1);\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 1313821514,\n  BIN: 5130562\n};\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== void 0) attribute.normalized = normalized;\n          }\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  }),\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0) hasMorphPosition = true;\n    if (target.NORMAL !== void 0) hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0) hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function (accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = new Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = {\n      refs: {},\n      uses: {}\n    };\n    this.cameraCache = {\n      refs: {},\n      uses: {}\n    };\n    this.lightCache = {\n      refs: {},\n      uses: {}\n    };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(this._invokeAll(function (ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function () {\n      return Promise.all([parser.getDependencies(\"scene\"), parser.getDependencies(\"animation\"), parser.getDependencies(\"camera\")]);\n    }).then(function (dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(parser._invokeAll(function (ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function () {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0) return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null) loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function (texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, {\n        textures: textureIndex\n      });\n      return texture;\n    }).catch(function () {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then(texture => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], {\n          type: sourceDef.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function (sourceURI2) {\n      return new Promise(function (resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function (imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function (texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function (error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function (texture) {\n      if (!texture) return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n      if (useVertexColors) cacheKey += \"vertex-colors:\";\n      if (useFlatShading) cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function (ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams);\n      if (materialDef.name) material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, {\n        materials: materialIndex\n      });\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = {\n          primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new Group();\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, {\n        meshes: meshIndex\n      });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0) continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0) continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0) return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function (camera) {\n        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n      }));\n    }\n    parser._invokeAll(function (ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function (promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = node => {\n        const reducedAssociations = /* @__PURE__ */new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse(node2 => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function (accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nexport { GLTFLoader };","map":{"version":3,"sources":["../../src/loaders/GLTFLoader.js"],"names":["self","res","sourceURI","node","accessor"],"mappings":"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","sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n"]},"metadata":{},"sourceType":"module"}