{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nconst cb = new Vector3();\nconst ab = new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nclass Vertex {\n  constructor(v, id) {\n    __publicField(this, \"position\");\n    __publicField(this, \"id\");\n    __publicField(this, \"faces\");\n    __publicField(this, \"neighbors\");\n    __publicField(this, \"collapseCost\");\n    __publicField(this, \"collapseNeighbor\");\n    __publicField(this, \"minCost\", 0);\n    __publicField(this, \"totalCost\", 0);\n    __publicField(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id;\n    this.faces = [];\n    this.neighbors = [];\n    this.collapseCost = 0;\n    this.collapseNeighbor = null;\n  }\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n    neighbors.splice(offset, 1);\n  }\n}\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    __publicField(this, \"a\");\n    __publicField(this, \"b\");\n    __publicField(this, \"c\");\n    __publicField(this, \"v1\");\n    __publicField(this, \"v2\");\n    __publicField(this, \"v3\");\n    __publicField(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n}\nclass SimplifyModifier {\n  constructor() {\n    __publicField(this, \"computeEdgeCollapseCost\", (u, v) => {\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n        il = u.faces.length,\n        face,\n        sideFace;\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      }\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j];\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      }\n      const borders = 0;\n      if (sideFaces.length < 2) {\n        curvature = 1;\n      }\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n    __publicField(this, \"computeEdgeCostAtVertex\", v => {\n      if (v.neighbors.length === 0) {\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 1e5;\n      v.collapseNeighbor = null;\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      }\n      v.collapseCost = v.totalCost / v.costCount;\n    });\n    __publicField(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f);\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    __publicField(this, \"collapse\", (vertices, faces, u, v) => {\n      if (!v) {\n        this.removeVertex(u, vertices);\n        return;\n      }\n      let i;\n      const tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      this.removeVertex(u, vertices);\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    __publicField(this, \"minimumCostEdge\", vertices => {\n      let least = vertices[0];\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    __publicField(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes;\n      for (let name in attributes) {\n        if (name !== \"position\") geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry);\n      const vertices = [];\n      const faces = [];\n      const positionAttribute = geometry.getAttribute(\"position\");\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      }\n      const geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      }\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n      let nextVertex;\n      let z = count;\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log(\"THREE.SimplifyModifier: No next vertex\");\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      }\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = [];\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      }\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      }\n      simplifiedGeometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n    removeFromArray(vertices, v);\n  }\n}\nexport { SimplifyModifier };","map":{"version":3,"sources":["../../src/modifiers/SimplifyModifier.ts"],"names":[],"mappings":"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","sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three'\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils'\n\nconst cb = new Vector3()\nconst ab = new Vector3()\n\nfunction pushIfUnique<TItem>(array: TItem[], object: TItem): void {\n  if (array.indexOf(object) === -1) array.push(object)\n}\n\nfunction removeFromArray<TItem>(array: TItem[], object: TItem): void {\n  const k = array.indexOf(object)\n  if (k > -1) array.splice(k, 1)\n}\n\nclass Vertex {\n  public position: Vector3\n  private id: number\n\n  public faces: Triangle[]\n  public neighbors: Vertex[]\n\n  public collapseCost: number\n  public collapseNeighbor: null | Vertex\n\n  public minCost: number = 0\n  public totalCost: number = 0\n  public costCount: number = 0\n\n  constructor(v: Vector3, id: number) {\n    this.position = v\n    this.id = id // old index id\n\n    this.faces = [] // faces vertex is connected\n    this.neighbors = [] // neighbouring vertices aka \"adjacentVertices\"\n\n    // these will be computed in computeEdgeCostAtVertex()\n    this.collapseCost = 0 // cost of collapsing this vertex, the less the better. aka objdist\n    this.collapseNeighbor = null // best candinate for collapsing\n  }\n\n  public addUniqueNeighbor(vertex: Vertex): void {\n    pushIfUnique(this.neighbors, vertex)\n  }\n\n  public removeIfNonNeighbor(n: Vertex): void {\n    const neighbors = this.neighbors\n    const faces = this.faces\n\n    const offset = neighbors.indexOf(n)\n    if (offset === -1) return\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return\n    }\n\n    neighbors.splice(offset, 1)\n  }\n}\n\n// we use a triangle class to represent structure of face slightly differently\nclass Triangle {\n  private a: number\n  private b: number\n  private c: Number\n\n  public v1: Vertex\n  public v2: Vertex\n  public v3: Vertex\n\n  public normal = new Vector3()\n\n  constructor(v1: Vertex, v2: Vertex, v3: Vertex, a: number, b: number, c: number) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.v1 = v1\n    this.v2 = v2\n    this.v3 = v3\n\n    this.computeNormal()\n\n    v1.faces.push(this)\n    v1.addUniqueNeighbor(v2)\n    v1.addUniqueNeighbor(v3)\n\n    v2.faces.push(this)\n    v2.addUniqueNeighbor(v1)\n    v2.addUniqueNeighbor(v3)\n\n    v3.faces.push(this)\n    v3.addUniqueNeighbor(v1)\n    v3.addUniqueNeighbor(v2)\n  }\n\n  private computeNormal(): void {\n    const vA = this.v1.position\n    const vB = this.v2.position\n    const vC = this.v3.position\n\n    cb.subVectors(vC, vB)\n    ab.subVectors(vA, vB)\n    cb.cross(ab).normalize()\n\n    this.normal.copy(cb)\n  }\n\n  public hasVertex(v: Vertex): boolean {\n    return v === this.v1 || v === this.v2 || v === this.v3\n  }\n\n  public replaceVertex(oldv: Vertex, newv: Vertex): void {\n    if (oldv === this.v1) this.v1 = newv\n    else if (oldv === this.v2) this.v2 = newv\n    else if (oldv === this.v3) this.v3 = newv\n\n    removeFromArray(oldv.faces, this)\n    newv.faces.push(this)\n\n    oldv.removeIfNonNeighbor(this.v1)\n    this.v1.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v2)\n    this.v2.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v3)\n    this.v3.removeIfNonNeighbor(oldv)\n\n    this.v1.addUniqueNeighbor(this.v2)\n    this.v1.addUniqueNeighbor(this.v3)\n\n    this.v2.addUniqueNeighbor(this.v1)\n    this.v2.addUniqueNeighbor(this.v3)\n\n    this.v3.addUniqueNeighbor(this.v1)\n    this.v3.addUniqueNeighbor(this.v2)\n\n    this.computeNormal()\n  }\n}\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nclass SimplifyModifier {\n  constructor() {}\n\n  private computeEdgeCollapseCost = (u: Vertex, v: Vertex): number => {\n    // if we collapse edge uv by moving u to v then how\n    // much different will the model change, i.e. the \"error\".\n\n    const edgelength = v.position.distanceTo(u.position)\n    let curvature = 0\n\n    const sideFaces = []\n    let i,\n      il = u.faces.length,\n      face,\n      sideFace\n\n    // find the \"sides\" triangles that are on the edge uv\n    for (i = 0; i < il; i++) {\n      face = u.faces[i]\n\n      if (face.hasVertex(v)) {\n        sideFaces.push(face)\n      }\n    }\n\n    // use the triangle facing most away from the sides\n    // to determine our curvature term\n    for (i = 0; i < il; i++) {\n      let minCurvature = 1\n      face = u.faces[i]\n\n      for (let j = 0; j < sideFaces.length; j++) {\n        sideFace = sideFaces[j]\n        // use dot product of face normals.\n        const dotProd = face.normal.dot(sideFace.normal)\n        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2)\n      }\n\n      curvature = Math.max(curvature, minCurvature)\n    }\n\n    // crude approach in attempt to preserve borders\n    // though it seems not to be totally correct\n    const borders = 0\n    if (sideFaces.length < 2) {\n      // we add some arbitrary cost for borders,\n      // borders += 10;\n      curvature = 1\n    }\n\n    const amt = edgelength * curvature + borders\n\n    return amt\n  }\n\n  private removeVertex(v: Vertex, vertices: Vertex[]): void {\n    console.assert(v.faces.length === 0)\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop() as Vertex\n      removeFromArray(n.neighbors, v)\n    }\n\n    removeFromArray(vertices, v)\n  }\n\n  private computeEdgeCostAtVertex = (v: Vertex): void => {\n    // compute the edge collapse cost for all edges that start\n    // from vertex v.  Since we are only interested in reducing\n    // the object by selecting the min cost edge at each step, we\n    // only cache the cost of the least cost edge at this vertex\n    // (in member variable collapse) as well as the value of the\n    // cost (in member variable collapseCost).\n\n    if (v.neighbors.length === 0) {\n      // collapse if no neighbors.\n      v.collapseNeighbor = null\n      v.collapseCost = -0.01\n\n      return\n    }\n\n    v.collapseCost = 100000\n    v.collapseNeighbor = null\n\n    // search all neighboring edges for \"least cost\" edge\n    for (let i = 0; i < v.neighbors.length; i++) {\n      const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i])\n\n      if (!v.collapseNeighbor) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.collapseCost = collapseCost\n        v.minCost = collapseCost\n        v.totalCost = 0\n        v.costCount = 0\n      }\n\n      v.costCount++\n      v.totalCost += collapseCost\n\n      if (collapseCost < v.minCost) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.minCost = collapseCost\n      }\n    }\n\n    // we average the cost of collapsing at this vertex\n    v.collapseCost = v.totalCost / v.costCount\n    // v.collapseCost = v.minCost;\n  }\n\n  private removeFace = (f: Triangle, faces: Triangle[]): void => {\n    removeFromArray(faces, f)\n\n    if (f.v1) removeFromArray(f.v1.faces, f)\n    if (f.v2) removeFromArray(f.v2.faces, f)\n    if (f.v3) removeFromArray(f.v3.faces, f)\n\n    // TODO optimize this!\n    const vs = [f.v1, f.v2, f.v3]\n    let v1, v2\n\n    for (let i = 0; i < 3; i++) {\n      v1 = vs[i]\n      v2 = vs[(i + 1) % 3]\n\n      if (!v1 || !v2) continue\n\n      v1.removeIfNonNeighbor(v2)\n      v2.removeIfNonNeighbor(v1)\n    }\n  }\n\n  private collapse = (vertices: Vertex[], faces: Triangle[], u: Vertex, v: Vertex): void => {\n    // u and v are pointers to vertices of an edge\n\n    // Collapse the edge uv by moving vertex u onto v\n\n    if (!v) {\n      // u is a vertex all by itself so just delete it..\n      this.removeVertex(u, vertices)\n      return\n    }\n\n    let i\n    const tmpVertices = []\n\n    for (i = 0; i < u.neighbors.length; i++) {\n      tmpVertices.push(u.neighbors[i])\n    }\n\n    // delete triangles on edge uv:\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      if (u.faces[i].hasVertex(v)) {\n        this.removeFace(u.faces[i], faces)\n      }\n    }\n\n    // update remaining triangles to have v instead of u\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      u.faces[i].replaceVertex(u, v)\n    }\n\n    this.removeVertex(u, vertices)\n\n    // recompute the edge collapse costs in neighborhood\n    for (i = 0; i < tmpVertices.length; i++) {\n      this.computeEdgeCostAtVertex(tmpVertices[i])\n    }\n  }\n\n  private minimumCostEdge = (vertices: Vertex[]): Vertex => {\n    // O(n * n) approach. TODO optimize this\n\n    let least = vertices[0]\n\n    for (let i = 0; i < vertices.length; i++) {\n      if (vertices[i].collapseCost < least.collapseCost) {\n        least = vertices[i]\n      }\n    }\n\n    return least\n  }\n\n  public modify = (geometry: BufferGeometry, count: number): BufferGeometry => {\n    geometry = geometry.clone()\n    const attributes = geometry.attributes\n\n    // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n    for (let name in attributes) {\n      if (name !== 'position') geometry.deleteAttribute(name)\n    }\n\n    geometry = BufferGeometryUtils.mergeVertices(geometry)\n\n    //\n    // put data of original geometry in different data structures\n    //\n\n    const vertices = []\n    const faces = []\n\n    // add vertices\n\n    const positionAttribute = geometry.getAttribute('position')\n\n    for (let i = 0; i < positionAttribute.count; i++) {\n      const v = new Vector3().fromBufferAttribute(positionAttribute, i)\n\n      const vertex = new Vertex(v, i)\n      vertices.push(vertex)\n    }\n\n    // add faces\n\n    const geomIndex = geometry.getIndex()\n\n    if (geomIndex !== null) {\n      for (let i = 0; i < geomIndex.count; i += 3) {\n        const a = geomIndex.getX(i)\n        const b = geomIndex.getX(i + 1)\n        const c = geomIndex.getX(i + 2)\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    } else {\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        const a = i\n        const b = i + 1\n        const c = i + 2\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    }\n\n    // compute all edge collapse costs\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.computeEdgeCostAtVertex(vertices[i])\n    }\n\n    let nextVertex\n\n    let z = count\n\n    while (z--) {\n      nextVertex = this.minimumCostEdge(vertices)\n\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex')\n        break\n      } else {\n        this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor as Vertex)\n      }\n    }\n\n    //\n\n    const simplifiedGeometry = new BufferGeometry()\n    const position = []\n    let index = []\n\n    //\n\n    for (let i = 0; i < vertices.length; i++) {\n      const vertex = vertices[i].position\n      position.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    //\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      const a = vertices.indexOf(face.v1)\n      const b = vertices.indexOf(face.v2)\n      const c = vertices.indexOf(face.v3)\n\n      index.push(a, b, c)\n    }\n\n    //\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    simplifiedGeometry.setIndex(index)\n\n    return simplifiedGeometry\n  }\n}\n\nexport { SimplifyModifier }\n"]},"metadata":{},"sourceType":"module"}