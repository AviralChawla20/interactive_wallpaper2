{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane, HalfFloatType } from \"three\";\nconst _ReflectorForSSRPass = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflectorForSSRPass = true;\n    this.type = \"ReflectorForSSRPass\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3();\n    scope.needsUpdate = false;\n    scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, \"distanceAttenuation\", {\n      get() {\n        return scope._distanceAttenuation;\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, \"fresnel\", {\n      get() {\n        return scope._fresnel;\n      },\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = scope.color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n    }\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"opacity\"].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms[\"virtualCameraNear\"].value = camera.near;\n      material.uniforms[\"virtualCameraFar\"].value = camera.far;\n      material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n      material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n      material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n      material.uniforms[\"resolution\"].value = scope.resolution;\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n};\nlet ReflectorForSSRPass = _ReflectorForSSRPass;\n__publicField(ReflectorForSSRPass, \"ReflectorShader\", {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n  fragmentShader: (/* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`)\n});\nexport { ReflectorForSSRPass };","map":{"version":3,"sources":["../../src/objects/ReflectorForSSRPass.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n  DepthTexture,\n  UnsignedShortType,\n  NearestFilter,\n  Plane,\n  HalfFloatType,\n} from 'three'\n\nclass ReflectorForSSRPass extends Mesh {\n  static ReflectorShader = {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true,\n    },\n\n    uniforms: {\n      color: { value: null },\n      tDiffuse: { value: null },\n      tDepth: { value: null },\n      textureMatrix: { value: new Matrix4() },\n      maxDistance: { value: 180 },\n      opacity: { value: 0.5 },\n      fresnelCoe: { value: null },\n      virtualCameraNear: { value: null },\n      virtualCameraFar: { value: null },\n      virtualCameraProjectionMatrix: { value: new Matrix4() },\n      virtualCameraMatrixWorld: { value: new Matrix4() },\n      virtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n      resolution: { value: new Vector2() },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isReflectorForSSRPass = true\n\n    this.type = 'ReflectorForSSRPass'\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader\n    const useDepthTexture = options.useDepthTexture === true\n    const yAxis = new Vector3(0, 1, 0)\n    const vecTemp0 = new Vector3()\n    const vecTemp1 = new Vector3()\n\n    //\n\n    scope.needsUpdate = false\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value\n    scope.color = color\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight)\n\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return\n        scope._distanceAttenuation = val\n        scope.material.defines.DISTANCE_ATTENUATION = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel\n      },\n      set(val) {\n        if (scope._fresnel === val) return\n        scope._fresnel = val\n        scope.material.defines.FRESNEL = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    const normal = new Vector3()\n    const reflectorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n\n    const view = new Vector3()\n    const target = new Vector3()\n\n    const textureMatrix = new Matrix4()\n    const virtualCamera = new PerspectiveCamera()\n\n    let depthTexture\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture()\n      depthTexture.type = UnsignedShortType\n      depthTexture.minFilter = NearestFilter\n      depthTexture.magFilter = NearestFilter\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType,\n    }\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters)\n\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture,\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader,\n    })\n\n    material.uniforms['tDiffuse'].value = renderTarget.texture\n    material.uniforms['color'].value = scope.color\n    material.uniforms['textureMatrix'].value = textureMatrix\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture\n    }\n\n    this.material = material\n\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias)\n    const globalPlanes = [globalPlane]\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance\n      material.uniforms['color'].value = scope.color\n      material.uniforms['opacity'].value = scope.opacity\n\n      vecTemp0.copy(camera.position).normalize()\n      vecTemp1.copy(vecTemp0).reflect(yAxis)\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2 // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(reflectorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(reflectorWorldPosition)\n\n      virtualCamera.position.copy(view)\n      virtualCamera.up.set(0, 1, 0)\n      virtualCamera.up.applyMatrix4(rotationMatrix)\n      virtualCamera.up.reflect(normal)\n      virtualCamera.lookAt(target)\n\n      virtualCamera.far = camera.far // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld()\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      material.uniforms['virtualCameraNear'].value = camera.near\n      material.uniforms['virtualCameraFar'].value = camera.far\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse\n      material.uniforms['resolution'].value = scope.resolution\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(virtualCamera.projectionMatrix)\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n\n      // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentClippingPlanes = renderer.clippingPlanes\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      renderer.clippingPlanes = globalPlanes\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.clippingPlanes = currentClippingPlanes\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      // scope.visible = true;\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n  }\n}\n\nexport { ReflectorForSSRPass }\n"]},"metadata":{},"sourceType":"module"}