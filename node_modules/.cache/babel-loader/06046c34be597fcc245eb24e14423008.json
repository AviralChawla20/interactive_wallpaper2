{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nclass EdgeSplitModifier {\n  constructor() {\n    __publicField(this, \"A\", new Vector3());\n    __publicField(this, \"B\", new Vector3());\n    __publicField(this, \"C\", new Vector3());\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"normals\", new Float32Array());\n    __publicField(this, \"indexes\", []);\n    __publicField(this, \"pointToIndexMap\", []);\n    __publicField(this, \"splitIndexes\", []);\n    __publicField(this, \"oldNormals\", []);\n    __publicField(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n    __publicField(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n    __publicField(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"edgeSplit\", (indexes, cutOff, original = null) => {\n      if (indexes.length === 0) return;\n      const groupResults = [];\n      for (let index of indexes) {\n        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n    __publicField(this, \"modify\", (geometry, cutOffAngle, tryKeepNormals = true) => {\n      let hadNormals = false;\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n        if (tryKeepNormals === true && geometry.index !== null) {\n          this.oldNormals = geometry.attributes.normal.array;\n        }\n        geometry.deleteAttribute(\"normal\");\n      }\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === void 0) {\n          throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n        }\n        geometry = mergeVertices(geometry);\n      }\n      this.indexes = geometry.index.array;\n      this.positions = geometry.getAttribute(\"position\").array;\n      this.computeNormals();\n      this.mapPositionsToIndexes();\n      this.splitIndexes = [];\n      for (let vertexIndexes of this.pointToIndexMap) {\n        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n      const newAttributes = {};\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name];\n        const newArray = new oldAttribute.array.constructor((this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize);\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n      const newIndexes = new Uint32Array(this.indexes.length);\n      newIndexes.set(this.indexes);\n      for (let i = 0; i < this.splitIndexes.length; i++) {\n        const split = this.splitIndexes[i];\n        const index = this.indexes[split.original];\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n        for (let j of split.indexes) {\n          newIndexes[j] = this.indexes.length + i;\n        }\n      }\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n        if (this.oldNormals !== null) {\n          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);\n          for (let splitData of this.splitIndexes) changedNormals[splitData.original] = true;\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n      return geometry;\n    });\n  }\n}\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["../../src/modifiers/EdgeSplitModifier.ts"],"names":[],"mappings":"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","sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3 } from 'three'\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils'\n\ninterface EdgeSplitToGroupsResult {\n  splitGroup: number[]\n  currentGroup: number[]\n}\n\ninterface SplitIndexes {\n  original: number\n  indexes: number[]\n}\n\nclass EdgeSplitModifier {\n  private A = new Vector3()\n  private B = new Vector3()\n  private C = new Vector3()\n\n  private positions: ArrayLike<number> = []\n  private normals: Float32Array = new Float32Array()\n  private indexes: ArrayLike<number> = []\n  private pointToIndexMap: number[][] = []\n  private splitIndexes: SplitIndexes[] = []\n  private oldNormals: ArrayLike<number> = []\n\n  constructor() {}\n\n  private computeNormals = (): void => {\n    this.normals = new Float32Array(this.indexes.length * 3)\n\n    for (let i = 0; i < this.indexes.length; i += 3) {\n      let index = this.indexes[i]\n\n      this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      index = this.indexes[i + 1]\n      this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      index = this.indexes[i + 2]\n      this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      this.C.sub(this.B)\n      this.A.sub(this.B)\n\n      const normal = this.C.cross(this.A).normalize()\n\n      for (let j = 0; j < 3; j++) {\n        this.normals[3 * (i + j)] = normal.x\n        this.normals[3 * (i + j) + 1] = normal.y\n        this.normals[3 * (i + j) + 2] = normal.z\n      }\n    }\n  }\n\n  private mapPositionsToIndexes = (): void => {\n    this.pointToIndexMap = Array(this.positions.length / 3)\n\n    for (let i = 0; i < this.indexes.length; i++) {\n      const index = this.indexes[i]\n\n      if (this.pointToIndexMap[index] == null) {\n        this.pointToIndexMap[index] = []\n      }\n\n      this.pointToIndexMap[index].push(i)\n    }\n  }\n\n  private edgeSplitToGroups = (indexes: number[], cutOff: number, firstIndex: number): EdgeSplitToGroupsResult => {\n    this.A.set(\n      this.normals[3 * firstIndex],\n      this.normals[3 * firstIndex + 1],\n      this.normals[3 * firstIndex + 2],\n    ).normalize()\n\n    const result: EdgeSplitToGroupsResult = {\n      splitGroup: [],\n      currentGroup: [firstIndex],\n    }\n\n    for (let j of indexes) {\n      if (j !== firstIndex) {\n        this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize()\n\n        if (this.B.dot(this.A) < cutOff) {\n          result.splitGroup.push(j)\n        } else {\n          result.currentGroup.push(j)\n        }\n      }\n    }\n\n    return result\n  }\n\n  private edgeSplit = (indexes: number[], cutOff: number, original: number | null = null): void => {\n    if (indexes.length === 0) return\n\n    const groupResults: EdgeSplitToGroupsResult[] = []\n\n    for (let index of indexes) {\n      groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index))\n    }\n\n    let result = groupResults[0]\n\n    for (let groupResult of groupResults) {\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult\n      }\n    }\n\n    if (original != null) {\n      this.splitIndexes.push({\n        original,\n        indexes: result.currentGroup,\n      })\n    }\n\n    if (result.splitGroup.length) {\n      this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0])\n    }\n  }\n\n  public modify = (geometry: BufferGeometry, cutOffAngle: number, tryKeepNormals = true): BufferGeometry => {\n    let hadNormals = false\n\n    if (geometry.attributes.normal) {\n      hadNormals = true\n\n      geometry = geometry.clone()\n\n      if (tryKeepNormals === true && geometry.index !== null) {\n        this.oldNormals = geometry.attributes.normal.array\n      }\n\n      geometry.deleteAttribute('normal')\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils'\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry)\n    }\n\n    this.indexes = (geometry.index as BufferAttribute).array\n    this.positions = geometry.getAttribute('position').array\n\n    this.computeNormals()\n    this.mapPositionsToIndexes()\n\n    this.splitIndexes = []\n\n    for (let vertexIndexes of this.pointToIndexMap) {\n      this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001)\n    }\n\n    const newAttributes: {\n      [key: string]: BufferAttribute\n    } = {}\n    for (let name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name]\n      // @ts-ignore\n      const newArray = new oldAttribute.array.constructor(\n        (this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize,\n      )\n\n      newArray.set(oldAttribute.array)\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized)\n    }\n\n    const newIndexes = new Uint32Array(this.indexes.length)\n    newIndexes.set(this.indexes)\n\n    for (let i = 0; i < this.splitIndexes.length; i++) {\n      const split = this.splitIndexes[i]\n      const index = this.indexes[split.original]\n\n      for (let attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          // @ts-ignore ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n          attribute.array[(this.indexes.length + i) * attribute.itemSize + j] =\n            attribute.array[index * attribute.itemSize + j]\n        }\n      }\n\n      for (let j of split.indexes) {\n        newIndexes[j] = this.indexes.length + i\n      }\n    }\n\n    geometry = new BufferGeometry()\n    geometry.setIndex(new BufferAttribute(newIndexes, 1))\n\n    for (let name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name])\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals()\n\n      if (this.oldNormals !== null) {\n        const changedNormals = new Array(this.oldNormals.length / 3).fill(false)\n\n        for (let splitData of this.splitIndexes) changedNormals[splitData.original] = true\n\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) {\n              // @ts-ignore ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n              geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j]\n            }\n          }\n        }\n      }\n    }\n\n    return geometry\n  }\n}\n\nexport { EdgeSplitModifier }\n"]},"metadata":{},"sourceType":"module"}