{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst MotionControllerConstants = {\n  Handedness: {\n    NONE: \"none\",\n    LEFT: \"left\",\n    RIGHT: \"right\"\n  },\n  ComponentState: {\n    DEFAULT: \"default\",\n    TOUCHED: \"touched\",\n    PRESSED: \"pressed\"\n  },\n  ComponentProperty: {\n    BUTTON: \"button\",\n    X_AXIS: \"xAxis\",\n    Y_AXIS: \"yAxis\",\n    STATE: \"state\"\n  },\n  ComponentType: {\n    TRIGGER: \"trigger\",\n    SQUEEZE: \"squeeze\",\n    TOUCHPAD: \"touchpad\",\n    THUMBSTICK: \"thumbstick\",\n    BUTTON: \"button\"\n  },\n  ButtonTouchThreshold: 0.05,\n  AxisTouchThreshold: 0.1,\n  VisualResponseProperty: {\n    TRANSFORM: \"transform\",\n    VISIBILITY: \"visibility\"\n  }\n};\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error(\"No basePath supplied\");\n  }\n  const profileListFileName = \"profilesList.json\";\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error(\"No xrInputSource supplied\");\n  }\n  if (!basePath) {\n    throw new Error(\"No basePath supplied\");\n  }\n  const supportedProfilesList = await fetchProfilesList(basePath);\n  let match = void 0;\n  xrInputSource.profiles.some(profileId => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error(\"No matching profile name found\");\n    }\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n  const profile = await fetchJsonFile(match.profilePath);\n  let assetPath = void 0;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === \"any\") {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);\n    }\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace(\"profile.json\", layout.assetPath);\n    }\n  }\n  return {\n    profile,\n    assetPath\n  };\n}\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT\n};\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n  const hypotenuse = Math.sqrt(x * x + y * y);\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5\n  };\n  return result;\n}\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    __publicField(this, \"value\");\n    __publicField(this, \"componentProperty\");\n    __publicField(this, \"states\");\n    __publicField(this, \"valueNodeName\");\n    __publicField(this, \"valueNodeProperty\");\n    __publicField(this, \"minNodeName\");\n    __publicField(this, \"maxNodeName\");\n    __publicField(this, \"valueNode\");\n    __publicField(this, \"minNode\");\n    __publicField(this, \"maxNode\");\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number | undefined} xAxis - The reported X axis value of the component\n   * @param {number | undefined} yAxis - The reported Y axis value of the component\n   * @param {number | undefined} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis,\n    yAxis,\n    button,\n    state\n  }) {\n    const {\n      normalizedXAxis,\n      normalizedYAxis\n    } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\n        break;\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\n        break;\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) && button ? button : 0;\n        break;\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state);\n        } else {\n          this.value = this.states.includes(state) ? 1 : 0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\nclass Component {\n  /**\n   * @param {string} componentId - Id of the component\n   * @param {InputProfileComponent} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    __publicField(this, \"id\");\n    __publicField(this, \"values\");\n    __publicField(this, \"type\");\n    __publicField(this, \"gamepadIndices\");\n    __publicField(this, \"rootNodeName\");\n    __publicField(this, \"visualResponses\");\n    __publicField(this, \"touchPointNodeName\");\n    __publicField(this, \"touchPointNode\");\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error(\"Invalid arguments supplied\");\n    }\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach(responseName => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,\n      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,\n      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0\n    };\n  }\n  get data() {\n    const data = {\n      id: this.id,\n      ...this.values\n    };\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT;\n    if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = this.values.button < 0 ? 0 : this.values.button;\n      this.values.button = this.values.button > 1 ? 1 : this.values.button;\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    }\n    if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\n      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    }\n    if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\n      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    }\n    Object.values(this.visualResponses).forEach(visualResponse => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\nclass MotionController {\n  /**\n   * @param {XRInputSource} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Profile} profile - The best matched profile description for the supplied xrInputSource\n   * @param {string} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    __publicField(this, \"xrInputSource\");\n    __publicField(this, \"assetUrl\");\n    __publicField(this, \"layoutDescription\");\n    __publicField(this, \"id\");\n    __publicField(this, \"components\");\n    if (!xrInputSource) {\n      throw new Error(\"No xrInputSource supplied\");\n    }\n    if (!profile) {\n      throw new Error(\"No profile supplied\");\n    }\n    if (!profile.layouts[xrInputSource.handedness]) {\n      throw new Error(\"No layout for \" + xrInputSource.handedness + \" handedness\");\n    }\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach(componentId => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n    this.updateFromGamepad();\n  }\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach(component => {\n      data.push(component.data);\n    });\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach(component => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\nexport { MotionController, MotionControllerConstants, fetchProfile, fetchProfilesList };","map":{"version":3,"sources":["../../src/libs/MotionControllers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nimport type { Object3D } from 'three'\n\ninterface GamepadIndices {\n  button: number\n  xAxis?: number\n  yAxis?: number\n}\n\ninterface VisualResponseDescription {\n  componentProperty: string\n  states: string[]\n  valueNodeProperty: string\n  valueNodeName: string\n  minNodeName?: string\n  maxNodeName?: string\n}\n\ntype VisualResponses = Record<string, VisualResponseDescription>\n\ninterface ComponentDescription {\n  type: string\n  gamepadIndices: GamepadIndices\n  rootNodeName: string\n  visualResponses: VisualResponses\n  touchPointNodeName?: string\n}\n\ninterface Components {\n  [componentKey: string]: ComponentDescription\n}\n\ninterface LayoutDescription {\n  selectComponentId: string\n  components: Components\n  gamepadMapping: string\n  rootNodeName: string\n  assetPath: string\n}\n\ntype Layouts = Partial<Record<XRHandedness, LayoutDescription>>\n\nexport interface Profile {\n  profileId: string\n  fallbackProfileIds: string[]\n  layouts: Layouts\n}\n\ninterface ProfilesList {\n  [profileId: string]: { path: string; deprecated?: boolean } | undefined\n}\n\nconst MotionControllerConstants = {\n  Handedness: {\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right',\n  },\n\n  ComponentState: {\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed',\n  },\n\n  ComponentProperty: {\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state',\n  },\n\n  ComponentType: {\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button',\n  },\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: {\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility',\n  },\n}\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile<T>(path: string): Promise<T> {\n  const response = await fetch(path)\n  if (!response.ok) {\n    throw new Error(response.statusText)\n  } else {\n    return response.json()\n  }\n}\n\nasync function fetchProfilesList(basePath: string): Promise<ProfilesList> {\n  if (!basePath) {\n    throw new Error('No basePath supplied')\n  }\n\n  const profileListFileName = 'profilesList.json'\n  const profilesList = await fetchJsonFile<ProfilesList>(`${basePath}/${profileListFileName}`)\n  return profilesList\n}\n\nasync function fetchProfile(\n  xrInputSource: XRInputSource,\n  basePath: string,\n  defaultProfile: string | null = null,\n  getAssetPath = true,\n): Promise<{ profile: Profile; assetPath: string | undefined }> {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied')\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied')\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath)\n\n  // Find the relative path to the first requested profile that is recognized\n  let match: { profileId: string; profilePath: string; deprecated: boolean } | undefined = undefined\n  xrInputSource.profiles.some((profileId: string) => {\n    const supportedProfile = supportedProfilesList[profileId]\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated,\n      }\n    }\n    return !!match\n  })\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found')\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile]\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`)\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated,\n    }\n  }\n\n  const profile = await fetchJsonFile<Profile>(match.profilePath)\n\n  let assetPath: string | undefined = undefined\n  if (getAssetPath) {\n    let layout\n    if ((xrInputSource.handedness as string) === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0] as XRHandedness]\n    } else {\n      layout = profile.layouts[xrInputSource.handedness]\n    }\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`)\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath)\n    }\n  }\n\n  return { profile, assetPath }\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT,\n}\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number | undefined} x The original x coordinate in the range -1 to 1\n * @param {number | undefined} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(\n  x: number | undefined = 0,\n  y: number | undefined = 0,\n): { normalizedXAxis: number; normalizedYAxis: number } {\n  let xAxis = x\n  let yAxis = y\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt(x * x + y * y)\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x)\n    xAxis = Math.cos(theta)\n    yAxis = Math.sin(theta)\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5,\n  }\n  return result\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse implements VisualResponseDescription {\n  value: number | boolean\n  componentProperty: string\n  states: string[]\n  valueNodeName: string\n  valueNodeProperty: string\n  minNodeName?: string\n  maxNodeName?: string\n  valueNode: Object3D | undefined\n  minNode: Object3D | undefined\n  maxNode: Object3D | undefined\n  constructor(visualResponseDescription: VisualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty\n    this.states = visualResponseDescription.states\n    this.valueNodeName = visualResponseDescription.valueNodeName\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty\n\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName\n      this.maxNodeName = visualResponseDescription.maxNodeName\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0\n    this.updateFromComponent(defaultComponentValues)\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number | undefined} xAxis - The reported X axis value of the component\n   * @param {number | undefined} yAxis - The reported Y axis value of the component\n   * @param {number | undefined} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis,\n    yAxis,\n    button,\n    state,\n  }: {\n    xAxis?: number\n    yAxis?: number\n    button?: number\n    state: string\n  }): void {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis)\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5\n        break\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5\n        break\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) && button ? button : 0\n        break\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state)\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0\n        }\n        break\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)\n    }\n  }\n}\n\nclass Component implements ComponentDescription {\n  id: string\n  values: {\n    state: string\n    button: number | undefined\n    xAxis: number | undefined\n    yAxis: number | undefined\n  }\n\n  type: string\n  gamepadIndices: GamepadIndices\n  rootNodeName: string\n  visualResponses: Record<string, VisualResponse>\n  touchPointNodeName?: string | undefined\n  touchPointNode?: Object3D\n\n  /**\n   * @param {string} componentId - Id of the component\n   * @param {InputProfileComponent} componentDescription - Description of the component to be created\n   */\n  constructor(componentId: string, componentDescription: ComponentDescription) {\n    if (\n      !componentId ||\n      !componentDescription ||\n      !componentDescription.visualResponses ||\n      !componentDescription.gamepadIndices ||\n      Object.keys(componentDescription.gamepadIndices).length === 0\n    ) {\n      throw new Error('Invalid arguments supplied')\n    }\n\n    this.id = componentId\n    this.type = componentDescription.type\n    this.rootNodeName = componentDescription.rootNodeName\n    this.touchPointNodeName = componentDescription.touchPointNodeName\n\n    // Build all the visual responses for this component\n    this.visualResponses = {}\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName])\n      this.visualResponses[responseName] = visualResponse\n    })\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices)\n\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined,\n    }\n  }\n\n  get data(): { id: Component['id'] } & Component['values'] {\n    const data = { id: this.id, ...this.values }\n    return data\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad: Gamepad): void {\n    // Set the state to default before processing other data sources\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button]\n      this.values.button = gamepadButton.value\n      this.values.button = this.values.button! < 0 ? 0 : this.values.button\n      this.values.button = this.values.button! > 1 ? 1 : this.values.button\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED\n      } else if (gamepadButton.touched || this.values.button! > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis]\n      this.values.xAxis = this.values.xAxis! < -1 ? -1 : this.values.xAxis\n      this.values.xAxis = this.values.xAxis! > 1 ? 1 : this.values.xAxis\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (\n        this.values.state === MotionControllerConstants.ComponentState.DEFAULT &&\n        Math.abs(this.values.xAxis!) > MotionControllerConstants.AxisTouchThreshold\n      ) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis]\n      this.values.yAxis = this.values.yAxis! < -1 ? -1 : this.values.yAxis\n      this.values.yAxis = this.values.yAxis! > 1 ? 1 : this.values.yAxis\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (\n        this.values.state === MotionControllerConstants.ComponentState.DEFAULT &&\n        Math.abs(this.values.yAxis!) > MotionControllerConstants.AxisTouchThreshold\n      ) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values)\n    })\n  }\n}\n/**\n * @description Builds a motion controller with components and visual responses based on the\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\n * @author Nell Waliczek / https://github.com/NellWaliczek\n */\nclass MotionController {\n  xrInputSource: XRInputSource\n  assetUrl: string\n  layoutDescription: LayoutDescription\n  id: string\n  components: Record<string, Component>\n  /**\n   * @param {XRInputSource} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Profile} profile - The best matched profile description for the supplied xrInputSource\n   * @param {string} assetUrl\n   */\n  constructor(xrInputSource: XRInputSource, profile: Profile, assetUrl: string) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied')\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied')\n    }\n\n    if (!profile.layouts[xrInputSource.handedness]) {\n      throw new Error('No layout for ' + xrInputSource.handedness + ' handedness')\n    }\n\n    this.xrInputSource = xrInputSource\n    this.assetUrl = assetUrl\n    this.id = profile.profileId\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness]!\n\n    this.components = {}\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId]\n      this.components[componentId] = new Component(componentId, componentDescription)\n    })\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad()\n  }\n\n  get gripSpace(): XRInputSource['gripSpace'] {\n    return this.xrInputSource.gripSpace\n  }\n\n  get targetRaySpace(): XRInputSource['targetRaySpace'] {\n    return this.xrInputSource.targetRaySpace\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data(): Array<Component['data']> {\n    const data: Array<Component['data']> = []\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data)\n    })\n    return data\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad(): void {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad!)\n    })\n  }\n}\n\nexport { MotionControllerConstants, MotionController, fetchProfile, fetchProfilesList }\n"]},"metadata":{},"sourceType":"module"}