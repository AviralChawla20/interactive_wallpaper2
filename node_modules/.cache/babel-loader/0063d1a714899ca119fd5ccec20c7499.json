{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3 } from \"three\";\nconst isMesh = object => object.isMesh;\nclass STLExporter {\n  constructor() {\n    __publicField(this, \"binary\", false);\n    __publicField(this, \"output\", \"\");\n    __publicField(this, \"offset\", 80);\n    // skip header\n    __publicField(this, \"objects\", []);\n    __publicField(this, \"triangles\", 0);\n    __publicField(this, \"vA\", new Vector3());\n    __publicField(this, \"vB\", new Vector3());\n    __publicField(this, \"vC\", new Vector3());\n    __publicField(this, \"cb\", new Vector3());\n    __publicField(this, \"ab\", new Vector3());\n    __publicField(this, \"normal\", new Vector3());\n  }\n  parse(scene, options) {\n    this.binary = (options == null ? void 0 : options.binary) !== void 0 ? options == null ? void 0 : options.binary : false;\n    scene.traverse(object => {\n      if (isMesh(object)) {\n        const geometry = object.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute(\"position\") || null;\n        if (!positionAttribute) return;\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        this.objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      this.output = new DataView(arrayBuffer);\n      this.output.setUint32(this.offset, this.triangles, true);\n      this.offset += 4;\n    } else {\n      this.output = \"\";\n      this.output += \"solid exported\\n\";\n    }\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d;\n      const geometry = this.objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (index !== null) {\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0);\n          const b = index.getX(j + 1);\n          const c = index.getX(j + 2);\n          this.writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0;\n          const b = j + 1;\n          const c = j + 2;\n          this.writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (!this.binary) {\n      this.output += \"endsolid exported\\n\";\n    }\n    return this.output;\n  }\n  writeFace(a, b, c, positionAttribute, object) {\n    this.vA.fromBufferAttribute(positionAttribute, a);\n    this.vB.fromBufferAttribute(positionAttribute, b);\n    this.vC.fromBufferAttribute(positionAttribute, c);\n    if (object.isSkinnedMesh) {\n      const mesh = object;\n      if (\"applyBoneTransform\" in mesh) {\n        mesh.applyBoneTransform(a, this.vA);\n        mesh.applyBoneTransform(b, this.vB);\n        mesh.applyBoneTransform(c, this.vC);\n      } else {\n        mesh.boneTransform(a, this.vA);\n        mesh.boneTransform(b, this.vB);\n        mesh.boneTransform(c, this.vC);\n      }\n    }\n    this.vA.applyMatrix4(object.matrixWorld);\n    this.vB.applyMatrix4(object.matrixWorld);\n    this.vC.applyMatrix4(object.matrixWorld);\n    this.writeNormal(this.vA, this.vB, this.vC);\n    this.writeVertex(this.vA);\n    this.writeVertex(this.vB);\n    this.writeVertex(this.vC);\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true);\n      this.offset += 2;\n    } else {\n      this.output += \"\t\tendloop\\n\";\n      this.output += \"\tendfacet\\n\";\n    }\n  }\n  writeNormal(vA, vB, vC) {\n    this.cb.subVectors(vC, vB);\n    this.ab.subVectors(vA, vB);\n    this.cb.cross(this.ab).normalize();\n    this.normal.copy(this.cb).normalize();\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, this.normal.y, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, this.normal.z, true);\n      this.offset += 4;\n    } else {\n      this.output += `\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`;\n      this.output += \"\t\touter loop\\n\";\n    }\n  }\n  writeVertex(vertex) {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, vertex.y, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, vertex.z, true);\n      this.offset += 4;\n    } else {\n      this.output += `\t\t\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\n`;\n    }\n  }\n}\nexport { STLExporter };","map":{"version":3,"sources":["../../src/exporters/STLExporter.ts"],"names":[],"mappings":";;;;;;;;;;;;AAsBA,MAAM,MAAA,GAAU,MAAA,IAAqC,MAAA,CAAe,MAAA;AAE7D,MAAM,WAAA,CAAY;EAAlB,WAAA,CAAA,EAAA;IACG,aAAA,CAAA,IAAA,EAAA,QAAA,EAAS,KAAA,CAAA;IAET,aAAA,CAAA,IAAA,EAAA,QAAA,EAA4B,EAAA,CAAA;IAC5B,aAAA,CAAA,IAAA,EAAA,QAAA,EAAiB,EAAA,CAAA;IAEjB;IAAA,aAAA,CAAA,IAAA,EAAA,SAAA,EAA8D,EAAA,CAAA;IAC9D,aAAA,CAAA,IAAA,EAAA,WAAA,EAAoB,CAAA,CAAA;IAEpB,aAAA,CAAA,IAAA,EAAA,IAAA,EAAK,IAAI,OAAA,CAAA,CAAA,CAAA;IACT,aAAA,CAAA,IAAA,EAAA,IAAA,EAAK,IAAI,OAAA,CAAA,CAAA,CAAA;IACT,aAAA,CAAA,IAAA,EAAA,IAAA,EAAK,IAAI,OAAA,CAAA,CAAA,CAAA;IACT,aAAA,CAAA,IAAA,EAAA,IAAA,EAAK,IAAI,OAAA,CAAA,CAAA,CAAA;IACT,aAAA,CAAA,IAAA,EAAA,IAAA,EAAK,IAAI,OAAA,CAAA,CAAA,CAAA;IACT,aAAA,CAAA,IAAA,EAAA,QAAA,EAAS,IAAI,OAAA,CAAA,CAAA,CAAA;;EAIrB,KAAA,CAAM,KAAA,EAAiB,OAAA,EAAiD;IACtE,IAAA,CAAK,MAAA,GAAA,CAAS,OAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,OAAA,CAAS,MAAA,MAAW,KAAA,CAAA,GAAY,OAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,OAAA,CAAS,MAAA,GAAS,KAAA;IAE1D,KAAA,CAAA,QAAA,CAAU,MAAA,IAAqB;MAC/B,IAAA,MAAA,CAAO,MAAM,CAAA,EAAG;QAClB,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA;QAEpB,IAAA,CAAC,QAAA,CAAS,gBAAA,EAAkB;UACxB,MAAA,IAAI,KAAA,CAAM,kEAAkE,CAAA;QACpF;QAEA,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA;QACvB,MAAM,iBAAA,GAAoB,QAAA,CAAS,YAAA,CAAa,UAAU,CAAA,IAAK,IAAA;QAC/D,IAAI,CAAC,iBAAA,EAAmB;QAExB,IAAA,CAAK,SAAA,IAAa,KAAA,KAAU,IAAA,GAAO,KAAA,CAAM,KAAA,GAAQ,CAAA,GAAI,iBAAA,CAAkB,KAAA,GAAQ,CAAA;QAE/E,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK;UAChB,QAAA,EAAU,MAAA;UACV;QAAA,CACD,CAAA;MACH;IAAA,CACD,CAAA;IAED,IAAI,IAAA,CAAK,MAAA,EAAQ;MACT,MAAA,YAAA,GAAe,IAAA,CAAK,SAAA,GAAY,CAAA,GAAI,IAAA,CAAK,SAAA,GAAY,CAAA,GAAI,CAAA,GAAI,CAAA,GAAI,EAAA,GAAK,CAAA;MACtE,MAAA,WAAA,GAAc,IAAI,WAAA,CAAY,YAAY,CAAA;MAC3C,IAAA,CAAA,MAAA,GAAS,IAAI,QAAA,CAAS,WAAW,CAAA;MACtC,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,SAAA,EAAW,IAAI,CAAA;MACvD,IAAA,CAAK,MAAA,IAAU,CAAA;IAAA,CAAA,MACV;MACL,IAAA,CAAK,MAAA,GAAS,EAAA;MACd,IAAA,CAAK,MAAA,IAAU,kBAAA;IACjB;IAES,KAAA,IAAA,CAAA,GAAI,CAAA,EAAG,EAAA,GAAK,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;MACrD,MAAM,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA,CAAE,QAAA;MAC/B,MAAM,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA,CAAE,QAAA;MAEjC,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA;MACjB,MAAA,iBAAA,GAAoB,QAAA,CAAS,YAAA,CAAa,UAAU,CAAA;MAE1D,IAAI,KAAA,KAAU,IAAA,EAAM;QAElB,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,KAAA,EAAO,CAAA,IAAK,CAAA,EAAG;UACvC,MAAM,CAAA,GAAI,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA;UAC1B,MAAM,CAAA,GAAI,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA;UAC1B,MAAM,CAAA,GAAI,KAAA,CAAM,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA;UAE1B,IAAA,CAAK,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,iBAAA,EAAmB,MAAqB,CAAA;QAClE;MAAA,CAAA,MACK;QAEL,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,iBAAA,CAAkB,KAAA,EAAO,CAAA,IAAK,CAAA,EAAG;UACnD,MAAM,CAAA,GAAI,CAAA,GAAI,CAAA;UACd,MAAM,CAAA,GAAI,CAAA,GAAI,CAAA;UACd,MAAM,CAAA,GAAI,CAAA,GAAI,CAAA;UAEd,IAAA,CAAK,SAAA,CAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,iBAAA,EAAmB,MAAqB,CAAA;QAClE;MACF;IACF;IAEI,IAAA,CAAC,IAAA,CAAK,MAAA,EAAQ;MAChB,IAAA,CAAK,MAAA,IAAU,qBAAA;IACjB;IAEA,OAAO,IAAA,CAAK,MAAA;EACd;EAEQ,SAAA,CACN,CAAA,EACA,CAAA,EACA,CAAA,EACA,iBAAA,EACA,MAAA,EACM;IACD,IAAA,CAAA,EAAA,CAAG,mBAAA,CAAoB,iBAAA,EAAmB,CAAC,CAAA;IAC3C,IAAA,CAAA,EAAA,CAAG,mBAAA,CAAoB,iBAAA,EAAmB,CAAC,CAAA;IAC3C,IAAA,CAAA,EAAA,CAAG,mBAAA,CAAoB,iBAAA,EAAmB,CAAC,CAAA;IAEhD,IAAI,MAAA,CAAO,aAAA,EAAe;MACxB,MAAM,IAAA,GAAO,MAAA;MAWb,IAAI,oBAAA,IAAwB,IAAA,EAAM;QAC3B,IAAA,CAAA,kBAAA,CAAmB,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;QAC7B,IAAA,CAAA,kBAAA,CAAmB,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;QAC7B,IAAA,CAAA,kBAAA,CAAmB,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;MAAA,CAAA,MAC7B;QACA,IAAA,CAAA,aAAA,CAAc,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;QACxB,IAAA,CAAA,aAAA,CAAc,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;QACxB,IAAA,CAAA,aAAA,CAAc,CAAA,EAAG,IAAA,CAAK,EAAE,CAAA;MAC/B;IACF;IAEK,IAAA,CAAA,EAAA,CAAG,YAAA,CAAa,MAAA,CAAO,WAAW,CAAA;IAClC,IAAA,CAAA,EAAA,CAAG,YAAA,CAAa,MAAA,CAAO,WAAW,CAAA;IAClC,IAAA,CAAA,EAAA,CAAG,YAAA,CAAa,MAAA,CAAO,WAAW,CAAA;IAEvC,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAA,EAAI,IAAA,CAAK,EAAE,CAAA;IAErC,IAAA,CAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA;IACnB,IAAA,CAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA;IACnB,IAAA,CAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA;IAExB,IAAI,IAAA,CAAK,MAAA,IAAU,IAAA,CAAK,MAAA,YAAkB,QAAA,EAAU;MAClD,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,CAAA,EAAG,IAAI,CAAA;MAC1C,IAAA,CAAK,MAAA,IAAU,CAAA;IAAA,CAAA,MACV;MACL,IAAA,CAAK,MAAA,IAAU,aAAA;MACf,IAAA,CAAK,MAAA,IAAU,aAAA;IACjB;EACF;EAEQ,WAAA,CAAY,EAAA,EAAa,EAAA,EAAa,EAAA,EAAmB;IAC1D,IAAA,CAAA,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;IACpB,IAAA,CAAA,EAAA,CAAG,UAAA,CAAW,EAAA,EAAI,EAAE,CAAA;IACzB,IAAA,CAAK,EAAA,CAAG,KAAA,CAAM,IAAA,CAAK,EAAE,CAAA,CAAE,SAAA,CAAA,CAAA;IAEvB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,EAAE,CAAA,CAAE,SAAA,CAAA,CAAA;IAE1B,IAAI,IAAA,CAAK,MAAA,IAAU,IAAA,CAAK,MAAA,YAAkB,QAAA,EAAU;MAClD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MACvD,IAAA,CAAK,MAAA,IAAU,CAAA;MACf,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MACvD,IAAA,CAAK,MAAA,IAAU,CAAA;MACf,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MACvD,IAAA,CAAK,MAAA,IAAU,CAAA;IAAA,CAAA,MACV;MACA,IAAA,CAAA,MAAA,IAAU,iBAAkB,IAAA,CAAK,MAAA,CAAO,CAAA,IAAK,IAAA,CAAK,MAAA,CAAO,CAAA,IAAK,IAAA,CAAK,MAAA,CAAO,CAAA;AAAA,CAAA;MAC/E,IAAA,CAAK,MAAA,IAAU,gBAAA;IACjB;EACF;EAEQ,WAAA,CAAY,MAAA,EAAuB;IACzC,IAAI,IAAA,CAAK,MAAA,IAAU,IAAA,CAAK,MAAA,YAAkB,QAAA,EAAU;MAClD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MAClD,IAAA,CAAK,MAAA,IAAU,CAAA;MACf,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MAClD,IAAA,CAAK,MAAA,IAAU,CAAA;MACf,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,MAAA,CAAO,CAAA,EAAG,IAAI,CAAA;MAClD,IAAA,CAAK,MAAA,IAAU,CAAA;IAAA,CAAA,MACV;MACL,IAAA,CAAK,MAAA,IAAU,aAAgB,MAAA,CAAO,CAAA,IAAK,MAAA,CAAO,CAAA,IAAK,MAAA,CAAO,CAAA;AAAA,CAAA;IAChE;EACF;AACF","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  InterleavedBufferAttribute,\n  Mesh,\n  Object3D,\n  SkinnedMesh,\n  Vector3,\n} from 'three'\n\nexport interface STLExporterOptionsBinary {\n  binary: true\n}\n\nexport interface STLExporterOptionsString {\n  binary?: false\n}\n\nexport interface STLExporterOptions {\n  binary?: boolean\n}\n\nconst isMesh = (object: unknown): object is Mesh => (object as any).isMesh\n\nexport class STLExporter {\n  private binary = false\n\n  private output: string | DataView = ''\n  private offset: number = 80 // skip header\n\n  private objects: { object3d: Object3D; geometry: BufferGeometry }[] = []\n  private triangles: number = 0\n\n  private vA = new Vector3()\n  private vB = new Vector3()\n  private vC = new Vector3()\n  private cb = new Vector3()\n  private ab = new Vector3()\n  private normal = new Vector3()\n\n  parse(scene: Object3D, options: STLExporterOptionsBinary): DataView\n  parse(scene: Object3D, options?: STLExporterOptionsString): string\n  parse(scene: Object3D, options?: STLExporterOptions): string | DataView {\n    this.binary = options?.binary !== undefined ? options?.binary : false\n\n    scene.traverse((object: Object3D) => {\n      if (isMesh(object)) {\n        const geometry = object.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position') || null\n        if (!positionAttribute) return\n\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        this.objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      this.output = new DataView(arrayBuffer)\n      this.output.setUint32(this.offset, this.triangles, true)\n      this.offset += 4\n    } else {\n      this.output = ''\n      this.output += 'solid exported\\n'\n    }\n\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d\n      const geometry = this.objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0)\n          const b = index.getX(j + 1)\n          const c = index.getX(j + 2)\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0\n          const b = j + 1\n          const c = j + 2\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      }\n    }\n\n    if (!this.binary) {\n      this.output += 'endsolid exported\\n'\n    }\n\n    return this.output\n  }\n\n  private writeFace(\n    a: number,\n    b: number,\n    c: number,\n    positionAttribute: BufferAttribute | InterleavedBufferAttribute,\n    object: SkinnedMesh,\n  ): void {\n    this.vA.fromBufferAttribute(positionAttribute, a)\n    this.vB.fromBufferAttribute(positionAttribute, b)\n    this.vC.fromBufferAttribute(positionAttribute, c)\n\n    if (object.isSkinnedMesh) {\n      const mesh = object as Omit<SkinnedMesh, 'boneTransform' | 'applyBoneTransform'> &\n        (\n          | {\n              boneTransform(index: number, vector: Vector3): Vector3\n            }\n          | {\n              applyBoneTransform(index: number, vector: Vector3): Vector3\n            }\n        )\n\n      // r151 https://github.com/mrdoob/three.js/pull/25586\n      if ('applyBoneTransform' in mesh) {\n        mesh.applyBoneTransform(a, this.vA)\n        mesh.applyBoneTransform(b, this.vB)\n        mesh.applyBoneTransform(c, this.vC)\n      } else {\n        mesh.boneTransform(a, this.vA)\n        mesh.boneTransform(b, this.vB)\n        mesh.boneTransform(c, this.vC)\n      }\n    }\n\n    this.vA.applyMatrix4(object.matrixWorld)\n    this.vB.applyMatrix4(object.matrixWorld)\n    this.vC.applyMatrix4(object.matrixWorld)\n\n    this.writeNormal(this.vA, this.vB, this.vC)\n\n    this.writeVertex(this.vA)\n    this.writeVertex(this.vB)\n    this.writeVertex(this.vC)\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true)\n      this.offset += 2\n    } else {\n      this.output += '\\t\\tendloop\\n'\n      this.output += '\\tendfacet\\n'\n    }\n  }\n\n  private writeNormal(vA: Vector3, vB: Vector3, vC: Vector3): void {\n    this.cb.subVectors(vC, vB)\n    this.ab.subVectors(vA, vB)\n    this.cb.cross(this.ab).normalize()\n\n    this.normal.copy(this.cb).normalize()\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      this.output += '\\t\\touter loop\\n'\n    }\n  }\n\n  private writeVertex(vertex: Vector3): void {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}