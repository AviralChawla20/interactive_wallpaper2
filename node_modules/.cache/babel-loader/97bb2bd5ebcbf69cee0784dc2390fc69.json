{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ColladaExporter {\n  constructor() {\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */new WeakMap();\n    this.materialMap = /* @__PURE__ */new WeakMap();\n    this.imageMap = /* @__PURE__ */new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  parse(object, onDone, options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n      return null;\n    }\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n      return null;\n    }\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n      return null;\n    }\n    if (this.options.textureDirectory !== \"\") {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n    }\n    if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : \"\"}</contributor>${`<created>${(/* @__PURE__ */new Date()).toISOString()}</created>`}${`<modified>${(/* @__PURE__ */new Date()).toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join(\"\")}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join(\"\")}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join(\"\")}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join(\"\")}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += \"</COLLADA>\";\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n  // Convert the urdf xml into a well-formatted, indented format\n  format(urdf) {\n    var _a, _b;\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : \"\";\n    let tagnum = 0;\n    return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n      const res = `${pad(\"  \", tagnum)}${tag}`;\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n      return res;\n    }).join(\"\\n\")) != null ? _b : \"\";\n  }\n  // Convert an image into a png format for saving\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n    return buf;\n  }\n  imageToData(image, ext) {\n    var _a;\n    this.canvas = this.canvas || document.createElement(\"canvas\");\n    this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n    return this.base64ToBuffer(base64data);\n  }\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      const TypedArrayConstructor = attr.array.constructor;\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n      return arr;\n    } else {\n      return attr.array;\n    }\n  }\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor;\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  }\n  // Returns the string for a geometry's attribute\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\"><float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(\" \")}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join(\"\")}</accessor></technique_common></source>` : \"\";\n    return res;\n  }\n  // Returns the string for a node's transform information\n  getTransform(o) {\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(\" \")}</matrix>`;\n  }\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n    if (!info) {\n      const bufferGeometry = g;\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? ` name=\"${g.name}\"` : \"\";\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`;\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`;\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n      if (\"normal\" in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      }\n      if (\"uv\" in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      }\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      }\n      if (\"color\" in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n      let indexArray = null;\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(\" \")}</p>`;\n        gnode += \"</triangles>\";\n      }\n      gnode += \"</mesh></geometry>\";\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n    return info;\n  }\n  // Process the given texture into the image library\n  // Returns the image library\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = \"png\";\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n      if (this.options.version === \"1.5.0\") {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n      imageNode += \"</image>\";\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n    return texid;\n  }\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = \"phong\";\n      if (m instanceof MeshLambertMaterial) {\n        type = \"lambert\";\n      } else if (m instanceof MeshBasicMaterial) {\n        type = \"constant\";\n        if (m.map !== null) {\n          console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n        }\n      }\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0;\n        let transparencyNode = \"\";\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\"}</transparent>`;\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== \"constant\" ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : \"\"}${type !== \"constant\" ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\"}</bump>` : \"\"}${type === \"phong\" ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : \"\"}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : \"\"}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : \"\"}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : \"\"}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : \"\"}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\"}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : \"\";\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n    return matid;\n  }\n  // Recursively process the object into a scene\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    const a = new Mesh();\n    a.geometry;\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry;\n      let matids = null;\n      let matidsArray;\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join(\"\")}</technique_common></bind_material>` : \"\")}</instance_geometry>`;\n    }\n    o.children.forEach(c => node += this.processObject(c));\n    node += \"</node>\";\n    return node;\n  }\n}\nexport { ColladaExporter };","map":{"version":3,"sources":["../../src/exporters/ColladaExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  InterleavedBufferAttribute,\n  Material,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Texture,\n} from 'three'\nimport type { TypedArray, TypedArrayConstructors } from '../types/shared'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nexport interface ColladaExporterOptions {\n  author?: string\n  textureDirectory?: string\n  version?: string\n}\n\nexport interface ColladaExporterResult {\n  data: string\n  textures: object[]\n}\n\ntype GeometryInfo = { meshid: string; bufferGeometry: BufferGeometry }\n\ntype MaterialRepresentation = MeshPhongMaterial | MeshBasicMaterial | MeshLambertMaterial\n\nclass ColladaExporter {\n  private options: {\n    version: string\n    author: string | null\n    textureDirectory: string\n    upAxis: string\n    unitName: string | null\n    unitMeter: string | null\n  }\n\n  private geometryInfo: WeakMap<BufferGeometry, GeometryInfo>\n  private materialMap: WeakMap<MaterialRepresentation, string>\n  private imageMap: WeakMap<Texture, string>\n  private textures: {\n    directory: string\n    name: string\n    ext: string\n    data: Uint8Array\n    original: Texture\n  }[]\n\n  private libraryImages: string[]\n  private libraryGeometries: string[]\n  private libraryEffects: string[]\n  private libraryMaterials: string[]\n\n  private canvas: HTMLCanvasElement | null\n  private ctx: CanvasRenderingContext2D | null\n\n  private transMat: Matrix4 | null\n\n  private getFuncs = ['getX', 'getY', 'getZ', 'getW'] as const\n\n  constructor() {\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null,\n    }\n\n    this.geometryInfo = new WeakMap()\n    this.materialMap = new WeakMap()\n    this.imageMap = new WeakMap()\n    this.textures = []\n\n    this.libraryImages = []\n    this.libraryGeometries = []\n    this.libraryEffects = []\n    this.libraryMaterials = []\n\n    this.canvas = null\n    this.ctx = null\n\n    this.transMat = null\n  }\n\n  public parse(\n    object: Object3D,\n    onDone: (res: ColladaExporterResult) => void,\n    options: ColladaExporterOptions = {},\n  ): ColladaExporterResult | null {\n    this.options = { ...this.options, ...options }\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.')\n      return null\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.')\n      return null\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.')\n      return null\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/')\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`)\n      return null\n    }\n\n    const libraryVisualScenes = this.processObject(object)\n\n    const specLink =\n      this.options.version === '1.4.1'\n        ? 'http://www.collada.org/2005/11/COLLADASchema'\n        : 'https://www.khronos.org/collada/'\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${\n      this.options.author !== null ? `<author>${this.options.author}</author>` : ''\n    }</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`\n\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`\n\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`\n\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`\n\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`\n\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`\n\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>'\n\n    dae += '</COLLADA>'\n\n    const res = {\n      data: this.format(dae),\n      textures: this.textures,\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res))\n    }\n\n    return res\n  }\n\n  // Convert the urdf xml into a well-formatted, indented format\n  private format(urdf: string): string {\n    const IS_END_TAG = /^<\\//\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/\n\n    const pad = (ch: string, num: number): string => (num > 0 ? ch + pad(ch, num - 1) : '')\n\n    let tagnum = 0\n\n    return (\n      urdf\n        .match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)\n        ?.map((tag) => {\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n            tagnum--\n          }\n\n          const res = `${pad('  ', tagnum)}${tag}`\n\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n            tagnum++\n          }\n\n          return res\n        })\n        .join('\\n') ?? ''\n    )\n  }\n\n  // Convert an image into a png format for saving\n  private base64ToBuffer(str: string): Uint8Array {\n    const b = atob(str)\n    const buf = new Uint8Array(b.length)\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i)\n    }\n\n    return buf\n  }\n\n  private imageToData(image: CanvasImageSource, ext: string): Uint8Array {\n    this.canvas = this.canvas || document.createElement('canvas')\n    this.ctx = this.ctx || this.canvas.getContext('2d')\n\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height\n\n    this.ctx?.drawImage(image, 0, 0)\n\n    // Get the base64 encoded data\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, '')\n\n    // Convert to a uint8 array\n    return this.base64ToBuffer(base64data)\n  }\n\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  private attrBufferToArray(attr: InterleavedBufferAttribute | BufferAttribute): number[] | ArrayLike<number> {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor: TypedArrayConstructors = attr.array.constructor\n      // @ts-ignore\n      const arr: number[] = new TypedArrayConstructor(attr.count * attr.itemSize)\n      const size = attr.itemSize\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i)\n        }\n      }\n\n      return arr\n    } else {\n      return attr.array\n    }\n  }\n\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  private subArray(arr: number[] | ArrayLike<number>, st: number, ct: number): TypedArray | number[] {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct)\n    } else {\n      const TypedArrayConstructor: TypedArrayConstructors = arr.constructor\n      // @ts-ignore\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct)\n    }\n  }\n\n  // Returns the string for a geometry's attribute\n  private getAttribute(\n    attr: InterleavedBufferAttribute | BufferAttribute,\n    name: string,\n    params: string[],\n    type: string,\n  ): string {\n    const array = this.attrBufferToArray(attr)\n    const res = Array.isArray(array)\n      ? `${\n          `<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')\n        }</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n          array.length / attr.itemSize,\n        )}\" stride=\"${attr.itemSize}\">`}${params\n          .map((n) => `<param name=\"${n}\" type=\"${type}\" />`)\n          .join('')}</accessor></technique_common></source>`\n      : ''\n\n    return res\n  }\n\n  // Returns the string for a node's transform information\n  private getTransform(o: Object3D): string {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix()\n\n    this.transMat = this.transMat || new Matrix4()\n    this.transMat.copy(o.matrix)\n    this.transMat.transpose()\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`\n  }\n\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  private processGeometry(g: BufferGeometry): GeometryInfo {\n    let info = this.geometryInfo.get(g)\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.')\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`\n\n      const indexCount = bufferGeometry.index\n        ? bufferGeometry.index.count * bufferGeometry.index.itemSize\n        : bufferGeometry.attributes.position.count\n\n      const groups =\n        bufferGeometry.groups != null && bufferGeometry.groups.length !== 0\n          ? bufferGeometry.groups\n          : [{ start: 0, count: indexCount, materialIndex: 0 }]\n\n      const gname = g.name ? ` name=\"${g.name}\"` : ''\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`\n\n      // define the geometry node and the vertices for the geometry\n      const posName = `${meshid}-position`\n      const vertName = `${meshid}-vertices`\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float')\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`\n\n      // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n      // serialize normals\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float')\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`\n      }\n\n      // serialize uvs\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`\n      }\n\n      // serialize lightmap uvs\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`\n      }\n\n      // serialize colors\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8')\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`\n      }\n\n      let indexArray: number[] | ArrayLike<number> | null = null\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index)\n      } else {\n        indexArray = new Array(indexCount)\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i]\n        const subarr = this.subArray(indexArray, group.start, group.count)\n        const polycount = subarr.length / 3\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`\n        gnode += triangleInputs\n\n        gnode += `<p>${subarr.join(' ')}</p>`\n        gnode += '</triangles>'\n      }\n\n      gnode += '</mesh></geometry>'\n\n      this.libraryGeometries.push(gnode)\n\n      info = { meshid, bufferGeometry }\n      this.geometryInfo.set(g, info)\n    }\n\n    return info\n  }\n\n  // Process the given texture into the image library\n  // Returns the image library\n  private processTexture(tex: Texture): string {\n    let texid = this.imageMap.get(tex)\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`\n\n      const ext = 'png'\n      const name = tex.name || texid\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`\n      }\n\n      imageNode += '</image>'\n\n      this.libraryImages.push(imageNode)\n      this.imageMap.set(tex, texid)\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex,\n      })\n    }\n\n    return texid\n  }\n\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  private processMaterial(m: MaterialRepresentation): string {\n    let matid = this.materialMap.get(m)\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`\n\n      let type = 'phong'\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert'\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant'\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.')\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0)\n        const diffuse = m.color ? m.color : new Color(0, 0, 0)\n        const specular = m.specular ? m.specular : new Color(1, 1, 1)\n        const shininess = m.shininess || 0\n        const reflectivity = m.reflectivity || 0\n\n        // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n        let transparencyNode = ''\n        if (m.transparent) {\n          transparencyNode += `<transparent>${\n            m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'\n          }</transparent>`\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${\n          m.emissiveMap\n            ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />'\n            : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`\n        }</emission>${\n          type !== 'constant'\n            ? `<diffuse>${\n                m.map\n                  ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`\n              }</diffuse>`\n            : ''\n        }${\n          type !== 'constant'\n            ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>`\n            : ''\n        }${\n          type === 'phong'\n            ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${\n                m.specularMap\n                  ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<float sid=\"shininess\">${shininess}</float>`\n              }</shininess>`\n            : ''\n        }${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`\n\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${\n          m.map\n            ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.map,\n              )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.specularMap\n            ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.specularMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.emissiveMap\n            ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.emissiveMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.normalMap\n            ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.normalMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>`\n            : ''\n        }${techniqueNode}${\n          m.side === DoubleSide\n            ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>'\n            : ''\n        }</profile_COMMON></effect>`\n\n        const materialName = m.name ? ` name=\"${m.name}\"` : ''\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`\n\n        this.libraryMaterials.push(materialNode)\n        this.libraryEffects.push(effectnode)\n        this.materialMap.set(m, matid)\n      }\n    }\n\n    return matid\n  }\n\n  // Recursively process the object into a scene\n  private processObject(o: Object3D): string {\n    let node = `<node name=\"${o.name}\">`\n\n    node += this.getTransform(o)\n    const a: Mesh<BufferGeometry, Material | Material[]> = new Mesh()\n    a.geometry\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry)\n      const meshid = geomInfo.meshid\n      const geometry = geomInfo.bufferGeometry\n\n      // ids of the materials to bind to the geometry\n      let matids = null\n      let matidsArray\n\n      // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n      const mat: MaterialRepresentation | MaterialRepresentation[] = o.material || new MeshBasicMaterial()\n      const materials = Array.isArray(mat) ? mat : [mat]\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length)\n      } else {\n        matidsArray = new Array(materials.length)\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]))\n\n      node += `${\n        `<instance_geometry url=\"#${meshid}\">` +\n        (matids != null\n          ? `<bind_material><technique_common>${matids\n              .map(\n                (id, i) =>\n                  `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`,\n              )\n              .join('')}</technique_common></bind_material>`\n          : '')\n      }</instance_geometry>`\n    }\n\n    o.children.forEach((c) => (node += this.processObject(c)))\n\n    node += '</node>'\n\n    return node\n  }\n}\n\nexport { ColladaExporter }\n"]},"metadata":{},"sourceType":"module"}